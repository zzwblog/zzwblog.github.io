<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="读书笔记——《More Effective C++》, 一个人的成长">
    <meta name="description" content="一、基础议题(Basics)1、仔细区别 pointers【指针】 和 references二者之间的区别是：在任何情况下都不能用指向空值的引用，而指针则可以；指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>读书笔记——《More Effective C++》 | 自由の翼</title>
    <link rel="icon" type="image/jpeg" href="/img/111.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    

    <script data-ad-client="ca-pub-6292651392430027" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<link rel="alternate" href="/atom.xml" title="自由の翼" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/img/logo1.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">自由の翼</span>

                    
                    
                    <script>
                      /* 标签页标题切换 */
                      var originTitle = document.title;
                      var titleTime;
                      document.addEventListener("visibilitychange", function () {
                        if (document.hidden) {
                          document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
                          clearTimeout(titleTime);
                        } else {
                          document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
                          titleTime = setTimeout(function () {
                            document.title = originTitle;
                          }, 2000);
                        }
                      });
                    </script>
                    

                    

                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/goodpapers" class="waves-effect waves-light">
      
      <i class="fas fa-coffee" style="zoom: 0.6;"></i>
      
      <span>收藏</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  

  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="margin-right: -100px; zoom: 0.6;"></i>
    </a>
  </li>

  <li>
  <a>
    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
  </a>
  </li>
  <li>
  <a></a>
  </li>

</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/img/logo1.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">自由の翼</div>
        <div class="logo-desc">
            
            只愿今朝逢知己，共同成长
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Home
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/goodpapers" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-coffee"></i>
			
			Goodpapers
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/zzw1024" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/zzw1024" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        

    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">读书笔记——《More Effective C++》</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/c-%E6%8F%90%E5%8D%87/">
                                <span class="chip bg-color">c++提升</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">
                                读书笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">

                <div class="info-break-policy">
                    
                        <i class="fa fa-user"></i> 作者:&nbsp;&nbsp;
                        zzw         
                    
                </div>

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-01-01
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-01-01
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    9.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    35 分
                </div>
                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、基础议题-Basics"><a href="#一、基础议题-Basics" class="headerlink" title="一、基础议题(Basics)"></a>一、基础议题(Basics)</h2><h3 id="1、仔细区别-pointers【指针】-和-references"><a href="#1、仔细区别-pointers【指针】-和-references" class="headerlink" title="1、仔细区别 pointers【指针】 和 references"></a>1、仔细区别 pointers【指针】 和 references</h3><p>二者之间的区别是：在任何情况下都不能用指向空值的引用，而指针则可以；指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变</p>
<p>在以下情况下使用指针：一是存在不指向任何对象的可能性；二是需要能够在不同的时刻指向不同的对象</p>
<p>在以下情况使用引用：总是指向一个对象且一旦指向一个对象之后就不会改变指向；重载某个操作符时，使用指针会造成语义误解</p>
<h3 id="2、最好使用-C-转型操作符"><a href="#2、最好使用-C-转型操作符" class="headerlink" title="2、最好使用 C++ 转型操作符"></a>2、最好使用 C++ 转型操作符</h3><p>为解决 C 旧式转型的缺点（允许将任何类型转为任何类型，且难以辨识），C++ 导入 4 个新的转型操作符（cast operators）：</p>
<p>static_cast , const_cast , dynamic_cast , reinterpret_cast：分别是常规类型转换，去常量转换，继承转换，函数指针转换</p>
<p>static_cast：功能上基本上与C风格的类型转换一样强大，含义也一样但是不能把struct转换成int类型或者把double类型转换成指针类型另外，它不<br>能从表达式中去除const属性。用来针对一个继承体系做向下的安全转换，目标类型必须为指针或者引用。基类中要有虚函数，否则会编译出错；static_cast则没有这个限制。原因是：存在虚函数，说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。必须保证源类型跟目标类型本来就是一致的，否则返回 null 指针。这个函数使用的是RTTI机制，所以编译器必须打开这个选项才能编译。</p>
<p>const_cast：用于类型转换掉表达式的const或volatileness属性但是不能用它来完成修改这两个属性之外的事情</p>
<p>dynamic_cast：用于安全地沿着类的继承关系向下类型转换失败的转换将返回空指针或者抛出异常</p>
<p>reinterpret_cast：这个操作符被用于的类型转换的转换结果时实现时定义因此，使用它的代码很难移植最普通的用途就是在函数指针之间进行转换</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">struct</span> B
<span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//想要使用 dynamic_cast ，基类中必须有虚函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> D <span class="token operator">:</span> B
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//i == 3</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>pj <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//int *pj = (int*)(&amp;j);     //等同于上面</span>
    <span class="token operator">*</span>pj <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//虽然 *pj的地址和 j 的地址是一样的，但是值却不一样。</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>pj<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//20</span>
    cout<span class="token operator">&lt;&lt;</span>j<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//10</span>
B <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>D<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FunPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>FunPtr<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fun<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//尽量避免使用</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3、绝对不要以多态方式处理数组"><a href="#3、绝对不要以多态方式处理数组" class="headerlink" title="3、绝对不要以多态方式处理数组"></a>3、绝对不要以多态方式处理数组</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">struct</span> B
<span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"base print()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> D <span class="token operator">:</span> B
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"derived print()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果没有此句，执行将正确，因为基类对象和子类对象长度相同  </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> B array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    B barray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">fun</span><span class="token punctuation">(</span>barray<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    D darray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">fun</span><span class="token punctuation">(</span>darray<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>array[i] 其实是一个指针算术表达式的简写，它代表的其实是 *(array+i)，array是一个指向数组起始处的指针。在 for 里遍历 array 时，必须要知道每个元素之间相差多少内存，而编译器则根据传入参数来计算得知为 sizeof(B)，而如果传入的是派生类数组对象，它依然认为是 sizeof(B)，除非正好派生类大小正好与基类相同，否则运行时会出现错误。但是如果我们设计软件的时候，不要让具体类继承具体类的话，就不太可能犯这种错误。（理由是，一个类的父类一般都会是一个抽象类，抽象类不存在数组） </p>
<h3 id="4、避免无用的-default-constructors"><a href="#4、避免无用的-default-constructors" class="headerlink" title="4、避免无用的 default constructors"></a>4、避免无用的 default constructors</h3><p>没有缺省构造函数造成的问题：通常不可能建立对象数组，对于使用非堆数组，可以在定义时提供必要的参数。另一种方法是使用指针数组，但是必须删除数组里的每个指针指向的对象，而且还增加了内存分配量。</p>
<p>提供无意义的缺省构造函数会影响类的工作效率，成员函数必须测试所有的部分是否都被正确的初始化。</p>
<h2 id="二、操作符-Operators"><a href="#二、操作符-Operators" class="headerlink" title="二、操作符(Operators)"></a>二、操作符(Operators)</h2><h3 id="5、对定制的“类型转换函数”保持警觉"><a href="#5、对定制的“类型转换函数”保持警觉" class="headerlink" title="5、对定制的“类型转换函数”保持警觉"></a>5、对定制的“类型转换函数”保持警觉</h3><p>定义类似功能的函数，而抛弃隐式类型转换，使得类型转换必须显示调用。例如 String类没有定义对Char*的隐式转换，而是用c_str函数来实施这个转换。拥有单个参数（或除第一个参数外都有默认值的多参数）构造函数的类，很容易被隐式类型转换，最好加上 explicit 防止隐式类型转换。</p>
<h3 id="6、区别-increment-decrement-操作符的前置和后置形式"><a href="#6、区别-increment-decrement-操作符的前置和后置形式" class="headerlink" title="6、区别 increment/decrement 操作符的前置和后置形式"></a>6、区别 increment/decrement 操作符的前置和后置形式</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>id <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//返回值为 const ，以避免 a++++这种形式</span>
        <span class="token comment" spellcheck="true">//因为第二个 operator++ 所改变的对象是第一个 operator++ 返回的对象</span>
        <span class="token comment" spellcheck="true">//最终结果其实也只是累加了一次，a++++ 也还是相当于 a++，这是违反直觉的</span>
        <span class="token keyword">const</span> A <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            A a <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>id <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> a<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token operator">++</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//++++a;   也是允许的，但 a++++ 不允许。</span>
    cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">++</span><span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>后置operator++(int) 的叠加是不允许的，原因有两个：一是与内建类型行为不一致（内建类型支持前置叠加)；二是其效果跟调用一次 operator++(int) 效果一样，这是违反直觉的。另外，后置式操作符使用 operator++(int)，参数的唯一目的只是为了区别前置式和后置式而已，当函数被调用时，编译器传递一个0作为int参数的值传递给该函数。<br>处置用户定制类型时，尽可能使用前置式，因为后置式会产生一个临时对象。</p>
<h3 id="7、千万不要重载-amp-amp-和-操作符"><a href="#7、千万不要重载-amp-amp-和-操作符" class="headerlink" title="7、千万不要重载 &amp;&amp;, || 和 , 操作符"></a>7、千万不要重载 &amp;&amp;, || 和 , 操作符</h3><pre><code>int *pi = NULL;
if(pi != 0 &amp;&amp; cout&lt;&lt;*pi&lt;&lt;endl) { }</code></pre><p>上面的代码不会报错，虽然 pi 是空指针，但 &amp;&amp; 符号采用”骤死式”评估方式，如果 pi == 0 的话，不会执行后面的语句。</p>
<p>不要重载这些操作符，是因为我们无法控制表达式的求解优先级，不能真正模仿这些运算符。操作符重载的目的是使程序更容易阅读，书写和理解，而不是来迷惑其他人。如果没有一个好理由重载操作符，就不要重载。而对于&amp;&amp;，||和“，”，很难找到一个好理由。 </p>
<h3 id="8、了解各种不同意义的-new-和-delete"><a href="#8、了解各种不同意义的-new-和-delete" class="headerlink" title="8、了解各种不同意义的 new 和 delete"></a>8、了解各种不同意义的 new 和 delete</h3><p>new 操作符的执行过程：</p>
<ol>
<li>调用operator new分配内存 ；//这一步可以使用 operator new 或 placement new 重载。</li>
<li>调用构造函数生成类对象；</li>
<li>返回相应指针。</li>
</ol>
<p>函数 operator new 通常声明如下： </p>
<p>void * operator new(size_t size);　　//第一个参数必须为 size_t，表示需要分配多少内存。</p>
<p>返回值为void型指针，表示这个指针指向的内存中的数据的类型要由用户来指定。比如内存分配函数malloc函数返回的指针就是void *型，用户在使用这个指针的时候，要进行强制类型转换，如（int *)malloc(1024)。任何类型的指针都可以直接赋给 void * 变量，而不必强制转换。如果函数的参数可以为任意类型的指针，则可以声明为 void * 了。 </p>
<p>void 有两个地方可以使用，第一是函数返回值，第二是作为无参函数的参数。（因为在C语言中，可以给无参函数传任意类型的参数，而且C语言中，没有指定函数返回值时，默认返回为 int 值）</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">User</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"size: "</span><span class="token operator">&lt;&lt;</span>size<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span>std<span class="token operator">::</span>string str<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"size: "</span><span class="token operator">&lt;&lt;</span>size <span class="token operator">&lt;&lt;</span><span class="token string">"\nname: "</span> <span class="token operator">&lt;&lt;</span> str<span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    User<span class="token operator">*</span> user1 <span class="token operator">=</span> <span class="token keyword">new</span> User<span class="token punctuation">;</span>
    User<span class="token operator">*</span> user2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token string">"JIM"</span><span class="token punctuation">)</span>User<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
    pi <span class="token operator">=</span> p<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>pi<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="三、异常-Exceptions"><a href="#三、异常-Exceptions" class="headerlink" title="三、异常(Exceptions)"></a>三、异常(Exceptions)</h2><h3 id="9、利用-destructors-避免泄漏资源"><a href="#9、利用-destructors-避免泄漏资源" class="headerlink" title="9、利用 destructors 避免泄漏资源"></a>9、利用 destructors 避免泄漏资源</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span>
<span class="token keyword">void</span> <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>pi<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">{</span>
        <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果此处抛出异常而未处理，则无法执行 delete 语句，造成内存泄漏。</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>
        <span class="token keyword">throw</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 一个函数在堆里申请内存到释放内存的过程中，如果发生异常，如果自己不处理而只交给调用程序处理，则可能由于未调用 delete 导致内存泄漏。上面的方法可以解决这一问题，不过这样的代码使人看起来心烦且难于维护，而且必须写双份的 delete 语句。函数返回时局部对象总是释放（调用其析构函数），无论函数是如何退出的。（仅有的一种例外是当调用 longjmp 时，而 longjmp 这个缺点也是C++最初支持异常处理的原因）</p>
<p>所以这里使用智能指针或类似于智能指针的对象是比较好的办法：</p>
<ul>
<li>auto_ptr; — 基本被弃用.</li>
<li>shared_ptr; — 共享指针, 引用计数为零就销毁对象空间.</li>
<li>weak_ptr; — weak_ptr是用来解决shared_ptr相互引用时的死锁问题. 弱引用不会增加引用计数.</li>
<li>unique_ptr; — unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权.<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span>
<span class="token keyword">void</span> <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ap</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用 auto_ptr 包装一下</span>
  std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>pi<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>上面的代码看起来简洁多了，因为 auto_ptr 会在离开作用域时调用其析构函数，析构函数中会做 delete 动作。  </p>
<h3 id="10、在-constructors-内阻止资源泄漏"><a href="#10、在-constructors-内阻止资源泄漏" class="headerlink" title="10、在 constructors 内阻止资源泄漏"></a>10、在 constructors 内阻止资源泄漏</h3><p>这一条讲得其实是捕获构造函数里的异常的重要性。</p>
<p><strong>堆栈辗转开解（stack-unwinding）：</strong>如果一个函数中出现异常，在函数内即通过 try..catch 捕捉的话，可以继续往下执行；如果不捕捉就会抛出（或通过 throw 显式抛出）到外层函数，则当前函数会终止运行，释放当前函数内的局部对象（局部对象的析构函数就自然被调用了），外层函数如果也没有捕捉到的话，会再次抛出到更外层的函数，该外层函数也会退出，释放其局部对象……如此一直循环下去，直到找到匹配的 catch 子句，如果找到 main 函数中仍找不到，则退出程序。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span>
<span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> userid_<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> username_ <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string address_ <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token function">userid</span><span class="token punctuation">(</span>userid_<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">username</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            username <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>username_<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//构造函数里抛出异常的话，由于对象没有构造完成，不会执行析构函数</span>
            address <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>address_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//此例中不会执行,会导致内存泄漏</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">delete</span> username<span class="token punctuation">;</span>
            <span class="token keyword">delete</span> address<span class="token punctuation">;</span>
            std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~B()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">int</span> userid<span class="token punctuation">;</span>
        std<span class="token operator">::</span>string<span class="token operator">*</span> username<span class="token punctuation">;</span>
        std<span class="token operator">::</span>string<span class="token operator">*</span> address<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span> B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> C++拒绝为没有完成构造函数的对象调用析构函数，原因是避免开销，因为只有在每个对象里加一些字节来记录构造函数执行了多少步，它会使对象变大，且减慢析构函数的运行速度。</p>
<p>一般建议不要在构造函数里做过多的资源分配，而应该把这些操作放在一个类似于 init 的成员函数中去完成。这样当 init 成员函数抛出异常时，如果对象是在栈上，析构函数仍会被调用(异常会自动销毁局部对象，调用局部对象的析构函数，见下面)，如果是在堆上，需要在捕获异常之后 delete 对象来调用析构函数。</p>
<h3 id="11、禁止异常流出-destructors-之外"><a href="#11、禁止异常流出-destructors-之外" class="headerlink" title="11、禁止异常流出 destructors 之外"></a>11、禁止异常流出 destructors 之外</h3><p>这一条讲得其实是捕获析构函数里的异常的重要性。第一是防止程序调用 terminate 终止（这里有个名词叫：堆栈辗转开解 stack-unwinding）；第二是析构函数内如果发生异常，则异常后面的代码将不执行，无法确保我们完成我们想做的清理工作。</p>
<p>之前我们知道，析构函数被调用，会发生在对象被删除时，如栈对象超出作用域或堆对象被显式 delete (还有继承体系中，virtual 基类析构函数会在子类对象析构时调用)。除此之外，在异常传递的堆栈辗转开解（stack-unwinding）过程中，异常处理系统也会删除局部对象，从而调用局部对象的析构函数，而此时如果该析构函数也抛出异常，C++程序是无法同时处理两个异常的，就会调用 terminate()终止程序(会立即终止，连局部对象也不释放)。另外，如果异常被抛出，析构函数可能未执行完毕，导致一些清理工作不能完成。</p>
<p>所以不建议在析构函数中抛出异常，如果异常不可避免，则应在析构函数内捕获，而不应当抛出。 场景再现如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">struct</span> T
<span class="token punctuation">{</span>
    <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"T()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">"init() throw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~T() begin"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">"~T() throw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~T() end"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>pi<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        T t<span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//下面也会引发 terminate</span>
    <span class="token comment" spellcheck="true">/*
    try
    {
        int *p2 = new int[1000000000000L];
    }catch(std::bad_alloc&amp;)
    {
        std::cout&lt;&lt;"bad_alloc"&lt;&lt;std::endl;
    }
    */</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">terminate_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"my terminate_handler()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span><span class="token function">set_terminate</span><span class="token punctuation">(</span>terminate_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="12、了解-“抛出一个-exception-”-与-“传递一个参数”-或-“调用一个虚函数”之间的差异"><a href="#12、了解-“抛出一个-exception-”-与-“传递一个参数”-或-“调用一个虚函数”之间的差异" class="headerlink" title="12、了解 “抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异"></a>12、了解 “抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异</h3><p>抛出异常对象，到 catch 中，有点类似函数调用，但是它有几点特殊性：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
        <span class="token keyword">throw</span> pi<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pi指向的对象是静态的，所以才能抛出指针</span>
<span class="token punctuation">}</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果抛出的是 int 对象的异常，是不能用 double 类型接收的，这一点跟普通函数传参不一样。异常处理中，支持的类型转换只有两种，一种是上面例子中演示的从”有型指针”转为”无型指针”，所以用 const void* 可以捕捉任何指针类型的 exception。另一种是继承体系中的类转换，可见下一条款的例子。<br>另外，它跟虚拟函数有什么不同呢？异常处理可以出现多个 catch 子句，而匹配方式是按先后顺序来匹配的（所以如 exception 异常一定要写在 runtime_error异常的后面，如果反过来的话，runtime_error异常语句永远不会执行），而虚函数则是根据虚函数表来的。</p>
<h3 id="13、以-by-reference-方式捕捉-exceptions"><a href="#13、以-by-reference-方式捕捉-exceptions" class="headerlink" title="13、以 by reference 方式捕捉 exceptions"></a>13、以 by reference 方式捕捉 exceptions</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>id <span class="token operator">=</span> b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里是静态对象</span>
    <span class="token keyword">throw</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//只有该对象是静态对象或全局对象时，才能以指针形式抛出</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token keyword">catch</span><span class="token punctuation">(</span>B<span class="token operator">*</span> b<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//这里以指针形式接收</span>
 <span class="token punctuation">{</span>
     std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>b<span class="token operator">-</span><span class="token operator">></span>id<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出3</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用指针方式来捕捉异常，上面的例子效率很高，没有产生临时对象。但是这种方式只能运用于全局或静态的对象（如果是 new 出来的堆中的对象也可以，但是该何时释放呢？）身上，否则的话由于对象离开作用域被销毁，catch中的指针指向不复存在的对象。接下来看看对象方式和指针方式：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"print():B"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token keyword">public</span> B
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"D copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"print():D"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    D d<span class="token punctuation">;</span>
    <span class="token keyword">throw</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>B b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//注意这里</span>
    <span class="token punctuation">{</span>
        b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的例子会输出：</p>
<p>可是如果把 catch(B b) 改成 catch(B&amp; b) 的话，则会输出：</p>
<p>该条款的目的就是告诉我们，请尽量使用引用方式来捕捉异常，它可以避免 new 对象的删除问题，也可以正确处理继承关系的多态问题，还可以减少异常对象的复制次数。 </p>
<h3 id="14、明智运用-exception-specifications"><a href="#14、明智运用-exception-specifications" class="headerlink" title="14、明智运用 exception specifications"></a>14、明智运用 exception specifications</h3><p>C++提供了一种异常规范，即在函数后面指定要抛出的异常类型，可以指定多个：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//必须这样声明，而不能是 void fun(void);</span>
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//说明可能抛出 int 和 double 异常</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>d<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="15、了解异常处理的成本"><a href="#15、了解异常处理的成本" class="headerlink" title="15、了解异常处理的成本"></a>15、了解异常处理的成本</h3><p>大致的意思是，异常的开销还是比较大的，只有在确实需要用它的地方才去用。</p>
<h2 id="四、效率-Efficiency"><a href="#四、效率-Efficiency" class="headerlink" title="四、效率(Efficiency)"></a>四、效率(Efficiency)</h2><h3 id="16、谨记-80-20-法则"><a href="#16、谨记-80-20-法则" class="headerlink" title="16、谨记 80-20 法则"></a>16、谨记 80-20 法则</h3><p>大致的意思是说，程序中80%的性能压力可能会集中在20%左右的代码处。那怎么找出这20%的代码来进行优化呢？可以通过Profiler分析程序等工具来测试，而不要凭感觉或经验来判断。</p>
<h3 id="17、考虑使用-lazy-evaluation（缓式评估）"><a href="#17、考虑使用-lazy-evaluation（缓式评估）" class="headerlink" title="17、考虑使用 lazy evaluation（缓式评估）"></a>17、考虑使用 lazy evaluation（缓式评估）</h3><p>懒惰计算法的含义是拖延计算的时间，等到需要时才进行计算其作用为：能避免不需要的对象拷贝，通过使用operator[]区分出读写操作，避免不需要的数据库读取操作，避免不需要的数字操作但是，如果计算都是重要的，懒惰计算法可能会减慢速度并增加内存的使用</p>
<h3 id="18、分期摊还预期的计算成本"><a href="#18、分期摊还预期的计算成本" class="headerlink" title="18、分期摊还预期的计算成本"></a>18、分期摊还预期的计算成本</h3><ul>
<li><p>over-eager evaluation, 如果程序常常用到某个计算, 设计一份数据结构以便能够及有效率地处理需求</p>
</li>
<li><p>(caching)利用告诉缓存暂存使用频率高的内容.</p>
</li>
<li><p>caching是分期摊还预期计算成本的一种做法. 预先取出是另一种做法. ◦系统调用往往比进程内的函数调用慢.</p>
</li>
<li><p>较快的速度往往导致较大的内存, 空间交换时间.</p>
</li>
<li><p>较大对象比较不容易塞入虚内存分页(virtual memory page)或缓存分页(cache page). ◦对象变大可能会降低性能, 因为换页活动会增加,<br>缓存命中率(cache hit rate)会降低. </p>
</li>
</ul>
<h3 id="19、了解临时对象的来源"><a href="#19、了解临时对象的来源" class="headerlink" title="19、了解临时对象的来源"></a>19、了解临时对象的来源</h3><p>C++真正所谓的临时对象是不可见的——只要产生一个 non-heap object 而没有为它命名，就产生了一个临时对象。它一般产生于两个地方：</p>
<p>一是函数参数的隐式类型转换，</p>
<p>二是函数返回对象时。 </p>
<p>任何时候，只要你看到一个 reference-to-const参数，就极可能会有一个临时对象被产生出来绑定至该参数上；任何时候，只要你看到函数返回一个对象，就会产生临时对象（并于稍后销毁）。</p>
<h3 id="20、协助完成“返回值优化-RVO-”"><a href="#20、协助完成“返回值优化-RVO-”" class="headerlink" title="20、协助完成“返回值优化(RVO)”"></a>20、协助完成“返回值优化(RVO)”</h3><p>不要在一个函数里返回一个局部对象的地址，因为它离开函数体后就析构了。不过在GCC下可以正常运行，无论是否打开优化；而在VS2010中如果关闭优化，就会看到效果。</p>
<p>这个条款想说的是：const Test fun(){ return Test(); } 比 const Test fun(){Test test; return test; }  好，更能使编译器进行优化。<br>不过现在看来，在经过编译器优化之后，这两个好像已经没有什么区别了。</p>
<h3 id="21、利用重载技术避免隐式类型转换"><a href="#21、利用重载技术避免隐式类型转换" class="headerlink" title="21、利用重载技术避免隐式类型转换"></a>21、利用重载技术避免隐式类型转换</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">struct</span> B
<span class="token punctuation">{</span>
    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b1<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>id <span class="token operator">+</span> b2<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//const B operator+(const B&amp; b1,int i)    //如果重载此方法，就不会产生临时对象了</span>
<span class="token comment" spellcheck="true">//{</span>
<span class="token comment" spellcheck="true">//  return B(b1.id + i);</span>
<span class="token comment" spellcheck="true">//}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    B b3 <span class="token operator">=</span> b1<span class="token operator">+</span> b2<span class="token punctuation">;</span>
    B b4 <span class="token operator">=</span> b1 <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//会把 6 先转换成B对象，产生临时对象</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="22、考虑以操作符复合形式-op-取代其独身形式-op"><a href="#22、考虑以操作符复合形式-op-取代其独身形式-op" class="headerlink" title="22、考虑以操作符复合形式(op=)取代其独身形式(op)"></a>22、考虑以操作符复合形式(op=)取代其独身形式(op)</h3><p>使用 operator+= 的实现来实现 operator= ，其它如果 operator*=、operator-= 等类似。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        B<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            id <span class="token operator">+</span><span class="token operator">=</span>  b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> <span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>id<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">int</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b1<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不用声明为 B 的 friend 函数,而且只需要维护 operator+= 即可。</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>B<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token operator">=</span> b2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里要去掉b1的const属性，才能带入operator+= 中的 this 中</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b3</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span>b1<span class="token operator">+</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10    这里进行 operator+ 操作，会改变 b1 的值，这个不应该吧</span>
    b1<span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//10</span>
    b3<span class="token operator">+</span><span class="token operator">=</span>b1<span class="token punctuation">;</span>
    b3<span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//110</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="23、考虑使用其它程序库"><a href="#23、考虑使用其它程序库" class="headerlink" title="23、考虑使用其它程序库"></a>23、考虑使用其它程序库</h3><p>提供类似功能的程序库，可能在效率、扩充性、移植性和类型安全方面有着不同的表现。比如说 iostream 和 stdio 库，所以选用不同的库可能会大幅改善程序性能。</p>
<h3 id="24、了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification-的成本"><a href="#24、了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification-的成本" class="headerlink" title="24、了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本"></a>24、了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本</h3><p>在使用虚函数时，大部分编译器会使用所谓的 virtual tables 和 virtual table pointers ，通常简写为 vtbls 和 vptrs 。vtbl 通常是由 “函数指针” 架构而成的数组，每一个声明（或继承）虚函数的类都有一个 vtbl ，而其中的条目就是该 class 的各个虚函数实现体的指针。<br>虚函数的第一个成本：必须为每个拥有虚函数的类耗费一个 vtbl 空间，其大小视虚函数的个数（包括继承而来的）而定。不过，一个类只会有一个 vtbl 空间，所以一般占用空间不是很大。</p>
<p>不要将虚函数声明为 inline ，因为虚函数是运行时绑定的，而 inline 是编译时展开的，即使你对虚函数使用 inline ，编译器也通常会忽略。<br>虚函数的第二个成本：必须为每个拥有虚函数的类的对象，付出一个指针的代价，即 vptr ，它是一个隐藏的 data member，用来指向所属类的 vtbl。</p>
<p>调用一个虚函数的成本，基本上和通过一个函数指针调用函数相同，虚函数本身并不构成性能上的瓶颈。</p>
<p>虚函数的第三个成本：事实上等于放弃了 inline。（如果虚函数是通过对象被调用，倒是可以 inline，不过一般都是通过对象的指针或引用调用的）</p>
<ul>
<li><p>虚函数真正的运行时期成本发生在和inlining互动的时候. 虚函数不应该inline. ◦因为inline函数需要在编译器将函数本体拷贝, 而virtual意味着等待, 直到运行期才知道运行谁.</p>
</li>
<li><p>多重继承往往导致虚基类的需求(virtual base class), 会形成更复杂和特殊的虚表.</p>
</li>
<li><p>一个类只需一份RTTI信息(运行时类型识别), 当某种类型至少拥有一个虚函数, 才能保证检验该对象的动态类型. </p>
<ul>
<li><p>RTTI的设计理念根据类的虚表(vtbl)来实现的.</p>
</li>
<li><p>RTTI的空间成本只需在每个类的虚表(vtbl)内增加一个条目, 即一个类型信息(type_info)对象空间.</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">struct</span> B1 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> B2 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> B3 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> D <span class="token operator">:</span> <span class="token keyword">virtual</span> B1<span class="token punctuation">,</span> <span class="token keyword">virtual</span> B2<span class="token punctuation">,</span> <span class="token keyword">virtual</span> B3 <span class="token punctuation">{</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B1<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//8</span>
std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B2<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//4</span>
std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//4</span>
std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//16</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//D 中只包含了三个 vptr ，D和B1共享了一个。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="五、技术-Techniques-Idioms-Patterns"><a href="#五、技术-Techniques-Idioms-Patterns" class="headerlink" title="五、技术(Techniques,Idioms,Patterns)"></a>五、技术(Techniques,Idioms,Patterns)</h2><h3 id="25、将-constructor-和-non-member-functions-虚化"><a href="#25、将-constructor-和-non-member-functions-虚化" class="headerlink" title="25、将 constructor 和 non-member functions 虚化"></a>25、将 constructor 和 non-member functions 虚化</h3><p>这里所谓的虚拟构造函数，并不是真的指在构造函数前面加上 virtual 修饰符，而是指能够根据传入不同的参数建立不同继承关系类型的对象。<br>被派生类重定义的虚函数可以与基类的虚函数具有不同的返回类型。所以所谓的虚拟复制构造函数，可以在基类里声明一个 virtual B* clone() const = 0 的纯虚函数，在子类中实现 virtual D* clone() const {return new D(*this);}</p>
<p>同样的，非成员函数虚化，这里也并不是指使用 virtual 来修饰非成员函数。比如下面这个输出 list 中多态对象的属性：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">B</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">value</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">virtual</span> ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span><span class="token operator">:</span>
        string value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D1</span> <span class="token operator">:</span> <span class="token keyword">public</span> B
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">D1</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token string">"protect value"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//子类构造函数中，要先调用基类构造函数初始化基类</span>
        ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>id<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//如果基类虚函数是 const 方法，则这里也必须使用 const 修饰</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">int</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D2</span> <span class="token operator">:</span> <span class="token keyword">public</span> B
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">D2</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token string">"protect value"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//子类构造函数中，要先调用基类构造函数初始化基类</span>
        ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>id<span class="token punctuation">;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">int</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    list<span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span> lt<span class="token punctuation">;</span>
    D1 <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    D2 <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
   <span class="token keyword">while</span><span class="token punctuation">(</span>it <span class="token operator">!=</span> lt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//D1   D2</span>
        it<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，即使给每一个继承类单独实现友元的 operator&lt;&lt; 方法，也不能实现动态绑定，只会调用基类的方法。那么，在基类里写 operator&lt;&lt; 用 virtual 修饰不就行了吗？遗憾的，虚函数不能是友元。</p>
<h3 id="26、限制某个-class-所能产生的对象数量"><a href="#26、限制某个-class-所能产生的对象数量" class="headerlink" title="26、限制某个 class 所能产生的对象数量"></a>26、限制某个 class 所能产生的对象数量</h3><p>只有一个对象：使用单一模式，将类的构造函数声明为private，再声明一个静态函数，该函数中有一个类的静态对象不将该静态对象放在类中原因是放在函数中时，执行函数时才建立对象，并且对象初始化时间确定的，即第一次执行该函数时另外，该函数不能声明为内联，如果内联可能造成程序的静态对象拷贝超过一个限制对象个数：建立一个基类，构造函数中计数加一，若超过最大值则抛出异常；析构函数中计数减一</p>
<p>编程点滴：</p>
<p>将模板类的定义和实现放在一个文件中，否则将造成引用未定义错误（血的教训）；</p>
<p>静态数据成员需要先声明再初始化；</p>
<p>用常量值作初始化的有序类型的const静态数据成员是一个常量表达式（可以作为数组定义的维数）；</p>
<p>构造函数中抛出异常，将导致静态数组成员重新初始化</p>
<h3 id="27、要求（或禁止）对象产生于-heap-中"><a href="#27、要求（或禁止）对象产生于-heap-中" class="headerlink" title="27、要求（或禁止）对象产生于 heap 中"></a>27、要求（或禁止）对象产生于 heap 中</h3><p>析构函数私有，有一个致命问题：妨碍了继承和组合（内含）。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B1</span>    <span class="token comment" spellcheck="true">//禁止对象产生于 heap 中</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B1"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B2</span>    <span class="token comment" spellcheck="true">//要求对象产生于 heap 中</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//模拟的析构函数</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token operator">~</span><span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//B1* b1  = new B1; //Error!</span>
    B1 b1<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//B2 b2;    //Error</span>
    B2<span class="token operator">*</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> B2<span class="token punctuation">;</span>
    b2<span class="token operator">-</span><span class="token operator">></span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="28、Smart-Pointer（智能指针）"><a href="#28、Smart-Pointer（智能指针）" class="headerlink" title="28、Smart Pointer（智能指针）"></a>28、Smart Pointer（智能指针）</h3><ul>
<li><p>智能指针是一个看起来, 用起来, 感觉起来都像内建指针, 但是提供了更多机能的一种对象. </p>
<ul>
<li>资源管理;</li>
<li>自动的重复写码工作.</li>
</ul>
</li>
<li><p>以智能指针取代C++内建指针: </p>
<ul>
<li>构造和析构: 何时被产生以及何时被销毁.</li>
<li>赋值和复制(Assignment and Copying), 复制和赋值其所指对象, 执行所谓的深拷贝(deep copy).</li>
<li>解引用(Dereferencing): 智能指针有权决定所指之物发生了什么事情. </li>
<li>采用lazy fetching方法.</li>
</ul>
</li>
<li><p>远程过程调用(remote procedure calls, RPC).</p>
</li>
<li><p>只能指针的构造, 赋值和析构 </p>
<ul>
<li>只有当确定要将对象所有权传递给函数的某个参数时, 才应该以by value方式传递auto_ptrs.</li>
</ul>
</li>
<li><p>实现解引操作符(Dereferencing Operators): </p>
<ul>
<li>返回引用值.</li>
</ul>
</li>
<li><p>测试智能指针是否为null: </p>
<ul>
<li>提供一个隐式类型转换操作符来进行测试.</li>
</ul>
</li>
<li><p>将智能指针(smart pointers) 转换为内建指针(Dumb Pointers). </p>
<ul>
<li>不要提供对内建指针的隐式转换操作符, 除非不得已.</li>
</ul>
</li>
<li><p>智能指针(Smart Pointers)和继承有关的类型转换 </p>
<ul>
<li>每个只能指针有个隐式类型转换操作符, 用来转换至另一个只能指针类.</li>
<li>函数调用的自变量匹配规则;</li>
<li>隐式类型转换函数;</li>
<li>template函数的暗自实例化;</li>
<li>成员函数模板(member function templates)等技术.</li>
</ul>
</li>
<li><p>智能指针与const: </p>
<ul>
<li>const用来修饰被指之物, 或是指针本身, 或是两者都可以. 智能指针也具有同样的弹性.</li>
<li>对于智能指针只有一个地方可以放置const: 只能放置与指针身上, 不能置于所指的对象.</li>
<li>non-const转换至const是安全的, 从const转换至non-const则不安全.</li>
</ul>
</li>
<li><p>自己实现的智能指针不容易实现, 了解和维护.</p>
</li>
</ul>
<h3 id="29、Reference-counting（引用计数）"><a href="#29、Reference-counting（引用计数）" class="headerlink" title="29、Reference counting（引用计数）"></a>29、Reference counting（引用计数）</h3><p>使用引用计数后，对象自己拥有自己，当没有人再使用它时，它自己自动销毁自己因此，引用计数是个简单的垃圾回收体系</p>
<p>在基类中调用delete this将导致派生类的对象被销毁</p>
<p>写时拷贝：与其它对象共享一个值直到写操作时才拥有自己的拷贝它是Lazy原则的特例</p>
<p>精彩的类层次结构：<br>RCObject类提供计数操作；<br>StringValue包含指向数据的指针并继承RCObject的计数操作；<br>RCPtr是一个灵巧指针，封装了本属于String的一些计数操作</p>
<h3 id="30、Proxy-classes（替身类、代理类）"><a href="#30、Proxy-classes（替身类、代理类）" class="headerlink" title="30、Proxy classes（替身类、代理类）"></a>30、Proxy classes（替身类、代理类）</h3><ul>
<li><p>凡是用来代表(象征)其他对象的对象, 常被称为proxy object(替身对象), 替身对象的类称为代理类. </p>
<ul>
<li>二维数组是观念上并不存在的一维数组.</li>
</ul>
</li>
<li><p>读取动作是所谓的右值运用(rvalue usage); 写动作是所谓的左值运用(lvalue usages).</p>
</li>
<li><p>返回字符串中字符的proxy, 而不返回字符本身.</p>
</li>
<li><p>对于一个proxy, 只有3间事情可做: </p>
<ul>
<li>产生它;</li>
<li>以它作为赋值动作的目标(接收端).</li>
<li>以其他方式使用它.</li>
</ul>
</li>
<li><p>Proxy 类很适合用来区分operator[]的左值运用和右值运用.</p>
</li>
<li><p>对proxy取址所获得的指针类型和对真是对象取址所获得的指针类型不同.</p>
</li>
<li><p>用户将proxy传递给接受引用到非const对象的函数.</p>
</li>
<li><p>ploxies难以完全取代真正对象的最后一个原因在于隐式类型转换.</p>
</li>
<li><p>proxy 对象是一种临时对象, 需要被产生和被销毁.</p>
</li>
<li><p>类的身份从与真实对象合作转移到与替身对象(proxies)合作, 往往会造成类语义的改变, 因为proxy 对象所展现的行为常常和真正的行为有些隐微差异.</p>
</li>
</ul>
<h3 id="31、让函数根据一个以上的对象类型来决定如何虚化"><a href="#31、让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="31、让函数根据一个以上的对象类型来决定如何虚化"></a>31、让函数根据一个以上的对象类型来决定如何虚化</h3><ul>
<li><p>面向对象函数调用机制(mutil-method): 根据所希望的多个参数而虚化的函数; — C++暂时不支持.</p>
</li>
<li><p>消息派分(message dispatch): 虚函数调用动作.</p>
</li>
<li><p>虚函数+RTTI(运行时期类型辨识): </p>
<ul>
<li>虚函数可以实现single dispatch, 利用typeid操作符来获取一个类的类型参数值.</li>
</ul>
</li>
<li><p>虚函数被发明的主要原因: </p>
<ul>
<li>把生产及维护”以类型为行事基准的函数”的负荷, 从程序员转移给编译器.</li>
</ul>
</li>
<li><p>只用虚函数: </p>
<ul>
<li>将double dispatching以两个single dispatches(两个分离的虚函数调用)实现出来: <ul>
<li>一个用来决定第一对象的动态类型.</li>
<li>另一个用来决定第二对象的动态类型.</li>
</ul>
</li>
<li>编译器必须根据此函数所获得的自变量的静态类型(被声明时的类型), 才能解析出哪一组函数被调用.</li>
</ul>
</li>
</ul>
<h2 id="六、杂项讨论-Miscellany"><a href="#六、杂项讨论-Miscellany" class="headerlink" title="六、杂项讨论(Miscellany)"></a>六、杂项讨论(Miscellany)</h2><h3 id="32、在未来时态下发展程序"><a href="#32、在未来时态下发展程序" class="headerlink" title="32、在未来时态下发展程序"></a>32、在未来时态下发展程序</h3><p>要用语言提供的特性来强迫程序符合设计，而不要指望使用者去遵守约定。比如禁止继承，禁止复制，要求类的实例只能创建在堆中等等。处理每个类的赋值和拷贝构造函数，如果这些函数是难以实现的，则声明它们为私有。</p>
<p>所提供的类的操作和函数有自然的语法和直观的语义，和内建类型（如 int）的行为保持一致。</p>
<p>尽可能写可移植性的代码，只有在性能极其重要时不可移植的结构才是可取的。</p>
<p>多为未来的需求考虑，尽可能完善类的设计。</p>
<h3 id="33、将非尾端类设计为抽象类"><a href="#33、将非尾端类设计为抽象类" class="headerlink" title="33、将非尾端类设计为抽象类"></a>33、将非尾端类设计为抽象类</h3><p>如果有一个实体类公有继承自另一个实体类，应该将两个类的继承层次改为三个类的继承层次，通过创造一个新的抽象类并将其它两个实体类都从它继承因此，设计类层次的一般规则是：非尾端类应该是抽象类在处理外来的类库，可能不得不违反这个规则</p>
<p>编程点滴：抽象类的派生类不能是抽象类；实现纯虚函数一般不常见，但对纯虚析构函数，它必须实现</p>
<h3 id="34、如何在同一个程序中结合-C-和-C"><a href="#34、如何在同一个程序中结合-C-和-C" class="headerlink" title="34、如何在同一个程序中结合 C++ 和 C"></a>34、如何在同一个程序中结合 C++ 和 C</h3><ul>
<li><p>结合C++和C程序需要考虑的问题: </p>
<ul>
<li>名称重整(name mangling): <ul>
<li>名称重整(name mangling)是C++中的一种程序, 为每个函数编出独一无二的名称.</li>
<li>绝不要重整其他语言编写函数的名称.</li>
<li>压制名称重整(name mangling), 必须在C++中使用extern “C” { … }指令. — 进行C连接.</li>
<li>不同编译器以不同的方法进行重整名称.        </li>
</ul>
</li>
<li>static的初始化: <ul>
<li>在main之前执行的代码: static class对象, 全局对象, namespace内的对象, 文件范围(file scope)内的对象, 其构造函数都在main函数之前执行.</li>
</ul>
</li>
</ul>
</li>
<li><p>动态内存分配: </p>
<ul>
<li>C++中使用new和delete, C中使用malloc和free.</li>
</ul>
</li>
<li><p>数据结构的兼容性: </p>
<ul>
<li>structs可以安全地在C++和C之间往返.</li>
</ul>
</li>
<li><p>在同一程序中混用C++和C, 应该记住以下几个简单规则: </p>
<ul>
<li>确定C++和C编译器产出兼容的目标文件(object file).</li>
<li>将双方都使用的函数声明为extern “C”.</li>
<li>如果可能, 尽量在C++中撰写main.</li>
<li>总是以delete删除new返回的内存, 总是以free释放malloc返回的内存.</li>
<li>将两个语言间的数据结构传递限制于C所能了解的形式; C++structs如果内涵非虚函数, 倒是不受此限制.</li>
</ul>
</li>
</ul>
<h3 id="35、让自己习惯于标准-C-语言"><a href="#35、让自己习惯于标准-C-语言" class="headerlink" title="35、让自己习惯于标准 C++ 语言"></a>35、让自己习惯于标准 C++ 语言</h3><ul>
<li><p>新的语言特性: </p>
<ul>
<li>RTTI, 命名空间(namespace), bool, 关键字mutable, 关键字explicit, enums作为重载函数的自变量所引发的类型晋升转换, 在类中为const static成员变量设定初值.</li>
</ul>
</li>
<li><p>STL(standard template library) — C++标准程序库中最大的组成部分. </p>
<ul>
<li>迭代器(iterators)是一种行为类似指针的对象, 针对STL 容器而定义.</li>
</ul>
</li>
</ul>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://www.zzw1024.top" rel="external nofollow noreferrer">zzw</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://www.zzw1024.top/2020/01/01/du-shu-bi-ji-more-effective-c/">http://www.zzw1024.top/2020/01/01/du-shu-bi-ji-more-effective-c/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="http://www.zzw1024.top" target="_blank">zzw</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/c-%E6%8F%90%E5%8D%87/">
                                    <span class="chip bg-color">c++提升</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">谢谢你请我吃糖果</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/img/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/img/weChatPay.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <div id="gitalk-container" style="padding: 0px 30px 0px 30px;"></div> 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">

if(true){
    var gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: 'bolg-comment',
    owner: '',
    admin: [''],
    id: 'Wed Jan 01 2020 15:38:48 GMT+0800',
    distractionFreeMode: ''
})
gitalk.render('gitalk-container') 
}
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/01/01/ruan-jian-shen-qi-shi-pin-xia-zai-shen-qi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="软件神器——视频下载神器">
                        
                        <span class="card-title">软件神器——视频下载神器</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            youtube-dl：Youtube-dl是谷歌github上的一个开源项目，它是一款轻量级的命令行下载实用工具，阿刚曾在乐软博客里文章《不仅仅是youtube，youtube-dl在线视频下载神器》一文章，详细介绍过Youtube-dl。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-01-01
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%BD%AF%E4%BB%B6%E7%A5%9E%E5%99%A8/" class="post-category">
                                    软件神器
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%A7%86%E9%A2%91/">
                        <span class="chip bg-color">视频</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/01/01/du-shu-bi-ji-effective-c/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="读书笔记——《Effective C++》">
                        
                        <span class="card-title">读书笔记——《Effective C++》</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            让自己习惯C++视C++为一个语言联邦
C语言
面对对象
C++模板
STL容器

尽量以const，enum，inline替换#define
const的好处： 
define直接常量替换，出现编译错误不易定位(不知道常量是哪个变量)
d
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-01-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">
                                    读书笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/c-%E6%8F%90%E5%8D%87/">
                        <span class="chip bg-color">c++提升</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('100')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 自由の翼<br />'
            + '作者: 自由の翼<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="http://www.zzw1024.top" target="_blank">自由の翼</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "11";
                    var startDate = "11";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/zzwblog" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="https://blog.csdn.net/weixin_42637495" class="tooltipped" target="_blank" data-tooltip="访问我的CSDN" data-position="top" data-delay="50">
        <i class="fab fa-dribbble"></i>
    </a>



    <a href="https://www.cnblogs.com/zzw1024/" class="tooltipped" target="_blank" data-tooltip="访问我的博客园" data-position="top" data-delay="50">
        <i class="fa fa-rss-square"></i>
    </a>



    <a href="mailto:819342493@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://pic3.superbed.cn/item/5de4fcd8f1f6f81c50366b77.png" class="tooltipped" target="_blank" data-tooltip="请加我QQ" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://pic1.superbed.cn/item/5de4fd1bf1f6f81c50367398.png" class="tooltipped" target="_blank" data-tooltip="请加我微信" data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>















</div>
    </div>

    <script>
    (function(){
        var bp = document.createElement('script');
        bp.src = '//push.zhanzhang.baidu.com/push.js';
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>

</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

    <!-- 雪花特效 -->
    
      <script type="text/javascript" src="/js/snow.js"></script>
    


    <!-- <script async type="text/javascript" size="90" alpha="0.2" zIndex="0" src="/plugins/ribbon.js/ribbon.min.js"></script> -->
    
    
        <script type="text/javascript" src="/plugins/live2d-widget.js/L2Dwidget.min.js"></script>
<script type="text/javascript">
  /**
   * 完整配置请参考：https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init
   */
  var pluginModelPath = "assets/", // 模型的文件路径，无需更改
    pluginRootPath = "/live2d_models/"; // 插件的路径，无需更改
  //特定的模型json文件名称
  var modelPathJson = {
    "epsilon2_1": "Epsilon2.1",
    "gf": "Gantzert_Felixander",
    "haru/01": "haru01",
    "haru/02": "haru02",
    "nietzsche": "nietzche"
  }

  
    var modelName = "shizuku";
  

  var modelJsonPath = "";
  if (modelPathJson[modelName]) {
    modelJsonPath = pluginRootPath + modelName + "/" + pluginModelPath + modelPathJson[modelName] +
      ".model.json";
  } else {
    modelJsonPath = pluginRootPath + modelName + "/" + pluginModelPath + modelName + ".model.json";
  }
  L2Dwidget.init({
    model: {
      jsonPath: modelJsonPath
    },
    display: {
       position: "right", 
       width: 145, 
       height: 315, 
       hOffset: 50, 
       vOffset: 35 
    },
    mobile: {
       show: false, 
       scale: 0.6 
    },
    react: {
       opacity: 0.8 
    }
  })

</script>

    

    <!-- 音乐 -->
     

    <!-- 天气 -->
     
        <!-- weather -->
<script type="text/javascript">
    WIDGET = {FID: 'iBarNbUMlb'}
    </script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>
    


</body>

</html>
