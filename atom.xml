<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自由の翼</title>
  <icon>https://www.gravatar.com/avatar/4b22ce9ec4999fcb091d9b70473733a4</icon>
  <subtitle>书的海洋遨游，知识的世界飞翔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zzw1024.top/"/>
  <updated>2020-06-10T05:10:27.000Z</updated>
  <id>http://www.zzw1024.top/</id>
  
  <author>
    <name>自由の翼</name>
    <email>819342493@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客——git项目推送多个仓库</title>
    <link href="http://www.zzw1024.top/2020/06/10/bo-ke-git-xiang-mu-tui-song-duo-ge-cang-ku/"/>
    <id>http://www.zzw1024.top/2020/06/10/bo-ke-git-xiang-mu-tui-song-duo-ge-cang-ku/</id>
    <published>2020-06-10T05:10:27.000Z</published>
    <updated>2020-06-10T05:10:27.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><p>转载:<a href="https://www.cnblogs.com/poloyy/p/12215199.html" target="_blank" rel="noopener">https://www.cnblogs.com/poloyy/p/12215199.html</a></p><h1 id="Gitee拉取Github仓库"><a href="#Gitee拉取Github仓库" class="headerlink" title="Gitee拉取Github仓库"></a>Gitee拉取Github仓库</h1><p>直接在Gitee中创建一个项目，然后再最后一行导入Github项目就阔以啦！<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131207560-500399712.png" alt=""></p><p>去到你的Github仓库复制https链接，直接粘贴就阔以啦<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131220912-39508480.png" alt=""></p><p>到此为止，在Gitee就已经创建好仓库啦</p><h1 id="本地配置推送方式"><a href="#本地配置推送方式" class="headerlink" title="本地配置推送方式"></a>本地配置推送方式</h1><ul><li>方式一：定义不同的远程仓库名称，然后分别推送 多次推送，配了几个远程仓库就推送几次 </li><li>方式二：在同一个远程仓库下添加另一个远程仓库的地址，然后推送 only一次推送 </li></ul><p>==以下情况均是本地只有单个ssh-key时的操作！！== </p><ol><li>方式一：多次推送</li></ol><ul><li>优点</li></ul><ul><li>想推哪个仓库就推哪个    </li><li>不想推哪个就不推哪个</li></ul><ul><li><p>缺点<br>推送仓库数量多时，时间成本高</p></li><li><p>1）.可以直接通过命令将本地项目和gitee项目关联<br><code>git remote add gitee 码云项目地址</code></p></li><li><p>2).也可以通过修改本地项目的配置文件</p><blockquote><p>a. 首先，进入到项目的 .git 文件夹，打开 config 文件<br>b. 然后，找到 [remote “origin”] ，复制一份remote到下面，修改remote的名字和url即可<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131603763-997002322.png" alt=""></p></blockquote></li></ul><p>为了避免冲突，将原始的remote名字也改掉，注意：remote的名字任意，但是在提交的时候要与这里对应<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131614188-1802431619.png" alt=""></p><ul><li><p>3).执行以下命令，可以看到配置的两个仓库<br><code>git remote</code></p></li><li><p>4).推送代码时，需要对两个仓库分别执行一次push命令，也就是多次推送</p><pre><code>git push github matser git push gitee master  </code></pre></li></ul><ol start="2"><li>方式二：一次推送</li></ol><ul><li><p>1).通过命令将码云项目地址添加到本地已有的remote下<br><code>git remote set-url --add origin 码云项目地址</code></p></li><li><p>2).也可以通过修改本地项目的配置文件<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131732930-127632063.png" alt=""></p></li><li><p>3).推送代码只需执行以下一条命令即可<br><code>git push</code></p></li></ul><h1 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h1><p>博主就是配完之后遇到了该问题，所以拿出来跟大家说说哈<br><code>git push的时有时候会出现错误[rejected] master -&gt; master (fetch first)</code><br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131745200-133461885.png" alt=""></p><p>此时可以输入： git push -f   进行解决错误，然后再： git push      </p><p>如果上述解决方式不管用也可以输入： git pull –rebase origin master  之后再进行 git push 即可。</p><h1 id="本地有多个ssh-key时"><a href="#本地有多个ssh-key时" class="headerlink" title="本地有多个ssh-key时"></a>本地有多个ssh-key时</h1><p>如果也想配多个ssh-key的话，可以参照这篇文章哦<br><code>https://www.cnblogs.com/poloyy/p/12189140.html</code></p><p>你需要更改两个地方</p><ul><li>第一：公钥配置文件，目录是： C:\Users\user.ssh 下的 config 文件</li></ul><p>现在多了gitee，所以对应的Host也要增加，如下图<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131816433-384293327.png" alt=""></p><p>我这里是两个ssh-key都会被Github和Gitee共用，正常来说是一个ssh-key指向一个仓库即可，譬如第一个key的Host配成Github的，第二个Key的Host配成Gitee<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131820697-1347076172.png" alt=""></p><ul><li>第二：需要修改在上面配置过的 config 文件，它在你的项目目录下的 .git 文件夹下</li></ul><p>原本只有一个ssh-key时，你的配置文件可能是这样的<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131831679-548241428.png" alt=""></p><p>当你有两个ssh-key时，你的配置文件就需要改成如下<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131841795-1639237760.png" alt=""></p><p>最后将 Github_HOST 、 Gitee_HOST 替换成你自己配置里的Host地址。其余步骤都是一样的啦！这里就是要强调下，如果有多个ssh-key时，还得修改下配置文件而已~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;

&lt;p&gt;转载:&lt;a href=&quot;https://www.cnblogs.com/poloyy/p/12215199.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/po
      
    
    </summary>
    
    
      <category term="博客" scheme="http://www.zzw1024.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="git, 推送" scheme="http://www.zzw1024.top/tags/git-%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>博客——博客搭建</title>
    <link href="http://www.zzw1024.top/2020/06/09/bo-ke-bo-ke-da-jian/"/>
    <id>http://www.zzw1024.top/2020/06/09/bo-ke-bo-ke-da-jian/</id>
    <published>2020-06-09T14:46:55.000Z</published>
    <updated>2020-06-09T14:46:55.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><blockquote><p>转载自博客：<a href="https://juejin.im/entry/5a574864f265da3e3c6c1217" target="_blank" rel="noopener">https://juejin.im/entry/5a574864f265da3e3c6c1217</a><br>侵权告知。</p></blockquote><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>在 Windows 环境下安装 Node.js 非常简单，仅须到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网下载</a>安装文件并执行即可完成安装。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c6feba58fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p>去<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git官网</a>根据你的电脑参数，下载对应版本。</p><p>下载完成，通过在命令行输入 git version 查看是否安装成功，有输出版本号说明安装成功。</p><p>鼠标邮件菜单里就多了Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行，我们选择Git Bash Here。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c6fea994bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c725a598e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="一、Hexo安装"><a href="#一、Hexo安装" class="headerlink" title="一、Hexo安装"></a>一、Hexo安装</h2><p>桌面右键鼠标，点击Git Bash Here，输入npm命令即可安装</p><pre><code>npm install hexo-cli -gnpm install hexo-deployer-git --save</code></pre><p>第一句是安装hexo，第二句是安装hexo部署到git page的deployer，两个都需要安装。</p><p>如下图即安装完成。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c728dda55c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="二、Hexo初始化配置"><a href="#二、Hexo初始化配置" class="headerlink" title="二、Hexo初始化配置"></a>二、Hexo初始化配置</h2><ul><li><p>创建Hexo文件夹<br>安装完成后，根据自己喜好建立目录（如F:\Blog\Hexo），直接进入F:\Blog\Hexo文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。<br><code>$ hexo init</code><br>安装 Hexo 完成后，Hexo 将会在指定文件夹中新建所需要的文件。Hexo文件夹下的目录如下：<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7293a169d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>本地查看效果<br>执行下面语句，执行完即可登录localhost:4000查看效果</p><pre><code>hexo generatehexo server</code></pre><p>登录localhost:4000，即可看到本地的效果如下：<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c72acc46d2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li></ul><h1 id="将博客部署到Github-Pages上"><a href="#将博客部署到Github-Pages上" class="headerlink" title="将博客部署到Github Pages上"></a>将博客部署到Github Pages上</h1><p>那么现在本地的博客已经搭建起来了，但是我们只可以通过本地连接查看我们的博客。那么我们现在需要做的就是把本地的博客发布到服务器上，让别人也可以连接我们的博客，而Github Pages就帮我完成了这件事情。但是Github Pages的代码就是寄存在Github上面的。那么接下来我们需要在Github上面创建一个新的项目。</p><h2 id="一、注册Github账户"><a href="#一、注册Github账户" class="headerlink" title="一、注册Github账户"></a>一、注册Github账户</h2><p>访问Github首页<br>点击右上角的 Sign Up，注册自己的账户</p><h2 id="二、创建项目代码库"><a href="#二、创建项目代码库" class="headerlink" title="二、创建项目代码库"></a>二、创建项目代码库</h2><p>注册完登陆后，我们就创建一个我们自己的Github Pages项目。点击New repository。<br>创建要点如下：<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7492a1849?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="三、配置SSH密钥"><a href="#三、配置SSH密钥" class="headerlink" title="三、配置SSH密钥"></a>三、配置SSH密钥</h2><p>配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下：</p><ol><li>第一步、看看是否存在SSH密钥(keys)<br>首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行:<br><code>$ cd ~/. ssh</code><br>检查你本机用户home目录下是否存在.ssh目录</li></ol><p>如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。</p><ol start="2"><li>第二步、创建一对新的SSH密钥(keys)<br><code>$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></li></ol><p>** 这将按照你提供的邮箱地址，创建一对密钥 ** </p><pre><code>Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</code></pre><p>直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如<code>/c/Users/you/.ssh/github_rsa</code></p><p>接着，根据提示，你需要输入密码和确认密码（说到这里，如果你很放心，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。所谓的最安全的密码，就是没有密码 哈哈）。相关提示如下：</p><pre><code>Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again]</code></pre><p>输入完成之后，屏幕会显示如下信息：</p><pre><code>Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</code></pre><ol start="3"><li>第三步、在GitHub账户中添加你的公钥<br>运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。<br><code>clip &lt; ~/.ssh/id_rsa.pub</code><br>接着：</li></ol><ul><li><p>1). 登陆GitHub,进入你的Account Settings.<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c74ea98dce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>2). 选择SSH Keys<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c75003310c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>3). 粘贴密钥，添加即可<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c758d3dd78?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li></ul><ol start="4"><li><p>第四步、测试<br>可以输入下面的命令，看看设置是否成功，<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>的部分不要修改：<br><code>$ ssh -T git@github.com</code><br>如果是下面的反馈：</p><pre><code>The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?</code></pre><p>不要紧张，输入yes就好，然后会看到：<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c76b83e076?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>第五步、设置用户信息<br>现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。<br>Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。</p><pre><code>$ git config --global user.name &quot;ryanlijianchang&quot;//用户名$ git config --global user.email  &quot;liji.anchang@163.com&quot;//填写自己的邮箱</code></pre></li><li><p>第六步、SSH Key配置成功<br>本机已成功连接到github。</p></li></ol><h2 id="四、将本地的Hexo文件更新到Github的库中"><a href="#四、将本地的Hexo文件更新到Github的库中" class="headerlink" title="四、将本地的Hexo文件更新到Github的库中"></a>四、将本地的Hexo文件更新到Github的库中</h2><ul><li><p>第一步、登录Github打开自己的项目 username.github.io<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c76bcbdef9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>第二步、打开之后，点击SSH，选择SSH类型地址<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c77317a936?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>第三步、复制地址<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c77a882a00?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>第四步、打开你一开始创建的Hexo文件夹（如F:\Blog\Hexo），用记事本打开刚文件夹下的_config.yml文件<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c787c11116?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>第五步、在配置文件里作如下修改，保存<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c78dc8dca4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li></ul><h2 id="第六步、在Hexo文件夹下执行："><a href="#第六步、在Hexo文件夹下执行：" class="headerlink" title="第六步、在Hexo文件夹下执行："></a>第六步、在Hexo文件夹下执行：</h2><pre><code>hexo ghexo d</code></pre><p>或者直接执行</p><pre><code>hexo g -d</code></pre><p>执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。对应的地址是 username.github.io(我的是：ryanlijianchang.github.io)。</p><p>假如这时候，报错 ERROR Deployer not found: git，那么就是你的deployer没有安装成功，你需要执行如下命令再安装一次：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>这样，你再执行hexo g -d，你的博客就部署到Github上了。</p><h2 id="第七步、在浏览器上输入自己的主页地址"><a href="#第七步、在浏览器上输入自己的主页地址" class="headerlink" title="第七步、在浏览器上输入自己的主页地址"></a>第七步、在浏览器上输入自己的主页地址</h2><p>在浏览器上输入Github Pager为我们生成的外链（例如我的是：ryanlijianchang.github.io/，而你的只需要把你的github用户名替换掉这个链接中的ryanlijianchang，因为我的用户名是这个，那么你自己的专属博客地址就是：https://[您的用户名].github.io/）即可看到自己的博客了。</p><p>当然，每一个人都可以通过这个地址访问到你的博客了。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c79436ba6a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h1 id="美化自己博客"><a href="#美化自己博客" class="headerlink" title="美化自己博客"></a>美化自己博客</h1><p>那么现在我们的博客已经挂在了Github服务器上面，别人已经可以通过地址来登陆我们的博客了，但是我们这时就有了新的需求，就是自己的博客并不好看，那怎么办的？这很简单，要知道很多前端开发者在Hexo框架下开发了很多的主题给我们使用，我们只需要把他们的主题克隆过来，然后通过修改配置文件即可达到我们所需要的效果。</p><p>那么我们应该怎么修改呢？</p><h2 id="一、进入Hexo的官网主题专栏"><a href="#一、进入Hexo的官网主题专栏" class="headerlink" title="一、进入Hexo的官网主题专栏"></a>一、进入<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo的官网</a>主题专栏</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7943f8189?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="二、挑选我们喜欢的主题"><a href="#二、挑选我们喜欢的主题" class="headerlink" title="二、挑选我们喜欢的主题"></a>二、挑选我们喜欢的主题</h2><p>可以看到有很多主题给我们选，我们只要选择喜欢的主题点击进去，然后进入到它的github地址，我们只要把这个地址复制下来(例如我是选择：hexo-theme-next这个主题)<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7ab832ba0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="三、克隆主题"><a href="#三、克隆主题" class="headerlink" title="三、克隆主题"></a>三、克隆主题</h2><p>再打开Hexo文件夹下的themes目录（F:\Blog\hexo\themes），右键Git Bash，在命令行输入:</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) </code></pre><p>下载中，等待下载完成：<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7b605e272?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="四、修改Hexo配置文件"><a href="#四、修改Hexo配置文件" class="headerlink" title="四、修改Hexo配置文件"></a>四、修改Hexo配置文件</h2><p>下载完成后，打开Hexo文件夹下的配置文件_config.yml</p><p>修改参数为：<code>theme: hexo-theme-next</code></p><h2 id="五、部署主题，本地查看效果"><a href="#五、部署主题，本地查看效果" class="headerlink" title="五、部署主题，本地查看效果"></a>五、部署主题，本地查看效果</h2><p>返回Hexo目录，右键Git Bash，输入</p><pre><code>hexo ghexo s</code></pre><p>打开浏览器，输入 Http://localhost:4000/ 即可看见我们的主题已经更换了。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7b86f3ce1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="六、如果效果满意，将它部署到Github上"><a href="#六、如果效果满意，将它部署到Github上" class="headerlink" title="六、如果效果满意，将它部署到Github上"></a>六、如果效果满意，将它部署到Github上</h2><p>打开Hexo文件夹，右键Git Bash，输入</p><pre><code>hexo clean   (必须要，不然有时因为缓存问题，服务器更新不了主题)hexo g -d</code></pre><h2 id="七、打开自己的主页，即可看到修改后的效果"><a href="#七、打开自己的主页，即可看到修改后的效果" class="headerlink" title="七、打开自己的主页，即可看到修改后的效果"></a>七、打开自己的主页，即可看到修改后的效果</h2><p>更多修改效果请查看对应主题的说明文档，点击此查看本主题(Next)对应的说明文档。</p><h1 id="在博客写文章"><a href="#在博客写文章" class="headerlink" title="在博客写文章"></a>在博客写文章</h1><h2 id="一、用hexo发表新文章"><a href="#一、用hexo发表新文章" class="headerlink" title="一、用hexo发表新文章"></a>一、用hexo发表新文章</h2><pre><code>$ hexo n &quot;文章标题&quot; </code></pre><p>其中 我的家 为文章标题，执行命令 hexo n “我的家” 后，会在项目 \Hexo\source_posts 中生成 我的家.md文件，用编辑器打开编写即可。</p><p>当然，也可以直接在\Hexo\source_posts中新建一个md文件，我就是这么做的。<br>写完后，推送到服务器上，执行以下命令即可在我们的站点看到新的文章。</p><pre><code>$ hexo g #生成$ hexo d #部署 # 可与hexo g合并为 hexo d -g</code></pre><h2 id="二、用Markdown写文章"><a href="#二、用Markdown写文章" class="headerlink" title="二、用Markdown写文章"></a>二、用Markdown写文章</h2><p>我们注意到在 \Hexo\source_posts 文件夹下存放着我们的文章，它们的格式都是以.md格式结尾的，没错，Hexo也是支持Markdown语法的，所以当我们需要写具有格式化的文章时，我们可以使用支持Markdown语法的编辑器进行文章编译，然后保存文件到 \Hexo\source_posts 文件夹下即可。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7bd487097?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>复制进去之后，只要执行</p><pre><code>$ hexo d -g </code></pre><p>推送到我们的Github仓库即可。</p><h3 id="那么什么是Markdown？"><a href="#那么什么是Markdown？" class="headerlink" title="那么什么是Markdown？"></a>那么什么是Markdown？</h3><p>Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p><h3 id="Markdown有什么优点？"><a href="#Markdown有什么优点？" class="headerlink" title="Markdown有什么优点？"></a>Markdown有什么优点？</h3><ul><li>专注你的文字内容而不是排版样式。</li><li>轻松的导出 HTML、PDF 和本身的 .md 文件。</li><li>纯文本内容，兼容所有的文本编辑器与字处理软件。</li><li>可读，直观。适合所有人的写作语言。</li></ul><h3 id="我该用什么工具？"><a href="#我该用什么工具？" class="headerlink" title="我该用什么工具？"></a>我该用什么工具？</h3><ul><li>Windows下可以使用 MarkdownPad2。</li><li>在 Mac OS X 上，我建议你用 Mou 这款免费且十分好用的 Markdown 编辑器。</li><li>Web 端上，我强烈推荐 简书 这款产品。</li></ul><h3 id="关于Markdown的更多资料可以查看如下："><a href="#关于Markdown的更多资料可以查看如下：" class="headerlink" title="关于Markdown的更多资料可以查看如下："></a>关于Markdown的更多资料可以查看如下：</h3><ul><li><a href="https://sspai.com/post/25137" target="_blank" rel="noopener">认识与入门 Markdown</a></li><li><a href="https://www.douban.com/note/350126154/?type=like" target="_blank" rel="noopener">Markdown入门指南</a></li></ul><h2 id="三、配置博客"><a href="#三、配置博客" class="headerlink" title="三、配置博客"></a>三、配置博客</h2><p>在blog目录下，用sublime打开_config.yml文件，修改参数信息</p><pre><code># Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title:  #标题subtitle:  #副标题description:  #站点描述，给搜索引擎看的author:  #作者email:  #电子邮箱language: zh-CN #语言# URL #链接格式url:  #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮enable: true #是否启用line_number: true #显示行号tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy:type: gitrepo: 刚刚github创库地址.gitbranch: master</code></pre><p>特别提醒，在每个参数的：** 后都要加一个空格 **</p><p>修改网站相关信息</p><pre><code>title: 崔斯特测试所用博客subtitle: 副标题description: 网页描述author: 崔斯特language: zh-CNtimezone: Asia/Shanghai</code></pre><p>配置部署（我的是zhihuya，修改成自己的）</p><pre><code>deploy: type: gitrepo: https://github.com/zhihuya/zhihuya.github.io.gitbranch: master</code></pre><h2 id="四、发表文章"><a href="#四、发表文章" class="headerlink" title="四、发表文章"></a>四、发表文章</h2><p>在CMD中输入</p><pre><code>$ hexo new &quot;崔斯特测试文章&quot;INFO  Created: F:\test\blog\source\_posts\崔斯特测试文章.md</code></pre><p>找到该文章，打开，使用Markdown语法，该语法介绍可以查看利用HEXO搭建的博客及Markdown语法介绍</p><pre><code>---title: 崔斯特测试文章date: 2017-02-28 13:03:44tags:---</code></pre><p>这是一篇测试文章，欢迎关注作者博客[1]: <a href="https://zhangslob.github.io/" target="_blank" rel="noopener">https://zhangslob.github.io/</a><br>保存，然后执行下列步骤：</p><pre><code>F:\test\blog$ hexo cleanINFO  Deleted database.INFO  Deleted public folder.</code></pre><pre><code>F:\test\blog$ hexo generateINFO  Start processingINFO  Files loaded in 1.48 s#省略INFO  29 files generated in 4.27 s</code></pre><pre><code>F:\test\blog$ hexo serverINFO  Start processingINFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></pre><p>这个时候，打开<a href="http://localhost:4000/，发现刚才的文章已经成功了" target="_blank" rel="noopener">http://localhost:4000/，发现刚才的文章已经成功了</a><br><img src="https://pic2.zhimg.com/80/v2-95377f456e18451b96316edbdeccd985_hd.jpg" alt=""></p><p>最后一步，发布到网上，执行：</p><pre><code>F:\test\blog$ hexo deployINFO  Deploying: gitINFO  Clearing .deploy_git folder...INFO  Copying files from public folder...#省略</code></pre><p>其中会跳出Github登录，直接登录，如果没有问题输入zhihuya（换成你的）.<a href="http://github.io/" target="_blank" rel="noopener">http://github.io/</a><br><img src="https://pic4.zhimg.com/80/v2-9eca7f5fb9a05dbf76ba193a7e408a17_hd.jpg" alt=""></p><p><a href="https://zhihuya.github.io" target="_blank" rel="noopener">崔斯特测试所用博客</a></p><p>然后就可以看到已经发布了<br><img src="https://pic1.zhimg.com/80/v2-4e7b67ea48bde5e2661540624f792010_hd.jpg" alt=""></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇仅仅针对windows，Mac请移步20分钟教你使用hexo搭建github博客</p><p>发布文章的步骤：</p><ol><li><p>hexo new 创建文章</p></li><li><p>Markdown语法编辑文章</p></li><li><p>部署（所有打开CMD都是在blog目录下）</p><pre><code>hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo generate #生成hexo server #启动服务预览，非必要，可本地浏览网页hexo deploy #部署发布</code></pre><p>简写Tips：</p><pre><code>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署</code></pre><p>如果在执行 hexo deploy 后,出现 error deployer not found:github 的错误，执行：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>出错是正常的，出错了自己先百度或google，实在不知道的可以询问我。</p></li></ol><p>托管的话不仅有github可以用，还有个国内的<a href="http://coding.net可选" target="_blank" rel="noopener">http://coding.net可选</a></p><h1 id="将自己的域名关联到Github-Pages上"><a href="#将自己的域名关联到Github-Pages上" class="headerlink" title="将自己的域名关联到Github Pages上"></a>将自己的域名关联到Github Pages上</h1><p>很多朋友创建了自己的博客之后会选择买一个属于自己的域名，然后将自己域名绑定到自己的Github Pages博客上，其实这也并不难，只要你有个域名。</p><h2 id="一、购买域名"><a href="#一、购买域名" class="headerlink" title="一、购买域名"></a>一、购买域名</h2><p>如果你不是很有钱，在阿里云上，你只要几块钱就可以买到一个域名。</p><p>选择你喜欢的域名，然后购买即可。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c8529b7e80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>##二、配置CNAME文件<br>在 \hexo\source 文件夹下创建文件 CNAME （新建记事本文件命名CNAME，然后打开）</p><p>内容为你的域名，例如我的域名是：ryane.top<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c855add24e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>在Hexo文件夹提交</p><pre><code>hexo g -d</code></pre><h2 id="三、修改DNS的DNS"><a href="#三、修改DNS的DNS" class="headerlink" title="三、修改DNS的DNS"></a>三、修改DNS的DNS</h2><ol><li><p>如果你是在阿里云购买域名的话，请登录阿里云网站。打开个人中心，点击域名<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c856d6f09b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>选择管理<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c85bffa826?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>修改DNS为</p><pre><code>f1g1ns2.dnspod.net f1g1ns1.dnspod.net </code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c871f901d6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li></ol><h2 id="四、域名解析"><a href="#四、域名解析" class="headerlink" title="四、域名解析"></a>四、域名解析</h2><ol><li><p>打开<a href="https://www.dnspod.cn" target="_blank" rel="noopener">DNSPOD</a>，注册一个账户</p></li><li><p>点击添加域名，把你的域名添加进去，如无意外，添加完之后就是以下这个状态<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c8762afc03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>此时点击添加记录，添加两个记录，一个主机记录为@， 一个为www，而记录值都是填同一个，填你的博客主页对应的ip，添加完后如下。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c8788184d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>但是如何获取ip值呢？打开运行，输入cmd，打开命令窗口输入 ping 主页地址 ， 红色部分即为你的ip值<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c88c7b5bba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>将IP输入过去，然后会提示你到域名注册的地方修改DNS。等待生效，最迟72小时生效。即可通过你的域名浏览你的博客主页。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当你完成了你的博客之后，相信你的心情跟我刚做完的心情是一样的，即便很累，但是当自己的博客成型之后，自己还是有一个成就感的，那么完成后，以后的路还很长，真正想要自己博客能够积累人气，还得靠好的内容，所以认真写文章吧，相信你会受益于此的。</p><p>如果大家有什么问题的话，可以在我留言板下留言，我看到评论时会第一时间回答大家。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><a href="https://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="noopener">Markdown–入门指南</a></li><li><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="noopener">如何搭建一个独立博客——简明 Github Pages与 jekyll 教程 by cnfeat</a></li><li><a href="https://www.cnblogs.com/zhcncn/p/4097881.html" target="_blank" rel="noopener">Hexo搭建Github静态博客 by 金石开</a></li><li><a href="http://www.xuanfengge.com/using-ssh-key-link-github-photo-tour.html" target="_blank" rel="noopener">使用SSH密钥连接Github【图文教程】 by 轩枫</a></li></ul><blockquote><p>** 声明：**<br>由于本人初次接触这方面的知识，所以本文是转载的，若侵权，望留言，我必删之。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;

&lt;blockquote&gt;
&lt;p&gt;转载自博客：&lt;a href=&quot;https://juejin.im/entry/5a574864f265da3e3c6c1217&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://
      
    
    </summary>
    
    
      <category term="博客" scheme="http://www.zzw1024.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://www.zzw1024.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>生活杂记——诗分享：人生</title>
    <link href="http://www.zzw1024.top/2020/06/09/sheng-huo-za-ji-shi-fen-xiang-ren-sheng/"/>
    <id>http://www.zzw1024.top/2020/06/09/sheng-huo-za-ji-shi-fen-xiang-ren-sheng/</id>
    <published>2020-06-09T14:33:17.000Z</published>
    <updated>2020-06-09T14:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><pre><code>        喜欢一个人</code></pre><p>　　　　　　始于颜值，陷于才华;</p><p>　　　　　　忠于人品，痴于身体;</p><p>　　　　　　迷于声音，醉于深情;</p><p>　　　　最后，却，折于物质，败于现实。</p><p>　　</p><p>　　　　这世间万千滋味，早有先人尝遍；</p><p>　　　　　　读过多少警示名言；</p><p>　　　　我们还是会不由自主的重蹈覆辙；</p><p>　　　　　　走他们走过的路；</p><p>　　　　　　受他们受过的苦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;
&lt;pre&gt;&lt;code&gt;        喜欢一个人&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　　　　　始于颜值，陷于才华;&lt;/p&gt;
&lt;p&gt;　　　　　　忠于人品，痴于身体;&lt;/p&gt;
&lt;p&gt;　　　　　　迷于声音，醉于深情;&lt;/p&gt;
&lt;p&gt;　　　　最后，却，
      
    
    </summary>
    
    
      <category term="生活杂记" scheme="http://www.zzw1024.top/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="人生" scheme="http://www.zzw1024.top/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>生活杂记——诗分享:活</title>
    <link href="http://www.zzw1024.top/2020/06/09/sheng-huo-za-ji-shi-fen-xiang-huo/"/>
    <id>http://www.zzw1024.top/2020/06/09/sheng-huo-za-ji-shi-fen-xiang-huo/</id>
    <published>2020-06-09T14:29:57.000Z</published>
    <updated>2020-06-09T14:29:57.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><p>如果羡慕成功者的富贵，</p><p>别一味模仿他们富贵后的事。</p><p>那些名牌表呀包呀酒呀车呀，</p><p>都是他们富贵后的事。</p><p>硬撑着模仿了，</p><p>也只能图个穷开心而已。</p><p>要模仿，</p><p>就模仿他们富贵前的事。</p><p>他们那些</p><p>鹰般的探索、</p><p>蛇般的专注、</p><p>蚁般的辛劳、</p><p>蛹般的耐心，</p><p>全是些风吹日晒灰头土脸的事！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;

&lt;p&gt;如果羡慕成功者的富贵，&lt;/p&gt;
&lt;p&gt;别一味模仿他们富贵后的事。&lt;/p&gt;
&lt;p&gt;那些名牌表呀包呀酒呀车呀，&lt;/p&gt;
&lt;p&gt;都是他们富贵后的事。&lt;/p&gt;
&lt;p&gt;硬撑着模仿了，&lt;/p&gt;
&lt;p&gt;也只能图个穷开心而已。&lt;/p&gt;
&lt;p&gt;要模仿，
      
    
    </summary>
    
    
      <category term="生活杂记" scheme="http://www.zzw1024.top/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="诗" scheme="http://www.zzw1024.top/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——关键路径详解</title>
    <link href="http://www.zzw1024.top/2020/06/09/shu-ju-jie-gou-guan-jian-lu-jing-xiang-jie/"/>
    <id>http://www.zzw1024.top/2020/06/09/shu-ju-jie-gou-guan-jian-lu-jing-xiang-jie/</id>
    <published>2020-06-09T14:16:34.000Z</published>
    <updated>2020-06-09T14:16:34.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><h1 id="AOV网："><a href="#AOV网：" class="headerlink" title="AOV网："></a>AOV网：</h1><p>顶点活动（Activity On Vertex，AOV）网是指用顶点表示活动，而用边集表示活动间优先关系的有向图。例如图10-57的先导课程示意图就是AOV网，其中图的顶点表示各项课程，也就是“活动”；有向边表示课程的先导关系，也就是“活动间的优先关系”。显然，图中不应当存在有向环，否则会让优先关系出现逻辑错误。<br><img src="https://img-blog.csdnimg.cn/20191122154223280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""><br>​</p><h1 id="AOE网："><a href="#AOE网：" class="headerlink" title="AOE网："></a>AOE网：</h1><p>边活动（Activity On Edge，AOE）网是指用带权的边集表示活动，而用顶点表示事件的有向图，其中边权表示完成活动需要的时间。例如图10-59中，边a1<del>a6表示需要学习的课程，也就是“活动”，边权表示课程学习需要消耗的时间；顶点V1</del>V6。表示到此刻为止前面的课程已经学完，后面的课程可以开始学习，也就是“事件”（如V5表示a4计算方法和a3实变函数已经学完，a6泛函分析可以开始学习。从另一个角度来看，a6只有当a4和a5都完成时才能开始进行，因此当a4计算方法学习完毕后必须等待a5实变函数学习完成后才能进入到a6泛函分析的学习），显然“事件”仅代表一个中介状态。<br><img src="https://img-blog.csdnimg.cn/2019112215324778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""><br>​</p><ul><li><p>源点：在AOE网中，没有入边的顶点称为源点；如顶点V1 </p></li><li><p>终点：在AOE网中，没有出边的顶点称为终点；如顶点V6 </p></li></ul><h1 id="AOE网的性质："><a href="#AOE网的性质：" class="headerlink" title="AOE网的性质："></a>AOE网的性质：</h1><ul><li><p>只有在进入某顶点的活动都已经结束，该顶点所代表的事件才发生；</p></li><li><p>只有在某顶点所代表的事件发生后，从该顶点出发的各活动才开始；</p></li></ul><p>AOE网中的<strong>最长路径被称为关键路径</strong>（强调：关键路径就是AOE网的最长路径），而把关键路径上的活动称为关键活动，显然关键活动会影响整个工程的进度。</p><h1 id="关键概念："><a href="#关键概念：" class="headerlink" title="关键概念："></a>关键概念：</h1><p>​<img src="https://img-blog.csdnimg.cn/201911221535246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""></p><ol><li>事件的最早发生时间ve[k]（earliest time of vertex）：即顶点vk的最早发生时间。</li></ol><p>从源点向终点方向计算</p><pre><code>ve[0] = 0ve[1] = ve[0] + a0 = 0 + 4 = 4ve[2] = max( ve[0] + a1, ve[1] + a2 ) = max(0 + 3, 4 + 2 = 6ve[3] = max(ve[1] + a4, ve[2] + a3) = max(4 + 6, 3 + 4) = 10</code></pre><ol start="2"><li>事件的最晚发生时间vl[k]（latest time of vertex）：即顶点vk的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期。</li></ol><p>从终点向源点方向计算</p><pre><code>vl[3] = ve[3] = 10vl[2] = vl[3] - a3 = 10 - 4 = 6vl[1] = min(vl[3] - a4, vl[2] - a2) = min(10-6, 6-2) = 4//之所以求最小，保证其他的点的最晚发生时间vl[0] = min(vl[2] - a1, vl[1] - a0) = min(4-4, 4-2) = 0 </code></pre><ol start="3"><li>活动的最早开工时间e[k]（earliest time of edge）：即弧ax的最早发生时间。</li></ol><p>5条边，5个活动</p><pre><code>e[0] = ve[0] = 0e[1] = ve[0] = 0e[2] = ve[1] = 4e[3] = ve[2] = 6e[4] = ve[1] = 4</code></pre><ol start="4"><li>活动的最晚开工时间l[k]（latest time of edge）：即弧ak的最晚发生时间，也就是不推迟工期的最晚开工时间。<pre><code>e[0] = v[1] - a0 = 4 - 4 = 0</code></pre></li></ol><p>e[1] = vl[2] - a1 = 6 - 3 = 3</p><p>e[2] = vl[2] - a2 = 6 - 2 = 4</p><p>e[3] = vl[3] - a3 = 10 - 4 = 6</p><p>e[4] = vl[3] - a4 = 10 - 6 = 4 </p><pre><code>活动的最早开始时间和最晚开始时间相等，则说明该活动时属于关键路径上的活动，即关键活动# 算法设计：关键路径算法是一种典型的动态规划法，设图G=(V, E)是个AOE网，结点编号为1,2,...,n，其中结点1与n 分别为始点和终点，ak=&lt;i, j&gt;∈E是G的一个活动。算法关键是确定活动的最早发生时间ve[k]和最晚发生时间vl[k]，进而获取顶点的最早开始时间e[k]和最晚开始时间l[k]。根据前面给出的定义，可推出活动的最早及最晚发生时间的计算方法：</code></pre><p>e(k) = ve(i) </p><p>l(k) = vl(j) - len(i,j)</p><pre><code>​![](https://img-blog.csdnimg.cn/20191122153716227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70)结点的最早发生时间的计算，需按拓扑次序递推：</code></pre><p>ve(1) = 0</p><p>ve(j) = MAX{ etv(i)+len(i, j) }</p><pre><code>对所有&lt;i,j&gt; ∈E的i  结点的最晚发生时间的计算，需按逆拓扑次序递推：</code></pre><p>vl(n) = ve(n)</p><p>vl(i) = MIN{vl(j) - len(i, j)} 对所有&lt;i,j&gt;∈E的j</p><pre><code>这种计算方法， 依赖于拓扑排序， 即计算ve( j) 前，应已求得j 的各前趋结点的ve值，而计算vl(i)前，应已求得i的各后继结点的vl值。ve的计算可在拓扑排序过程中进行，即在每输出一个结点i后，在删除i的每个出边&lt;i,j&gt;（即入度减1）的同时，执行</code></pre><p>if ( ve[i]+len(i,j)) &gt; ve[j] )</p><p>ve[j] = ve[i] + len(i,j)</p><pre><code>这时会发现，如果想要获得ve[j]的正确值，ve[il]\~ve[ik]必须已经得到。有什么办法能够在访问某个结点时保证它的前驱结点都已经访问完毕呢？没错，使用拓扑排序就可以办到。当按照拓扑序列计算ve数组时，总是能保证计算ve[i]的时候ve[il]~ve[ik]都已经得到。但是这时又碰到另一个问题，通过前驱结点去寻找所有后继结点很容易，但是通过后继结点V；去寻找它的前驱结点V1~Vx似乎没有那么直观。一个比较好的办法是，在拓扑排序访问到某个结点时，不是让它去找前驱结点来更新ve[i]，而是使用ve[i]去更新其所有后继结点的ve值。通过这个方法，可以让拓扑排序访问到V；的时候，V1\~Vk一定都已经用来更新过ve[i]，此时的ve[i]便是正确值，就可以用它去更新V；的所有后继结点的ve值。</code></pre><p>//拓扑序列</p><p>stack<int>topOrder;</p><p>//拓扑排序，顺便求ve数组</p><p>bool topologicalSort()</p><p>{</p><pre><code>queue&lt;int&gt;q;for(int i=0;i&lt;n;i++)    if(inDegree[i]==0)        q.push(i);while(!q.empty()){    int u=q.front();    q.pop();    topOrder.push(u);//将u加入拓扑序列    for(int i=0;i&lt;G[u].size();i++)    {        int v=G[u][i].v;//u的i号后继结点编号为v        inDegree[v]--;        if(inpegree[v]==0)            q.push(v);        //用ve[u]来更新u的所有后继结点        if(ve[u]+G[u][i].w&gt; ve[v])            ve[v]=ve[u]+G[u][i].w;    }}if(toporder.size()== n)    return true;else    return false;</code></pre><p>}</p><pre><code>同理，如图10-64所示，从事件V出发通过相应的活动ar1~ark可以到达k个事件V1~Vk，活动的边权为length[r1]~length[rk]。假设已经算好了事件V1~Vk的最迟发生时间xl[j1]～vl[jk]，那么事件Vi的最迟发生时间就是vl[j1]-length[r1]~vl[jk]-length[rk]中的最小值。此处取最小值是因为必须保证Vj1~Vjk的最迟发生时间能被满足；可以通过下面这个公式辅助理解。![](https://img-blog.csdnimg.cn/20191122153835953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70)和ve数组类似，如果需要算出vl[i]的正确值，vl[j1]\~vl[jk]必须已经得到。这个要求与ve数组的刚好相反，也就是需要在访问某个结点时保证它的后继结点都已经访问完毕，而这可以通过使用逆拓扑序列来实现。幸运的是，不必再做一次逆拓扑排序来得到逆拓扑序列，而是可以通过颠倒拓扑序列来得到一组合法的逆拓扑序列。此时会发现，在上面实现拓扑排序的过程中使用了栈来存储拓扑序列，那么只需要按顺序出栈就是逆拓扑序列。而当访问逆拓扑序列中的每个事件Vi时，就可以遍历Vi的所有后继结点Vj1\~Vjk，使用vI[j1]\~vl[jk]来求出vl[i]。这部分的代码如下所示：</code></pre><p>fill(vl，v1+n，ve[n-1]);//v1数组初始化，初始值为终点的ve值</p><p>//直接使用toporder出栈即为逆拓扑序列，求解v1数组</p><p>while(！topOrder.empty())</p><p>{</p><pre><code>int u=topOrder.top();//栈顶元素为utopOrder.pop();for(int i=0;i&lt;G[u].size();i++){    int v=G[u][i].v;//u的后继结点v    //用u的所有后继结点v的v1值来更新v1[u]    if(vl[v]-G[u][i].w &lt; vl[u])        vl[u]=vl[v]-G[u][i].w;}</code></pre><p>}</p><pre><code>复制代码1 fill(vl，v1+n，ve[n-1]);//v1数组初始化，初始值为终点的ve值2 3 //直接使用toporder出栈即为逆拓扑序列，求解v1数组4 5 while(！topOrder.empty())6 7 {8 9     int u=topOr通过上面的步骤已经把求解关键活动的过程倒着推导了一遍，下面给出上面过程的步骤总结，即“先求点，再夹边”：* ①按拓扑序和逆拓扑序分别计算各顶点（事件）的最早发生时间和最迟发生时间：![](https://img-blog.csdnimg.cn/20191122153922180.png)​* ②用上面的结果计算各边（活动）的最早开始时间和最迟开始时间：![](https://img-blog.csdnimg.cn/2019112215395853.png)​* ③e[i-→] = l[i-→i]的活动即为关键活动。主体部分代码如下（适用汇点确定且唯一的情况，以n-1号顶点为汇点为例）：【主体代码】求取关键路径：</code></pre><p>//遍历邻接表的所有边，计算活动的最早开始时间e和最迟开始时间1</p><p>for(int u=0；u&lt;n；u++)</p><p>{</p><pre><code>for(int i=0；i&lt;G[u].size()；i++){    int v=G[u][i].v，w=G[u][i].w；    //活动的最早开始时间e和最迟开始时间1    int e=ve[u]，l=vl[v]-w；    //如果e==1，说明活动u-&gt;v是关键活动    if(e==1)    printf(&quot;%d-&gt;%d\n&quot;，u,v)；//输出关键活动}}return ve[n-1]；//返回关键路径长度</code></pre><p>}</p><pre><code>在上述代码中，没有将活动的最早开始时间e和最迟开始时间l存储下来，这是因为一般来说e和l只是用来判断当前活动是否是关键活动，没有必要单独存下来。如果确实想要将它存储下来，只需要在结构体Node中添加域e和1即可。如果事先不知道汇点编号，有没有办法比较快地获得关键路径长度呢？当然是有办法的，那就是取ve数组的最大值。原因在于，ve数组的含义是事件的最早开始时间，因此所有事件中ve最大的一定是最后一个（或多个）事件，也就是汇点。于是只需要在fill函数之前添加一小段语句，然后改变下vl函数初始值即可，代码如下：</code></pre><p>int maxLength = 0;</p><p>for(int i=0; i&lt;n; ++i)</p><p>{</p><pre><code>if(ve[i] &gt; maxLength)    maxLength = ve[i];</code></pre><p>}</p><p>fill(vl, vl + n, maxLength);</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;

&lt;h1 id=&quot;AOV网：&quot;&gt;&lt;a href=&quot;#AOV网：&quot; class=&quot;headerlink&quot; title=&quot;AOV网：&quot;&gt;&lt;/a&gt;AOV网：&lt;/h1&gt;&lt;p&gt;顶点活动（Activity On Vertex，AOV）网是指用顶点表示活动
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.zzw1024.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="关键路径" scheme="http://www.zzw1024.top/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——最小生成树</title>
    <link href="http://www.zzw1024.top/2020/06/09/shu-ju-jie-gou-zui-xiao-sheng-cheng-shu/"/>
    <id>http://www.zzw1024.top/2020/06/09/shu-ju-jie-gou-zui-xiao-sheng-cheng-shu/</id>
    <published>2020-06-09T14:12:36.000Z</published>
    <updated>2020-06-09T14:12:36.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><h1 id="最小生成树："><a href="#最小生成树：" class="headerlink" title="最小生成树："></a>最小生成树：</h1><p>最小生成树（Minimum Spanning Tree，MST）是在一个给定的无向图G（V，E）中求一棵树T，使得这棵树拥有图G中的所有顶点，且所有边都是来自图G中的边，并且满足整棵树的边权之和最小。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191122155454937-1989257498.png" alt=""></p><p>图10-43给出了一个图G及其最小生成树T，其中较粗的线即为最小生成树的边。可以看到，边AB、BC、BD包含了图G的所有顶点，且由它们生成的树的边权之和为6，是所有生成树中权值最小的（例如边AD、BD、CD生成的树，其边权之和为7，大于之前给出的树的边权之和）。</p><p>最小生成树有3个性质需要掌握：</p><blockquote><ul><li>①最小生成树是树，因此其边数等于顶点数减1，且树内一定不会有环。</li></ul></blockquote><blockquote><ul><li>②对给定的图G（V，E），其最小生成树可以不唯一，但其边权之和一定是唯一的。</li></ul></blockquote><blockquote><ul><li>③由于最小生成树是在无向图上生成的，因此其根结点可以是这棵树上的任意一个结点。于是，如果题目中涉及最小生成树本身的输出，为了让最小生成树唯一，一般都会直接给出根结点，读者只需以给出的结点作为根结点来求解最小生成树即可。</li></ul></blockquote><p>求解最小生成树一般有两种算法，即prim算法与kruskal算法。</p><p>这两个算法都是采用了贪心法的思想，只是贪心的策略不太一样。</p><h1 id="Prim算法与Kurskal算法比较"><a href="#Prim算法与Kurskal算法比较" class="headerlink" title="Prim算法与Kurskal算法比较"></a>Prim算法与Kurskal算法比较</h1><blockquote><ul><li>（1）从算法的思想可以看出，如果图G中的边数较小时，可以采用Kruskal算法，因为Kruskal 算法每次查找最短的边；边数较多可以用Prim算法，因为它是每次加一个结点。可见，Kruskal算法适用于稀疏图，而Prim算法适用于稠密图。</li></ul></blockquote><blockquote><ul><li>（2）从时间上讲，Prim算法的时间复杂度为O（n2），Kruskal 算法的时间复杂度为O（eloge）。</li></ul></blockquote><blockquote><ul><li>（3）从空间上讲，显然在Prim算法中，只需要很小的空间就可以完成算法，因为每一次都是从V-U集合出发进行扫描的，只扫描与当前结点集到U集合的最小边。但在Kruskal算法中，需要对所有的边进行排序，对于大型图而言，Kruskal算法需要占用比Prim算法大得多的空间。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;

&lt;h1 id=&quot;最小生成树：&quot;&gt;&lt;a href=&quot;#最小生成树：&quot; class=&quot;headerlink&quot; title=&quot;最小生成树：&quot;&gt;&lt;/a&gt;最小生成树：&lt;/h1&gt;&lt;p&gt;最小生成树（Minimum Spanning Tree，MST）是在
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.zzw1024.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="最小生成树" scheme="http://www.zzw1024.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——prim算法【最小生成树1】</title>
    <link href="http://www.zzw1024.top/2020/06/09/shu-ju-jie-gou-prim-suan-fa-zui-xiao-sheng-cheng-shu-1/"/>
    <id>http://www.zzw1024.top/2020/06/09/shu-ju-jie-gou-prim-suan-fa-zui-xiao-sheng-cheng-shu-1/</id>
    <published>2020-06-09T14:04:28.000Z</published>
    <updated>2020-06-09T14:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><p>适用范围：要求无向图</p><p>prim算法（读者可以将其读作“普里姆算法”）用来解决最小生成树问题，</p><p>其基本思想是：</p><ul><li><p>对图G（VE）设置集合S，存放已被访问的顶点，</p></li><li><p>然后每次从集合V-S中选择与集合S的最短距离最小的一个顶点（记为u），访问并加入集合S。</p></li><li><p>令顶点u为中介点，优化所有从u能到达的顶点v与集合S之间的最短距离。</p></li></ul><p>这样的操作执行n次（n为顶点个数），直到集合S已包含所有顶点。可以发现，prim算法的思想与最短路径中Dijkstra算法的思想几乎完全相同，只是在涉及最短距离时使用了集合S代替Dijkstra算法中的起点s。</p><pre><code>int prim(){//默认0号为初始点，函数返回最小生成树的边权之和    fi11(d，d+MAXV，Inf)；//fi11函数将整个d数组赋为INE (慎用memset )    d[0]=0；//只有0号顶点到集合s的距离为0，其余全为Inf    int ans=0；//存放最小生成树的边权之和    for (int i=0；i&lt;n；i++ )   {//循环n次        int u=-1，MIN=Inf；//u使d[u]最小，MIN存放该最小的d[u]        for (int j=0；j&lt;n；j++ )        {//找到未访问的顶点中d[]最小的            if (vis[j]==false &amp;&amp; d[j]&lt;MIN )            {                u=j；                MIN=d[j]；            }        }        //找不到小于Inf的d[u]，则剩下的顶点和集合s不连通        if (u==-1 )            return-1；        vis[u]=true；//标记u为已访问        ans += d[u]；//将与集合s距离最小的边加入最小生成树        for (int v=0；v&lt;n；v++ )        {//v未访问&amp;&amp;u能到达v&amp;&amp;以u为中介点可以使v离集合S更近            if (vis[v]==false &amp;&amp; G[u][v] ！= Inf &amp;&amp; G[u][v]&lt; d[v] )                d[v]=G[u][v]；//将G[u][v]赋值给d[v]        }    }    return ans；//返回最小生成树的边权之和}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;

&lt;p&gt;适用范围：要求无向图&lt;/p&gt;
&lt;p&gt;prim算法（读者可以将其读作“普里姆算法”）用来解决最小生成树问题，&lt;/p&gt;
&lt;p&gt;其基本思想是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对图G（VE）设置集合S，存放已被访问的顶点，&lt;/p&gt;
&lt;/li
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.zzw1024.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="prim, 最小生成树" scheme="http://www.zzw1024.top/tags/prim-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——kruskal算法【最小生成树2】</title>
    <link href="http://www.zzw1024.top/2020/06/09/shu-ju-jie-gou-kruskal-suan-fa-zui-xiao-sheng-cheng-shu-2/"/>
    <id>http://www.zzw1024.top/2020/06/09/shu-ju-jie-gou-kruskal-suan-fa-zui-xiao-sheng-cheng-shu-2/</id>
    <published>2020-06-09T14:04:14.000Z</published>
    <updated>2020-06-09T14:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><p>设G=（V，E）是无向连通带权图，V={1，2，…，n}；</p><p>设最小生成树T=（V，TE），该树的初始状态为只有n个顶点而无边的非连通图T=（V，{}），Kruskal算法将这n个顶点看成是n个孤立的连通分支。</p><p>它首先将所有的边按权值从小到大排序，然后只要T中选中的边数不到n-1，就做如下的贪心选择：</p><p>在边集E中选取权值最小的边（i，j），如果将边（i，j）加入集合TE中不产生回路（圈），则将边（i，j）加入边集TE中，即用边（i，j）将这两个连通分支合并连接成一个连通分支；</p><p>否则继续选择下一条最短边。把边（i，j）从集合E中删去。</p><p>继续上面的贪心选择，直到T中所有顶点都在同一个连通分支上为止。</p><p>此时，选取到的n-1条边恰好构成G的一棵最小生成树T。</p><p>那么，怎样判断加入某条边后图T会不会出现回路呢？</p><p>该算法对于手工计算十分方便，因为用肉眼可以很容易看到挑选哪些边能够避免构成回路（避圈法），但使用计算机程序来实现时，还需要一种机制来进行判断。</p><p>Kruskal算法用了一个非常聪明的方法，就是运用集合避圈：</p><p>如果所选择加入的边的起点和终点都在T的集合中，那么就可以断定一定会形成回路（圈）。其实就是我们前面提到的“避圈法”：边的两个结点不能属于同一集合。</p><blockquote><ul><li>步骤1：初始化。将图G的边集E中的所有边按权值从小到大排序，边集TE={}，把每个顶点都初始化为一个孤立的分支，即一个顶点对应一个集合。</li></ul></blockquote><blockquote><ul><li>步骤2：在E中寻找权值最小的边（i，j）。</li></ul></blockquote><blockquote><ul><li>步骤3：如果顶点i和位于两个不同连通分支，则将边（i，j）加入边集TE，并执行合并操作，将两个连通分支进行合并【即两个顶点设置成同一个集合号，一般向小集合号合并】。</li></ul></blockquote><blockquote><ul><li>步骤4：将边（i，j）从集合E中删去，即E=E-{（i，j）}。</li></ul></blockquote><blockquote><ul><li>步骤5：如果选取边数小于n-1，转步骤2；否则，算法结束，生成最小生成树了。</li></ul></blockquote><p>** 适用范围：要求无向图 ** </p><p>kruskal算法（读者可以将其读作“克鲁斯卡尔算法”同样是解决最小生成树问题的一个算法。和prim算法不同，kruskal算法采用了边贪心的策略，其思想极其简洁，理解难度比prim算法要低很多。</p><p>kruskal算法的基本思想为：在初始状态时隐去图中的所有边，这样图中每个顶点都自成一个连通块。</p><p>之后执行下面的步骤：</p><ul><li><p>①对所有边按边权从小到大进行排序。</p></li><li><p>②按边权从小到大测试所有边，如果当前测试边所连接的两个顶点不在同一个连通块中，则把这条测试边加入当前最小生成树中；否则，将边舍弃。</p></li><li><p>③执行步骤②，直到最小生成树中的边数等于总顶点数减1或是测试完所有边时结束。</p></li></ul><p>而当结束时如果最小生成树的边数小于总顶点数减1，说明该图不连通。</p><p>接下来以图10-51a为例，给出对该图执行kruskal算法的步骤。</p><p>当前图中边权最小的边为V。V，权值为1。由于Vo和V4在不同的连通块中，因此把边VoVa加入最小生成树中，此时最小生成树中有1条边，权值之和为1，如图10-51所示。</p><p>因此，kruskal算法的思想简单说来就是：</p><p>每次选择图中最小边权的边，如果边两端的顶点在不同的连通块中，就把这条边加入最小生成树中。</p><pre><code>//边集定义部分struct edge{    int u，v；//边的两个端点编号    int cost；//边权}E[MAXE]；//最多有MAXE条边bool cmp(edge a，edge b){    return a.cost &lt;b.cost；}//并查集部分int father[MAXV]；//并查集数组int findFather(int x){//并查集查询函数    int a=x；    while(x！=father[x])        x=father[x]；    //路径压缩    while(a！=father[a])    {        int z = a；        a = father[a]；        father[z]=x；    }    return x；}//kruskal部分，返回最小生成树的边权之和，参数n为顶点个数，m为图的边数int kruskal(int n，int m){//ans为所求边权之和，Num Edge为当前生成树的边数    int ans=0，Num Edge=0；    for(int i=0；i&lt;n；i++)//顶点范围是[0，n-1]        father[i]=i；//并查集初始化    sort(E，E+m，cmp)；//所有边按边权从小到大排序    for(int i=0；i&lt;m；i++)    {//枚举所有边        int faU=findFather(E[i].u)；//查询测试边两个端点所在集合的根结点        int faV=findFather(E[i].v)；        if(faU！=faV)        {//如果不在一个集合中            father[faU]=faV；//合并集合(即把测试边加入最小生成树中)            ans += E[i].cost；//边权之和增加测试边的边权            Num_Edge++；//当前生成树的边数加1            if(Num_Edge == n-1)                break；//边数等于顶点数减1时结束算法        }    }    if(Num_Edge！=n-1)        return -1；//无法连通时返回-1    else        return ans；//返回最小生成树的边权之和}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;

&lt;p&gt;设G=（V，E）是无向连通带权图，V={1，2，…，n}；&lt;/p&gt;
&lt;p&gt;设最小生成树T=（V，TE），该树的初始状态为只有n个顶点而无边的非连通图T=（V，{}），Kruskal算法将这n个顶点看成是n个孤立的连通分支。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.zzw1024.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="kruskal, 最小生成树" scheme="http://www.zzw1024.top/tags/kruskal-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法——KMP算法:字符匹配</title>
    <link href="http://www.zzw1024.top/2020/06/09/suan-fa-kmp-suan-fa-zi-fu-pi-pei/"/>
    <id>http://www.zzw1024.top/2020/06/09/suan-fa-kmp-suan-fa-zi-fu-pi-pei/</id>
    <published>2020-06-09T13:31:28.000Z</published>
    <updated>2020-06-09T13:31:28.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><h1 id="暴力匹配："><a href="#暴力匹配：" class="headerlink" title="暴力匹配："></a>暴力匹配：</h1><p>假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？ </p><p>如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有： </p><p>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</p><p>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</p><p>理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下：</p><pre><code>int ViolentMatch(char* s, char* p){    int sLen = strlen(s);    int pLen = strlen(p);    int i = 0;    int j = 0;    while (i &lt; sLen &amp;&amp; j &lt; pLen)    {        if (s[i] == p[j])        {            //①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++            i++;            j++;        }        else        {            //②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0            i = i - j + 1;  //i回到前一次遍历对比的位置            j = 0;        }    }    //匹配成功，返回模式串p在文本串s中的位置，否则返回-1    if (j == pLen)        return i - j;    else        return -1;}</code></pre><p>举个例子，如果给定文本串S“BBC ABCDAB ABCDABCDABDE”，和模式串P“ABCDABD”，现在要拿模式串P去跟文本串S匹配，整个过程如下所示：</p><blockquote><ol><li>S[0]为B，P[0]为A，不匹配，执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[1]跟P[0]匹配，相当于文本串要往右移动一位（i=1，j=0） </li></ol></blockquote><blockquote><ol start="2"><li>S[1]跟P[0]还是不匹配，继续执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[2]跟P[0]匹配（i=2，j=0），从而文本串串不断的向右移动一位（不断的执行“令i = i - (j - 1)，j = 0”，i从2变到4，j一直为0） </li></ol></blockquote><blockquote><ol start="3"><li>直到S[4]跟P[0]匹配成功（i=4，j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，可得S[i]为S[5]，P[j]为P[1]，即接下来S[5]跟P[1]匹配（i=5，j=1）  </li></ol></blockquote><blockquote><ol start="4"><li>S[5]跟P[1]匹配成功，继续执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，得到S[6]跟P[2]匹配（i=6，j=2），如此进行下去 </li></ol></blockquote><blockquote><ol start="5"><li>直到S[10]为空格字符，P[6]为字符D（i=10，j=6），因为不匹配，重新执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，相当于S[5]跟P[0]匹配（i=5，j=0）  </li></ol></blockquote><blockquote><ol start="6"><li>至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了S[9]、P[5]，但因为S[10]跟P[6]不匹配，所以文本串回溯到S[5]，模式串回溯到P[0]，从而让S[5]跟P[0]匹配。 </li></ol></blockquote><p>而S[5]肯定跟P[0]失配。为什么呢？因为在之前第4步匹配中，我们已经得知S[5] = P[1] = B，而P[0] = A，即P[1] != P[0]，故S[5]必定不等于P[0]，所以回溯过去必然会导致失配。那有没有一种算法，让i 不往回退，只需要移动j 即可呢？ </p><p>答案是肯定的。这种算法就是本文的主旨KMP算法，它利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。</p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212317023-1101605783.png" alt=""></p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><ul><li>定义</li></ul><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。 </p><p>下面先直接给出KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明☺）： </p><p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p><p>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]）， 都令i++，j++，继续匹配下一个字符；</p><p>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述）， 即移动的实际位数为：j - next[j]，且此值大于等于1。 </p><p>很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。</p><p>例如如果next [j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。</p><p>此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。</p><p>** 再强调一遍，next[i]就是子串s[0…i]的最长相等前后缀的前缀最后一位的下标。 **</p><p>** next数组的含义就是当j+1位失配时，j应该回退到的位置。 **</p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212432574-1006267186.png" alt=""></p><ul><li>由此可以总结出KMP算法的一般思路：</li></ul><blockquote><ul><li>①初始化j=-1，表示pattern当前已被匹配的最后位。</li></ul></blockquote><blockquote><ul><li>②让i遍历文本串text，对每个i，执行③④来试图匹配text[i]和pattern[i+1]。</li></ul></blockquote><blockquote><ul><li>③不断令j=next[i]，直到j回退为-1，或是text[i]=pattern[i+1]成立。</li></ul></blockquote><blockquote><ul><li>④如果text[i]=pattern[i+1]，则令j++。如果j达到m-1，说明pattern是text的子串，返回true。</li></ul></blockquote><ul><li>KMP算法的代码如下：<pre><code>//next的数组的原理就是复制一次原数组，然后和原数组向后差一位进行匹配void getNext(vector&lt;int&gt;&amp;next){  int j = 0;  int k = -1;//k是关键，k=0就是求前缀数组，k=-1就是将前缀数组向后移一位  int len = pattern.length();  next[0] = -1;  while (j &lt; len-1)  {      if (k == -1 || pattern[j] == pattern[k])//将复制数组与原数组匹配      {          ++k;          ++j;          next[j] = k;      }      else          k = next[k];//又从复制数组的头开始匹配，-1的位置  }}int KMP(){  int i = 0, j = 0;  int slen = text.length(), plen = pattern.length();  vector&lt;int&gt;next(pattern.length());  getNext(next);  while (i &lt; slen &amp;&amp; j &lt; plen)  {      if (j == -1 || text[i] == pattern[j])//j==-1表示第一个字母都没有匹配上      {          ++i;          ++j;      }      else          j = next[j];//一旦没匹配，就跳next中的步数  }  if (j == plen)//匹配成功      return i - j;  else      return -1;}</code></pre></li></ul><h2 id="详细步骤讲解："><a href="#详细步骤讲解：" class="headerlink" title="详细步骤讲解："></a>详细步骤讲解：</h2><ol><li>①寻找前缀后缀最长公共元素长度</li></ol><p>对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：<br>!()[<a href="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212544600-803968379.png]" target="_blank" rel="noopener">https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212544600-803968379.png]</a></p><p>比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k + 1 = 2）。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212544600-803968379.png" alt=""></p><ol start="2"><li>②求next数组<br>next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212538710-1902602709.png" alt=""></li></ol><p>比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）。</p><ol start="3"><li>③根据next数组进行匹配<br>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀pj-k pj-k+1, …, pj-1 跟文本串si-k si-k+1, …, si-1匹配成功，但pj 跟si匹配失败时，因为next[j] = k，相当于在不包含pj的模式串中有最大长度为k 的相同前缀后缀，即p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令j = next[j]，从而让模式串右移j - next[j] 位，使得模式串的前缀p0 p1, …, pk-1对应着文本串 si-k si-k+1, …, si-1，而后让pk 跟si 继续匹配。如下图所示：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212607443-50359875.png" alt=""></li></ol><p>综上，KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 j - next[j] 位。</p><p>接下来，分别具体解释上述3个步骤。 </p><h2 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h2><ol><li>寻找最长前缀后缀 </li></ol><p>如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212632985-1520852601.png" alt=""></p><p>也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212643038-407128118.png" alt=""></p><ol start="2"><li>基于《最大长度表》匹配</li></ol><p>最长前缀和最长后缀的匹配长度：<br>即PreIndex = 0,  LastIndex = N;</p><p>前缀指针向后移动，后缀指针向前移动，前缀指针不能到最后的一个字符，后缀指针不能到第一个字符，然后查找他们最长【从左至右的顺序】的相同长度。</p><p>上图所示：str = “abcabcd”<br>一般最长前缀和最长后缀值为： index[0] = -1, index[1] == 0, 因为0位无前字符，1位也无不满足后缀指针不等于第一个字符。</p><p>其他的需要计算：<br>d的标记为3：即以0位置的a为前缀指针，d前面的字母c为后缀指针，找到的相同最长字符为”abc”  == 3</p><p>因为模式串中首尾可能会有重复的字符，故可得出下述结论：<br>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p><p>下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。</p><p>如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：</p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212752075-1606534188.png" alt=""></p><ul><li><p>1).因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212837465-34254220.png" alt=""></p></li><li><p>2). 继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212846470-1422279734.png" alt=""></p></li><li><p>3). 模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 =2 位。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212854776-147524862.png" alt=""></p></li><li><p>4). A与空格失配，向右移动1 位。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212903151-244050017.png" alt=""></p></li><li><p>5). 继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 = 4 位。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212910289-948231451.png" alt=""></p></li><li><p>6). 经历第5步后，发现匹配成功，过程结束。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212916627-1500097556.png" alt=""></p></li></ul><p>通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。</p><ol start="3"><li>根据《最大长度表》求next 数组</li></ol><p>由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212933754-1746143212.png" alt=""></p><p>而且，根据这个表可以得出下述结论：</p><blockquote><p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p></blockquote><p>上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。 </p><p>给定字符串“ABCDABD”，可求得它的next 数组如下：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212955003-427379178.png" alt=""></p><p>把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。</p><p>换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213004240-1194731365.png" alt=""></p><p>根据最大长度表求出了next 数组后，从而有失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</p><p>而后，你会发现，无论是基于《最大长度表》的匹配，还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为：</p><p>根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值</p><p>而根据《next 数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的next 值</p><p>其中，从0开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），</p><p>而失配字符对应的next 值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。</p><p>所以，你可以把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是可以的，区别不过是怎么用的问题。</p><ol start="4"><li>通过代码递推计算next 数组</li></ol><p>接下来，咱们来写代码求下next 数组。</p><p>基于之前的理解，可知计算next 数组的方法可以采用递推：</p><ul><li>1). 如果对于值k，已有p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k。</li></ul><p>此意味着什么呢？究其本质，next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀。有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j] 位。</p><ul><li>2). 下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？</li></ul><p>对于P的前j+1个序列字符：</p><p>若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1；</p><p>若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀”p0 p1, …, pk-1 pk”跟后缀“pj-k pj-k+1, …, pj-1 pj”相等，那么是否可能存在另一个值t+1 &lt; k+1，使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, …, k, …, j]）进行P串前缀跟P串后缀的匹配。</p><p>如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213116707-1536479101.png" alt=""></p><p>但如果pk != pj 呢？说明“p0 pk-1 pk”  ≠ “pj-k pj-1 pj”。换言之，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213159715-62831620.png" alt=""></p><p>结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk’-1 pk’ = pj-k’ pj-1 pj，则最大相同的前缀后缀长度为k’ + 1，从而next [j + 1] = k’ + 1 = next [k’ ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。</p><p>那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？这又归根到next数组的含义。我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。此过程相当于模式串的自我匹配，所以不断的递归k = next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。如下图所示：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213215099-1610682320.png" alt=""></p><p>找到p[k]对应的next[k]，根据对称性，只需再判断p[next[k]]与p[j]是否相等即可，于是令k = next[k],这里恰好就使用了递归的思路。其实我觉得不要一开始就陷入递归的方法中，换一种思路，直接从考虑对称性入手，可直接得出k = next[k]，而这正好是递归罢了。</p><p>所以，因最终在前缀ABC中没有找到D，故E的next 值为0：</p><p>模式串的后缀：ABDE</p><p>模式串的前缀：ABC</p><p>前缀右移两位：     ABC</p><p>那能否举一个能在前缀中找到字符D的例子呢？OK，咱们便来看一个能在前缀中找到字符D的例子，如下图所示：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213243820-1979109095.png" alt=""></p><p>给定模式串DABCDABDE，我们很顺利的求得字符D之前的“DABCDAB”的各个子串的最长相同前缀后缀的长度分别为0 0 0 0 1 2 3，但当遍历到字符D，要求包括D在内的“DABCDABD”最长相同前缀后缀时，我们发现pj处的字符D跟pk处的字符C不一样，换言之，前缀DABC的最后一个字符C 跟后缀DABD的最后一个字符D不相同，所以不存在长度为4的相同前缀后缀。</p><p>怎么办呢？既然没有长度为4的相同前缀后缀，咱们可以寻找长度短点的相同前缀后缀，最终，因在p0处发现也有个字符D，p0 = pj，所以p[j]对应的长度值为1，相当于E对应的next 值为1（即字符E之前的字符串“DABCDABD”中有长度为1的相同前缀和后缀）。</p><p>综上，可以通过递推求得next 数组，代码如下所示：</p><pre><code>//next的数组的原理就是复制一次原数组，然后和原数组向后差一位进行匹配void getNext(vector&lt;int&gt;&amp;next){    int j = 0;    int k = -1;//k是关键，k=0就是求前缀数组，k=-1就是将前缀数组向后移一位    int len = pattern.length();    next[0] = -1;    while (j &lt; len-1)    {        if (k == -1 || pattern[j] == pattern[k])//将复制数组与原数组匹配        {            ++k;            ++j;            next[j] = k;        }        else            k = next[k];//又从复制数组的头开始匹配，-1的位置    }}</code></pre><h1 id="扩展：BM算法"><a href="#扩展：BM算法" class="headerlink" title="扩展：BM算法"></a>扩展：BM算法</h1><p>KMP的匹配是从模式串的开头开始匹配的，而1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了一种新的字符串匹配算法：Boyer-Moore算法，简称BM算法。该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高。</p><p>BM算法定义了两个规则：</p><ul><li>坏字符规则：</li></ul><blockquote><p>当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为-1。</p></blockquote><ul><li>好后缀规则：</li></ul><blockquote><p>当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p></blockquote><p>下面举例说明BM算法。例如，给定文本串“HERE IS A SIMPLE EXAMPLE”，和模式串“EXAMPLE”，现要查找模式串是否在文本串中，如果存在，返回模式串在文本串中的位置。</p><ol><li><p>首先，”文本串”与”模式串”头部对齐，从尾部开始比较。”S”与”E”不匹配。这时，”S”就被称为”坏字符”（bad character），即不匹配的字符，它对应着模式串的第6位。且”S”不包含在模式串”EXAMPLE”之中（相当于最右出现位置是-1），这意味着可以把模式串后移6-(-1)=7位，从而直接移到”S”的后一位。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213411338-916688068.png" alt=""></p></li><li><p>依然从尾部开始比较，发现”P”与”E”不匹配，所以”P”是”坏字符”。但是，”P”包含在模式串 “EXAMPLE”之中。因为“P”这个“坏字符”对应着模式串的第6位（从0开始编号），且在模式串中的最右出现位置为4，所以，将模式串后移6-4=2位，两个”P”对齐。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213424562-493568045.png" alt=""></p></li><li><p>依次比较，得到 “MPLE”匹配，称为”好后缀”（good suffix），即所有尾部匹配的字符串。注意，”MPLE”、”PLE”、”LE”、”E”都是好后缀。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213436187-1376005758.png" alt=""></p></li><li><p>发现“I”与“A”不匹配：“I”是坏字符。如果是根据坏字符规则，此时模式串应该后移2-(-1)=3位。问题是，有没有更优的移法？<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213446841-192806358.png" alt=""></p></li></ol><p>5、更优的移法是利用好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串中上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p><p>所有的“好后缀”（MPLE、PLE、LE、E）之中，只有“E”在“EXAMPLE”的头部出现，所以后移6-0=6位。</p><p>可以看出，“坏字符规则”只能移3位，“好后缀规则”可以移6位。每次后移这两个规则之中的较大值。这两个规则的移动位数，只与模式串有关，与原文本串无关。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213457225-193867223.png" alt=""></p><ol start="6"><li>继续从尾部开始比较，“P”与“E”不匹配，因此“P”是“坏字符”，根据“坏字符规则”，后移 6 - 4 = 2位。因为是最后一位就失配，尚未获得好后缀。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213533438-360358258.png" alt=""></li></ol><p>由上可知，BM算法不仅效率高，而且构思巧妙，容易理解。</p><pre><code>//bad character数组，128   ASCll码为数组大小vector&lt;int&gt; preBmBc(string ps) {    vector&lt;int&gt; BC(128, ps.size());    for (size_t i = 0; i &lt; ps.size(); i++)        BC[ps[i]] = ps.size() - i - 1;//记住每个字母的最右端的位置，重复字母中，后端会把前端覆盖掉的    //记住，这位置的反着的，即ps.size()-i;return BC;}void BM(string text, string pattern){    vector&lt;int&gt; matched;//匹配的好字符    vector&lt;int&gt; BC = preBmBc(pattern);//创建bad character数组int tlen = text.size();    int plen = pattern.size();int tindex = 0;//text索引    while (tindex + plen &lt;= tlen) {        int badmove = 0;//坏字符位置        int goodmove = 0;//好字符位置        for (size_t j = plen; j &gt;= 0; j--)        {            if (text[tindex + j - 1] != pattern[j - 1]) {//匹配失败                badmove = BC[text[tindex + j - 1]]; //bad character移动步数,不存在则是将整个模式字符后移                break;            }           if (j == 0) {//匹配到                return;            }        }        tindex += badmove;    }}</code></pre><h1 id="扩展：Sunday算法"><a href="#扩展：Sunday算法" class="headerlink" title="扩展：Sunday算法"></a>扩展：Sunday算法</h1><p>上文中，我们已经介绍了KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比BM算法更快的查找算法即Sunday算法。</p><p>Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似：</p><p>只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。</p><p>如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；</p><p>否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。</p><p>下面举个例子说明下Sunday算法。假定现在要在文本串”substring searching algorithm”中查找模式串”search”。</p><ol><li><p>刚开始时，把模式串与文本串左边对齐：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213627855-1819294926.png" alt=""></p></li><li><p>结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213636947-1994610482.png" alt=""></p></li><li><p>结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127215416721-1703260399.png" alt=""></p></li><li><p>匹配成功。<br>回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。完。</p></li></ol><pre><code>int Sunday(string text, string pattern){    int i = 0;    int j = 0;    while (i &lt; text.length() &amp;&amp; j &lt; pattern.length())    {        if (text[i] == pattern[j])        {            i++;            j++;        }        else        {            int k = pattern.length() - 1;while (k &gt;= 0)            {                if (text[i + pattern.length() + 1] == pattern[k])//查询后面的哪个字母在pattern是否存在                {                    break;                }                else                {                    k--;                }            }            i += (pattern.length() - (k + 1) + 1);            j = 0;        }    }    if (j == pattern.length())//匹配成功        return i;    else        return -1;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;

&lt;h1 id=&quot;暴力匹配：&quot;&gt;&lt;a href=&quot;#暴力匹配：&quot; class=&quot;headerlink&quot; title=&quot;暴力匹配：&quot;&gt;&lt;/a&gt;暴力匹配：&lt;/h1&gt;&lt;p&gt;假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zzw1024.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构, 字符匹配" scheme="http://www.zzw1024.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>数据库——windows连接远程Oracle数据库</title>
    <link href="http://www.zzw1024.top/2020/06/07/shu-ju-ku-windows-lian-jie-yuan-cheng-oracle-shu-ju-ku/"/>
    <id>http://www.zzw1024.top/2020/06/07/shu-ju-ku-windows-lian-jie-yuan-cheng-oracle-shu-ju-ku/</id>
    <published>2020-06-07T06:03:26.000Z</published>
    <updated>2020-06-07T06:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><h1 id="一、在windows安装Oracle客户端："><a href="#一、在windows安装Oracle客户端：" class="headerlink" title="一、在windows安装Oracle客户端："></a>一、在windows安装Oracle客户端：</h1><p>下载地址：<a href="https://www.oracle.com/database/technologies/112010-win64soft.html" target="_blank" rel="noopener">https://www.oracle.com/database/technologies/112010-win64soft.html</a><br>** 选择第二项管理员安装**</p><ul><li><p>问题1：版本错误</p></li><li><p><em>解决：*</em><br>修改安装文件：\client\stage\cvu<br>编辑该目录下的两个xml文件：oracle.client_InstantClient.xml和cvu_prereq.xml<br>按规律添加以下内容：</p><pre><code>&lt;OPERATING_SYSTEM RELEASE=&quot;6.2&quot;&gt;   &lt;VERSION VALUE=&quot;3&quot;/&gt;   &lt;ARCHITECTURE VALUE=&quot;64-bit&quot;/&gt;   &lt;NAME VALUE=&quot;Windows 10&quot;/&gt;   &lt;ENV_VAR_LIST&gt;       &lt;ENV_VAR NAME=&quot;PATH&quot; MAX_LENGTH=&quot;5119&quot; /&gt;   &lt;/ENV_VAR_LIST&gt;&lt;/OPERATING_SYSTEM&gt;</code></pre></li><li><p>问题二：安装目录重复<br>重新选择安装目录！</p></li></ul><h1 id="二、安装PL-SQL-Developer"><a href="#二、安装PL-SQL-Developer" class="headerlink" title="二、安装PL/SQL Developer"></a>二、安装PL/SQL Developer</h1><p>下载地址：<a href="https://www.allroundautomations.com/try-it-free/" target="_blank" rel="noopener">https://www.allroundautomations.com/try-it-free/</a></p><h1 id="三、登录连接Orcle"><a href="#三、登录连接Orcle" class="headerlink" title="三、登录连接Orcle"></a>三、登录连接Orcle</h1><ul><li>问题一：没有监听<br>修改服务端Oracle的文件：<br>一定得备份！！！</li><li><em>解决办法简述：*</em></li></ul><ul><li>1.修改/home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/listener.ora中的localhost改为192.168.8.13【服务器IP】；   </li><li>2.修改/home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/tnsnames.ora中的localhost改为192.168.8.13【服务器IP】；    </li><li>3.修改后，重启oracle，监听，并注册，主win10上的plsql就可以远程连接虚拟机上的数据库了。</li></ul><p><strong>具体操作步骤如下：</strong></p><ul><li>1、修改数据库服务器中listener.ora文件内容<br>原始内容:<pre><code># listener.ora Network Configuration File:/home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/listener.ora# Generated by Oracle configuration tools.LISTENER =(DESCRIPTION_LIST =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))    (ADDRESS = (PROTOCOL = TCP)(HOST = localhost.localdomain)(PORT = 1521))  ))ADR_BASE_LISTENER = /home/tools/oracle11g</code></pre>修改后的内容如下：<pre><code># listener.ora Network Configuration File: /home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER =  (SID_LIST =      (SID_DESC =          (GLOBAL_DBNAME = orcl)          (ORACLE_HOME = /home/tools/oracle11g/product/11.2.0/dbhome_1/)          (SID_NAME = orcl)      )  )</code></pre></li></ul><p>LISTENER =<br>  (DESCRIPTION_LIST =<br>    (DESCRIPTION =<br>      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))<br>      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.8.13)(PORT = 1521))<br>    )<br>  )</p><p>ADR_BASE_LISTENER = /home/tools/oracle11g</p><pre><code>- 2、修改数据库服务器中tnsnames.ora文件内容原始内容:</code></pre><h1 id="tnsnames-ora-Network-Configuration-File-home-tools-oracle11g-product-11-2-0-dbhome-1-network-admin-tnsnames-ora"><a href="#tnsnames-ora-Network-Configuration-File-home-tools-oracle11g-product-11-2-0-dbhome-1-network-admin-tnsnames-ora" class="headerlink" title="tnsnames.ora Network Configuration File: /home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/tnsnames.ora"></a>tnsnames.ora Network Configuration File: /home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/tnsnames.ora</h1><h1 id="Generated-by-Oracle-configuration-tools"><a href="#Generated-by-Oracle-configuration-tools" class="headerlink" title="Generated by Oracle configuration tools."></a>Generated by Oracle configuration tools.</h1><p>ORCL =<br>  (DESCRIPTION =<br>    (ADDRESS = (PROTOCOL = TCP)(HOST = localhost.localdomain)(PORT = 1521))<br>    (CONNECT_DATA =<br>      (SERVER = DEDICATED)<br>      (SERVICE_NAME = orcl)<br>    )<br>  )</p><pre><code>修改后的内容：</code></pre><h1 id="tnsnames-ora-Network-Configuration-File-u01-app-oracle-product-11-2-0-dbhome-1-network-admin-tnsnames-ora"><a href="#tnsnames-ora-Network-Configuration-File-u01-app-oracle-product-11-2-0-dbhome-1-network-admin-tnsnames-ora" class="headerlink" title="tnsnames.ora Network Configuration File: /u01/app/oracle/product/11.2.0/dbhome_1/network/admin/tnsnames.ora"></a>tnsnames.ora Network Configuration File: /u01/app/oracle/product/11.2.0/dbhome_1/network/admin/tnsnames.ora</h1><h1 id="Generated-by-Oracle-configuration-tools-1"><a href="#Generated-by-Oracle-configuration-tools-1" class="headerlink" title="Generated by Oracle configuration tools."></a>Generated by Oracle configuration tools.</h1><p>LISTENER_ORCL =<br>  (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.183.129)(PORT = 1521))</p><p>orcl =<br>  (DESCRIPTION =<br>    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.183.129)(PORT = 1521))<br>    (CONNECT_DATA =<br>      (SERVER = DEDICATED)<br>      (SERVICE_NAME = orcl)<br>    )<br>  )</p><pre><code>* 添加服务器管理员权限运行Net Mananger按步骤添加：![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNzEzNTcxMjM4Ny0zMzA1MDI2OTMucG5n?x-oss-process=image/format,png)然后按内容添加：![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNzEzNTczNTY1Ni0xMzkyNjU0MjQ3LnBuZw?x-oss-process=image/format,png)* 修改windows客户端文件使用管理员权限修改：D:\Oracle11g_Client\product\11.2.0\client_1\network\admin修改内容为：【核对一下，一般不用修改】</code></pre><h1 id="tnsnames-ora-Network-Configuration-File-D-Oracle11g-Client-product-11-2-0-client-1-NETWORK-ADMIN-tnsnames-ora"><a href="#tnsnames-ora-Network-Configuration-File-D-Oracle11g-Client-product-11-2-0-client-1-NETWORK-ADMIN-tnsnames-ora" class="headerlink" title="tnsnames.ora Network Configuration File: D:\Oracle11g_Client\product\11.2.0\client_1\NETWORK\ADMIN\tnsnames.ora"></a>tnsnames.ora Network Configuration File: D:\Oracle11g_Client\product\11.2.0\client_1\NETWORK\ADMIN\tnsnames.ora</h1><h1 id="Generated-by-Oracle-configuration-tools-2"><a href="#Generated-by-Oracle-configuration-tools-2" class="headerlink" title="Generated by Oracle configuration tools."></a>Generated by Oracle configuration tools.</h1><p>ORCL =<br>  (DESCRIPTION =<br>    (ADDRESS_LIST =<br>      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.183.129)(PORT = 1521))<br>    )<br>    (CONNECT_DATA =<br>      (SERVICE_NAME = orcl)<br>    )<br>  )</p><pre><code># 三、在数据库服务器中启动监听并更新注册 #* 最后重启一下监听与数据库并更新注册</code></pre><p>$ lsnrctl stop        #先关闭监听服务<br>$ lsnrctl start        #开启监听服务<br>$ sqlplus / as sysdba      #登入<br>SQL&gt; shutdown immediate    #立即关闭数据库服务<br>SQL&gt; startup        #开启数据库服务<br>命令：SQL&gt; alter system register;  #注册<br>System altered.<br>SQL&gt;<br>SQL&gt; quit #登出<br>输出：<br>Disconnected from Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production<br>With the Partitioning, OLAP, Data Mining and Real Application Testing options</p><pre><code># 四、登录plsql![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNzE0MDAzNjc4MC0xMTM1MzkyMTYucG5n?x-oss-process=image/format,png)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;

&lt;h1 id=&quot;一、在windows安装Oracle客户端：&quot;&gt;&lt;a href=&quot;#一、在windows安装Oracle客户端：&quot; class=&quot;headerlink&quot; title=&quot;一、在windows安装Oracle客户端：&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.zzw1024.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle, 安装" scheme="http://www.zzw1024.top/tags/Oracle-%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>数据库——Ubuntu 16.04安装Oracle 11gR教程</title>
    <link href="http://www.zzw1024.top/2020/06/06/shu-ju-ku-ubuntu-16.04-an-zhuang-oracle-11gr-jiao-cheng/"/>
    <id>http://www.zzw1024.top/2020/06/06/shu-ju-ku-ubuntu-16.04-an-zhuang-oracle-11gr-jiao-cheng/</id>
    <published>2020-06-06T14:22:58.000Z</published>
    <updated>2020-06-06T14:22:58.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><p>转自博客：<a href="https://www.cnblogs.com/sunshine5683/archive/2018/11/13/9953672.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunshine5683/archive/2018/11/13/9953672.html</a></p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Ubuntu版本：ubuntu-16.04.3-desktop-amd64<br>Oracle版本：linux.x64_11gR2_database</p><h1 id="二、安装JDK"><a href="#二、安装JDK" class="headerlink" title="二、安装JDK"></a>二、安装JDK</h1><pre><code>sudo apt-get updatesudo apt-get install openjdk-8-jdk</code></pre><p>编辑profile</p><pre><code>cd /etcsudo vim profile</code></pre><p>在文件中加入以下内容</p><pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><p>更新</p><pre><code>Source /etc/profile</code></pre><p>测试下jdk是否安装成功</p><pre><code>java -version</code></pre><h1 id="三、安装依赖"><a href="#三、安装依赖" class="headerlink" title="三、安装依赖"></a>三、安装依赖</h1><pre><code>sudo apt-get -y install lesstif2sudo apt-get -y install lesstif2-dev（这两个包是32位包，需要换源安装：sucd /etc/apt/sources.list.decho &quot;deb http://old-releases.ubuntu.com/ubuntu/ raring main restricted universe multiverse&quot; &gt; ia32-libs-raring.listapt updateapt-get -y install lesstif2 lesstif2-dev）</code></pre><p>把源换回来  </p><pre><code>rm -rf ia32-libs-raring.listapt update</code></pre><p>退出root账户</p><pre><code>exit</code></pre><p>继续安装剩下的依赖</p><pre><code>sudo asudo apt-get install automake sudo apt-get install autotools-devsudo apt-get install binutilssudo apt-get install bzip2sudo apt-get install elfutilssudo apt-get install expatsudo apt-get install gawksudo apt-get install gccsudo apt-get install gcc-multilibsudo apt-get install g++-multilibsudo apt-get install ia32-libssudo apt-get install kshsudo apt-get install lesssudo apt-get install lesstif2sudo apt-get install lesstif2-devsudo apt-get install lib32z1sudo apt-get install libaio1sudo apt-get install libaio-devsudo apt-get install libc6-devsudo apt-get install libc6-dev-i386sudo apt-get install libc6-i386 sudo apt-get install libelf-devsudo apt-get install libltdl-devsudo apt-get install libmotif4sudo apt-get install libodbcinstq4-1 libodbcinstq4-1:i386sudo apt-get install libpth-devsudo apt-get install libpthread-stubs0sudo apt-get install libpthread-stubs0-devsudo apt-get install libstdc++5sudo apt-get install lsb-cxxsudo apt-get install makesudo apt-get install openssh-serversudo apt-get install pdkshsudo apt-get install rlwrapsudo apt-get install rpmsudo apt-get install sysstatsudo apt-get install unixodbcsudo apt-get install unixodbc-devsudo apt-get install unzipsudo apt-get install x11-utilssudo apt-get install zlibc</code></pre><p>或者：</p><pre><code>sudo apt-get -y install automake autotools-dev binutils bzip2 elfutils expat gawk gcc gcc-multilib g++-multilib lib32ncurses5 lib32z1 ksh less lib32z1 libaio1 libaio-dev libc6-dev libc6-dev-i386 libc6-i386 libelf-dev libltdl-dev libxm4 libodbcinstq4-1 libodbcinstq4-1:i386 libpth-dev libpthread-stubs0-dev libstdc++5 make openssh-server rlwrap rpm sysstat unixodbc unixodbc-dev unzip x11-utils zlibc</code></pre><p>安装这个需要点时间（这是一个吐血的历程，原本是一个一个安装，还要查看安装结果。本人将这一堆依赖处理成了一个语句，这些包亲测没问题）</p><h1 id="四、配置环境"><a href="#四、配置环境" class="headerlink" title="四、配置环境"></a>四、配置环境</h1><p>用下面的命令查询系统的参数</p><pre><code>/sbin/sysctl -a | grep sem/sbin/sysctl -a | grep file-max/sbin/sysctl -a | grep aio-max/sbin/sysctl -a | grep ip_local_port_range/sbin/sysctl -a | grep rmem_default/sbin/sysctl -a | grep rmem_max/sbin/sysctl -a | grep wmem_default/sbin/sysctl -a | grep wmem_max/sbin/sysctl -a | grep shmall/sbin/sysctl -a | grep shmmax/sbin/sysctl -a | grep shmmni</code></pre><p>将查询出来的参数填入下面对应的地方<br>在/etc/sysctl.conf中追加的文件内容为：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDUwMzc0My0xOTcyNDQzOTkucG5n?x-oss-process=image/format,png" alt=""></p><p>更新内核参数</p><pre><code>cd /etcsudo sysctl –p</code></pre><p>添加用户的内核限制（我的用户名是zzw）</p><pre><code>cd security/sudo vim limits.conf</code></pre><p>将以下内容加到文件后面</p><pre><code>zzw soft nproc 2047zzw hard nproc 16384zzw soft nofile 1024zzw hard nofile 65536zzw soft stack 10240</code></pre><p>首先检查/etc/pam.d/login<br>增加一行（有了就不用增加了）：</p><pre><code>session required pam_limits.so </code></pre><p>同样检查/etc/pam.d/su，没有这行就自己加上：</p><pre><code>session required pam_limits.so</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDYxNDcyNi05ODI3MjYxMDAucG5n?x-oss-process=image/format,png" alt=""></p><p>创建文件夹</p><pre><code>mkdir /home/rogear/toolsmkdir /home/rogear/tools/oracle11g</code></pre><p>配置oracle的环境变量</p><pre><code>sudo vim /etc/profile</code></pre><p>将下面内容加到文件后面</p><pre><code>export ORACLE_BASE=/home/rogear/tools/oracle11gexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1export ORACLE_SID=orclexport ORACLE_UNQNAME=orclexport NLS_LANG=.AL32UTF8export PATH=${PATH}:${ORACLE_HOME}/bin/:$ORACLE_HOME/lib64</code></pre><p>更新参数</p><pre><code>source /etc/profile</code></pre><p>欺骗oracle的安装设置</p><pre><code>sudo mkdir /usr/lib64sudo ln -s /etc /etc/rc.dsudo ln -s /lib/x86_64-linux-gnu/libgcc_s.so.1 /lib64/sudo ln -s /usr/bin/awk /bin/awksudo ln -s /usr/bin/basename /bin/basenamesudo ln -s /usr/bin/rpm /bin/rpmsudo ln -s /usr/lib/x86_64-linux-gnu/libc_nonshared.a /usr/lib64/sudo ln -s /usr/lib/x86_64-linux-gnu/libpthread_nonshared.a /usr/lib64/sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /lib64/sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /usr/lib64/</code></pre><p>切换root账户</p><pre><code>suecho &#39;Red Hat Linux release 5&#39; &gt; /etc/RedHat-releaseexit</code></pre><h1 id="五、正式安装"><a href="#五、正式安装" class="headerlink" title="五、正式安装"></a>五、正式安装</h1><p>前期条件准备好了，接下来正式开始安装oracle。将oracle的安装包下载到oracle11g文件夹下，包是官网下的，这里不提供下载地址<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDY0MTczNy02NTk2NTY1ODAucG5n?x-oss-process=image/format,png" alt=""></p><p>解压压缩包</p><pre><code>unzip linux.x64_11gR2_database_1of2.zipunzip linux.x64_11gR2_database_2of2.zipcd database/./runInstaller</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcwNDA4NC04NjQwMzg5NDMucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcwODE5NC03OTIxOTgwNzMucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcxMjcxMS0xNTI1MTM4NjQ4LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcxNjcxMi0xMTE3MjU5NzY2LnBuZw?x-oss-process=image/format,png" alt=""></p><p><strong>注意前三项的安装路径选择！！！</strong><br>如果提示容量不足，则删除原来错误的地址文件，重新启动！<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcyMTE2My0xNTMzMTM5MzEwLnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcyNTEyOC0xMzcyNTAzNTc4LnBuZw?x-oss-process=image/format,png" alt=""></p><p>上面这个说密码不符合规范，不用管，直接过<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDczMDI0NS0xOTgzODYwNzY2LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDczNDQyNS0zMzA1ODYxNjAucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDczODgwMi02MDk4ODU0NDkucG5n?x-oss-process=image/format,png" alt=""></p><p>这个地方有个东西需要跑一下，新开一个teminal找到那个东西跑一下<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDc0NjM1OC0xNzg1MTY2NDQ4LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDc1MDAzMC0xNTkyNDQ4ODczLnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDc1MzIzOS02OTY4MDE3OTAucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDc1NzcxNi0xMzMzMjA2ODE5LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDgwMjI4Ni02OTMzMjc0MjUucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDgwNjEzNy03Mzg3Mjg3NTkucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDgxMDUyMC0yMDkwNzU5MzkyLnBuZw?x-oss-process=image/format,png" alt=""></p><p>新开一个teminal（ctrl+alt+t）</p><pre><code>cd /home/rogear/tools/oracle11g/product/11.2.0/dbhome_1/sysman/lib/gedit ins_emagent.mk</code></pre><p>用查询功能（ctrl+f）找到下面这个东西（$(SYSMANBIN)emd），然后改一下<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDgzMTk4My0xODIxMDE0OTk4LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDgzNTQ2Mi0xMzQ1NDk1MTY5LnBuZw?x-oss-process=image/format,png" alt=""></p><p>保存后退出，然后点击Retry通过。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDg0Mjc1MS0xMzY3NjU2MjExLnBuZw?x-oss-process=image/format,png" alt=""></p><p>新开teminal，输入下面4个命令</p><pre><code>sudo sed -i &#39;s/^\(TNSLSNR_LINKLINE.*\$(TNSLSNR_OFILES)\) \(\$(LINKTTLIBS)\)/\1 -Wl,--no-as-needed \2/g&#39; /home/zzw/tools/oracle11g/product/11.2.0/dbhome_1/network/lib/env_network.mksudo sed -i &#39;s/^\(ORACLE_LINKLINE.*\$(ORACLE_LINKER)\) \(\$(PL_FLAGS)\)/\1 -Wl,--no-as-needed \2/g&#39; /home/zzw/tools/oracle11g/product/11.2.0/dbhome_1/rdbms/lib/env_rdbms.mksudo sed -i &#39;s/^\(\$LD \$LD_RUNTIME\) \(\$LD_OPT\)/\1 -Wl,--no-as-needed \2/g&#39; /home/zzw/tools/oracle11g/product/11.2.0/dbhome_1/bin/genorasdkshsudo sed -i &#39;s/^\(\s*\)\(\$(OCRLIBS_DEFAULT)\)/\1 -Wl,--no-as-needed \2/g&#39; /home/zzw/tools/oracle11g/product/11.2.0/dbhome_1/srvm/lib/ins_srvm.mk</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDg1NTg5OS0xMTcwOTMzMTE3LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkwMDYzMi00NTMwMDQ3OC5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkwNDEzNC0xMDg2NzE2OTQ3LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkwODQ1Mi02NjgyMDM2MjEucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkxMTI4NC05MDQwODY2ODcucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkxNDAzMS0xMDY3MDA3NDA5LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkxNjgyOC02NzczMjI5ODMucG5n?x-oss-process=image/format,png" alt=""></p><p>到这里oracle就安装完了，接下来就可以测试了</p><h1 id="六、测试"><a href="#六、测试" class="headerlink" title="六、测试"></a>六、测试</h1><p>启动oracle<br>检查参数</p><pre><code>echo $ORACLE_BASEecho $ORACLE_HOMEecho $PATH</code></pre><p>如果不对的话需要设置下<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDk1Nzg2My0zNjQ0Njk0MTUucG5n?x-oss-process=image/format,png" alt=""></p><p>启动监听</p><pre><code>lsnrctl start</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTAxNzcxMS0xODMxNzUxMTIwLnBuZw?x-oss-process=image/format,png" alt=""></p><p>启动服务</p><pre><code>sqlplus /nologconn / as sysdbastartup</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTAzNjA5OS0xOTAxODI5MDEzLnBuZw?x-oss-process=image/format,png" alt=""></p><p>做个小测试<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTA0NDIwMS0zOTM0Mjc2NzcucG5n?x-oss-process=image/format,png" alt=""></p><p>到这里说明oracle可以用了</p><p>关闭oracle<br>shutdown<br>(不带参数的shutdown很长时间都没反应，我用的shutdown immediate，还可以用其它参数，如下： shutdown normal：不允许新的连接、等��会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。  shutdown transactional：不允许新的连接、不等待会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。  shutdown immediate：不允许新的连接、不等待会话结束、不等待事务结束、做一个检查点并关闭数据文件。没有结束的事务是自动rollback的。启动时不需要实例恢复。  shutdown abort：不允许新的连接、不等待会话结束、不等待事务结束、不做检查点且没有关闭数据文件。启动时自动进行实例恢复。<br>quit退出<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEwNTIxOS04NzY0NzkzMzkucG5n?x-oss-process=image/format,png" alt=""></p><p>关闭监听<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEwODU5My0xNTg3NjI0NDkzLnBuZw?x-oss-process=image/format,png" alt=""></p><h1 id="七、外部连接数据库"><a href="#七、外部连接数据库" class="headerlink" title="七、外部连接数据库"></a>七、外部连接数据库</h1><p>先按照上面的方法启动oracle<br>查看虚拟机的ip地址<br>ifconfig<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEyNDM4OC0xNTk4ODczNzUyLnBuZw?x-oss-process=image/format,png" alt=""></p><p>在宿主机用cmd测试能否ping通<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEyOTg5Ny0yMDMxODMyMzYucG5n?x-oss-process=image/format,png" alt=""></p><p>用plsql连接<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEzNDIwMi0xMjI3NzQ4NjY1LnBuZw?x-oss-process=image/format,png" alt=""></p><p>报错：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEzODQwMC01Mjk1NDc1MjYucG5n?x-oss-process=image/format,png" alt=""></p><p>到ORACLE_HOME 下去修改listener.ora和tnsnames.ora<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTE0NDE1Ny0xNjk1MTkyOTYwLnBuZw?x-oss-process=image/format,png" alt=""></p><p>（先做好备份）<br>将localhost改为虚拟机的ip地址</p><pre><code>vim listener.ora</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTE1MjMwOS0xNzg0NzMzMDQ5LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTE1ODI3My02MjM5MTk5Ny5wbmc?x-oss-process=image/format,png" alt=""></p><p>vim tnsnames.ora<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIxMTQxMS02OTUzODA0ODYucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIxNjY2Mi0xNjc4OTQ4OTQ0LnBuZw?x-oss-process=image/format,png" alt=""></p><p>重启oracle服务和监听<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIyMTI3OC05MjAxNTU2NTEucG5n?x-oss-process=image/format,png" alt=""></p><p>启动监听<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIyNDk0OS04MTEzMzI1MjgucG5n?x-oss-process=image/format,png" alt=""></p><p>启动服务<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIyODczNi0xNTgzMTYxNTY1LnBuZw?x-oss-process=image/format,png" alt=""></p><p>给scott解锁<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIzMjg3MS0xMzY4OTY0ODk4LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIzNjczNy0xOTIyNDUyNTcucG5n?x-oss-process=image/format,png" alt=""></p><p>进入该scott秘密啊的界面<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTI0NTAzOC01NDA1NDI2NTQucG5n?x-oss-process=image/format,png" alt=""></p><p>建议还是用tiger作为密码，不然以后自己忘了就有点傻了<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTI1MDc3MS0xNzAxNTkwMTk0LnBuZw?x-oss-process=image/format,png" alt=""></p><p>system账户我也是解锁和重新设置密码以后才登陆成功的<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTI1NzM1My0xMzMyMjQxNDA1LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTMwMzM1OC0xNTg4OTUxNzkzLnBuZw?x-oss-process=image/format,png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;


&lt;p&gt;转自博客：&lt;a href=&quot;https://www.cnblogs.com/sunshine5683/archive/2018/11/13/9953672.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.zzw1024.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle, 安装" scheme="http://www.zzw1024.top/tags/Oracle-%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记——《图解HTTP》（四）</title>
    <link href="http://www.zzw1024.top/2020/04/15/du-shu-bi-ji-tu-jie-http-si/"/>
    <id>http://www.zzw1024.top/2020/04/15/du-shu-bi-ji-tu-jie-http-si/</id>
    <published>2020-04-15T07:09:59.000Z</published>
    <updated>2020-04-15T07:09:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h2><h3 id="为何认证："><a href="#为何认证：" class="headerlink" title="为何认证："></a>为何认证：</h3><pre><code>计算机本身无法判断坐在显示器前的使用者的身份、进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务器，就得让对方的客户端自报家门。可是，就算正在访问服务器的对方声称自己是ueno，身份是否属实这点却也无从谈起。为确认ueno本人是否真的具有访问系统的权限，就需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”。   </code></pre><ul><li><p>核对的信息通常是指以下这些。 </p><ul><li>密码：只有本人才会知道的字符串信息。   </li><li>动态令牌：仅限本人持有的设备内显示的一次性密码。   </li><li>数字证书：仅限本人（终端）持有的信息。</li><li>生物认证：指纹和虹膜等本人的生理信息。       </li><li>IC卡等：仅限本人持有的信息。  </li></ul></li><li><p>HTTP使用的认证方式<br>  HTTP/1.1使用的认证方式如下所示。  </p><ul><li>BASIC 认证（基本认证）  </li><li>DIGEST认证（摘要认证）  </li><li>SSL客户端认证  </li><li>FormBase认证（基于表单认证）<br>此外，还有Windows统一认证（Keberos认证、NTLM认证）。  </li></ul></li></ul><h3 id="BASIC认证："><a href="#BASIC认证：" class="headerlink" title="BASIC认证："></a>BASIC认证：</h3><pre><code>BASIC认证（基本认证）是从HTTP/1.0就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是Web服务器与通信客户端之间进行的认证方式。</code></pre><p>认证步骤：</p><ol><li><p>步骤1：<br> 当请求的资源需要BASIC认证时，服务器会随状态码401 Authorization Required，返回带     WWW-Authenticate首部字段的响应。该字段内包含认证的方式（BASIC）及Request-URI 安全域字符串（realm）。</p></li><li><p>步骤2：<br> 接收到状态码401的客户端为了通过BASIC认证，需要将用户ID及密码发送给服务器。发送的字符串内容是由用户ID和密码构成，两者中间以冒号(:)连接后，再经过Base64编码处理。把这串字符串写入首部字段Authorization后，发送请求。<br> 当用户代理为浏览器时，用户仅需输入用户ID和密码即可，之后，浏览器会自动完成到Base64编码的转换工作。</p></li><li><p>步骤3：<br> 接收到包含首部字段Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含Request-URI资源的响应。</p><p> BASIC认证虽然采用Base64编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户ID和密码，在HTTP等非加密通信的线路上进行BASIC认证的过程中，如果被人窃听，被盗的可能性极高。<br> 另外，除此之外想再进行一次BASIC认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一BASIC认证使用上不够便捷灵活，且达不到多数Web网站期望的安全性等级，因此它并不常用。     </p></li></ol><h3 id="DIGEST认证"><a href="#DIGEST认证" class="headerlink" title="DIGEST认证"></a>DIGEST认证</h3><pre><code>为弥补BASIC认证存在的弱点，从HTTP/1.1起就有了DIGEST认证。DIGEST认证同样使用质询/响应的方式（challenge/response），但不会像BASIC认证那样直接发送明文密码。      所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。        </code></pre><p>认证步骤：  </p><ol><li><p>步骤1：<br> 请求需认证的资源时，服务器会随着状态码401 Authorization Required，返回带WWW-Authenticate首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）。首部字段wWW-Authenticate内必须包含realm和nonce这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。<br> nonce是一种每次随返回的401响应生成的任意随机字符串。该字符串通常推荐由Base64编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现。      </p></li><li><p>步骤2：<br> 接收到401状态码的客户端，返回的响应中包含DIGEST认证必须的首部字段Authorization信息。首部字段Authorization内必须包含username、 realm、 nonce、 uri和response的字段信息。其中，realm和nonce就是之前从服务器接收到的响应中的字段。username是realm限定范围内可进行认证的用户名。uri （digest-uri） 即Request-URI的值，但考虑到经代理转发后Request-URI的值可能被修改，因此事先会复制一份副本保存在uri内。response也可叫做Request-Digest，存放经过MD5运算后的密码字符串，形成响应码。响应中其他的实体请参见第6章的请求首部字段Authorization。</p></li><li><p>步骤3：<br> 接收到包含首部字段Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则返回包含Request-URI资源的响应。并且这时会在首部字段Authentication-Info写入一些认证成功的相关信息。DIGEST认证提供了高于BASIC认证的安全等级，但是和HTTPS的客户端认证相比仍旧很弱。DIGEST认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。DIGEST认证和BASIC认证一样，使用上不那么便捷灵活，且仍达不到多数Web网站对高度安全等级的追求标准。因此它的适用范围也有所受限。    </p></li></ol><h3 id="SSL客户端认证"><a href="#SSL客户端认证" class="headerlink" title="SSL客户端认证"></a>SSL客户端认证</h3><pre><code>从使用用户ID和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果用户ID和密码被盗，就很有可能被第三者冒充。利用SSL客户端认证则可以避免该情况的发生。       SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。为达到SSL客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。     </code></pre><ol><li>步骤1：<br> 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。 </li><li>步骤2：<br> 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate 报文方式发送给服务器。 </li><li>步骤3：<br> 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信。  </li></ol><h3 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h3><pre><code>基于表单的认证方法并不是在HTTP协议中定义的。客户端会向服务器上的Web应用程序发送登录信息（Credential），按登录信息的验证结果认证。根据Web应用程序的实际安装，提供的用户界面及认证方式也各不相同。     </code></pre><ul><li><p>认证多半为基于表单认证<br>  由于使用上的便利性及安全性问题，HTTP协议标准提供的BASIC认证和DIGEST认证几乎不怎么使用。另外，SL客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。</p></li><li><p>Session 管理及Cookie应用<br>  基于表单认证的标准规范尚未有定论，一般会使用Cookie来管理Session（会话）。基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。但鉴于HTTP是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用Cookie来管理Session,以弥补HTTP协议中不存在的状态管理功能。</p></li></ul><ol><li>步骤1：<br> 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。</li><li>步骤2：<br> 服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。<br> 向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID（如PHPSESSID=028a8c…）。你可以把Session ID想象成一种用以区分不同用户的等位号。然而，如果Session ID被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止Session ID被盗，或被猜出。为了做到这点，Session ID应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。<br> 另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上htponly属性。</li><li>步骤3：<br>客户端接收到从服务器端发来的SessionID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以SessionID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。   </li></ol><h2 id="第九章-基于HTTP的功能追加协议"><a href="#第九章-基于HTTP的功能追加协议" class="headerlink" title="第九章 基于HTTP的功能追加协议"></a>第九章 基于HTTP的功能追加协议</h2><h3 id="消除HTTP瓶颈的SPDY"><a href="#消除HTTP瓶颈的SPDY" class="headerlink" title="消除HTTP瓶颈的SPDY"></a>消除HTTP瓶颈的SPDY</h3><pre><code>Google在2010年发布了SPDY（取自SPeeDY，发音同speedy），其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）。</code></pre><ul><li><p>HTTP的瓶颈<br>  在Facebook和Twitter等SNS网站上，几乎能够实时观察到海量用户公开发布的内容，这也是一种乐趣。当几百、几千万的用户发布内容时，Web网站为了保存这些新增内容，在很短的时间内就会发生大量的内容更新。为了尽可能实时地显示这些更新的内容，服务器上一有内容更新，就需要直接把那些内容反馈到客户端的界面上。虽然看起来挺简单的，但HTTP却无法妥善地处理好这项任务。<br>  使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。若想在现有web实现所需的功能，以下这些HTTP标准就会成为瓶颈。      </p><ul><li>一条连接上只可发送一个请求。  </li><li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。     </li><li>请求/响应首部未经压缩就发送。首部信息越多延迟越大。   </li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。       </li><li>可任意选择数据压缩格式。非强制压缩发送。   </li></ul></li><li><p>SPDY的设计与功能<br>  SPDY没有完全改写HITP协议，而是在TCP/ IP的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。<br>  SPDY以会话层的形式加人，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。<br>  <img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415151718425-740453936.png" alt=""></p></li></ul><p>使用SPDY后，HTTP协议额外获得以下功能：  </p><ul><li><p>多路复用流<br>通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。</p></li><li><p>赋予请求优先级<br>SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</p></li><li><p>压缩HTTP首部<br>压缩HTTP请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。</p></li><li><p>推送功能<br>支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p></li><li><p>服务器提示功能<br>服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</p></li></ul><h3 id="使用浏览器进行全双工通信的WebSocket"><a href="#使用浏览器进行全双工通信的WebSocket" class="headerlink" title="使用浏览器进行全双工通信的WebSocket"></a>使用浏览器进行全双工通信的WebSocket</h3><p>利用Ajax和Comet技术进行通信可以提升web的浏览速度。但问题在于通信若使用HTTP协议，就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及API。   </p><ul><li><p>*WebSocket的设计与功能<br>WebSocket，即web浏览器与web服务器之间全双工通信标准。其中，WebSocket协议由IETF定为标准，WebSocketAPI由W3C定为标准。仍在开发中的技术主要是为了解决Ajax和Comet里XMLHttpRequest附带的缺陷所引起的问题。</p></li><li><p>WebSocket协议<br>一旦web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p></li></ul><p>下面我们列举一下WebSocket协议的主要特点。</p><ul><li><p>推送功能<br>支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p></li><li><p>减少通信量<br>只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。</p></li></ul><p>为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次“握手”（Handshaking）的步骤。</p><h3 id="期盼已久的HTTP-2-0"><a href="#期盼已久的HTTP-2-0" class="headerlink" title="期盼已久的HTTP/2.0"></a>期盼已久的HTTP/2.0</h3><p>目前主流的HTTP/1.1标准，自1999年发布的RFC2616之后再未进行过改订。SPDY和WebSocket等技术纷纷出现，很难断言HTTP/1.1仍是适用于当下的Web的协议。</p><p>负责互联网技术标准的IETF（Internet Engineering Task Force，互联网工程任务组）创立httpbis工作组，其目标是推进下一代HTTP——HTTP/2.0在2014年11月实现标准化。</p><ul><li><p>HTTP/2.0的特点<br>HTTP/2.0的目标是改善用户在使用Web时的速度体验。由于基本上都会先通过HTTP/1.1与TCP连接，现在我们以下面的这些协议为基础，探讨一下它们的实现方法。</p><ul><li>SPDY</li><li>HTTP Speed+Mobility</li><li>Network-Friendly HTTP Upgrade</li></ul></li></ul><p>http2.0技术讨论：<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415151940900-59375749.png" alt=""></p><h2 id="第十章-构建Web内容的技术"><a href="#第十章-构建Web内容的技术" class="headerlink" title="第十章 构建Web内容的技术"></a>第十章 构建Web内容的技术</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML（HyperText Markup Language，超文本标记语言）是为了发送Web上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在HTML文档内的这种特殊字符串叫做HTML标签（Tag）。  </p><h3 id="设计应用CSS"><a href="#设计应用CSS" class="headerlink" title="设计应用CSS"></a>设计应用CSS</h3><p>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现HTML内的各种元素，属于样式表标准之一。即使是相同的HTML文档，通过改变应用的CSS，用浏览器看到的页面外观也会随之改变。CSS的理念就是让文档的结构和设计分离，达到解耦的目的。</p><h3 id="动态HTML"><a href="#动态HTML" class="headerlink" title="动态HTML"></a>动态HTML</h3><p>所谓动态HTML（Dynamic HTML），是指使用客户端脚本语言将静态的HTML内容变成动态的技术的总称。鼠标单击点开的新闻、Google Maps等可滚动的地图就用到了动态HTML。</p><p>动态HTML技术是通过调用客户端脚本语言JavaScript，实现对HTML的Web页面的动态改造。利用DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的HTML元素。</p><h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><p>Web应用是指通过Web功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和e-learning等。互联网（Internet）或企业内网（Intranet）上遍布各式各样的Web应用。</p><p>原本应用HTTP协议的Web的机制就是对客户端发来的请求，返回事前准备好的内容。可随着Web越来越普及，仅靠这样的做法已不足以应对所有的需求，更需要引入由程序创建HTML内容的做法。类似这种由程序创建的内容称为动态内容，而事先准备好的内容称为静态内容。Web应用则作用于动态内容之上。</p><h3 id="数据发布的格式及语言"><a href="#数据发布的格式及语言" class="headerlink" title="数据发布的格式及语言"></a>数据发布的格式及语言</h3><p>XML（extensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用XML，使互联网数据共享变得更容易。<br>XML和HTML都是从标准通用标记语言SGML（Standard Generalized Markup Language）简化而成。与HTML相比，它对数据的记录方式做了特殊处理。</p><h2 id="第十一章-Web的攻击技术"><a href="#第十一章-Web的攻击技术" class="headerlink" title="第十一章 Web的攻击技术"></a>第十一章 Web的攻击技术</h2><h3 id="针对Web的攻击技术"><a href="#针对Web的攻击技术" class="headerlink" title="针对Web的攻击技术"></a>针对Web的攻击技术</h3><p>简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等资源才是攻击且标。目前，来自互联网的攻击大多是冲着Web站点来的，它们大多把Web应用作为攻击目标。</p><ul><li><p>*以服务器为目标的主动攻击<br>主动攻击（active attack）是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击。</p></li><li><p>以服务器为目标的被动攻击<br>被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标Web应用访问发起攻击。<br>被动攻击通常的攻击模式如下所示。</p></li></ul><ul><li>步骤1：攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的HTTP请求。  </li><li>步骤2：当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。   </li><li>步骤3：中招后的用户浏览器会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击代码。  </li><li>步骤4：执行完攻击代码，存在安全漏洞的Web应用会成为攻击者的跳板，可能导致用户所持的Cookie等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。   </li></ul><p>被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</p><h3 id="因输出值转义不完全引发的安全漏洞"><a href="#因输出值转义不完全引发的安全漏洞" class="headerlink" title="因输出值转义不完全引发的安全漏洞"></a>因输出值转义不完全引发的安全漏洞</h3><p>实施Web应用的安全对策可大致分为以下两部分。  </p><ul><li>客户端的验证  </li><li>Web应用端（服务器端）的验证   <ul><li>输入值验证   </li><li>输出值转义   </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第八章-确认访问用户身份的认证&quot;&gt;&lt;a href=&quot;#第八章-确认访问用户身份的认证&quot; class=&quot;headerlink&quot; title=&quot;第八章 确认访问用户身份的认证&quot;&gt;&lt;/a&gt;第八章 确认访问用户身份的认证&lt;/h2&gt;&lt;h3 id=&quot;为何认证：&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="http" scheme="http://www.zzw1024.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记——《图解HTTP》（三）</title>
    <link href="http://www.zzw1024.top/2020/04/15/du-shu-bi-ji-tu-jie-http-san/"/>
    <id>http://www.zzw1024.top/2020/04/15/du-shu-bi-ji-tu-jie-http-san/</id>
    <published>2020-04-15T06:29:15.000Z</published>
    <updated>2020-04-15T06:29:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h2><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143112867-1087293884.png" alt=""></p><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143120863-947712630.png" alt=""></p><h3 id="HTTP首部字段类型"><a href="#HTTP首部字段类型" class="headerlink" title="HTTP首部字段类型"></a>HTTP首部字段类型</h3><ul><li>通用首部字段（General Header Fields）<br>  请求报文和响应报文两方都会使用的首部。   </li><li>请求首部字段（Request Header Fields）<br>  从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。   </li><li>响应首部字段（Response Header Fields）<br>  从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。   </li><li>实体首部字段（Entity Header Fields）<br>  针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。   </li></ul><h3 id="HTTP-1-1通用首部字段"><a href="#HTTP-1-1通用首部字段" class="headerlink" title="HTTP/1.1通用首部字段"></a>HTTP/1.1通用首部字段</h3><ul><li><p>Cache-Control<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143305662-1773928462.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143334645-713960820.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143343440-114223268.png" alt=""></p></li><li><p>public表示其他用户也可利用缓存   </p></li><li><p>private表示响应只以特定的用户作为对象 </p></li></ul><h3 id="no-cache指令："><a href="#no-cache指令：" class="headerlink" title="no-cache指令："></a>no-cache指令：</h3><pre><code>使用no-cache指令的目的是为了防止从缓存中返回过期的资源。客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</code></pre><h3 id="HTTP1-1警告码："><a href="#HTTP1-1警告码：" class="headerlink" title="HTTP1.1警告码："></a>HTTP1.1警告码：</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143438442-1432162543.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143443501-283778518.png" alt=""></p><h3 id="请求首部字段："><a href="#请求首部字段：" class="headerlink" title="请求首部字段："></a>请求首部字段：</h3><pre><code>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</code></pre><ul><li><p>文本文件<br>  text/htm1，text/plain，text/css…<br>  application/xhtml+xml,application/xml…   </p></li><li><p>图片文件<br>  image/jpeg,image/gif,image/png…   </p></li><li><p>视频文件<br>  video/mpeg，video/quicktime….    </p></li><li><p>应用程序使用的二进制文件<br>  application/octet-stream,application/zip…   </p></li><li><p>gzip<br>  由文件压缩程序gzip（GNUzip）生成的编码格式（RFC1952），采用Lempel-Ziv算法（LZ77）及32位循环冗余校验（Cyclic Redundancy Check，通称CRC）。  </p></li><li><p>compress<br>  由UNIX文件压缩程序compress生成的编码格式，采用Lempel-Ziv-Welch算法（LZW）。    </p></li><li><p>deflate<br>  组合使用zlib格式（RFC1950）及由deflate压缩算法（RFC1951）生成的编码格式。         </p></li><li><p>identity<br>  不执行压缩或不会变化的默认编码格式    </p><p>  采用权重q值来表示相对优先级、这点与首部字段Accept相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。 </p></li></ul><h3 id="响应首部字段："><a href="#响应首部字段：" class="headerlink" title="响应首部字段："></a>响应首部字段：</h3><pre><code>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。     </code></pre><h3 id="实体首部字段："><a href="#实体首部字段：" class="headerlink" title="实体首部字段："></a>实体首部字段：</h3><pre><code>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</code></pre><h3 id="为Cookies服务的首部字段："><a href="#为Cookies服务的首部字段：" class="headerlink" title="为Cookies服务的首部字段："></a>为Cookies服务的首部字段：</h3><pre><code>管理服务器与客户端之间状态的Cookie，虽然没有被编入标准化HTTP/1.1的RFC2616中，但在Web网站方面得到了广泛的应用。   Cookie的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该      Web网站时，可通过通信方式取回之前发放的Cookie。调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露。   至2013年5月，Cookie的规格标准文档有以下4种。     </code></pre><ul><li>由网景公司颁布的规格标准<br>  网景通信公司设计并开发了Cookie，并制定相关的规格标准。1994年前后，Cookie正式应用在网景浏览器中。目前最为普及的Cookie方式也是以此为基准的。  </li><li>RFC2109<br>  某企业尝试以独立技术对Cookie规格进行标准化统筹。原本的意图是想和网景公司制定的标准交互应用，可惜发生了微妙的差异。现在该标准已淡出了人们的视线。           </li><li>RFC2965<br>  为终结Internet Explorer 浏览器与Netscape Navigator的标准差异而导致的浏览器战争，RFC2965内定义了新的HTTP首部Set-Cookie2和Cookie2。可事实上，它们几乎没怎么投入使用。       </li><li>RFC6265<br>  将网景公司制定的标准作为业界事实标准（De facto standard），重新定义Cookie标准后的产物。</li></ul><h3 id="其他首部字段："><a href="#其他首部字段：" class="headerlink" title="其他首部字段："></a>其他首部字段：</h3><p>X-Frame-Options:<br>    DENY：属于HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题。主要为了防止点击劫持攻击。 </p><ul><li>DENY：拒绝     </li><li>SAMEORIGIN：仅同源域名下的页面匹配时许可。      </li></ul><p>X-XSS-Protection：<br>    属于响应首部，用于控制浏览器XSS防护机制的开关。  </p><ul><li>0：将XSS过滤设置成无效状态    </li><li>1：将XSS过滤设置成有效状态     </li></ul><p>DNT：<br>    请求首部，Do Not Track，拒绝个人信息被收集，是表示拒绝被精确广告追踪的一种方法。<br>    0：同意<br>    1：拒绝    </p><p>P3P（在线隐私偏好平台）：<br>    响应首部，可以让Web网站上的个人隐私编程一种仅供程序可理解的形式，以达到保护用户隐私的作用。    </p><ul><li>创建P3P隐私  </li><li>保存在/w3c/p3p.xml   </li><li>从P3P隐私中新建Compact policies后，输出到HTTP响应中。     </li></ul><h2 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h2><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><p>HTTP主要有这些不足，例举如下。    </p><ul><li><p>通信使用明文（不加密），内容可能会被窃听  </p></li><li><p>不验证通信方的身份，因此有可能遭遇伪装   </p></li><li><p>无法证明报文的完整性，所以有可能已遭篡改      </p></li><li><p>TCP/IP是可能被窃听的网络<br>  如果要问为什么通信时不加密是一个缺点，这是因为，按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。<br>  所谓互联网，是由能连通到全世界的网络组成的。无论世界哪个角落的服务器在和客户端通信时，在此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节中会遭到恶意窥视行为。 </p></li><li><p>通信的加密<br>  一种方式就是将通信加密。HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容。<br>  用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL。     </p></li><li><p>内容的加密<br>  还有一种将参与通信的内容本身加密的方式。由于HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。在这种情况下，客户端需要对HTTP报文进行加密处理后再发送请求。<br>  由于该方式不同于SSL或TES将整个通信线路加密处理，所以内容仍有被篡改的风险。稍后我们会加以说明。        </p></li><li><p>任何人都可以发起请求<br>  HTTP协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。     </p><ul><li>无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器。  </li><li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。   </li><li>无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。  </li><li>无法判定请求是来自何方、出自谁手。  </li><li>即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击）。     </li></ul></li></ul><h3 id="SSL中的数字证书："><a href="#SSL中的数字证书：" class="headerlink" title="SSL中的数字证书："></a>SSL中的数字证书：</h3><pre><code>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外、伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。另外，客户端持有证书即可完成个人身份的确认，也可用于对Web网站的认证环节。    由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。   换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。      </code></pre><h3 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS = HTTP + 加密 + 认证 + 完整性保护"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h3><ul><li><p>HTTPS是身披SSL(TLS)外壳的HTTP<br>  通常HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415144719450-1082315715.png" alt=""></p><p>  SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术。</p></li><li><p>使用两把密钥的公开密钥加密<br>  公开密钥加密方式很好地解决了共享密钥加密的困难。<br>  公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。<br>  另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。</p></li><li><p>HTTPS采用混合加密机制<br>  HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势，将多种方法组合起来用于通信。<br>  在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p></li><li><p>HTTPS中的数字证书：<br>  为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。<br>  数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。    </p><ul><li>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。    </li><li>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。   </li><li>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。<br>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。<br>数字证书认证机构的私有密钥  </li></ul><ul><li>服务器把自己的公开密钥登录至数字证书认证机构   </li><li>数字证书认证机构用自己的私有密钥向服务器的公开密码署数字签名并颁发公钥证书   </li><li>数字证书认证机构的公开密钥已事先植入到浏览器里了。客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性。   </li><li>使用服务器的公开密钥对报文加密后发送   </li><li>服务器用私有密钥对报文解密 </li></ul></li><li><p>可证明组织真实性的EV SSL证书<br>  证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是EVSSL证书（Extended Validation SSL Certificate）。<br>  EVSSL证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的Web网站能够获得更高的认可度。<br>  持有EVSSL证书的Web网站的浏览器地址栏处的背景色是绿色的，从视觉上就能一眼辨别出。而且在地址栏的左侧显示了SSL证书中记录的组织名称以及颁发证书的认证机构的名称。  </p></li></ul><h3 id="HTTPS安全通信机制："><a href="#HTTPS安全通信机制：" class="headerlink" title="HTTPS安全通信机制："></a>HTTPS安全通信机制：</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415150519883-141471649.png" alt=""></p><ol><li>步骤1：客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li><li>步骤2：服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>步骤3：之后服务器发送Certificate报文。报文中包含公开密钥证书。</li><li>步骤4：最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。</li><li>步骤5：SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。</li><li>步骤6：接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。</li><li>步骤7：客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li><li>步骤8：服务器同样发送Change Cipher Spec报文。</li><li>步骤9：服务器同样发送Finished报文。</li><li>步骤10：服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。</li><li>步骤11：应用层协议通信，即发送HTTP响应。</li><li>步骤12：最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCPFIN报文来关闭与TCP的通信。</li></ol><h3 id="SSL和TLS："><a href="#SSL和TLS：" class="headerlink" title="SSL和TLS："></a>SSL和TLS：</h3><pre><code>HTTPS使用SSL（Secure Socket Layer）和TLS（Transport Layer Security）这两个协议。  SSL技术最初是由浏览器开发商网景通信公司率先倡导的，开发过SSL3.0之前的版本。目前主导权已转移到IETF（Internet Engineering Task Force，Internet工程任务组）的手中。IETF以SSL3.0为基准，后又制定了TLS1.0、TLS1.1和TLS1.2。  TSL是以SSL为原型开发的协议，有时会统一称该协议为SSL。当前主流的版本是SSL3.0和TLS1.0。由于SSL1.0协议在设计之初被发现出了问题，就没有实际投入使用。SSL2.0也被发现存在问题，所以很多浏览器直接废除了该协议版本。  </code></pre><h3 id="SSL速度慢吗"><a href="#SSL速度慢吗" class="headerlink" title="SSL速度慢吗"></a>SSL速度慢吗</h3><pre><code>HTTPS也存在一些问题，那就是当使用SSL时，它的处理速度会变慢。  由于HTTPS还需要做服务器、客户端双方加密及解密处理，因此会消耗CPU和内存等硬件资源。和HTTP通信相比，SSL通信部分消耗网络资源。而SSL通信部分，又因为要对通信进行处理，所以时间上又延长了。HTTPS比HTTP要慢2到100倍。   SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU及内存等资源，导致处理速度变慢。和使用HTTP相比，网络负载可能会变慢2到100倍。除去和TCP连接、发送HTTP请求+响应以外，还必须进行SSL通信，因此整体上处理通信量不可避免会增加。  另一点是SSL必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起HTTP会更多地消耗服务器和客户端的硬件资源，导致负载增强。  针对速度变慢这一问题，并没有根本性的解决方案，我们会使用SSL加速器这种（专用服务器）硬件来改善该问题。该硬件为SSL通信专用硬件，相对软件来讲，能够提高数倍SSL的计算速度。仅在SSL处理时发挥SSL加速器的功效，以分担负载。   </code></pre><p>解决方法：  </p><ul><li>不全都用HTTPS<br>  如果是非敏感信息则使用HTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS加密通信。</li><li>通信内容部分加密<br>  在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第六章-HTTP首部&quot;&gt;&lt;a href=&quot;#第六章-HTTP首部&quot; class=&quot;headerlink&quot; title=&quot;第六章 HTTP首部&quot;&gt;&lt;/a&gt;第六章 HTTP首部&lt;/h2&gt;&lt;h3 id=&quot;HTTP请求报文&quot;&gt;&lt;a href=&quot;#HTTP请求报文&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="http" scheme="http://www.zzw1024.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记——《图解HTTP》（二）</title>
    <link href="http://www.zzw1024.top/2020/04/15/du-shu-bi-ji-tu-jie-http-er/"/>
    <id>http://www.zzw1024.top/2020/04/15/du-shu-bi-ji-tu-jie-http-er/</id>
    <published>2020-04-15T05:24:16.000Z</published>
    <updated>2020-04-15T05:24:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-HTTP报文内的HTTP信息"><a href="#第三章-HTTP报文内的HTTP信息" class="headerlink" title="第三章 HTTP报文内的HTTP信息"></a>第三章 HTTP报文内的HTTP信息</h2><p>HTTP报文：<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415135639051-562443235.png" alt=""></p><p>请求报文和响应报文首部内容由以下几部分组成。           </p><ul><li>请求行：包含用于请求的方法、请求 URI 和 HTTP 版本        </li><li>状态行：包含表明响应结果的状态码、原因短语和 HTTP 版本        </li><li>首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部：通用首部、请求首部、响应首部和实体首部。    </li></ul><h3 id="编码提升传输效率："><a href="#编码提升传输效率：" class="headerlink" title="编码提升传输效率："></a>编码提升传输效率：</h3><ul><li>报文主体和实体主体的区别</li></ul><p>HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p><ul><li>压缩传输的内容编码</li></ul><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。<br>常用的内容编码有以下几种：gzip(GNU zip)、compress(UNIX 系统的标准压缩)、deflate(zlib) 和 identity(不进行压缩)</p><ul><li>分割发送的分块传输编码</li></ul><p>分块传输编码会将实体主体分为多个部分。使用分块传输编码的实体主体会由接收的客户端负责界面，恢复到编码前的实体主体。</p><h3 id="内容协商："><a href="#内容协商：" class="headerlink" title="内容协商："></a>内容协商：</h3><ul><li><p>服务器驱动协商（Server-driven Negotiation）<br>由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。</p></li><li><p>客户端驱动协商（Agent-driven Negotiation）<br>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。</p></li><li><p>透明协商（Transparent Negotiation）<br>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</p></li></ul><h2 id="第四章-返回结果的HTTP状态码"><a href="#第四章-返回结果的HTTP状态码" class="headerlink" title="第四章 返回结果的HTTP状态码"></a>第四章 返回结果的HTTP状态码</h2><h3 id="状态码返回告知："><a href="#状态码返回告知：" class="headerlink" title="状态码返回告知："></a>状态码返回告知：</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415135650140-517015800.png" alt=""></p><ul><li><p>2XX 成功<br>200 OK  客户端发送的请求在服务端正常处理<br>204 No Content  服务端成功处理请求，但没有资源返回<br>206 Partial Content 客户端进行了范围请求，而服务器成功执行    </p></li><li><p>3XX 重定向<br>301 Moved Permanently   永久性重定向<br>302 Found   临时性重定向<br>303 See Other   由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。<br>304 Not Modified    客户端请求的资源找到，但未符合条件的请求<br>307 Temporary Redirect  临时重定向，与302不同的是不会从POST变成GET<br>当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。<br>301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做。     </p></li><li><p>4XX 客户端错误<br>400 Bad Request 客户端请求报文出错<br>401 Unauthorized    客户端的请求需要HTTP认证<br>403 Forbidden   请求资源被拒绝访问<br>404 Not Found   访问的资源不存在     </p></li><li><p>5XX 服务器错误<br>500 Internal Server Error   服务器在执行请求时发生错误<br>503 Service Unavailable 服务器无法访问     </p></li></ul><h2 id="第五章-与HTTP协作"><a href="#第五章-与HTTP协作" class="headerlink" title="第五章 与HTTP协作"></a>第五章 与HTTP协作</h2><h3 id="用单台虚拟主机实现多个域名："><a href="#用单台虚拟主机实现多个域名：" class="headerlink" title="用单台虚拟主机实现多个域名："></a>用单台虚拟主机实现多个域名：</h3><p>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。即使在物理层面只有一台服务器，但只要利用虚拟主机的功能，则可以假想已具有多台服务器。</p><p>在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发生 HTTP 请求时，必须在 Host 首部内完整指定主机或域名的 URI。</p><h3 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h3><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p><p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p><ul><li><p>缓存代理<br>代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</p></li><li><p>透明代理<br>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。</p></li></ul><h3 id="网关："><a href="#网关：" class="headerlink" title="网关："></a>网关：</h3><p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。</p><p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p><h3 id="隧道："><a href="#隧道：" class="headerlink" title="隧道："></a>隧道：</h3><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</p><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</p><p>隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p><h3 id="保存资源的缓存："><a href="#保存资源的缓存：" class="headerlink" title="保存资源的缓存："></a>保存资源的缓存：</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p><p>缓存服务器是代理服务器的一种，并归类在缓存代理类型中。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本在代理服务器上。</p><ul><li>缓存的有效期限<br>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</li></ul><p>缓存的有效期限：即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题。<br>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器会再次从源服务器上获取”新”资源。</p><ul><li>客户端的缓存<br>缓存不仅可以存在于缓存服务器内，也可以存在客户端浏览器中。浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。</li></ul><p>另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第三章-HTTP报文内的HTTP信息&quot;&gt;&lt;a href=&quot;#第三章-HTTP报文内的HTTP信息&quot; class=&quot;headerlink&quot; title=&quot;第三章 HTTP报文内的HTTP信息&quot;&gt;&lt;/a&gt;第三章 HTTP报文内的HTTP信息&lt;/h2&gt;&lt;p&gt;HTTP报文
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="http" scheme="http://www.zzw1024.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记——《图解HTTP》（一）</title>
    <link href="http://www.zzw1024.top/2020/04/15/du-shu-bi-ji-tu-jie-http-yi/"/>
    <id>http://www.zzw1024.top/2020/04/15/du-shu-bi-ji-tu-jie-http-yi/</id>
    <published>2020-04-15T05:03:51.000Z</published>
    <updated>2020-04-15T05:03:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-了解Web及网络基础"><a href="#第一章-了解Web及网络基础" class="headerlink" title="第一章 了解Web及网络基础"></a>第一章 了解Web及网络基础</h2><h3 id="http的诞生："><a href="#http的诞生：" class="headerlink" title="http的诞生："></a>http的诞生：</h3><ul><li>http0.9为1990年问世，由于没有正式标准建立，从而成为http1.0的前身，为http0.9</li><li>http1.0为1996年正式发布，为最初的标准协议。</li><li>http1.1为1997年正式发布，为目前最主流的协议版本。</li><li>http2.0正在制定中。。。</li></ul><h3 id="TCP-IP："><a href="#TCP-IP：" class="headerlink" title="TCP/IP："></a>TCP/IP：</h3><p>分为4层：应用层、传输层、网络层、数据链路层。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131038348-1877806121.png" alt=""></p><p>每一层必须打上上一层的首部。</p><h3 id="URI："><a href="#URI：" class="headerlink" title="URI："></a>URI：</h3><p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。<br>绝对URI格式：<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131511968-1204698359.png" alt=""></p><ol><li><p>使用http：<br>或https：等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号：。也可使用data：或javascript：这类指定数据或脚本程序的方案名。 </p></li><li><p>登录信息（认证）<br>指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</p></li><li><p>服务器地址<br>使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的Pv6地址名。</p></li><li><p>服务器端口<br>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。带层次的文件路径。指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p></li><li><p>带层次的文件路径<br>指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p></li><li><p>查询字符串<br>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</p></li><li><p>片段标识符<br>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项。</p></li></ol><h2 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h2><p>查看网页header部分：<br>F12后进入开发者模式，然后选中All,然后F5刷新网页，在name中随便打开一个，就可以打开其相关的Headers信息了。</p><p>HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。现在使用Cookie技术来达到一个处理状态的。</p><h3 id="GET：获取资源"><a href="#GET：获取资源" class="headerlink" title="GET：获取资源"></a>GET：获取资源</h3><p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGl（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131534612-2146907352.png" alt=""></p><h3 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h3><p>POST方法用来传输实体的主体。虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131551408-24285555.png" alt=""></p><h3 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h3><p>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST （REpresentational State Transfer，表征状态转移）标准的同类Web网站，就可能会开放使用PUT方法。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131618502-930083218.png" alt=""></p><h3 id="HEAD：获得报文首部"><a href="#HEAD：获得报文首部" class="headerlink" title="HEAD：获得报文首部"></a>HEAD：获得报文首部</h3><p>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131636235-887066925.png" alt=""></p><h3 id="DELETE：删除文件"><a href="#DELETE：删除文件" class="headerlink" title="DELETE：删除文件"></a>DELETE：删除文件</h3><p>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131648573-1336804768.png" alt=""></p><h3 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h3><p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131719681-671783301.png" alt=""></p><h3 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h3><p>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。<br>发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200OK的响应。<br>客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。<br>但是，TRACE方法本来就不怎么常用，再加上它容易引发XST<br>（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131835697-42751909.png" alt=""></p><h3 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h3><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<br>CONNECT方法的格式如下所示。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131912889-1239429781.png" alt=""></p><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131918318-1673449996.png" alt=""></p><h3 id="持久连接："><a href="#持久连接：" class="headerlink" title="持久连接："></a>持久连接：</h3><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一TCP连接。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131925966-392111315.png" alt=""></p><h4 id="持久连接：-1"><a href="#持久连接：-1" class="headerlink" title="持久连接："></a>持久连接：</h4><p>为解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive或HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。<br>在HTTP/1.1中，所有的连接默认都是持久连接，但在HTTP/1.0内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131945115-1106583189.png" alt=""></p><h4 id="管线化："><a href="#管线化：" class="headerlink" title="管线化："></a>管线化：</h4><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。<br>从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。<br>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131955435-1090784576.png" alt=""></p><h3 id="使用Cookie："><a href="#使用Cookie：" class="headerlink" title="使用Cookie："></a>使用Cookie：</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。<br>假设要求登录认证的Web页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。<br>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。<br>Cookie会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。<br>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章-了解Web及网络基础&quot;&gt;&lt;a href=&quot;#第一章-了解Web及网络基础&quot; class=&quot;headerlink&quot; title=&quot;第一章 了解Web及网络基础&quot;&gt;&lt;/a&gt;第一章 了解Web及网络基础&lt;/h2&gt;&lt;h3 id=&quot;http的诞生：&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="http" scheme="http://www.zzw1024.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——009 Palindrome Number</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-009-palindrome-number/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-009-palindrome-number/</id>
    <published>2020-01-03T15:20:33.000Z</published>
    <updated>2020-01-03T15:20:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><h1 id="hdashf"><a href="#hdashf" class="headerlink" title="hdashf"></a>hdashf</h1><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><pre><code>Input: 121Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.Follow up:</code></pre><p>Coud you solve it without converting the integer to a string?</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//水题咯</span><span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//负数和尾数为0都不是回文数字</span>    <span class="token keyword">double</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        num <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> num <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> s<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;hdashf&quot;&gt;&lt;a href=&quot;#hdashf&quot; class=&quot;headerlink&quot; title=&quot;hdashf&quot;&gt;&lt;/a&gt;hdashf&lt;/h1&gt;&lt;p&gt;Determine whether 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="回文" scheme="http://www.zzw1024.top/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——008 String to Integer (atoi)</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-008-string-to-integer-atoi/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-008-string-to-integer-atoi/</id>
    <published>2020-01-03T15:15:24.000Z</published>
    <updated>2020-01-03T15:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>** Description **</p><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;42&quot;Output: 42</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;   -42&quot;Output: -42Explanation: The first non-whitespace character is &#39;-&#39;, which is the minus sign.             Then take as many numerical digits as possible, which gets 42.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.</code></pre><p><strong>Example 4:</strong></p><pre><code>Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &#39;w&#39;, which is not a numerical              digit or a +/- sign. Therefore no valid conversion could be performed.</code></pre><p><strong>Example 5:</strong></p><pre><code>Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.             Thefore INT_MIN (−231) is returned.</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">Solution <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用来防止溢出的</span>        <span class="token keyword">bool</span> isBegan <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//是否开始了</span>        <span class="token keyword">int</span> isMinus <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是否是负数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isBegan <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//还没有开始</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isBegan <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">||</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第一次遇到负号</span>                isMinus <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是负数</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token comment" spellcheck="true">//不是数字</span>                <span class="token keyword">return</span> res <span class="token operator">*</span> isMinus<span class="token punctuation">;</span>            isBegan <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开始了</span>            <span class="token comment" spellcheck="true">//判断是否越界    </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>res <span class="token operator">*</span> isMinus<span class="token punctuation">)</span> <span class="token operator">&lt;</span> INT_MIN<span class="token punctuation">)</span><span class="token keyword">return</span> INT_MIN<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> isMinus <span class="token operator">></span> INT_MAX<span class="token punctuation">)</span><span class="token keyword">return</span> INT_MAX<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">*</span> isMinus<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;** Description **&lt;/p&gt;
&lt;p&gt;Implement atoi which converts a string to an integer.&lt;/p&gt;
&lt;p&gt;The function first discards as many whitespace char
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.zzw1024.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——007 Reverse Integer</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-007-reverse-integer/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-007-reverse-integer/</id>
    <published>2020-01-03T14:26:05.000Z</published>
    <updated>2020-01-03T14:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1:</strong></p><pre><code>Input: 123Output: 321</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: -123Output: -321</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: 120Output: 21Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</code></pre><p><strong>Solution:</strong></p><p>翻转一个带字符整数<br>最高数值为【-2^31 - 2^31-1】32位系统，由于int型的数值范围是 -2147483648～2147483647，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> rev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pop <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        x <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rev <span class="token operator">></span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rev <span class="token operator">==</span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">></span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rev <span class="token operator">&lt;</span> INT_MIN <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rev <span class="token operator">==</span> INT_MIN <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        rev <span class="token operator">=</span> rev <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> pop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> rev<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">></span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="数值" scheme="http://www.zzw1024.top/tags/%E6%95%B0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——006 ZigZag Conversion</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-006-zigzag-conversion/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-006-zigzag-conversion/</id>
    <published>2020-01-03T14:21:05.000Z</published>
    <updated>2020-01-03T14:21:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><pre><code>P   A   H   NA P L S I I GY   I   R</code></pre><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><p>** Example 1: **</p><p>Input: s = “PAYPALISHIRING”, numRows = 3<br>Output: “PAHNAPLSIIGYIR”</p><p>** Example 2: **</p><p>Input: s = “PAYPALISHIRING”, numRows = 4<br>Output: “PINALSIGYAHRPI”<br>Explanation:</p><pre><code>P     I    NA   L S  I GY A   H RP     I</code></pre><p>** Solution: **</p><p>注意输入的字母排序是按照倒着的N排序的，然后让你根据这个倒置的N的图形进行按行排序输出<br>按照半个N，即:一个竖和一个行的循环将数据输入到每一行中<br>比如输入：0，1，2，3，4，5，6，7，8，9，10；4行<br>其形状为<br>0            6<br>1        5    7<br>2    4        8    10<br>3            9<br>按照半个N，即0，1，2，3 与4，5 为循环，然后确定半个N的大小为size = 2 * numRows - 2 = 6<br>半个N的下竖为, 存入行[i%size]，上斜存入[size - i % size];</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">convert</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> numRows <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> s<span class="token punctuation">;</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token function">rows</span><span class="token punctuation">(</span>numRows<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> numRows <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//半个N的大小</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> id <span class="token operator">=</span> i <span class="token operator">%</span> size<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> numRows<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//竖下</span>                rows<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token comment" spellcheck="true">//斜上</span>                rows<span class="token punctuation">[</span>size <span class="token operator">-</span> id<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> str <span class="token operator">:</span> rows<span class="token punctuation">)</span>            res <span class="token operator">+</span><span class="token operator">=</span> str<span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.zzw1024.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——005 Longest Palindromic Substring</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-005-longest-palindromic-substring/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-005-longest-palindromic-substring/</id>
    <published>2020-01-03T02:56:06.000Z</published>
    <updated>2020-01-03T02:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>** Example 1: **</p><pre><code>Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.</code></pre><p>** Example 2: **</p><pre><code>Input: &quot;cbbd&quot;Output: &quot;bb&quot;</code></pre><p>** Solution: **</p><p>使用中将对称思路<br>及从头开始遍历，对于每个字母进行左右向外扩散，判断是不是回文子串<br>注意，向外扩散有两种方式，第一种，就是以该字母为中心向外扩散，第二种就是该字母和其右端的字母开始进行向外扩散   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">help</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//奇数类型的中心向两边扩撒</span>            <span class="token function">help</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//偶数类型的中心向两边扩撒            </span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">help</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>res<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token operator">--</span>L<span class="token punctuation">;</span>            <span class="token operator">++</span>R<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>L <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="回文" scheme="http://www.zzw1024.top/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
</feed>
