<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自由の翼</title>
  <icon>https://www.gravatar.com/avatar/4b22ce9ec4999fcb091d9b70473733a4</icon>
  <subtitle>书的海洋遨游，知识的世界飞翔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zzw1024.top/"/>
  <updated>2020-01-03T15:20:33.000Z</updated>
  <id>http://www.zzw1024.top/</id>
  
  <author>
    <name>自由の翼</name>
    <email>819342493@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode——009 Palindrome Number</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-009-palindrome-number/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-009-palindrome-number/</id>
    <published>2020-01-03T15:20:33.000Z</published>
    <updated>2020-01-03T15:20:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><pre><code>Input: 121Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.Follow up:</code></pre><p>Coud you solve it without converting the integer to a string?</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//水题咯</span><span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//负数和尾数为0都不是回文数字</span>    <span class="token keyword">double</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        num <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> num <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> s<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backw
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="回文" scheme="http://www.zzw1024.top/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——008 String to Integer (atoi)</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-008-string-to-integer-atoi/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-008-string-to-integer-atoi/</id>
    <published>2020-01-03T15:15:24.000Z</published>
    <updated>2020-01-03T15:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>** Description **</p><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;42&quot;Output: 42</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;   -42&quot;Output: -42Explanation: The first non-whitespace character is &#39;-&#39;, which is the minus sign.             Then take as many numerical digits as possible, which gets 42.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.</code></pre><p><strong>Example 4:</strong></p><pre><code>Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &#39;w&#39;, which is not a numerical              digit or a +/- sign. Therefore no valid conversion could be performed.</code></pre><p><strong>Example 5:</strong></p><pre><code>Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.             Thefore INT_MIN (−231) is returned.</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">Solution <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用来防止溢出的</span>        <span class="token keyword">bool</span> isBegan <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//是否开始了</span>        <span class="token keyword">int</span> isMinus <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是否是负数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isBegan <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//还没有开始</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isBegan <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">||</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第一次遇到负号</span>                isMinus <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是负数</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token comment" spellcheck="true">//不是数字</span>                <span class="token keyword">return</span> res <span class="token operator">*</span> isMinus<span class="token punctuation">;</span>            isBegan <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开始了</span>            <span class="token comment" spellcheck="true">//判断是否越界    </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>res <span class="token operator">*</span> isMinus<span class="token punctuation">)</span> <span class="token operator">&lt;</span> INT_MIN<span class="token punctuation">)</span><span class="token keyword">return</span> INT_MIN<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> isMinus <span class="token operator">></span> INT_MAX<span class="token punctuation">)</span><span class="token keyword">return</span> INT_MAX<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">*</span> isMinus<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;** Description **&lt;/p&gt;
&lt;p&gt;Implement atoi which converts a string to an integer.&lt;/p&gt;
&lt;p&gt;The function first discards as many whitespace char
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.zzw1024.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——007 Reverse Integer</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-007-reverse-integer/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-007-reverse-integer/</id>
    <published>2020-01-03T14:26:05.000Z</published>
    <updated>2020-01-03T14:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1:</strong></p><pre><code>Input: 123Output: 321</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: -123Output: -321</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: 120Output: 21Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</code></pre><p><strong>Solution:</strong></p><p>翻转一个带字符整数<br>最高数值为【-2^31 - 2^31-1】32位系统，由于int型的数值范围是 -2147483648～2147483647，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> rev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pop <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        x <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rev <span class="token operator">></span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rev <span class="token operator">==</span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">></span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rev <span class="token operator">&lt;</span> INT_MIN <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rev <span class="token operator">==</span> INT_MIN <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        rev <span class="token operator">=</span> rev <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> pop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> rev<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">></span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="数值" scheme="http://www.zzw1024.top/tags/%E6%95%B0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——006 ZigZag Conversion</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-006-zigzag-conversion/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-006-zigzag-conversion/</id>
    <published>2020-01-03T14:21:05.000Z</published>
    <updated>2020-01-03T14:21:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><pre><code>P   A   H   NA P L S I I GY   I   R</code></pre><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><p>** Example 1: **</p><p>Input: s = “PAYPALISHIRING”, numRows = 3<br>Output: “PAHNAPLSIIGYIR”</p><p>** Example 2: **</p><p>Input: s = “PAYPALISHIRING”, numRows = 4<br>Output: “PINALSIGYAHRPI”<br>Explanation:</p><pre><code>P     I    NA   L S  I GY A   H RP     I</code></pre><p>** Solution: **</p><p>注意输入的字母排序是按照倒着的N排序的，然后让你根据这个倒置的N的图形进行按行排序输出<br>按照半个N，即:一个竖和一个行的循环将数据输入到每一行中<br>比如输入：0，1，2，3，4，5，6，7，8，9，10；4行<br>其形状为<br>0            6<br>1        5    7<br>2    4        8    10<br>3            9<br>按照半个N，即0，1，2，3 与4，5 为循环，然后确定半个N的大小为size = 2 * numRows - 2 = 6<br>半个N的下竖为, 存入行[i%size]，上斜存入[size - i % size];</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">convert</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> numRows <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> s<span class="token punctuation">;</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token function">rows</span><span class="token punctuation">(</span>numRows<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> numRows <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//半个N的大小</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> id <span class="token operator">=</span> i <span class="token operator">%</span> size<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> numRows<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//竖下</span>                rows<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token comment" spellcheck="true">//斜上</span>                rows<span class="token punctuation">[</span>size <span class="token operator">-</span> id<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> str <span class="token operator">:</span> rows<span class="token punctuation">)</span>            res <span class="token operator">+</span><span class="token operator">=</span> str<span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.zzw1024.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——005 Longest Palindromic Substring</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-005-longest-palindromic-substring/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-005-longest-palindromic-substring/</id>
    <published>2020-01-03T02:56:06.000Z</published>
    <updated>2020-01-03T02:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>** Example 1: **</p><pre><code>Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.</code></pre><p>** Example 2: **</p><pre><code>Input: &quot;cbbd&quot;Output: &quot;bb&quot;</code></pre><p>** Solution: **</p><p>使用中将对称思路<br>及从头开始遍历，对于每个字母进行左右向外扩散，判断是不是回文子串<br>注意，向外扩散有两种方式，第一种，就是以该字母为中心向外扩散，第二种就是该字母和其右端的字母开始进行向外扩散   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">help</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//奇数类型的中心向两边扩撒</span>            <span class="token function">help</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//偶数类型的中心向两边扩撒            </span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">help</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>res<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token operator">--</span>L<span class="token punctuation">;</span>            <span class="token operator">++</span>R<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>L <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="回文" scheme="http://www.zzw1024.top/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——003 Longest Substring Without Repeating Characters</title>
    <link href="http://www.zzw1024.top/2020/01/02/leetcode-003-longest-substring-without-repeating-characters/"/>
    <id>http://www.zzw1024.top/2020/01/02/leetcode-003-longest-substring-without-repeating-characters/</id>
    <published>2020-01-02T15:08:38.000Z</published>
    <updated>2020-01-02T15:08:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a string, find the length of the longest substring without repeating characters.</p><p>** Example 1: **</p><pre><code>Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. </code></pre><p>** Example 2: **</p><pre><code>Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1.</code></pre><p>** Example 3: **</p><pre><code>Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3.              Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</code></pre><p>** Solution: **</p><p>使用unordered_map来记录重复字母出现的最右端位置，然后使用现在的位置减去重复字母位置，中间就是没有重复字母的子串了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> L <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用来记录字母出现的最右端位置</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                L <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i <span class="token operator">-</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;
&lt;p&gt;** Exam
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.zzw1024.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——002 Add Two Numbers</title>
    <link href="http://www.zzw1024.top/2020/01/02/leetcode-002-add-two-numbers/"/>
    <id>http://www.zzw1024.top/2020/01/02/leetcode-002-add-two-numbers/</id>
    <published>2020-01-02T14:24:58.000Z</published>
    <updated>2020-01-02T14:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>** Example: **</p><pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.</code></pre><p>** Solution: **</p><p>题目很简单，直接相加就行</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记住，这是带头节点的</span>        ListNode <span class="token operator">*</span>p <span class="token operator">=</span> result<span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> l1<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//进位</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">||</span> p2<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span>p1 <span class="token operator">?</span> p1<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>p2 <span class="token operator">?</span> p2<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token punctuation">;</span>            p<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            p1 <span class="token operator">=</span> p1 <span class="token operator">?</span> p1<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2 <span class="token operator">?</span> p2<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            p<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are store
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.zzw1024.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——001 Two Sum</title>
    <link href="http://www.zzw1024.top/2020/01/02/leetcode-001-two-sum/"/>
    <id>http://www.zzw1024.top/2020/01/02/leetcode-001-two-sum/</id>
    <published>2020-01-02T14:08:35.000Z</published>
    <updated>2020-01-02T14:08:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>** Example: ** </p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><p>** Solution: **</p><p>可以使用最简单的暴力法</p><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    v1 <span class="token operator">=</span> nums<span class="token punctuation">;</span>    <span class="token keyword">int</span> num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p1 <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>        p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>        num1 <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v1<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            num2 <span class="token operator">=</span> v2<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            v2<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num1 <span class="token operator">+</span> num2<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>                v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>                f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific tar
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="目标和" scheme="http://www.zzw1024.top/tags/%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>视频下载神器</title>
    <link href="http://www.zzw1024.top/2020/01/01/shi-pin-xia-zai-shen-qi/"/>
    <id>http://www.zzw1024.top/2020/01/01/shi-pin-xia-zai-shen-qi/</id>
    <published>2020-01-01T14:25:42.000Z</published>
    <updated>2020-01-01T14:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="youtube-dl："><a href="#youtube-dl：" class="headerlink" title="youtube-dl："></a>youtube-dl：</h2><p>Youtube-dl是谷歌github上的一个开源项目，它是一款轻量级的命令行下载实用工具，阿刚曾在乐软博客里文章《不仅仅是youtube，youtube-dl在线视频下载神器》一文章，详细介绍过Youtube-dl。 </p><p>作为一款命令行视频下载神器，Youtube-dl功能强大，可解析下载包括youtube、youku、腾讯视频、爱奇艺等国内外上百个视频网站，它甚至还支持XXX网站的视频解析与下载，比如阿刚经常用它下载XXX片子~~</p><p>youtube-dl支持Winodws ，linux和mac平台。安装配置简单，在Windows平台上，你只需下载youtube-dl.exe并为其创建系统变量，就可以通过CMD输入youtube-dl命令来下载视频了。</p><p>youtube-dl支持的命令众多，在Github项目主页上大家可以查阅命令，或者直接键入”Youtube-dl -h”查看帮助说明。</p><p><strong>常用命令</strong></p><pre><code>youtube-dl --list-extractors #查看支持网站列表youtube-dl -U #程序升级youtube-dl --get-format URL #获取视频格式youtube-dl -F URL #获取所有格式youtube-dl -o 输出路径</code></pre><p>如果你要下载视频，只需键入命令”youtube-dl +视频地址”</p><p>默认情况下，youtube-dl会自动选择下载最高画质。　　</p><p>【安装使用】：</p><p><strong>window：</strong></p><p>安装有pip3的环境后，直接输入 pip install you-get就可以使用</p><pre><code>youtube-dl  url </code></pre><p><strong>Liunx：</strong></p><p>解压后可以直接使用：</p><pre><code>youtube-dl url</code></pre><p>或者使用 sudo  apt install youtube-dl</p><p>。。。。。貌似不能用了</p><h2 id="you-get"><a href="#you-get" class="headerlink" title="you-get"></a>you-get</h2><p>youget下载</p><p>you-get是一款开源在线视频下载工具，与youtubedl相同，同样是一款轻量级多平台命令行工具，you-get支持众多视频网站，包含 41 家国内主流视频、音乐网站，如 优酷土豆、爱奇艺、腾讯视频、芒果TV 、网易云音乐等等。</p><p>you-get有三种安装方式，如果你电脑安装了Python，可以通过pip3 install </p><p>you-get命令一键安装。Windows平台还可通过Chocolatey来一键安装。当然还有最简单直接的exe文件（需创建变量）</p><p>you-get支持的命令非常丰富，使用最简单的命令you-get +视频网址，即可解析下载视频~~</p><p>默认情况下，you-get自动解析下载最佳画质的视频。同样在下载完成后，you-get会自动调用ffmpeg合并视频。　　</p><p>【安装使用】：</p><p><strong>window：</strong></p><p>安装有pip3的环境后，直接输入 pip install you-get就可以使用</p><p>you-get url</p><p><strong>Liunx：</strong></p><p>解压后可以直接使用：</p><p>you-get url</p><p>或者使用 sudo  apt install you-get</p><p>。。。。实测还能使用</p><h2 id="ykdl："><a href="#ykdl：" class="headerlink" title="ykdl："></a>ykdl：</h2><p>由于视频网站规则不断变换，无论是神器youtube-dl，you-get，经常莫名其妙无法解析视频，尤其是you-get，优酷某些特殊视频，在解析时经常出现”客户端无权播放-201”</p><p>这种情况下，我们可以试试ykdl。</p><p>ykdl——顾名思义，一款专注于国内优酷视频的命令行下载工具。阿刚这些天试用下来，在优酷视频解析下载方面ykdl的表现更为强大，至少在写这篇文章时，某些优酷视频，youtube-dl和you-get要么只能解析下载前几分钟，要么直接无法解析。</p><p>常用命令</p><pre><code>　　-h, --help　　　　　　　　　　 显示帮助信息　　-l, --playlist　　　　　　　　 下载播放列表　　-i, --info　　　　　　　　　　　　显示视频信息　　-J, --json　　　　　　　　　　 以json格式显示视频信息.　　-F --FORMAT,　　　　　　 视频格式　　-o --OUTPUT_DIR,　　　　设置视频下载的保存路径　　-O --OUTPUT_NAME, 设置视频输出的名称　　-p --PLAYER,　　　　　　　　直接调用mpv播放器播放视频　　ykdl的命令并不太多，但足够我们使用，最简单的命令　　ykdl+视频网址，可一键解析下载视频。　　</code></pre><p>【安装使用】：</p><p><strong>window：</strong></p><p>安装有pip3的环境后，直接输入 pip install ykdl就可以使用</p><p>ykdl url </p><p><strong>Liunx：</strong></p><p>解压后可以直接使用：</p><p>ydkl url</p><p>或者使用 sudo  apt install ykdl 下载再使用</p><p>。。。。貌似失效了</p><h2 id="annie"><a href="#annie" class="headerlink" title="annie:"></a>annie:</h2><p>下载　　</p><p>annie是GitHub上一个开源项目，是一款专注于在线视频下载的轻量级命令行工具。annie支持解析下载包括youtube、优酷、爱奇艺、腾讯视频、抖音等国内外17个在线视频网站。</p><p>annie支持的命令相当多，下面阿刚简单的介绍几个常用的命令。</p><p>直接下载一个视频：</p><p>如果你想下载多个链接视频，那么就在后面加上多个链接　</p><pre><code>annie https://www.bilibili.com/video/av45654043</code></pre><p>列举视频所有清晰度，但不下载：</p><pre><code>annie -i https://www.bilibili.com/video/av45654043</code></pre><p>根据列举出来的清晰度，下载指定清晰度的视频：</p><ul><li>比如列表显示的1080P视频<pre><code>annie -f 80 https://www.bilibili.com/video/av45654043</code></pre></li></ul><p>一般视频都默认下载到当前目录，如果你想下载到其它目录，需要在下载时候，加一个-o参数，后面带上文件夹路径即可。</p><ul><li>比如下载到桌面C:\Users\Rats\Desktop文件夹，Linux路径写法为/root/Rats<pre><code>annie -o C:\Users\Rats\Desktop -f 80 https://www.bilibili.com/video/av45654043</code></pre></li></ul><p>如果是下载bilibili电视剧，可以在后面加一个-p参数，然后可以将所有集数一起下载。</p><ul><li><p>列出该集数的电视剧所有集数清晰度等信息</p><pre><code>annie -i -p https://www.bilibili.com/bangumi/play/ep133269</code></pre></li><li><p>下载1到20集1080P视频</p><pre><code>annie -f 80 -p -start 1 -end 20 https://www.bilibili.com/bangumi/play/ep133269</code></pre></li></ul><p>目前播放列表暂时只支持B站和youtube。</p><p>你也可以将你需要下载的链接存放到bz.txt文件里，然后使用命令一起下载：</p><ul><li><p>列出所有链接信息</p><pre><code>annie -F /root/bz.txt -i</code></pre></li><li><p>下载1080p视频</p><pre><code>annie -f 80 -F /root/bz.txt</code></pre></li></ul><p>如果你下载的视频，比如需要会员啥的，就需要Cookies了，这里补充下优酷会员下载视频方法。</p><p>首先登录优酷账号，然后获取Cookies，只需要P_pck_rm参数即可，再新建一个文本cookie.txt，格式如下：</p><ul><li>后面为该值参数<pre><code>P_pck_rm=moerats</code></pre></li></ul><p>接下来在命令中加上-c cookie.txt参数解析地址并下载视频：</p><ul><li><p>获取视频格式列表</p><pre><code>annie -i -c cookie.txt https://v.youku.com/v_show/id_*.html</code></pre></li><li><p>根据自己需求下载指定清晰度视频</p><pre><code>annie -f mp4hd3v2-guoyu -c cookie.txt https://v.youku.com/v_show/id_*.html</code></pre></li></ul><p>【安装使用】：</p><p><strong>window：</strong></p><p>下载解压后，将文件根目录添加到用户的环境变量中</p><p>annie  rul</p><p><strong>Liunx：</strong></p><p>下载后解压后可以直接使用</p><p>。。。。实测，功能巨强！！！！</p><h2 id="Video-Download-Manager"><a href="#Video-Download-Manager" class="headerlink" title="Video Download Manager"></a>Video Download Manager</h2><p>如果你实在不喜欢命令行工具，那么这款使用youtube-dl+you-get为核心的工具一定可以满足你的需求。</p><p>你无需理会那些让人抓狂的命令，只需复制粘贴视频地址即可解析下载。</p><p>【安装使用】：</p><p>直接百度下载安装就行</p><p>。。。。不爱用</p><p>如何下载VIP视频</p><p>以上的使用都一样：</p><p>通过加载cookies获取播放权限，实现视频解析和下载。也就是说，首先你必须要有个VIP账户。</p><ul><li><p>step1:</p><p>  获取Cookies</p><p>  首先登陆会员账号，快捷键F12，打开开发者工具。选择”Network”，F5快捷键重新加载页面，选择视频播放页面，将Headers里的Cookies信息全部复制，保存为txt文件，比如Cookies.txt</p></li><li><p>step2:</p><p>  加载Cookies</p><p>  通过annie -c命令加载已保存的Cookies.txt文件。即可成功解析B站大会员视频，如图中</p><p>  （B站登陆账户最高可观看1080P视频，大会员可看1080P+视频）</p></li></ul><hr><p>指定下载储存的文件位置：</p><p>[命令] -o   [位置]   [视频地址url]<br>***s</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;youtube-dl：&quot;&gt;&lt;a href=&quot;#youtube-dl：&quot; class=&quot;headerlink&quot; title=&quot;youtube-dl：&quot;&gt;&lt;/a&gt;youtube-dl：&lt;/h2&gt;&lt;p&gt;Youtube-dl是谷歌github上的一个开源项目，它是一款轻量
      
    
    </summary>
    
    
      <category term="软件神器" scheme="http://www.zzw1024.top/categories/%E8%BD%AF%E4%BB%B6%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="视频" scheme="http://www.zzw1024.top/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>《More Effective C++》——读书笔记</title>
    <link href="http://www.zzw1024.top/2020/01/01/more-effective-c-du-shu-bi-ji/"/>
    <id>http://www.zzw1024.top/2020/01/01/more-effective-c-du-shu-bi-ji/</id>
    <published>2020-01-01T07:38:48.000Z</published>
    <updated>2020-01-01T07:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基础议题-Basics"><a href="#一、基础议题-Basics" class="headerlink" title="一、基础议题(Basics)"></a>一、基础议题(Basics)</h2><h3 id="1、仔细区别-pointers【指针】-和-references"><a href="#1、仔细区别-pointers【指针】-和-references" class="headerlink" title="1、仔细区别 pointers【指针】 和 references"></a>1、仔细区别 pointers【指针】 和 references</h3><p>二者之间的区别是：在任何情况下都不能用指向空值的引用，而指针则可以；指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变</p><p>在以下情况下使用指针：一是存在不指向任何对象的可能性；二是需要能够在不同的时刻指向不同的对象</p><p>在以下情况使用引用：总是指向一个对象且一旦指向一个对象之后就不会改变指向；重载某个操作符时，使用指针会造成语义误解</p><h3 id="2、最好使用-C-转型操作符"><a href="#2、最好使用-C-转型操作符" class="headerlink" title="2、最好使用 C++ 转型操作符"></a>2、最好使用 C++ 转型操作符</h3><p>为解决 C 旧式转型的缺点（允许将任何类型转为任何类型，且难以辨识），C++ 导入 4 个新的转型操作符（cast operators）：</p><p>static_cast , const_cast , dynamic_cast , reinterpret_cast：分别是常规类型转换，去常量转换，继承转换，函数指针转换</p><p>static_cast：功能上基本上与C风格的类型转换一样强大，含义也一样但是不能把struct转换成int类型或者把double类型转换成指针类型另外，它不<br>能从表达式中去除const属性。用来针对一个继承体系做向下的安全转换，目标类型必须为指针或者引用。基类中要有虚函数，否则会编译出错；static_cast则没有这个限制。原因是：存在虚函数，说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。必须保证源类型跟目标类型本来就是一致的，否则返回 null 指针。这个函数使用的是RTTI机制，所以编译器必须打开这个选项才能编译。</p><p>const_cast：用于类型转换掉表达式的const或volatileness属性但是不能用它来完成修改这两个属性之外的事情</p><p>dynamic_cast：用于安全地沿着类的继承关系向下类型转换失败的转换将返回空指针或者抛出异常</p><p>reinterpret_cast：这个操作符被用于的类型转换的转换结果时实现时定义因此，使用它的代码很难移植最普通的用途就是在函数指针之间进行转换</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//想要使用 dynamic_cast ，基类中必须有虚函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//i == 3</span><span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pj <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//int *pj = (int*)(&amp;j);     //等同于上面</span>    <span class="token operator">*</span>pj <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//虽然 *pj的地址和 j 的地址是一样的，但是值却不一样。</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>pj<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//20</span>    cout<span class="token operator">&lt;&lt;</span>j<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//10</span>B <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>D<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FunPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>FunPtr<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fun<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//尽量避免使用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、绝对不要以多态方式处理数组"><a href="#3、绝对不要以多态方式处理数组" class="headerlink" title="3、绝对不要以多态方式处理数组"></a>3、绝对不要以多态方式处理数组</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"base print()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"derived print()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果没有此句，执行将正确，因为基类对象和子类对象长度相同  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> B array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B barray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span>barray<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D darray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span>darray<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>array[i] 其实是一个指针算术表达式的简写，它代表的其实是 *(array+i)，array是一个指向数组起始处的指针。在 for 里遍历 array 时，必须要知道每个元素之间相差多少内存，而编译器则根据传入参数来计算得知为 sizeof(B)，而如果传入的是派生类数组对象，它依然认为是 sizeof(B)，除非正好派生类大小正好与基类相同，否则运行时会出现错误。但是如果我们设计软件的时候，不要让具体类继承具体类的话，就不太可能犯这种错误。（理由是，一个类的父类一般都会是一个抽象类，抽象类不存在数组） </p><h3 id="4、避免无用的-default-constructors"><a href="#4、避免无用的-default-constructors" class="headerlink" title="4、避免无用的 default constructors"></a>4、避免无用的 default constructors</h3><p>没有缺省构造函数造成的问题：通常不可能建立对象数组，对于使用非堆数组，可以在定义时提供必要的参数。另一种方法是使用指针数组，但是必须删除数组里的每个指针指向的对象，而且还增加了内存分配量。</p><p>提供无意义的缺省构造函数会影响类的工作效率，成员函数必须测试所有的部分是否都被正确的初始化。</p><h2 id="二、操作符-Operators"><a href="#二、操作符-Operators" class="headerlink" title="二、操作符(Operators)"></a>二、操作符(Operators)</h2><h3 id="5、对定制的“类型转换函数”保持警觉"><a href="#5、对定制的“类型转换函数”保持警觉" class="headerlink" title="5、对定制的“类型转换函数”保持警觉"></a>5、对定制的“类型转换函数”保持警觉</h3><p>定义类似功能的函数，而抛弃隐式类型转换，使得类型转换必须显示调用。例如 String类没有定义对Char*的隐式转换，而是用c_str函数来实施这个转换。拥有单个参数（或除第一个参数外都有默认值的多参数）构造函数的类，很容易被隐式类型转换，最好加上 explicit 防止隐式类型转换。</p><h3 id="6、区别-increment-decrement-操作符的前置和后置形式"><a href="#6、区别-increment-decrement-操作符的前置和后置形式" class="headerlink" title="6、区别 increment/decrement 操作符的前置和后置形式"></a>6、区别 increment/decrement 操作符的前置和后置形式</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>id <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//返回值为 const ，以避免 a++++这种形式</span>        <span class="token comment" spellcheck="true">//因为第二个 operator++ 所改变的对象是第一个 operator++ 返回的对象</span>        <span class="token comment" spellcheck="true">//最终结果其实也只是累加了一次，a++++ 也还是相当于 a++，这是违反直觉的</span>        <span class="token keyword">const</span> A <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            A a <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>id <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">++</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//++++a;   也是允许的，但 a++++ 不允许。</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">++</span><span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后置operator++(int) 的叠加是不允许的，原因有两个：一是与内建类型行为不一致（内建类型支持前置叠加)；二是其效果跟调用一次 operator++(int) 效果一样，这是违反直觉的。另外，后置式操作符使用 operator++(int)，参数的唯一目的只是为了区别前置式和后置式而已，当函数被调用时，编译器传递一个0作为int参数的值传递给该函数。<br>处置用户定制类型时，尽可能使用前置式，因为后置式会产生一个临时对象。</p><h3 id="7、千万不要重载-amp-amp-和-操作符"><a href="#7、千万不要重载-amp-amp-和-操作符" class="headerlink" title="7、千万不要重载 &amp;&amp;, || 和 , 操作符"></a>7、千万不要重载 &amp;&amp;, || 和 , 操作符</h3><pre><code>int *pi = NULL;if(pi != 0 &amp;&amp; cout&lt;&lt;*pi&lt;&lt;endl) { }</code></pre><p>上面的代码不会报错，虽然 pi 是空指针，但 &amp;&amp; 符号采用”骤死式”评估方式，如果 pi == 0 的话，不会执行后面的语句。</p><p>不要重载这些操作符，是因为我们无法控制表达式的求解优先级，不能真正模仿这些运算符。操作符重载的目的是使程序更容易阅读，书写和理解，而不是来迷惑其他人。如果没有一个好理由重载操作符，就不要重载。而对于&amp;&amp;，||和“，”，很难找到一个好理由。 </p><h3 id="8、了解各种不同意义的-new-和-delete"><a href="#8、了解各种不同意义的-new-和-delete" class="headerlink" title="8、了解各种不同意义的 new 和 delete"></a>8、了解各种不同意义的 new 和 delete</h3><p>new 操作符的执行过程：</p><ol><li>调用operator new分配内存 ；//这一步可以使用 operator new 或 placement new 重载。</li><li>调用构造函数生成类对象；</li><li>返回相应指针。</li></ol><p>函数 operator new 通常声明如下： </p><p>void * operator new(size_t size);　　//第一个参数必须为 size_t，表示需要分配多少内存。</p><p>返回值为void型指针，表示这个指针指向的内存中的数据的类型要由用户来指定。比如内存分配函数malloc函数返回的指针就是void *型，用户在使用这个指针的时候，要进行强制类型转换，如（int *)malloc(1024)。任何类型的指针都可以直接赋给 void * 变量，而不必强制转换。如果函数的参数可以为任意类型的指针，则可以声明为 void * 了。 </p><p>void 有两个地方可以使用，第一是函数返回值，第二是作为无参函数的参数。（因为在C语言中，可以给无参函数传任意类型的参数，而且C语言中，没有指定函数返回值时，默认返回为 int 值）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"size: "</span><span class="token operator">&lt;&lt;</span>size<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span>std<span class="token operator">::</span>string str<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"size: "</span><span class="token operator">&lt;&lt;</span>size <span class="token operator">&lt;&lt;</span><span class="token string">"\nname: "</span> <span class="token operator">&lt;&lt;</span> str<span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    User<span class="token operator">*</span> user1 <span class="token operator">=</span> <span class="token keyword">new</span> User<span class="token punctuation">;</span>    User<span class="token operator">*</span> user2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token string">"JIM"</span><span class="token punctuation">)</span>User<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>    pi <span class="token operator">=</span> p<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>pi<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、异常-Exceptions"><a href="#三、异常-Exceptions" class="headerlink" title="三、异常(Exceptions)"></a>三、异常(Exceptions)</h2><h3 id="9、利用-destructors-避免泄漏资源"><a href="#9、利用-destructors-避免泄漏资源" class="headerlink" title="9、利用 destructors 避免泄漏资源"></a>9、利用 destructors 避免泄漏资源</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">void</span> <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>pi<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">try</span>    <span class="token punctuation">{</span>        <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果此处抛出异常而未处理，则无法执行 delete 语句，造成内存泄漏。</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>        <span class="token keyword">throw</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">delete</span> pi<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 一个函数在堆里申请内存到释放内存的过程中，如果发生异常，如果自己不处理而只交给调用程序处理，则可能由于未调用 delete 导致内存泄漏。上面的方法可以解决这一问题，不过这样的代码使人看起来心烦且难于维护，而且必须写双份的 delete 语句。函数返回时局部对象总是释放（调用其析构函数），无论函数是如何退出的。（仅有的一种例外是当调用 longjmp 时，而 longjmp 这个缺点也是C++最初支持异常处理的原因）</p><p>所以这里使用智能指针或类似于智能指针的对象是比较好的办法：</p><ul><li>auto_ptr; — 基本被弃用.</li><li>shared_ptr; — 共享指针, 引用计数为零就销毁对象空间.</li><li>weak_ptr; — weak_ptr是用来解决shared_ptr相互引用时的死锁问题. 弱引用不会增加引用计数.</li><li>unique_ptr; — unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权.<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">void</span> <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ap</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用 auto_ptr 包装一下</span>  std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>pi<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>上面的代码看起来简洁多了，因为 auto_ptr 会在离开作用域时调用其析构函数，析构函数中会做 delete 动作。  </p><h3 id="10、在-constructors-内阻止资源泄漏"><a href="#10、在-constructors-内阻止资源泄漏" class="headerlink" title="10、在 constructors 内阻止资源泄漏"></a>10、在 constructors 内阻止资源泄漏</h3><p>这一条讲得其实是捕获构造函数里的异常的重要性。</p><p><strong>堆栈辗转开解（stack-unwinding）：</strong>如果一个函数中出现异常，在函数内即通过 try..catch 捕捉的话，可以继续往下执行；如果不捕捉就会抛出（或通过 throw 显式抛出）到外层函数，则当前函数会终止运行，释放当前函数内的局部对象（局部对象的析构函数就自然被调用了），外层函数如果也没有捕捉到的话，会再次抛出到更外层的函数，该外层函数也会退出，释放其局部对象……如此一直循环下去，直到找到匹配的 catch 子句，如果找到 main 函数中仍找不到，则退出程序。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> userid_<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> username_ <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string address_ <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token function">userid</span><span class="token punctuation">(</span>userid_<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">username</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            username <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>username_<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//构造函数里抛出异常的话，由于对象没有构造完成，不会执行析构函数</span>            address <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>address_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//此例中不会执行,会导致内存泄漏</span>        <span class="token punctuation">{</span>            <span class="token keyword">delete</span> username<span class="token punctuation">;</span>            <span class="token keyword">delete</span> address<span class="token punctuation">;</span>            std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~B()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> userid<span class="token punctuation">;</span>        std<span class="token operator">::</span>string<span class="token operator">*</span> username<span class="token punctuation">;</span>        std<span class="token operator">::</span>string<span class="token operator">*</span> address<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> C++拒绝为没有完成构造函数的对象调用析构函数，原因是避免开销，因为只有在每个对象里加一些字节来记录构造函数执行了多少步，它会使对象变大，且减慢析构函数的运行速度。</p><p>一般建议不要在构造函数里做过多的资源分配，而应该把这些操作放在一个类似于 init 的成员函数中去完成。这样当 init 成员函数抛出异常时，如果对象是在栈上，析构函数仍会被调用(异常会自动销毁局部对象，调用局部对象的析构函数，见下面)，如果是在堆上，需要在捕获异常之后 delete 对象来调用析构函数。</p><h3 id="11、禁止异常流出-destructors-之外"><a href="#11、禁止异常流出-destructors-之外" class="headerlink" title="11、禁止异常流出 destructors 之外"></a>11、禁止异常流出 destructors 之外</h3><p>这一条讲得其实是捕获析构函数里的异常的重要性。第一是防止程序调用 terminate 终止（这里有个名词叫：堆栈辗转开解 stack-unwinding）；第二是析构函数内如果发生异常，则异常后面的代码将不执行，无法确保我们完成我们想做的清理工作。</p><p>之前我们知道，析构函数被调用，会发生在对象被删除时，如栈对象超出作用域或堆对象被显式 delete (还有继承体系中，virtual 基类析构函数会在子类对象析构时调用)。除此之外，在异常传递的堆栈辗转开解（stack-unwinding）过程中，异常处理系统也会删除局部对象，从而调用局部对象的析构函数，而此时如果该析构函数也抛出异常，C++程序是无法同时处理两个异常的，就会调用 terminate()终止程序(会立即终止，连局部对象也不释放)。另外，如果异常被抛出，析构函数可能未执行完毕，导致一些清理工作不能完成。</p><p>所以不建议在析构函数中抛出异常，如果异常不可避免，则应在析构函数内捕获，而不应当抛出。 场景再现如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> T<span class="token punctuation">{</span>    <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"T()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">"init() throw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~T() begin"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">"~T() throw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~T() end"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pi<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        T t<span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下面也会引发 terminate</span>    <span class="token comment" spellcheck="true">/*    try    {        int *p2 = new int[1000000000000L];    }catch(std::bad_alloc&amp;)    {        std::cout&lt;&lt;"bad_alloc"&lt;&lt;std::endl;    }    */</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">terminate_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"my terminate_handler()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">set_terminate</span><span class="token punctuation">(</span>terminate_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12、了解-“抛出一个-exception-”-与-“传递一个参数”-或-“调用一个虚函数”之间的差异"><a href="#12、了解-“抛出一个-exception-”-与-“传递一个参数”-或-“调用一个虚函数”之间的差异" class="headerlink" title="12、了解 “抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异"></a>12、了解 “抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异</h3><p>抛出异常对象，到 catch 中，有点类似函数调用，但是它有几点特殊性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>        <span class="token keyword">throw</span> pi<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pi指向的对象是静态的，所以才能抛出指针</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果抛出的是 int 对象的异常，是不能用 double 类型接收的，这一点跟普通函数传参不一样。异常处理中，支持的类型转换只有两种，一种是上面例子中演示的从”有型指针”转为”无型指针”，所以用 const void* 可以捕捉任何指针类型的 exception。另一种是继承体系中的类转换，可见下一条款的例子。<br>另外，它跟虚拟函数有什么不同呢？异常处理可以出现多个 catch 子句，而匹配方式是按先后顺序来匹配的（所以如 exception 异常一定要写在 runtime_error异常的后面，如果反过来的话，runtime_error异常语句永远不会执行），而虚函数则是根据虚函数表来的。</p><h3 id="13、以-by-reference-方式捕捉-exceptions"><a href="#13、以-by-reference-方式捕捉-exceptions" class="headerlink" title="13、以 by reference 方式捕捉 exceptions"></a>13、以 by reference 方式捕捉 exceptions</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>id <span class="token operator">=</span> b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里是静态对象</span>    <span class="token keyword">throw</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//只有该对象是静态对象或全局对象时，才能以指针形式抛出</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">try</span><span class="token punctuation">{</span>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>B<span class="token operator">*</span> b<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//这里以指针形式接收</span> <span class="token punctuation">{</span>     std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>b<span class="token operator">-</span><span class="token operator">></span>id<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出3</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用指针方式来捕捉异常，上面的例子效率很高，没有产生临时对象。但是这种方式只能运用于全局或静态的对象（如果是 new 出来的堆中的对象也可以，但是该何时释放呢？）身上，否则的话由于对象离开作用域被销毁，catch中的指针指向不复存在的对象。接下来看看对象方式和指针方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"print():B"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"D copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"print():D"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    D d<span class="token punctuation">;</span>    <span class="token keyword">throw</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>B b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//注意这里</span>    <span class="token punctuation">{</span>        b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子会输出：</p><p>可是如果把 catch(B b) 改成 catch(B&amp; b) 的话，则会输出：</p><p>该条款的目的就是告诉我们，请尽量使用引用方式来捕捉异常，它可以避免 new 对象的删除问题，也可以正确处理继承关系的多态问题，还可以减少异常对象的复制次数。 </p><h3 id="14、明智运用-exception-specifications"><a href="#14、明智运用-exception-specifications" class="headerlink" title="14、明智运用 exception specifications"></a>14、明智运用 exception specifications</h3><p>C++提供了一种异常规范，即在函数后面指定要抛出的异常类型，可以指定多个：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//必须这样声明，而不能是 void fun(void);</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//说明可能抛出 int 和 double 异常</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>d<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="15、了解异常处理的成本"><a href="#15、了解异常处理的成本" class="headerlink" title="15、了解异常处理的成本"></a>15、了解异常处理的成本</h3><p>大致的意思是，异常的开销还是比较大的，只有在确实需要用它的地方才去用。</p><h2 id="四、效率-Efficiency"><a href="#四、效率-Efficiency" class="headerlink" title="四、效率(Efficiency)"></a>四、效率(Efficiency)</h2><h3 id="16、谨记-80-20-法则"><a href="#16、谨记-80-20-法则" class="headerlink" title="16、谨记 80-20 法则"></a>16、谨记 80-20 法则</h3><p>大致的意思是说，程序中80%的性能压力可能会集中在20%左右的代码处。那怎么找出这20%的代码来进行优化呢？可以通过Profiler分析程序等工具来测试，而不要凭感觉或经验来判断。</p><h3 id="17、考虑使用-lazy-evaluation（缓式评估）"><a href="#17、考虑使用-lazy-evaluation（缓式评估）" class="headerlink" title="17、考虑使用 lazy evaluation（缓式评估）"></a>17、考虑使用 lazy evaluation（缓式评估）</h3><p>懒惰计算法的含义是拖延计算的时间，等到需要时才进行计算其作用为：能避免不需要的对象拷贝，通过使用operator[]区分出读写操作，避免不需要的数据库读取操作，避免不需要的数字操作但是，如果计算都是重要的，懒惰计算法可能会减慢速度并增加内存的使用</p><h3 id="18、分期摊还预期的计算成本"><a href="#18、分期摊还预期的计算成本" class="headerlink" title="18、分期摊还预期的计算成本"></a>18、分期摊还预期的计算成本</h3><ul><li><p>over-eager evaluation, 如果程序常常用到某个计算, 设计一份数据结构以便能够及有效率地处理需求</p></li><li><p>(caching)利用告诉缓存暂存使用频率高的内容.</p></li><li><p>caching是分期摊还预期计算成本的一种做法. 预先取出是另一种做法. ◦系统调用往往比进程内的函数调用慢.</p></li><li><p>较快的速度往往导致较大的内存, 空间交换时间.</p></li><li><p>较大对象比较不容易塞入虚内存分页(virtual memory page)或缓存分页(cache page). ◦对象变大可能会降低性能, 因为换页活动会增加,<br>缓存命中率(cache hit rate)会降低. </p></li></ul><h3 id="19、了解临时对象的来源"><a href="#19、了解临时对象的来源" class="headerlink" title="19、了解临时对象的来源"></a>19、了解临时对象的来源</h3><p>C++真正所谓的临时对象是不可见的——只要产生一个 non-heap object 而没有为它命名，就产生了一个临时对象。它一般产生于两个地方：</p><p>一是函数参数的隐式类型转换，</p><p>二是函数返回对象时。 </p><p>任何时候，只要你看到一个 reference-to-const参数，就极可能会有一个临时对象被产生出来绑定至该参数上；任何时候，只要你看到函数返回一个对象，就会产生临时对象（并于稍后销毁）。</p><h3 id="20、协助完成“返回值优化-RVO-”"><a href="#20、协助完成“返回值优化-RVO-”" class="headerlink" title="20、协助完成“返回值优化(RVO)”"></a>20、协助完成“返回值优化(RVO)”</h3><p>不要在一个函数里返回一个局部对象的地址，因为它离开函数体后就析构了。不过在GCC下可以正常运行，无论是否打开优化；而在VS2010中如果关闭优化，就会看到效果。</p><p>这个条款想说的是：const Test fun(){ return Test(); } 比 const Test fun(){Test test; return test; }  好，更能使编译器进行优化。<br>不过现在看来，在经过编译器优化之后，这两个好像已经没有什么区别了。</p><h3 id="21、利用重载技术避免隐式类型转换"><a href="#21、利用重载技术避免隐式类型转换" class="headerlink" title="21、利用重载技术避免隐式类型转换"></a>21、利用重载技术避免隐式类型转换</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b1<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>id <span class="token operator">+</span> b2<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//const B operator+(const B&amp; b1,int i)    //如果重载此方法，就不会产生临时对象了</span><span class="token comment" spellcheck="true">//{</span><span class="token comment" spellcheck="true">//  return B(b1.id + i);</span><span class="token comment" spellcheck="true">//}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    B b3 <span class="token operator">=</span> b1<span class="token operator">+</span> b2<span class="token punctuation">;</span>    B b4 <span class="token operator">=</span> b1 <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//会把 6 先转换成B对象，产生临时对象</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="22、考虑以操作符复合形式-op-取代其独身形式-op"><a href="#22、考虑以操作符复合形式-op-取代其独身形式-op" class="headerlink" title="22、考虑以操作符复合形式(op=)取代其独身形式(op)"></a>22、考虑以操作符复合形式(op=)取代其独身形式(op)</h3><p>使用 operator+= 的实现来实现 operator= ，其它如果 operator*=、operator-= 等类似。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        B<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            id <span class="token operator">+</span><span class="token operator">=</span>  b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>id<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b1<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不用声明为 B 的 friend 函数,而且只需要维护 operator+= 即可。</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>B<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token operator">=</span> b2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里要去掉b1的const属性，才能带入operator+= 中的 this 中</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b3</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>b1<span class="token operator">+</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10    这里进行 operator+ 操作，会改变 b1 的值，这个不应该吧</span>    b1<span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//10</span>    b3<span class="token operator">+</span><span class="token operator">=</span>b1<span class="token punctuation">;</span>    b3<span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//110</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="23、考虑使用其它程序库"><a href="#23、考虑使用其它程序库" class="headerlink" title="23、考虑使用其它程序库"></a>23、考虑使用其它程序库</h3><p>提供类似功能的程序库，可能在效率、扩充性、移植性和类型安全方面有着不同的表现。比如说 iostream 和 stdio 库，所以选用不同的库可能会大幅改善程序性能。</p><h3 id="24、了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification-的成本"><a href="#24、了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification-的成本" class="headerlink" title="24、了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本"></a>24、了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本</h3><p>在使用虚函数时，大部分编译器会使用所谓的 virtual tables 和 virtual table pointers ，通常简写为 vtbls 和 vptrs 。vtbl 通常是由 “函数指针” 架构而成的数组，每一个声明（或继承）虚函数的类都有一个 vtbl ，而其中的条目就是该 class 的各个虚函数实现体的指针。<br>虚函数的第一个成本：必须为每个拥有虚函数的类耗费一个 vtbl 空间，其大小视虚函数的个数（包括继承而来的）而定。不过，一个类只会有一个 vtbl 空间，所以一般占用空间不是很大。</p><p>不要将虚函数声明为 inline ，因为虚函数是运行时绑定的，而 inline 是编译时展开的，即使你对虚函数使用 inline ，编译器也通常会忽略。<br>虚函数的第二个成本：必须为每个拥有虚函数的类的对象，付出一个指针的代价，即 vptr ，它是一个隐藏的 data member，用来指向所属类的 vtbl。</p><p>调用一个虚函数的成本，基本上和通过一个函数指针调用函数相同，虚函数本身并不构成性能上的瓶颈。</p><p>虚函数的第三个成本：事实上等于放弃了 inline。（如果虚函数是通过对象被调用，倒是可以 inline，不过一般都是通过对象的指针或引用调用的）</p><ul><li><p>虚函数真正的运行时期成本发生在和inlining互动的时候. 虚函数不应该inline. ◦因为inline函数需要在编译器将函数本体拷贝, 而virtual意味着等待, 直到运行期才知道运行谁.</p></li><li><p>多重继承往往导致虚基类的需求(virtual base class), 会形成更复杂和特殊的虚表.</p></li><li><p>一个类只需一份RTTI信息(运行时类型识别), 当某种类型至少拥有一个虚函数, 才能保证检验该对象的动态类型. </p><ul><li><p>RTTI的设计理念根据类的虚表(vtbl)来实现的.</p></li><li><p>RTTI的空间成本只需在每个类的虚表(vtbl)内增加一个条目, 即一个类型信息(type_info)对象空间.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> B1 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B2 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B3 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> <span class="token keyword">virtual</span> B1<span class="token punctuation">,</span> <span class="token keyword">virtual</span> B2<span class="token punctuation">,</span> <span class="token keyword">virtual</span> B3 <span class="token punctuation">{</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B1<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//8</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B2<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//4</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//4</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//16</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//D 中只包含了三个 vptr ，D和B1共享了一个。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="五、技术-Techniques-Idioms-Patterns"><a href="#五、技术-Techniques-Idioms-Patterns" class="headerlink" title="五、技术(Techniques,Idioms,Patterns)"></a>五、技术(Techniques,Idioms,Patterns)</h2><h3 id="25、将-constructor-和-non-member-functions-虚化"><a href="#25、将-constructor-和-non-member-functions-虚化" class="headerlink" title="25、将 constructor 和 non-member functions 虚化"></a>25、将 constructor 和 non-member functions 虚化</h3><p>这里所谓的虚拟构造函数，并不是真的指在构造函数前面加上 virtual 修饰符，而是指能够根据传入不同的参数建立不同继承关系类型的对象。<br>被派生类重定义的虚函数可以与基类的虚函数具有不同的返回类型。所以所谓的虚拟复制构造函数，可以在基类里声明一个 virtual B* clone() const = 0 的纯虚函数，在子类中实现 virtual D* clone() const {return new D(*this);}</p><p>同样的，非成员函数虚化，这里也并不是指使用 virtual 来修饰非成员函数。比如下面这个输出 list 中多态对象的属性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">value</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">virtual</span> ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span><span class="token operator">:</span>        string value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D1</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">D1</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token string">"protect value"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//子类构造函数中，要先调用基类构造函数初始化基类</span>        ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>id<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//如果基类虚函数是 const 方法，则这里也必须使用 const 修饰</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D2</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">D2</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token string">"protect value"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//子类构造函数中，要先调用基类构造函数初始化基类</span>        ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>id<span class="token punctuation">;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span> lt<span class="token punctuation">;</span>    D1 <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D2 <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>    lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d2<span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>it <span class="token operator">!=</span> lt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//D1   D2</span>        it<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，即使给每一个继承类单独实现友元的 operator&lt;&lt; 方法，也不能实现动态绑定，只会调用基类的方法。那么，在基类里写 operator&lt;&lt; 用 virtual 修饰不就行了吗？遗憾的，虚函数不能是友元。</p><h3 id="26、限制某个-class-所能产生的对象数量"><a href="#26、限制某个-class-所能产生的对象数量" class="headerlink" title="26、限制某个 class 所能产生的对象数量"></a>26、限制某个 class 所能产生的对象数量</h3><p>只有一个对象：使用单一模式，将类的构造函数声明为private，再声明一个静态函数，该函数中有一个类的静态对象不将该静态对象放在类中原因是放在函数中时，执行函数时才建立对象，并且对象初始化时间确定的，即第一次执行该函数时另外，该函数不能声明为内联，如果内联可能造成程序的静态对象拷贝超过一个限制对象个数：建立一个基类，构造函数中计数加一，若超过最大值则抛出异常；析构函数中计数减一</p><p>编程点滴：</p><p>将模板类的定义和实现放在一个文件中，否则将造成引用未定义错误（血的教训）；</p><p>静态数据成员需要先声明再初始化；</p><p>用常量值作初始化的有序类型的const静态数据成员是一个常量表达式（可以作为数组定义的维数）；</p><p>构造函数中抛出异常，将导致静态数组成员重新初始化</p><h3 id="27、要求（或禁止）对象产生于-heap-中"><a href="#27、要求（或禁止）对象产生于-heap-中" class="headerlink" title="27、要求（或禁止）对象产生于 heap 中"></a>27、要求（或禁止）对象产生于 heap 中</h3><p>析构函数私有，有一个致命问题：妨碍了继承和组合（内含）。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span>    <span class="token comment" spellcheck="true">//禁止对象产生于 heap 中</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B1"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B2</span>    <span class="token comment" spellcheck="true">//要求对象产生于 heap 中</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//模拟的析构函数</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token operator">~</span><span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//B1* b1  = new B1; //Error!</span>    B1 b1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//B2 b2;    //Error</span>    B2<span class="token operator">*</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> B2<span class="token punctuation">;</span>    b2<span class="token operator">-</span><span class="token operator">></span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="28、Smart-Pointer（智能指针）"><a href="#28、Smart-Pointer（智能指针）" class="headerlink" title="28、Smart Pointer（智能指针）"></a>28、Smart Pointer（智能指针）</h3><ul><li><p>智能指针是一个看起来, 用起来, 感觉起来都像内建指针, 但是提供了更多机能的一种对象. </p><ul><li>资源管理;</li><li>自动的重复写码工作.</li></ul></li><li><p>以智能指针取代C++内建指针: </p><ul><li>构造和析构: 何时被产生以及何时被销毁.</li><li>赋值和复制(Assignment and Copying), 复制和赋值其所指对象, 执行所谓的深拷贝(deep copy).</li><li>解引用(Dereferencing): 智能指针有权决定所指之物发生了什么事情. </li><li>采用lazy fetching方法.</li></ul></li><li><p>远程过程调用(remote procedure calls, RPC).</p></li><li><p>只能指针的构造, 赋值和析构 </p><ul><li>只有当确定要将对象所有权传递给函数的某个参数时, 才应该以by value方式传递auto_ptrs.</li></ul></li><li><p>实现解引操作符(Dereferencing Operators): </p><ul><li>返回引用值.</li></ul></li><li><p>测试智能指针是否为null: </p><ul><li>提供一个隐式类型转换操作符来进行测试.</li></ul></li><li><p>将智能指针(smart pointers) 转换为内建指针(Dumb Pointers). </p><ul><li>不要提供对内建指针的隐式转换操作符, 除非不得已.</li></ul></li><li><p>智能指针(Smart Pointers)和继承有关的类型转换 </p><ul><li>每个只能指针有个隐式类型转换操作符, 用来转换至另一个只能指针类.</li><li>函数调用的自变量匹配规则;</li><li>隐式类型转换函数;</li><li>template函数的暗自实例化;</li><li>成员函数模板(member function templates)等技术.</li></ul></li><li><p>智能指针与const: </p><ul><li>const用来修饰被指之物, 或是指针本身, 或是两者都可以. 智能指针也具有同样的弹性.</li><li>对于智能指针只有一个地方可以放置const: 只能放置与指针身上, 不能置于所指的对象.</li><li>non-const转换至const是安全的, 从const转换至non-const则不安全.</li></ul></li><li><p>自己实现的智能指针不容易实现, 了解和维护.</p></li></ul><h3 id="29、Reference-counting（引用计数）"><a href="#29、Reference-counting（引用计数）" class="headerlink" title="29、Reference counting（引用计数）"></a>29、Reference counting（引用计数）</h3><p>使用引用计数后，对象自己拥有自己，当没有人再使用它时，它自己自动销毁自己因此，引用计数是个简单的垃圾回收体系</p><p>在基类中调用delete this将导致派生类的对象被销毁</p><p>写时拷贝：与其它对象共享一个值直到写操作时才拥有自己的拷贝它是Lazy原则的特例</p><p>精彩的类层次结构：<br>RCObject类提供计数操作；<br>StringValue包含指向数据的指针并继承RCObject的计数操作；<br>RCPtr是一个灵巧指针，封装了本属于String的一些计数操作</p><h3 id="30、Proxy-classes（替身类、代理类）"><a href="#30、Proxy-classes（替身类、代理类）" class="headerlink" title="30、Proxy classes（替身类、代理类）"></a>30、Proxy classes（替身类、代理类）</h3><ul><li><p>凡是用来代表(象征)其他对象的对象, 常被称为proxy object(替身对象), 替身对象的类称为代理类. </p><ul><li>二维数组是观念上并不存在的一维数组.</li></ul></li><li><p>读取动作是所谓的右值运用(rvalue usage); 写动作是所谓的左值运用(lvalue usages).</p></li><li><p>返回字符串中字符的proxy, 而不返回字符本身.</p></li><li><p>对于一个proxy, 只有3间事情可做: </p><ul><li>产生它;</li><li>以它作为赋值动作的目标(接收端).</li><li>以其他方式使用它.</li></ul></li><li><p>Proxy 类很适合用来区分operator[]的左值运用和右值运用.</p></li><li><p>对proxy取址所获得的指针类型和对真是对象取址所获得的指针类型不同.</p></li><li><p>用户将proxy传递给接受引用到非const对象的函数.</p></li><li><p>ploxies难以完全取代真正对象的最后一个原因在于隐式类型转换.</p></li><li><p>proxy 对象是一种临时对象, 需要被产生和被销毁.</p></li><li><p>类的身份从与真实对象合作转移到与替身对象(proxies)合作, 往往会造成类语义的改变, 因为proxy 对象所展现的行为常常和真正的行为有些隐微差异.</p></li></ul><h3 id="31、让函数根据一个以上的对象类型来决定如何虚化"><a href="#31、让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="31、让函数根据一个以上的对象类型来决定如何虚化"></a>31、让函数根据一个以上的对象类型来决定如何虚化</h3><ul><li><p>面向对象函数调用机制(mutil-method): 根据所希望的多个参数而虚化的函数; — C++暂时不支持.</p></li><li><p>消息派分(message dispatch): 虚函数调用动作.</p></li><li><p>虚函数+RTTI(运行时期类型辨识): </p><ul><li>虚函数可以实现single dispatch, 利用typeid操作符来获取一个类的类型参数值.</li></ul></li><li><p>虚函数被发明的主要原因: </p><ul><li>把生产及维护”以类型为行事基准的函数”的负荷, 从程序员转移给编译器.</li></ul></li><li><p>只用虚函数: </p><ul><li>将double dispatching以两个single dispatches(两个分离的虚函数调用)实现出来: <ul><li>一个用来决定第一对象的动态类型.</li><li>另一个用来决定第二对象的动态类型.</li></ul></li><li>编译器必须根据此函数所获得的自变量的静态类型(被声明时的类型), 才能解析出哪一组函数被调用.</li></ul></li></ul><h2 id="六、杂项讨论-Miscellany"><a href="#六、杂项讨论-Miscellany" class="headerlink" title="六、杂项讨论(Miscellany)"></a>六、杂项讨论(Miscellany)</h2><h3 id="32、在未来时态下发展程序"><a href="#32、在未来时态下发展程序" class="headerlink" title="32、在未来时态下发展程序"></a>32、在未来时态下发展程序</h3><p>要用语言提供的特性来强迫程序符合设计，而不要指望使用者去遵守约定。比如禁止继承，禁止复制，要求类的实例只能创建在堆中等等。处理每个类的赋值和拷贝构造函数，如果这些函数是难以实现的，则声明它们为私有。</p><p>所提供的类的操作和函数有自然的语法和直观的语义，和内建类型（如 int）的行为保持一致。</p><p>尽可能写可移植性的代码，只有在性能极其重要时不可移植的结构才是可取的。</p><p>多为未来的需求考虑，尽可能完善类的设计。</p><h3 id="33、将非尾端类设计为抽象类"><a href="#33、将非尾端类设计为抽象类" class="headerlink" title="33、将非尾端类设计为抽象类"></a>33、将非尾端类设计为抽象类</h3><p>如果有一个实体类公有继承自另一个实体类，应该将两个类的继承层次改为三个类的继承层次，通过创造一个新的抽象类并将其它两个实体类都从它继承因此，设计类层次的一般规则是：非尾端类应该是抽象类在处理外来的类库，可能不得不违反这个规则</p><p>编程点滴：抽象类的派生类不能是抽象类；实现纯虚函数一般不常见，但对纯虚析构函数，它必须实现</p><h3 id="34、如何在同一个程序中结合-C-和-C"><a href="#34、如何在同一个程序中结合-C-和-C" class="headerlink" title="34、如何在同一个程序中结合 C++ 和 C"></a>34、如何在同一个程序中结合 C++ 和 C</h3><ul><li><p>结合C++和C程序需要考虑的问题: </p><ul><li>名称重整(name mangling): <ul><li>名称重整(name mangling)是C++中的一种程序, 为每个函数编出独一无二的名称.</li><li>绝不要重整其他语言编写函数的名称.</li><li>压制名称重整(name mangling), 必须在C++中使用extern “C” { … }指令. — 进行C连接.</li><li>不同编译器以不同的方法进行重整名称.        </li></ul></li><li>static的初始化: <ul><li>在main之前执行的代码: static class对象, 全局对象, namespace内的对象, 文件范围(file scope)内的对象, 其构造函数都在main函数之前执行.</li></ul></li></ul></li><li><p>动态内存分配: </p><ul><li>C++中使用new和delete, C中使用malloc和free.</li></ul></li><li><p>数据结构的兼容性: </p><ul><li>structs可以安全地在C++和C之间往返.</li></ul></li><li><p>在同一程序中混用C++和C, 应该记住以下几个简单规则: </p><ul><li>确定C++和C编译器产出兼容的目标文件(object file).</li><li>将双方都使用的函数声明为extern “C”.</li><li>如果可能, 尽量在C++中撰写main.</li><li>总是以delete删除new返回的内存, 总是以free释放malloc返回的内存.</li><li>将两个语言间的数据结构传递限制于C所能了解的形式; C++structs如果内涵非虚函数, 倒是不受此限制.</li></ul></li></ul><h3 id="35、让自己习惯于标准-C-语言"><a href="#35、让自己习惯于标准-C-语言" class="headerlink" title="35、让自己习惯于标准 C++ 语言"></a>35、让自己习惯于标准 C++ 语言</h3><ul><li><p>新的语言特性: </p><ul><li>RTTI, 命名空间(namespace), bool, 关键字mutable, 关键字explicit, enums作为重载函数的自变量所引发的类型晋升转换, 在类中为const static成员变量设定初值.</li></ul></li><li><p>STL(standard template library) — C++标准程序库中最大的组成部分. </p><ul><li>迭代器(iterators)是一种行为类似指针的对象, 针对STL 容器而定义.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基础议题-Basics&quot;&gt;&lt;a href=&quot;#一、基础议题-Basics&quot; class=&quot;headerlink&quot; title=&quot;一、基础议题(Basics)&quot;&gt;&lt;/a&gt;一、基础议题(Basics)&lt;/h2&gt;&lt;h3 id=&quot;1、仔细区别-pointers【指针】
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++提升" scheme="http://www.zzw1024.top/tags/c-%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》——读书笔记</title>
    <link href="http://www.zzw1024.top/2020/01/01/effective-c-du-shu-bi-ji/"/>
    <id>http://www.zzw1024.top/2020/01/01/effective-c-du-shu-bi-ji/</id>
    <published>2020-01-01T07:38:26.000Z</published>
    <updated>2020-01-01T07:38:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h3><ul><li>C语言</li><li>面对对象</li><li>C++模板</li><li>STL容器</li></ul><h3 id="尽量以const，enum，inline替换-define"><a href="#尽量以const，enum，inline替换-define" class="headerlink" title="尽量以const，enum，inline替换#define"></a>尽量以const，enum，inline替换#define</h3><ol><li>const的好处： <ol><li>define直接常量替换，出现编译错误不易定位(不知道常量是哪个变量)</li><li>define没有作用域，const有作用域提供了封装性</li></ol></li><li>enum的好处： <ol><li>提供了封装性</li><li>编译器肯定不会分配额外内存空间(其实const也不会)</li></ol></li><li>inline的好处： <ol><li>define宏函数容易造成误用(下面有个例子)</li></ol></li></ol><p>//define误用举例</p><pre><code>#define MAX(a, b) a &gt; b ? a : bint a = 5, b = 0;MAX(++a, b) //a++调用2次MAX(++a, b+10) //a++调用一次</code></pre><p>然而，了解宏的机制以后，我们也可以用宏实现特殊的技巧。例如：C++反射，TEST</p><h3 id="宏实现工厂模式"><a href="#宏实现工厂模式" class="headerlink" title="宏实现工厂模式"></a>宏实现工厂模式</h3><ol><li>需要一个全局的map用于存储类的信息以及创建实例的函数</li><li>需要调用全局对象的构造函数用于注册</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>register_fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CCFactory</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">NewInstance</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> map_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>class_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>it <span class="token operator">==</span> map_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span>      <span class="token keyword">return</span> it<span class="token operator">-</span><span class="token operator">></span><span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Register</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">,</span> register_fun func<span class="token punctuation">)</span><span class="token punctuation">{</span>    map_<span class="token punctuation">[</span>class_name<span class="token punctuation">]</span> <span class="token operator">=</span> func<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">static</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> register_fun<span class="token operator">></span> map_<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> register_fun<span class="token operator">></span> CCFactory<span class="token operator">::</span>map_<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Register</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Register</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">,</span> register_fun func<span class="token punctuation">)</span><span class="token punctuation">{</span>    CCFactory<span class="token operator">::</span><span class="token function">Register</span><span class="token punctuation">(</span>class_name<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> REGISTER_CLASS(class_name); \  const Register class_name_register(#class_name, []()->void *{return new class_name;});</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h3><ol><li>const定义接口，防止误用</li><li>const成员函数，代表这个成员函数承诺不会改变对象值 <ol><li>const成员只能调用const成员函数(加-fpermissive编译选项就可以了)</li><li>非const成员可以调用所有成员函数</li></ol></li></ol><p>尽量使用const来修饰函数名和参数变量名</p><p>尽量使用const来修饰类名<br><code>void function(classA  test);  //classA为自定义的类型</code></p><p>这样使用值传参的缺点：</p><ul><li>会导致自定义类型的构造函数和析构函数多次被调用，当自定义类型的构造函数和析构函数比较费时的时候，效率比较底下。</li><li>在传递派生类时容易产生对象被切割的问题。</li></ul><p>建议：<br><code>void function(const classA &amp;s);</code></p><p>优点：</p><ul><li>可以回避自定义类型的构造和析构函数的调用，不会影响效率。</li><li>不会产生对象切割问题，因为引用的底层其实就是指针，在内存中只有一份实例。</li></ul><p>原则：</p><ul><li>如果可以的话，尽量传递 const 的引用作为函数的参数。</li><li>不要将这个条款应用在内置类型上，对于内置类型(int double)，pass-by-value更适合。</li></ul><h3 id="确定对象使用前已被初始化"><a href="#确定对象使用前已被初始化" class="headerlink" title="确定对象使用前已被初始化"></a>确定对象使用前已被初始化</h3><ol><li>内置类型需要定义时初始化</li><li>最好使用初始化序列(序列顺序与声明顺序相同)，而不是在构造函数中赋值</li><li>跨编译单元定义全局对象不能确保初始化顺序 </li></ol><p>将static对象放入一个函数<br>Fuck&amp; fuck(){<br>    static Fuck f;<br>    return f;<br>}</p><h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="了解C-默默编调用了哪些函数"><a href="#了解C-默默编调用了哪些函数" class="headerlink" title="了解C++默默编调用了哪些函数"></a>了解C++默默编调用了哪些函数</h3><p>如果类中没有定义，程序却调用了，编译器会产生一些函数</p><ul><li><p>一个 default 构造函数</p></li><li><p>一个 copy 构造函数</p></li><li><p>一个 copy assignment 操作符</p></li><li><p>一个析构函数(non virtual)</p></li><li><p>如果自己构造了带参数的构造函数，编译器不会产生default构造函数</p></li><li><p>base class如果把拷贝构造函数或者赋值操作符设置为private，不会产生这两个函数</p></li><li><p>含有引用成员变量或者const成员变量不产生赋值操作符</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Fuck</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>  std<span class="token operator">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用定义后不能修改绑定对象</span>  <span class="token keyword">const</span> std<span class="token operator">::</span>string con_str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//const对象定义后不能修改</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>将默认生成的函数声明为private，或者C++ 11新特性”=delete”</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Uncopyable</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Uncopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h3><ol><li>给多态基类应该主动声明virtual析构函数</li><li>非多态基类，没有virtual函数，不要声明virtual析构函数</li></ol><h3 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h3><p>构造函数可以抛出异常，析构函数不能抛出异常。</p><p>因为析构函数有两个地方可能被调用。一是用户调用，这时抛出异常完全没问题。二是前面有异常抛出，正在清理堆栈，调用析构函数。这时如果再抛出异常，两个异常同时存在，异常处理机制只能terminate().</p><p>构造函数抛出异常，会有内存泄漏吗？</p><p>不会</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第二步，调用构造函数构造对象</span>    <span class="token keyword">new</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>T<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// placement new: 只调用T的构造函数</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 释放第一步分配的内存</span>    <span class="token keyword">throw</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 重抛异常，通知应用程序</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绝不在构造和析构过程中调用virtual函数"><a href="#绝不在构造和析构过程中调用virtual函数" class="headerlink" title="绝不在构造和析构过程中调用virtual函数"></a>绝不在构造和析构过程中调用virtual函数</h3><p>构造和析构过程中，虚表指针指向的虚表在变化。调用的是对应虚表指针指向的函数。</p><h3 id="令operator-返回一个reference-to-this"><a href="#令operator-返回一个reference-to-this" class="headerlink" title="令operator= 返回一个reference to *this"></a>令operator= 返回一个reference to *this</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x，y，z；x<span class="token operator">=</span>y<span class="token operator">=</span>z<span class="token operator">=</span><span class="token number">15</span>；同样有趣的是，赋值采用右结合律，x<span class="token operator">=</span>（y<span class="token operator">=</span>（z<span class="token operator">=</span><span class="token number">15</span>））；Widget<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span>（<span class="token keyword">const</span> Widget<span class="token operator">&amp;</span>rhs）<span class="token comment" spellcheck="true">//返回类型是个reference，</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token operator">*</span><span class="token keyword">this</span>；<span class="token operator">/</span>返回左侧对象<span class="token punctuation">}</span><span class="token operator">*</span> 在<span class="token keyword">operator</span><span class="token operator">=</span> 里处理自我赋值Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span>    ···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制对象时务忘其每一个成分"><a href="#复制对象时务忘其每一个成分" class="headerlink" title="复制对象时务忘其每一个成分"></a>复制对象时务忘其每一个成分</h3><ol><li>记得实现拷贝构造函数和赋值操作符的时候，调用base的相关函数</li><li>可以让拷贝构造函数和赋值操作符调用一个共同的函数，例如init</li></ol><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h3><ol><li>为了防止资源泄漏，请使用RAII对象，在构造函数里面获得资源，在析构函数里面释放资源</li><li>shared_ptr，unique_lock都是RAII对象</li></ol><h3 id="在资源管理类小心copy行为"><a href="#在资源管理类小心copy行为" class="headerlink" title="在资源管理类小心copy行为"></a>在资源管理类小心copy行为</h3><ul><li>常见的RAII对象copy行为 <ol><li>禁止copy</li><li>引用计数</li><li>深度复制</li><li>转移资源拥有权</li></ol></li></ul><h3 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h3><p>用户可能需要原始资源作为参数传入某个接口。有两种方式：</p><ul><li>提供显示调用接口</li><li>提供隐式转换接口(不推荐)</li></ul><h3 id="成对使用new和delete要采用相同的格式"><a href="#成对使用new和delete要采用相同的格式" class="headerlink" title="成对使用new和delete要采用相同的格式"></a>成对使用new和delete要采用相同的格式</h3><p>new和delete对应；new []和delete []对应</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//前面还分配了4个字节代表数组的个数</span><span class="token keyword">int</span> <span class="token operator">*</span>A <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前面分配了8个字节，分别代表对象的个数和Object的大小</span>Object <span class="token operator">*</span>O <span class="token operator">=</span> <span class="token keyword">new</span> Object<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="以独立的语句将newd对象置入智能指针"><a href="#以独立的语句将newd对象置入智能指针" class="headerlink" title="以独立的语句将newd对象置入智能指针"></a>以独立的语句将newd对象置入智能指针</h3><p>调用std::make_shared，而不要调用new，防止new Obeject和传入智能指针的过程产生异常<br>process(new Widget, priority);</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//其实这样也可以，独立的语句</span>shard_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">process</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="让接口容易被正确使用，不易被误用"><a href="#让接口容易被正确使用，不易被误用" class="headerlink" title="让接口容易被正确使用，不易被误用"></a>让接口容易被正确使用，不易被误用</h3><ol><li>好的接口很容易被正确使用，不容易被误用。努力达成这些性质(例如 explicit关键字)</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容</li><li>“防治误用”b包括建立新类型，限制类型上的操作，束缚对象值，以及消除用户的资源管理责任</li><li>shared_ptr支持定制deleter，需要灵活使用</li></ol><ul><li>宁以pass-by-refrence-to-const替换pass-by-value</li></ul><p>1.尽量以pass-by-reference-to-const替换pass-by-value，比较高效，并且可以避免切割问题<br>2.以上规则并不使用内置类型，以及STL迭代器，和函数对象。它们采用pass-by-value更合适(其实采用pass-by-reference-to-const也可以)<br>对象以by value的方式传递，其实际意义是由该对象的copy constructor决定的。这可能会使pass-by-value成为成本很高的动作。<br>以pass by reference，还可以避免所谓的“切割slicing问题”，又称为“upcasting问题”。详见《Thingking in C＋＋》P629<br>pass by reference是一件美妙的事情，但会导致某些复杂性。最知名的问题就是aliasing(别名问题)，见条款17。某些情况下必须pass by value。references的底层几乎都是指针完成，所以passing by reference通常意味着传递的是指针。如果有个小对象，例如一个int，那么pass by value可能比pass by reference的效率更高一些。  </p><ul><li>必须返回对象时，别妄想返回其reference</li></ul><p>1.不要返回pointer或者reference指向一个on stack对象(被析构)<br>2.不要返回pointer或者reference指向一个on heap对象(需要用户delete，我觉得必要的时候也不是不可以)<br>3.不要返回pointer或者reference指向local static对象，却需要多个这样的对象(static只能有一份)</p><ul><li>将成员变量申明为private</li></ul><p>1.切记将成员变量申明为private<br>2.protected并不比public更有封装性(用户可能继承你的base class)</p><h3 id="宁以non-member，non-friend替换member"><a href="#宁以non-member，non-friend替换member" class="headerlink" title="宁以non-member，non-friend替换member"></a>宁以non-member，non-friend替换member</h3><p>作者说多一个成员函数，就多一分破坏封装性，好像有点道理，但是我们都没有这样遵守。直接写member函数方便一些。</p><h3 id="若所有参数都需要类型转换，请为此采用non-member函数"><a href="#若所有参数都需要类型转换，请为此采用non-member函数" class="headerlink" title="若所有参数都需要类型转换，请为此采用non-member函数"></a>若所有参数都需要类型转换，请为此采用non-member函数</h3><p>如果调用member函数，就使得第一个参数的类失去一次类型转换的机会。</p><h3 id="考虑写一个不抛出异常的swap函数"><a href="#考虑写一个不抛出异常的swap函数" class="headerlink" title="考虑写一个不抛出异常的swap函数"></a>考虑写一个不抛出异常的swap函数</h3><ol><li><p>当std::swap效率不高(std::swap调用拷贝构造函数和赋值操作符，如果是深拷贝，效率不会高)，提供一个swap成员函数，并确定不会抛出异常。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token keyword">const</span> Obj<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//深拷贝}</span> Obj<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Obj<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>深拷贝<span class="token keyword">private</span><span class="token operator">:</span> OtherClass <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果提供一个member swap，也该提供一个non-member swap用来调用前者</p></li></ol><ol start="3"><li><p>调用swap时应该针对std::swap使用using声明式，然后调用swap不带任何”命名空间修饰”</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Obj<span class="token operator">&amp;</span> o1<span class="token punctuation">,</span> Obj<span class="token operator">&amp;</span> o2<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这样可以让编译器自己决定调用哪个swap，万一用户没有实现针对Obj的swap，还能调用std::swap</span> <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span> <span class="token function">swap</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>不要往std命名空间里面加东西</p></li></ol><h3 id="在constructor中尽量以initialization动作取代assignment动作"><a href="#在constructor中尽量以initialization动作取代assignment动作" class="headerlink" title="在constructor中尽量以initialization动作取代assignment动作"></a>在constructor中尽量以initialization动作取代assignment动作</h3><p>【尽量使用初始化列表来代替赋值】<br>const members和reference members只能被初始化，不能够被赋值（assigned）。这个时候，如果在构造函数中要对其初始化时必须用member initialization list。 另外，从效率方面考虑，也建议用以initialization动作取代assignment动作。<br>例外的情况：</p><ol><li>static class member不应该在构造函数中初始化。</li><li>如果有很多built-in type类型的class member要初始化，建议使用assignment，这和initialization在效率上没有什么区别，而且容易维护。</li><li>initialization list中的members初始化次序应该和其在class内的声明次序相同</li></ol><p>class members系以它们在class内的声明次序来初始化，和它们在member initialization list中出现的次序完全无关。基类的成员变量永远在继承类成员变量之前被初始化，所以如果运用了继承，你应该在member intialization lists起始处列出base class的初始设定值。</p><p>结论是：对象被初始化时，如果你希望确实掌握真正发生了什么事，请以class内的members声明次序，将各个memebers列于initialization list中。    </p><h3 id="区分member-functions，non-member-functions和friend-functions三者"><a href="#区分member-functions，non-member-functions和friend-functions三者" class="headerlink" title="区分member functions，non-member functions和friend functions三者"></a>区分member functions，non-member functions和friend functions三者</h3><p>member functions和non-member functions的区别是：member functions可以是虚函数，而non-member functions不可以。<br>在一个类中，只要能够避免friend函数，就应该尽量避免，“因为就像真实世界一样，朋友带来的麻烦常常多于其价值。”：）^_^</p><ol><li>虚拟函数必须是class members。</li><li>绝不要让operator&gt;&gt;和operator&lt;&lt;成为members。</li><li>如果non-member functions需要用到class的non-public members，让它成为class的friend functions。   </li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="尽可能延后变量定义式出现的时间"><a href="#尽可能延后变量定义式出现的时间" class="headerlink" title="尽可能延后变量定义式出现的时间"></a>尽可能延后变量定义式出现的时间</h3><p>C语言推荐在函数开始的时候定义所有变量(最开始的C语言编译器要求，现在并不需要)，C++推荐在使用对象前才定义对象</p><h3 id="尽量少做转型动作"><a href="#尽量少做转型动作" class="headerlink" title="尽量少做转型动作"></a>尽量少做转型动作</h3><ol><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。</li><li>如果转型是必要的，试着将它隐藏于某个函数后。客户可以随时调用该函数，而不需要将转型放入自己的代码。</li><li>使用C++风格的转型。</li></ol><h3 id="避免返回handles指向对象内部成分"><a href="#避免返回handles指向对象内部成分" class="headerlink" title="避免返回handles指向对象内部成分"></a>避免返回handles指向对象内部成分</h3><p>简单说，就是成员函数返回指针或者非const引用不要指向成员变量，这样会破坏封装性</p><h3 id="为“异常安全”而努力是值得的"><a href="#为“异常安全”而努力是值得的" class="headerlink" title="为“异常安全”而努力是值得的"></a>为“异常安全”而努力是值得的</h3><ul><li><p>“异常安全函数”承诺即使发生异常也不会有资源泄漏。在这个基础下，它有3个级别 </p><ol><li>基本保证：抛出异常，需要用户处理程序状态改变(自己写代码保证这个级别就行了把)</li><li>强烈保证：抛出异常，程序状态恢复到调用前</li><li>不抛异常：内置类型的操作就绝不会抛出异常</li></ol></li><li><p>“强烈保证”往往可以通过copy-and-swap实现，但是”强烈保证”并非对所有函数都具有实现意义</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//我反正从来没有这样写过</span><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>  Object <span class="token function">new_obj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  new_obj<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token function">swap</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> new_obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="透彻了解inline函数的里里外外"><a href="#透彻了解inline函数的里里外外" class="headerlink" title="透彻了解inline函数的里里外外"></a>透彻了解inline函数的里里外外</h3><p>这里插播一个C++处理定义的重要原则，一处定义原则：</p><ul><li><p>全局变量，静态数据成员，非内联函数和成员函数只能整个程序定义一次</p></li><li><p>类类型(class，struct,union)，内联函数可以每个翻译单元定义一次 </p><ol><li>template类的成员函数或者template函数，定义在头文件中，编译器可以帮忙去重</li><li>普通类的template函数，定义在头文件中，需要加inline</li></ol></li><li><p>inline应该限制在小的，频繁调用的函数上</p></li><li><p>inline只是给编译器的建议，编译器不一定执行</p></li></ul><h3 id="将文件的编译依存关系降到最低"><a href="#将文件的编译依存关系降到最低" class="headerlink" title="将文件的编译依存关系降到最低"></a>将文件的编译依存关系降到最低</h3><ol><li>支持”编译依存最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes(impl对象提供服务)和Interface classes。</li></ol><p>其实就是使用前置声明，下面有个需要注意的点</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Obj.h</span><span class="token keyword">class</span> <span class="token class-name">ObjImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>ObjImpl<span class="token operator">></span> pObjImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上面的写法会报错，因为编译器会再.h文件里面产生默认的析构函数，</span><span class="token comment" spellcheck="true">//析构函数要调用ObjImpl的析构函数，然后我们现在只有声明式，不能调用ObjImpl的实现。</span><span class="token comment" spellcheck="true">//下面的实现才是正确的</span><span class="token comment" spellcheck="true">//Obj.h</span><span class="token keyword">class</span> <span class="token class-name">ObjImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//声明</span>    <span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>ObjImpl<span class="token operator">></span> pObjImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Obj.cpp</span><span class="token comment" spellcheck="true">//现在可以看到ObjImpl的实现</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;ObjImpl></span></span>Obj<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于STL的对象不需要前置声明。</p><h2 id="继承与面对对象设计"><a href="#继承与面对对象设计" class="headerlink" title="继承与面对对象设计"></a>继承与面对对象设计</h2><h3 id="确定你的public继承塑模出is-a模型"><a href="#确定你的public继承塑模出is-a模型" class="headerlink" title="确定你的public继承塑模出is-a模型"></a>确定你的public继承塑模出is-a模型</h3><p>public继承意味着is-a。适用于base class身上的每一个函数也一定适用于derived class。</p><h3 id="避免遮掩继承而来的名称"><a href="#避免遮掩继承而来的名称" class="headerlink" title="避免遮掩继承而来的名称"></a>避免遮掩继承而来的名称</h3><p>子作用域会遮掩父作用域的名称。一般来讲，我们可以有以下几层作用域</p><ul><li>global作用域</li><li>namespace作用域 <ul><li>Base class作用域 <ul><li>Drive class作用域 <ul><li>成员函数 <ul><li>控制块作用域</li></ul></li></ul></li></ul></li><li>非成员函数作用域 <ul><li>控制块作用域</li></ul></li></ul></li></ul><p>注意：遮掩的是上一层作用域的名称，重载(不同参数)的函数也会直接遮掩</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//会遮掩f1()，子类并没有继承f1()</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Drive d<span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>可以通过<span class="token keyword">using</span>声明式或者<span class="token keyword">inline</span>转交解决这一问题<span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//using 声明式</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token operator">::</span>f1<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//inline转交</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Base<span class="token operator">::</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区分接口继承和实现继承"><a href="#区分接口继承和实现继承" class="headerlink" title="区分接口继承和实现继承"></a>区分接口继承和实现继承</h3><ol><li>纯虚函数：提供接口继承 <ol><li>Drived class必须实现纯虚函数</li><li>不能构造含有纯虚函数的类</li><li>纯虚函数可以有成员变量</li><li>可以给纯虚函数提供定义(wtf)</li></ol></li><li>虚函数：提供接口继承和默认的实现继承</li><li>非虚函数：提供了接口继承和强制的实现继承(最好不要在Drived class重新定义非虚函数)</li></ol><p>在编写自己的 class 时，你应该明白提供下面 3 种类型函数的理由</p><ul><li>pure virtual function</li><li>virtual function</li><li>no-virtual function</li></ul><p>何时提供 pure virtual function？</p><p>要求派生类只继承接口时，提供纯虚函数。【就像下单函数一样，其作用就是提供接口让你来重写】</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span>vitrual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>；何时提供 <span class="token keyword">virtual</span> function？要求派生类只继承接口和缺省实现时，提供虚函数。<span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span>vitrual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>何时提供 no-virtual function？</p><p>要求派生类只继承接口的强制实现时，提供非虚函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原则</strong></p><ul><li>纯虚函数指定接口继承。//这跟XTP中的订阅反馈函数的重载一样</li><li>虚函数指定接口和缺省实现继承。  //</li><li>非虚函数指定接口的强制实现继承。</li><li>接口继承和实现继承不同。</li></ul><h3 id="考虑virtual函数以外的选择"><a href="#考虑virtual函数以外的选择" class="headerlink" title="考虑virtual函数以外的选择"></a>考虑virtual函数以外的选择</h3><pre class="line-numbers language-cpp"><code class="language-cpp">non<span class="token operator">-</span><span class="token keyword">virtual</span> interface：提供非虚接口<span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优点：</strong></p><ul><li>可以在调用虚函数的前后，做一些准备工作(抽出一段重复代码)</li><li>提供良好的ABI兼容性</li></ul><h3 id="聊一聊ABI兼容性"><a href="#聊一聊ABI兼容性" class="headerlink" title="聊一聊ABI兼容性"></a>聊一聊ABI兼容性</h3><p>我们知道，程序库的优势之一是库版本升级，只要保证借口的一致性，用户不用修改任何代码。<br>一般一个设计完好的程序库都会提供一份C语言接口，为什么呢，我们来看看C++ ABI有哪些脆弱性。</p><ul><li>虚函数的调用方式，通常是 vptr/vtbl 加偏移量调用</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Object.h</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>···    <span class="token keyword">virtual</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第3个虚函数</span>···<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用户代码</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Object <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> Object<span class="token punctuation">;</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//编译器：vptr[3]()</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//如果加了虚函数，用户代码根据偏移量找到的是newfun函数</span><span class="token comment" spellcheck="true">//Object.h</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>···    <span class="token keyword">virtual</span> <span class="token function">newfun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第3个虚函数</span>    <span class="token keyword">virtual</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第4个虚函数</span>···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>name mangling 名字粉碎实现重载</li></ul><p>C++没有为name mangling制定标准。例如void fun(int)，有的编译器定为fun_int_，有的编译器指定为fun%int%。<br>因此，C++接口的库要求用户必须和自己使用同样的编译器(这个要求好过分)</p><ul><li>其实C语言接口也不完美</li></ul><p>例如struct和class。编译阶段，编译器将struct或class的对象对成员的访问通过偏移量来实现</p><h3 id="使用std-fun提供回调"><a href="#使用std-fun提供回调" class="headerlink" title="使用std::fun提供回调"></a>使用std::fun提供回调</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> doInterface<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="古典策略模式"><a href="#古典策略模式" class="headerlink" title="古典策略模式"></a>古典策略模式</h3><p>用另外一个继承体系替代</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        p<span class="token operator">-</span><span class="token operator">></span><span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    BaseInterface <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BaseInterface</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绝不重新定义继承而来的non-virtual函数"><a href="#绝不重新定义继承而来的non-virtual函数" class="headerlink" title="绝不重新定义继承而来的non-virtual函数"></a>绝不重新定义继承而来的non-virtual函数</h3><p>记住就行</p><h3 id="绝不重新定义继承而来的缺省参数值"><a href="#绝不重新定义继承而来的缺省参数值" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Drive "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                                                                 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                                                          Base <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> Drive<span class="token punctuation">;</span>                                                               b<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//   vptr[0](1)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Drive 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺省参数值是静态绑定</li><li>虚函数是动态绑定</li><li>遵守这条规定防止出错</li></ul><h3 id="通过复合塑模出has-a或者”根据某物实现出”"><a href="#通过复合塑模出has-a或者”根据某物实现出”" class="headerlink" title="通过复合塑模出has-a或者”根据某物实现出”"></a>通过复合塑模出has-a或者”根据某物实现出”</h3><ol><li>复合的意义和public完全不一样</li><li>根据某物实现出和is-a的区别：</li></ol><p>这个也是什么时候使用继承，什么时候使用复合。复合代表使用了这个对象的某些方法，但是却不想它的接口入侵。</p><h3 id="明智而审慎地使用private继承"><a href="#明智而审慎地使用private继承" class="headerlink" title="明智而审慎地使用private继承"></a>明智而审慎地使用private继承</h3><ol><li>private继承是”根据某物实现出“</li><li>唯一一个使用private继承的理由就是，可以使用空白基类优化技术，节约内存空间</li></ol><h3 id="C-对空类的处理"><a href="#C-对空类的处理" class="headerlink" title="C++对空类的处理"></a>C++对空类的处理</h3><p>C++ 设计者在设计这门语言要求所有的对象必须要有不同的地址(C语言没有这个要求)。C++编译器的实现方式是给让空类占据一个字节。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//8个字节</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    Base b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4个字节</span>classObject <span class="token operator">:</span> <span class="token keyword">private</span> Base<span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="明智而审慎地使用多重继承"><a href="#明智而审慎地使用多重继承" class="headerlink" title="明智而审慎地使用多重继承"></a>明智而审慎地使用多重继承</h3><p>首先我们来了解一下多重继承的内存布局。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//包含A对象</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B对象</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,C对象</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,A,B,C,D对象</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span><span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C<span class="token punctuation">{</span><span class="token punctuation">}</span>由于菱形继承，基类被构造了两次。其实，C<span class="token operator">++</span>也提供了针对菱形继承的解决方案的<span class="token comment" spellcheck="true">//包含A对象</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B对象</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,C对象</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B,C,D对象</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span><span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C<span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用虚继承，B,C对象里面会产生一个指针指向唯一一份A对象。这样付出的代价是必须再运行期根据这个指针的偏移量寻找A对象。</p><p>多重继承唯一的那么一点点用就是一个Base class提供public继承，另一个Base class提供private继承。(还是没什么用啊，干嘛不适用复合)</p><h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="了解隐式接口和编译期多态"><a href="#了解隐式接口和编译期多态" class="headerlink" title="了解隐式接口和编译期多态"></a>了解隐式接口和编译期多态</h3><ol><li>接口：强制用户实现某些函数</li><li>多态：相同的函数名，却有不同的实现</li><li>继承和模板都支持接口和多态</li><li>对继承而言，接口是显式的，以函数为中心，多态发生在运行期；</li><li>对模板而言，接口是隐式的，多态表现在template具象化和函数重载<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//这里接口要求T必须实现operator ></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T <span class="token function">max</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="了解typename的双重意义"><a href="#了解typename的双重意义" class="headerlink" title="了解typename的双重意义"></a>了解typename的双重意义</h3><ol><li>声明template参数时，前缀关键字class和typename可以互换</li><li>使用typename表明嵌套类型(防止产生歧义)</li></ol><p><strong>第一层：</strong>作为类模板的参数时，与 class 功能相同。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyTYpe</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个定义完全相同。</p><p><strong>第二层：</strong> typename 可以让模板里面定义嵌套从属名称的类型变成有效的类型，因为 C++ 的解析器在模板中遇到嵌套从属类型时，默认认为它是无效的类型。</p><p>例如：无效的嵌套从属类型</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>        T<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要认为指定它为有效的嵌套从属类型</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">typename</span> T<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况 当你想在 template 中指定一个有效的嵌套从属类型名称，只需要在嵌套从属类型前面加上 typename 关键字即可。<br><strong>例外</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">*</span> 不得在 base <span class="token keyword">class</span> <span class="token class-name">list</span> 中使用 <span class="token keyword">typename</span><span class="token comment" spellcheck="true">/* 错误用法 */</span><span class="token keyword">class</span> <span class="token class-name">Deriver</span> <span class="token operator">:</span> <span class="token keyword">public</span> <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>MyType<span class="token punctuation">;</span><span class="token operator">*</span> 不得在 member initialization list 中使用 <span class="token keyword">typename</span><span class="token keyword">class</span> <span class="token class-name">Deriver</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>MyType<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment" spellcheck="true">/* 错误用法 */</span>  <span class="token keyword">explicit</span> <span class="token function">Deriver</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">MyType</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原则</strong></p><ul><li><p>class 和 typename 在声明模板参数时作用相同。</p></li><li><p>使用 typename 标识嵌套从属类型，但是不得在 base class list 和 member initialization list 中使用。</p></li></ul><h3 id="学习处理模板化基类内的名称"><a href="#学习处理模板化基类内的名称" class="headerlink" title="学习处理模板化基类内的名称"></a>学习处理模板化基类内的名称</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>                                                                        <span class="token keyword">public</span><span class="token operator">:</span>                                                                              <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>                                                             <span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>                                                    <span class="token keyword">public</span><span class="token operator">:</span>                                                                            <span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span><span class="token punctuation">{</span>                                                            <span class="token comment" spellcheck="true">//error 编译器不知道基类有print函数</span>    <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解决方案</span><span class="token comment" spellcheck="true">//this->print();</span><span class="token comment" spellcheck="true">//using Base&lt;T>::print</span><span class="token comment" spellcheck="true">//base&lt;T>::print直接调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将参数无关代码抽离template"><a href="#将参数无关代码抽离template" class="headerlink" title="将参数无关代码抽离template"></a>将参数无关代码抽离template</h3><ol><li>非类型模板参数造成的代码膨胀：以函数参数或者成员变量替换</li><li>类型模板参数造成的代码膨胀：特化它们，让含义相近的类型模板参数使用同一份底层代码。例如int，long, const int</li></ol><h3 id="运用成员函数模版接收所有兼容类型"><a href="#运用成员函数模版接收所有兼容类型" class="headerlink" title="运用成员函数模版接收所有兼容类型"></a>运用成员函数模版接收所有兼容类型</h3><p>我们来考虑一下智能指针的拷贝构造函数和赋值操作符怎么实现。它需要子类的智能指针能够隐式转型为父类智能指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//拷贝构造函数，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//赋值操作符，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//声明正常的拷贝构造函数</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span>；    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    T <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用成员函数模版生成“可接受所有兼容类型”的函数</li><li>即使有了“泛化拷贝构造函数”和“泛化的赋值操作符”，仍然需要声明正常的拷贝构造函数和赋值操作符</li><li>在一个类模版内，template名称可被用来作为作为“template和其参数”的简略表达式</li></ul><h3 id="所有参数需要类型转换的时候请为模版定义非成员函数"><a href="#所有参数需要类型转换的时候请为模版定义非成员函数" class="headerlink" title="所有参数需要类型转换的时候请为模版定义非成员函数"></a>所有参数需要类型转换的时候请为模版定义非成员函数</h3><ol><li>当我们编写一个模版类，某个相关函数都需要类型转换，需要把这个函数定义为非成员函数</li><li>但是模版的类型推到遇见了问题，需要把这个函数声明为友元函数帮助推导</li><li>模版函数只有声明编译器不会帮忙具现化，所以我们需要实现的是友元模版函数<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">{</span> … <span class="token keyword">friend</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">Rational</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">GetNumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">.</span><span class="token function">GetNumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         a<span class="token punctuation">.</span><span class="token function">GetDenominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">.</span><span class="token function">GetDenominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> …<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="请使用traits-classes表现类型信息"><a href="#请使用traits-classes表现类型信息" class="headerlink" title="请使用traits classes表现类型信息"></a>请使用traits classes表现类型信息</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">ccSizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> type_traits<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>size<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>traits采用类模版和特化的方式，为不同的类型提供了相同的类型抽象(都由size)</li><li>为某些类型提供编译期测试，例如is_fundamental(是否为内置类型)</li></ul><h2 id="模版元编程"><a href="#模版元编程" class="headerlink" title="模版元编程"></a>模版元编程</h2><p>本质上就是函数式编程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//上楼梯，每次上一步或者两步，有多少种</span><span class="token keyword">int</span> <span class="token function">climb</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//元编程，采用类模版</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>n <span class="token operator">+</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-2</span><span class="token operator">></span><span class="token operator">::</span>n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>C++元编程可以将计算转移到编译期，执行速度迅速(缺陷？)</li></ul><h2 id="函数调用的栈结构："><a href="#函数调用的栈结构：" class="headerlink" title="函数调用的栈结构："></a>函数调用的栈结构：</h2><p>当编译器为函数调用生成代码时，首先将参数从右至左压栈，然后是函数返回的地址（Return Address）压栈，同时在函数内部，生成代码来将堆栈指针移动（向上或向下，这要视机器而定），为函数的本地变量提供存储空间。当函数调用完毕，栈指针将移动到函数（Return Address）的位置，这样函数的本地变量出栈。那么函数的返回值（尤其是一个自定义的类型）存放在什么地方？答案是将函数的返回值作为一个参数压栈，直接将返回值的信息拷贝至该参数中。这个答案没有解决所有的问题，但它效率很高。</p><p>下面是一个函数调用的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> f（<span class="token keyword">int</span> x，<span class="token keyword">char</span> c）；<span class="token keyword">int</span> g＝f（a，b）；看一下它对应的汇编代码：push b；push a；call f（）；add sp，<span class="token number">4</span>；mov g，<span class="token keyword">register</span> a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先是两个参数压栈，然后调用函数，完了将参数出栈，将返回值放在寄存器中（因为int是built-in type），传递给返回值g。这与上面讲的函数调用的过程稍有不同。插一句：前段时间碰到很多次stack overflow的错误，搞死我了。但是当我理解了函数调用背后的故事后，stack overflow的问题终于暂时解决了。</p><p>何为copy constructor？</p><p>当需要从一个已存在的对象创建另一个对象时，会调用copy constructor。当然，我们也可以阻止这样的行为。忠告中会讲到。<br>看下面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//copy constructor</span><span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//assignment operator</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">char</span> <span class="token operator">*</span>m_data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果缺少了copy constructor和assignment operator，当进行复制时会进行bitcopy，也就是按位进行拷贝。试想如果上面的类中没有copy constructor和assignment operator，调用如下语句时的问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">String a（“hello”）；<span class="token comment" spellcheck="true">//m_data指向字符串“hello”</span>String b（“World”）；<span class="token comment" spellcheck="true">//m_data指向字符串“world”</span>b＝a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样，经过bitcopy，a和b中的m_data都指向“hello”，“world”没人管了，Memory Leak！！！而且，当a或b中的一个调用了析构函数后，“hello”所在的内存将被释放，这样另一个中的指针指向了一片非法内存！！！</p><p>忠告：如果class的成员变量中含有任何指针，请为这个类写copy constructor和assignment operator。但是你如果确信你的class不会执行copy和assignment动作，这时候写copy constructor和assignment operator会觉得有点得不偿失，这时候将copy-construction（No definition）声明为private，将阻止使用值传递方式(pass an object of your class by value)。呵呵，我知道这个时候你的头在游泳了。</p><h2 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h2><h3 id="了解new-handler的行为"><a href="#了解new-handler的行为" class="headerlink" title="了解new-handler的行为"></a>了解new-handler的行为</h3><p>new和malloc对比：</p><ul><li>new构造对象，malloc不会</li><li>new分配不出内存会抛异常，malloc返回NULL</li><li>new分配不出内存可以调用用户设置的new-handler，malloc没有<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> std<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>new_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回旧的handler</span>  new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以为每个类设置专属new handler</li></ul><h3 id="了解new和delete合理的替换时机"><a href="#了解new和delete合理的替换时机" class="headerlink" title="了解new和delete合理的替换时机"></a>了解new和delete合理的替换时机</h3><p>C++中对象的构造和析构经历了都两个阶段</p><ul><li>operator new, operator delete：分配和释放内存</li><li>调用构造函数，调用析构函数</li></ul><p>替换new和delete的理由，就是需要收集分配内存的资源信息</p><h3 id="编写符合常规的new和delete"><a href="#编写符合常规的new和delete" class="headerlink" title="编写符合常规的new和delete"></a>编写符合常规的new和delete</h3><ol><li>operator new应该内含一个无穷循环尝试分配内存，如果无法满足，就调用new-handler。class版本要处理“比正确大小更大的(错误)申请”</li><li>operator deleter应该处理Null。classz专属版本还要处理“比正确大小更小的(错误)申请”</li></ol><h3 id="写了operator-new也要写相应的operator-delete"><a href="#写了operator-new也要写相应的operator-delete" class="headerlink" title="写了operator new也要写相应的operator delete"></a>写了operator new也要写相应的operator delete</h3><p>我们知道，new一个对象要经历两步。如果在调用构造函数失败，编译器会寻找一个“带相同额外参数”的operator delete，否则就不调用，造成资源泄漏</p><p>我觉得这个条款讲的不是太通俗，所以我决定来个“俗”点的：<br>重载new和delete时必须要做到的，这里的重载包括（参见《Thinking in C++》）：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Overloading global <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>Overloading <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span> fro a <span class="token keyword">class</span><span class="token punctuation">;</span>Overloading <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span> <span class="token keyword">for</span> arrays。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不过现在有了这练习上乘内功的口诀，就不怕走火入魔了。</p><p>口诀：</p><ol><li>正确的返回值</li><li>内存不足，调用错误处理函数</li><li>不索求任何内存时的调用</li><li>避免不经意遮掩了“正常”形式的new(见条款9)</li></ol><h3 id="问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？"><a href="#问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？" class="headerlink" title="问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？"></a>问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？</h3><p>解决：</p><ol><li><p>祭出inline函数，搞定！</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span><span class="token keyword">public</span>：<span class="token keyword">void</span> f（）；<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">,</span> new_handler p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//我们重载，为了区别，则多添加一个参数</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这是系统自己的</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为自己重载new添加的额外参数添加默认参数值，一样搞定！</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span><span class="token keyword">public</span>：<span class="token keyword">void</span> f（）；<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">,</span> new_handler p＝<span class="token number">0</span>）<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="绝不重新定义继承而来的缺省参数值-1"><a href="#绝不重新定义继承而来的缺省参数值-1" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Drive "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                                                                 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                                                          Base <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> Drive<span class="token punctuation">;</span>                                                               b<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//   vptr[0](1)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Drive 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺省参数值是静态绑定</li><li>虚函数是动态绑定</li><li>遵守这条规定防止出错</li></ul><h3 id="运用成员函数模版接收所有兼容类型-1"><a href="#运用成员函数模版接收所有兼容类型-1" class="headerlink" title="运用成员函数模版接收所有兼容类型"></a>运用成员函数模版接收所有兼容类型</h3><p>我们来考虑一下智能指针的拷贝构造函数和赋值操作符怎么实现。它需要子类的智能指针能够隐式转型为父类智能指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//拷贝构造函数，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//赋值操作符，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//声明正常的拷贝构造函数</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span>；    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    T <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用成员函数模版生成“可接受所有兼容类型”的函数</li><li>即使有了“泛化拷贝构造函数”和“泛化的赋值操作符”，仍然需要声明正常的拷贝构造函数和赋值操作符</li><li>在一个类模版内，template名称可被用来作为作为“template和其参数”的简略表达式</li></ul><h2 id="模版元编程-1"><a href="#模版元编程-1" class="headerlink" title="模版元编程"></a>模版元编程</h2><p>本质上就是函数式编程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//上楼梯，每次上一步或者两步，有多少种</span><span class="token keyword">int</span> <span class="token function">climb</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//元编程，采用类模版</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>n <span class="token operator">+</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-2</span><span class="token operator">></span><span class="token operator">::</span>n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++元编程可以将计算转移到编译期，执行速度迅速(缺陷？)</p><h2 id="STL使用小细节"><a href="#STL使用小细节" class="headerlink" title="STL使用小细节"></a>STL使用小细节</h2><h3 id="删除连续容器-vector-deque-string-的元素"><a href="#删除连续容器-vector-deque-string-的元素" class="headerlink" title="删除连续容器(vector,deque,string)的元素"></a>删除连续容器(vector,deque,string)的元素</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 当c是vector、string，删除value</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除</span><span class="token keyword">bool</span> <span class="token function">assertFun</span><span class="token punctuation">(</span>valuetype<span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove_if</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> assertFun<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 有时候我们不得不遍历去完成，并删除</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除list中某个元素"><a href="#删除list中某个元素" class="headerlink" title="删除list中某个元素"></a>删除list中某个元素</h3><pre class="line-numbers language-cpp"><code class="language-cpp">c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除    </span>c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>assertFun<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span> 删除关联容器<span class="token punctuation">(</span>set<span class="token punctuation">,</span>map<span class="token punctuation">)</span>中某个元素c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;让自己习惯C&quot;&gt;&lt;a href=&quot;#让自己习惯C&quot; class=&quot;headerlink&quot; title=&quot;让自己习惯C++&quot;&gt;&lt;/a&gt;让自己习惯C++&lt;/h2&gt;&lt;h3 id=&quot;视C-为一个语言联邦&quot;&gt;&lt;a href=&quot;#视C-为一个语言联邦&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++提升" scheme="http://www.zzw1024.top/tags/c-%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>软件记录</title>
    <link href="http://www.zzw1024.top/2020/01/01/ruan-jian-ji-lu/"/>
    <id>http://www.zzw1024.top/2020/01/01/ruan-jian-ji-lu/</id>
    <published>2020-01-01T07:37:38.000Z</published>
    <updated>2020-01-01T07:37:38.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>用来记录我喜爱的软件应用，仅限window用户</p><hr><hr><p><strong>所有软件直接百度至官网或者xxx贴中下载，因为链接总会死，所以此处不给附上链接</strong></p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ol><li><p><a href="https://www.google.com/intl/zh-CN/chrome/" target="_blank" rel="noopener">Goole Chrome</a><br> 你们的最爱</p></li><li><p><a href="https://browser.360.cn/ee/" target="_blank" rel="noopener">360极速浏览器</a><br> 我的最爱</p></li></ol><h3 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h3><ol><li><p><a href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener">Visual Studio</a><br> 社区版免费，支持各类语言，C的爹</p></li><li><p><a href="https://ww2.mathworks.cn/products/matlab.html" target="_blank" rel="noopener">MATLAB</a><br> 数据分析</p></li><li><p><a href="https://www.anaconda.com" target="_blank" rel="noopener">Anaconda</a><br> 机器学习、爬虫</p></li><li><p><a href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">PyCharm</a><br> python的爹</p></li><li><p><a href="https://www.netsarang.com/zh/xshell/" target="_blank" rel="noopener">Xshell&amp;shell家族</a><br> linux服务器远程必备</p></li><li><p><a href="https://www.qt.io/download" target="_blank" rel="noopener">QT</a><br> 界面开发</p></li><li><p><a href="https://git-scm.com" target="_blank" rel="noopener">git</a><br> 仓库备份</p></li><li><p><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">VMware Workstation</a><br> 虚拟机</p></li><li><p><a href="https://cmake.org" target="_blank" rel="noopener">Cmake</a><br> C++项目不可少</p></li><li><p><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">sublime</a><br>代码编辑神器，我离不开了</p></li><li><p><a href="https://notepad-plus-plus.org/downloads/" target="_blank" rel="noopener">Notepad++</a><br>代码编辑器，界面风格巨丑</p></li><li><p><a href="https://www.ultraedit.com/#" target="_blank" rel="noopener">Ultra家族</a><br>代码对比，编辑，文件传输，泽家族都干</p></li></ol><h3 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h3><ol><li><p><a href="https://calibre-ebook.com" target="_blank" rel="noopener">calibre</a><br> 各类电子书的阅读神器</p></li><li><p><a href="https://www.office.com" target="_blank" rel="noopener">office</a><br> 呵呵🙂</p></li><li><p><a href="https://www.wps.cn" target="_blank" rel="noopener">WPS</a><br> 国产的？！真香😄</p></li><li><p><a href="https://products.office.com/zh-cn/visio/" target="_blank" rel="noopener">visio</a><br> 专业流程图，不要安装与office用一版本，会失败</p></li><li><p><a href="http://www.ctex.org/CTeXDownload" target="_blank" rel="noopener">LaTex</a><br> 就是LaTex，著名的论文排版神器</p></li></ol><h3 id="社交应用"><a href="#社交应用" class="headerlink" title="社交应用"></a>社交应用</h3><ol><li><p><a href="https://tim.qq.com/" target="_blank" rel="noopener">TIM</a><br> 替代QQ</p></li><li><p><a href="https://weixin.qq.com/" target="_blank" rel="noopener">微信</a><br> 你不用？！</p></li></ol><h3 id="下载神器"><a href="#下载神器" class="headerlink" title="下载神器"></a>下载神器</h3><ol><li><p><a href="https://pan.baidu.com" target="_blank" rel="noopener">百度网盘</a><br> 不是神器，渣渣，真香！</p></li><li><p><a href="https://www.xunlei.com" target="_blank" rel="noopener">迅雷</a><br> 无会员比死</p></li><li><p><a href="http://pandownload.com" target="_blank" rel="noopener">PanDownload</a><br> 希望崛起，貌似死了</p></li><li><p><a href="http://enfi.cloud" target="_blank" rel="noopener">ENFI下载器</a><br> 这是我唯一舍得花钱的网盘下载器</p></li><li><p><a href="https://www.apowersoft.cn/video-download-capture" target="_blank" rel="noopener">Apowersoft视频下载王</a><br> B站视频可下载</p></li></ol><h3 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h3><ol><li><p><a href="https://yasuo.360.cn" target="_blank" rel="noopener">360压缩</a><br> 速度不是盖的</p></li><li><p><a href="https://www.teamviewer.cn/cn/" target="_blank" rel="noopener">TeamView</a><br> 远程必备，安装时记得选择个人使用</p></li><li><p><a href="https://products.office.com/en-us/onenote/digital-note-taking-app" target="_blank" rel="noopener">OneNote</a><br> 个人认为最强大的笔记软件</p></li><li><p><a href="https://onedrive.live.com/about/en-US/" target="_blank" rel="noopener">OneDrive</a><br> 为了不让你的OneNote丢失，你必须后台一直开着它    </p></li><li><p><a href="https://daumpotplayer.com/download/" target="_blank" rel="noopener">PotPlayer</a><br> 视频播放神器，还有视频源哦</p></li></ol><h3 id="简直神器"><a href="#简直神器" class="headerlink" title="简直神器"></a>简直神器</h3><ol><li><p><a href="http://www.bingdian001.com" target="_blank" rel="noopener">fish</a><br> 百度文库的克星</p></li><li><p><a href="https://www.onlinedown.net/soft/1225142.htm" target="_blank" rel="noopener">DesktopNotes</a><br> 桌面便签必备</p></li><li><p><a href="https://justgetflux.com" target="_blank" rel="noopener">f.lux</a><br> 屏幕护眼</p></li><li><p><a href="https://tianruoocr.cn" target="_blank" rel="noopener">天若OCR</a><br> 截图文字识别神器</p></li><li><p><a href="https://zh.snipaste.com" target="_blank" rel="noopener">Snipaste</a><br> 一键截图，我的爱</p></li><li><p><a href="https://www.faststone.org/FSCaptureDetail.htm" target="_blank" rel="noopener">FSCapture</a><br> 长屏截图</p></li><li><p><a href="http://www.mathtype.cn" target="_blank" rel="noopener">Math Type</a><br> 公式编辑器</p></li><li><p><a href="https://www.pcworld.com/article/3202314/microsoft-onenote-add-ins-and-tools.html" target="_blank" rel="noopener">notegem2016</a><br> 配合OneNote笔记的一个神助攻</p></li><li><p><a href="https://download.cnet.com/TakeColor/3000-2192_4-10387506.html" target="_blank" rel="noopener">TakeColor</a><br> 颜色获取神器</p></li></ol><h3 id="软件下载网站"><a href="#软件下载网站" class="headerlink" title="软件下载网站"></a>软件下载网站</h3><ol><li><p><a href="https://apkpure.com/cn/search?q=APkpure&t=app" target="_blank" rel="noopener">apkpure</a><br> 需翻墙，良心的GoolePlay</p></li><li><p><a href="https://play.google.com/store?hl=zh-CN&tab=w81" target="_blank" rel="noopener">GoolePlay</a><br> 你知道的</p></li><li><p><a href="http://yx.bsh.me" target="_blank" rel="noopener">异星空间</a><br> 软件下载的好地址</p></li><li><p><a href="http://sj.qq.com/index.html" target="_blank" rel="noopener">应用宝</a><br> 腾讯的</p></li><li><p><a href="https://pc.qq.com" target="_blank" rel="noopener">腾讯软件中心</a><br> 腾讯的PC版</p></li><li><p><a href="http://www.carrotchou.blog" target="_blank" rel="noopener">胡萝卜周</a><br> 反正我粉了</p></li><li><p><a href="http://www.zdfans.com" target="_blank" rel="noopener">ZD423</a><br> 我是铁粉</p></li><li><p><a href="https://mirrors.tuna.tsinghua.edu.cn" target="_blank" rel="noopener">清华镜像</a><br> 很强的镜像网站</p></li><li><p><a href="https://www.coolapk.com" target="_blank" rel="noopener">酷安</a><br> 什么都别说，我手机安的就是酷安，所有软件都来自于它</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;用来记录我喜爱的软件应用，仅限window用户&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;所有软件直接百度至官网或者xxx贴中下载，因为链接总会死，所以此处不给附上链接&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;浏览器&quot;&gt;&lt;a href=&quot;#浏览器&quot; cl
      
    
    </summary>
    
    
      <category term="软件神器" scheme="http://www.zzw1024.top/categories/%E8%BD%AF%E4%BB%B6%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="安装" scheme="http://www.zzw1024.top/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——004-Median-of-Two-Sorted-Arrays</title>
    <link href="http://www.zzw1024.top/2019/12/30/leetcode-004-median-of-two-sorted-arrays/"/>
    <id>http://www.zzw1024.top/2019/12/30/leetcode-004-median-of-two-sorted-arrays/</id>
    <published>2019-12-30T15:07:07.000Z</published>
    <updated>2019-12-30T15:07:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p><strong>Example 1:</strong></p><pre><code>nums1 = [1, 3]   nums2 = [2]   </code></pre><pre><code>The median is 2.0   </code></pre><p><strong>Example 2:</strong></p><pre><code>nums1 = [1, 2]   nums2 = [3, 4]   </code></pre><pre><code>The median is (2 + 3)/2 = 2.5</code></pre><p><strong>solution</strong><br>当一看到这道题的算法复杂度的限制为O(log(m+1)),<br>就可以排除将两个数组排序后再寻找中位数。<br>感觉题目又在提示我们使用二分法，但感觉此处没法使用二分法。  </p><p>我的方法就是一边排序一遍判断是否是位，即使用k来对数组A，B进行排序，<br>当k==（A+B）/2【数组大小】时，即可直接返回中位数，唯一值得注意的就是数组大小为奇数还是偶数的问题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>sum <span class="token operator">+</span><span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> sum <span class="token operator">+</span><span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReturn</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReturn</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReturn</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">isReturn</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">&amp;</span>sum<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> mid <span class="token operator">&amp;&amp;</span> s <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>借鉴</strong><br>借鉴一下<a href="https://github.com/grandyang/leetcode/issues/4" target="_blank" rel="noopener">大神</a>的思路,<br>使用递归求解，但大致思路和我一样。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">findKth</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums2<span class="token punctuation">[</span>j <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums1<span class="token punctuation">[</span>i <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> midVal1 <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums1<span class="token punctuation">[</span>i <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> midVal2 <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums2<span class="token punctuation">[</span>j <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>midVal1 <span class="token operator">&lt;</span> midVal2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> i <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">-</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> i<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> j <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k <span class="token operator">-</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;/p&gt;
&lt;p&gt;Find the median of t
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="中位数" scheme="http://www.zzw1024.top/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Chrome插件推荐</title>
    <link href="http://www.zzw1024.top/2019/12/30/chrome-cha-jian-tui-jian/"/>
    <id>http://www.zzw1024.top/2019/12/30/chrome-cha-jian-tui-jian/</id>
    <published>2019-12-30T11:42:46.000Z</published>
    <updated>2019-12-30T11:42:46.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>个人感觉极速360杠杆的，Chrome能的它也能，Chrome不能的它也能！！！</p><hr><hr><p>所有插件百度名字官网，或者到对应的浏览器扩展商城，或者Chrome应用商店下载；<br>下载解压后可以直接拖拽进浏览器即可。</p><hr><h3 id="插件神库"><a href="#插件神库" class="headerlink" title="插件神库"></a>插件神库</h3><p>找插件的必备之地</p><ol><li><p><a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">chrome网上应用商店</a><br> 墙的了就使,墙不了看下面</p></li><li><p><a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a><br> 油猴脚本插件的必选之地</p></li></ol><h3 id="万能插件"><a href="#万能插件" class="headerlink" title="万能插件"></a>万能插件</h3><ol><li><p><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">油猴Tampermonkey</a></p><p> 以下插件请到<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a>中下载</p><ul><li>CNKI中国知网PDF全文下载（特制版）<br>  知网论文下载必备</li><li>【全新升级】百度文库原文档免费下载<br>  百度文库下载必备</li><li>智能划词翻译<br>  网页翻译神器</li><li>网盘自动填写密码【威力加强版】<br>  度盘分享免密</li></ul></li></ol><h3 id="安全插件"><a href="#安全插件" class="headerlink" title="安全插件"></a>安全插件</h3><ol><li>360安全网银<br> 钓鱼网站必死</li></ol><h3 id="广告拦截"><a href="#广告拦截" class="headerlink" title="广告拦截"></a>广告拦截</h3><ol><li>广告终结者<br> 个人感觉还可以</li></ol><h3 id="下载神器"><a href="#下载神器" class="headerlink" title="下载神器"></a>下载神器</h3><ol><li>GitZip for github<br> github项目不再需要全部下载，直接双击相应文件名后的空白后，出现✔选中成功；<br> 选中完毕后，点击右下脚的大箭头即可下载</li></ol><h3 id="浏览器辅助"><a href="#浏览器辅助" class="headerlink" title="浏览器辅助"></a>浏览器辅助</h3><ol><li><p>smartUp手势<br> 这是chrome的短板，我弃之而去的理由</p></li><li><p>Stylish<br> 绚丽的goole主页</p></li></ol><h3 id="万能梯"><a href="#万能梯" class="headerlink" title="万能梯"></a>万能梯</h3><ol><li><p>Ghelper<br> 买了会员，你懂的，无限制，不买会员，goole随便玩</p></li><li><p>Hoxx VPN Proxy<br> 免费梯，速度还可以，推荐选择港地</p></li><li><p>skyZIP Proxy<br> 貌似死了</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;个人感觉极速360杠杆的，Chrome能的它也能，Chrome不能的它也能！！！&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;所有插件百度名字官网，或者到对应的浏览器扩展商城，或者Chrome应用商店下载；&lt;br&gt;下载解压后可以直接拖拽进浏览器即可。&lt;/p&gt;
&lt;hr&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="软件神器" scheme="http://www.zzw1024.top/categories/%E8%BD%AF%E4%BB%B6%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="插件" scheme="http://www.zzw1024.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>vim的配置</title>
    <link href="http://www.zzw1024.top/2019/12/24/vim-de-pei-zhi/"/>
    <id>http://www.zzw1024.top/2019/12/24/vim-de-pei-zhi/</id>
    <published>2019-12-24T02:08:33.000Z</published>
    <updated>2019-12-24T02:08:33.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>set sw=4set ts=4set etset smarttabset smartindentset lbrset fo+=mBset smset selection=inclusiveset wildmenuset mousemodel=popup&quot; 这里根据自己需要的插件来设置，以下是我的配置 &quot;&quot;&quot; YouCompleteMe:语句补全插件set runtimepath+=~/.vim/bundle/YouCompleteMeautocmd InsertLeave * if pumvisible() == 0|pclose|endif &quot;离开插入模式后自动关闭预览窗口&quot;let g:ycm_collect_identifiers_from_tags_files = 1           &quot; 开启 YCM基于标签引擎let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释与字符串中的内容也用于补全let g:syntastic_ignore_files=[&quot;.*\.py$&quot;]let g:ycm_seed_identifiers_with_syntax = 1                  &quot; 语法关键字补全let g:ycm_complete_in_comments = 1let g:ycm_confirm_extra_conf = 0                            &quot; 关闭加载.ycm_extra_conf.py提示let g:ycm_key_list_select_completion = [&#39;&lt;c-n&gt;&#39;, &#39;&lt;Down&gt;&#39;]  &quot; 映射按键,没有这个会拦截掉tab, 导致其他插件的tab不能用.let g:ycm_key_list_previous_completion = [&#39;&lt;c-p&gt;&#39;, &#39;&lt;Up&gt;&#39;]let g:ycm_complete_in_comments = 1                          &quot; 在注释输入中也能补全let g:ycm_complete_in_strings = 1                           &quot; 在字符串输入中也能补全let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释和字符串中的文字也会被收入补全let g:ycm_global_ycm_extra_conf=&#39;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#39;let g:ycm_show_diagnostics_ui = 0                           &quot; 禁用语法检查inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;CR&gt;&quot;             &quot; 回车即选中当前项nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;     &quot; 跳转到定义处let g:ycm_min_num_of_chars_for_completion=2                 &quot; 从第2个键入字符就开始罗列匹配项&quot;au FileType php setlocal dict+=~/.vim/dict/php_funclist.dictau FileType css setlocal dict+=~/.vim/dict/css.dictau FileType c setlocal dict+=~/.vim/dict/c.dictau FileType cpp setlocal dict+=~/.vim/dict/cpp.dictau FileType scale setlocal dict+=~/.vim/dict/scale.dictau FileType javascript setlocal dict+=~/.vim/dict/javascript.dictau FileType html setlocal dict+=~/.vim/dict/javascript.dictau FileType html setlocal dict+=~/.vim/dict/css.dict&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 显示相关  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;syntax onset cul &quot;高亮光标所在行set cucset shortmess=atI   &quot; 启动的时候不显示那个援助乌干达儿童的提示  set go=             &quot; 不要图形按钮  &quot;color desert     &quot; 设置背景主题  color ron     &quot; 设置背景主题  &quot;color torte     &quot; 设置背景主题  &quot;set guifont=Courier_New:h10:cANSI   &quot; 设置字体  &quot;autocmd InsertLeave * se nocul  &quot; 用浅色高亮当前行  autocmd InsertEnter * se cul    &quot; 用浅色高亮当前行  set ruler           &quot; 显示标尺  set showcmd         &quot; 输入的命令显示出来，看的清楚些  &quot;set whichwrap+=&lt;,&gt;,h,l   &quot; 允许backspace和光标键跨越行边界(不建议)  set scrolloff=3     &quot; 光标移动到buffer的顶部和底部时保持3行距离  set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)}   &quot;状态行显示的内容  set laststatus=2    &quot; 启动显示状态行(1),总是显示状态行(2)  &quot;set foldenable      &quot; 允许折叠  &quot;&quot;set foldmethod=manual   &quot; 手动折叠  set nocompatible  &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限  &quot; 显示中文帮助if version &gt;= 603    set helplang=cn    set encoding=utf-8endif&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop=4&quot; 统一缩进为4set softtabstop=4set shiftwidth=4&quot; 使用空格代替制表符set expandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history=1000&quot;搜索逐字符高亮set hlsearchset incsearch&quot;语言设置set langmenu=zh_CN.UTF-8set helplang=cn&quot; 总是显示状态行set cmdheight=2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+=!&quot; 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-&quot; 字符间插入的像素行数目&quot;markdown配置au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn}   set filetype=mkdau BufRead,BufNewFile *.{go}   set filetype=goau BufRead,BufNewFile *.{js}   set filetype=javascript&quot;rkdown to HTML  nmap md :!~/.vim/markdown.pl % &gt; %.html &lt;CR&gt;&lt;CR&gt;nmap fi :!firefox %.html &amp; &lt;CR&gt;&lt;CR&gt;nmap \ \ccvmap \ \cc&quot;将tab替换为空格nmap tt :%s/\t/    /g&lt;CR&gt;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新文件标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.rb,*.java,*.py exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle()     &quot;如果文件类型为.sh文件     if &amp;filetype == &#39;sh&#39;         call setline(1,&quot;\#!/bin/bash&quot;)         call append(line(&quot;.&quot;), &quot;&quot;)     elseif &amp;filetype == &#39;python&#39;        call setline(1,&quot;#!/usr/bin/env python&quot;)        call append(line(&quot;.&quot;),&quot;# coding=utf-8&quot;)        call append(line(&quot;.&quot;)+1, &quot;&quot;)     elseif &amp;filetype == &#39;ruby&#39;        call setline(1,&quot;#!/usr/bin/env ruby&quot;)        call append(line(&quot;.&quot;),&quot;# encoding: utf-8&quot;)        call append(line(&quot;.&quot;)+1, &quot;&quot;)        &quot;    elseif &amp;filetype == &#39;mkd&#39;        &quot;        call setline(1,&quot;&lt;head&gt;&lt;meta charset=\&quot;UTF-8\&quot;&gt;&lt;/head&gt;&quot;)    else         call setline(1, &quot;/*************************************************************************&quot;)         call append(line(&quot;.&quot;), &quot;    &gt; File Name: &quot;.expand(&quot;%&quot;))         call append(line(&quot;.&quot;)+1, &quot;    &gt; Author: zzw &quot;)         call append(line(&quot;.&quot;)+2, &quot;    &gt; Mail: 819342493@qq.com&quot;)         call append(line(&quot;.&quot;)+3, &quot;    &gt; Created Time: &quot;.strftime(&quot;%c&quot;))         call append(line(&quot;.&quot;)+4, &quot; ************************************************************************/&quot;)         call append(line(&quot;.&quot;)+5, &quot;&quot;)    endif    if expand(&quot;%:e&quot;) == &#39;cpp&#39;        call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;)        call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;)        call append(line(&quot;.&quot;)+8, &quot;&quot;)    endif    if &amp;filetype == &#39;c&#39;        call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;)        call append(line(&quot;.&quot;)+7, &quot;&quot;)    endif    if expand(&quot;%:e&quot;) == &#39;h&#39;        call append(line(&quot;.&quot;)+6, &quot;#ifndef _&quot;.toupper(expand(&quot;%:r&quot;)).&quot;_H&quot;)        call append(line(&quot;.&quot;)+7, &quot;#define _&quot;.toupper(expand(&quot;%:r&quot;)).&quot;_H&quot;)        call append(line(&quot;.&quot;)+8, &quot;#endif&quot;)    endif    if &amp;filetype == &#39;java&#39;        call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%:r&quot;))        call append(line(&quot;.&quot;)+7,&quot;&quot;)    endif    &quot;新建文件后，自动定位到文件末尾endfunc autocmd BufNewFile * normal G&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;键盘命令&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;:nmap &lt;silent&gt; &lt;F9&gt; &lt;ESC&gt;:Tlist&lt;RETURN&gt;&quot; shift tab pagesmap &lt;S-Left&gt; :tabp&lt;CR&gt;map &lt;S-Right&gt; :tabn&lt;CR&gt;map! &lt;C-Z&gt; &lt;Esc&gt;zzimap! &lt;C-O&gt; &lt;C-Y&gt;,map &lt;C-A&gt; ggVG$&quot;+ymap &lt;Esc&gt;&lt;Esc&gt; :w&lt;CR&gt;map &lt;F12&gt; gg=Gmap &lt;C-w&gt; &lt;C-w&gt;wimap &lt;C-k&gt; &lt;C-y&gt;,imap &lt;C-t&gt; &lt;C-q&gt;&lt;TAB&gt;imap &lt;C-j&gt; &lt;ESC&gt;&quot; 选中状态下 Ctrl+c 复制&quot;map &lt;C-v&gt; &quot;*paimap &lt;C-v&gt; &lt;Esc&gt;&quot;*paimap &lt;C-a&gt; &lt;Esc&gt;^imap &lt;C-e&gt; &lt;Esc&gt;$vmap &lt;C-c&gt; &quot;+yset mouse=v&quot;set clipboard=unnamed&quot;去空行  nnoremap &lt;F2&gt; :g/^\s*$/d&lt;CR&gt; &quot;比较文件  nnoremap &lt;C-F2&gt; :vert diffsplit &quot;nnoremap &lt;Leader&gt;fu :CtrlPFunky&lt;Cr&gt;&quot;nnoremap &lt;C-n&gt; :CtrlPFunky&lt;Cr&gt;&quot;列出当前目录文件  map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt; :NERDTreeToggle&lt;CR&gt;&quot;打开树状文件目录  map &lt;C-F3&gt; \be  :autocmd BufRead,BufNewFile *.dot map &lt;F5&gt; :w&lt;CR&gt;:!dot -Tjpg -o %&lt;.jpg % &amp;&amp; eog %&lt;.jpg  &lt;CR&gt;&lt;CR&gt; &amp;&amp; exec &quot;redr!&quot;&quot;C，C++ 按F5编译运行map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc()    exec &quot;w&quot;    if &amp;filetype == &#39;c&#39;        exec &quot;!g++ % -o %&lt;&quot;        exec &quot;!time ./%&lt;&quot;    elseif &amp;filetype == &#39;cpp&#39;        exec &quot;!g++ % -std=c++11 -o %&lt;&quot;        exec &quot;!time ./%&lt;&quot;    elseif &amp;filetype == &#39;java&#39;         exec &quot;!javac %&quot;         exec &quot;!time java %&lt;&quot;    elseif &amp;filetype == &#39;sh&#39;        :!time bash %    elseif &amp;filetype == &#39;python&#39;        exec &quot;!time python2.7 %&quot;    elseif &amp;filetype == &#39;html&#39;        exec &quot;!firefox % &amp;&quot;    elseif &amp;filetype == &#39;go&#39;        &quot;        exec &quot;!go build %&lt;&quot;        exec &quot;!time go run %&quot;    elseif &amp;filetype == &#39;mkd&#39;        exec &quot;!~/.vim/markdown.pl % &gt; %.html &amp;&quot;        exec &quot;!firefox %.html &amp;&quot;    endifendfunc&quot;C,C++的调试map &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb()    exec &quot;w&quot;    exec &quot;!g++ % -std=c++11 -g -o %&lt;&quot;    exec &quot;!gdb ./%&lt;&quot;endfunc&quot;代码格式优化化map &lt;F6&gt; :call FormartSrc()&lt;CR&gt;&lt;CR&gt;&quot;定义FormartSrc()func FormartSrc()    exec &quot;w&quot;    if &amp;filetype == &#39;c&#39;        exec &quot;!astyle --style=ansi -a --suffix=none %&quot;    elseif &amp;filetype == &#39;cpp&#39; || &amp;filetype == &#39;hpp&#39;        exec &quot;r !astyle --style=ansi --one-line=keep-statements -a --suffix=none %&gt; /dev/null 2&gt;&amp;1&quot;    elseif &amp;filetype == &#39;perl&#39;        exec &quot;!astyle --style=gnu --suffix=none %&quot;    elseif &amp;filetype == &#39;py&#39;||&amp;filetype == &#39;python&#39;        exec &quot;r !autopep8 -i --aggressive %&quot;    elseif &amp;filetype == &#39;java&#39;        exec &quot;!astyle --style=java --suffix=none %&quot;    elseif &amp;filetype == &#39;jsp&#39;        exec &quot;!astyle --style=gnu --suffix=none %&quot;    elseif &amp;filetype == &#39;xml&#39;        exec &quot;!astyle --style=gnu --suffix=none %&quot;    else        exec &quot;normal gg=G&quot;        return    endif    exec &quot;e! %&quot;endfunc&quot;结束定义FormartSrc&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;实用设置&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 设置当文件被改动时自动载入set autoread&quot; quickfix模式autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;&quot;代码补全 set completeopt=preview,menu &quot;允许插件  filetype plugin on&quot;共享剪贴板  set clipboard=unnamed &quot;从不备份  set nobackup&quot;make 运行:set makeprg=g++\ -Wall\ \ %&quot;自动保存set autowriteset ruler                   &quot; 打开状态栏标尺set cursorline              &quot; 突出显示当前行set magic                   &quot; 设置魔术set guioptions-=T           &quot; 隐藏工具栏set guioptions-=m           &quot; 隐藏菜单栏&quot;set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&amp;fileformat}\ %{&amp;encoding}\ %c:%l/%L%)\&quot; 设置在状态行显示的信息set foldcolumn=0set foldmethod=indent set foldlevel=3 set foldenable              &quot; 开始折叠&quot; 不要使用vi的键盘模式，而是vim自己的set nocompatible&quot; 语法高亮set syntax=on&quot; 去掉输入错误的提示声音set noeb&quot; 在处理未保存或只读文件的时候，弹出确认set confirm&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop=4&quot; 统一缩进为4set softtabstop=4set shiftwidth=4&quot; 不要用空格代替制表符set noexpandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history=1000&quot;禁止生成临时文件set nobackupset noswapfile&quot;搜索忽略大小写set ignorecase&quot;搜索逐字符高亮set hlsearchset incsearch&quot;行内替换set gdefault&quot;编码设置set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936&quot;语言设置set langmenu=zh_CN.UTF-8set helplang=cn&quot; 我的状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)}set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]&quot; 总是显示状态行set laststatus=2&quot; 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+=!&quot; 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-&quot; 字符间插入的像素行数目set linespace=0&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 使回格键（backspace）正常处理indent, eol, start等set backspace=2&quot; 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0&quot; 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\ ,stl:\ ,stlnc:\&quot; 高亮显示匹配的括号set showmatch&quot; 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1&quot; 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3&quot; 为C程序提供自动缩进set smartindent&quot; 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile *  setfiletype txt&quot;自动补全:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;=ClosePair(&#39;)&#39;)&lt;CR&gt;&quot;:inoremap { {&lt;CR&gt;}&lt;ESC&gt;O&quot;:inoremap } &lt;c-r&gt;=ClosePair(&#39;}&#39;)&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;=ClosePair(&#39;]&#39;)&lt;CR&gt;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i:inoremap &#39; &#39;&#39;&lt;ESC&gt;ifunction! ClosePair(char)    if getline(&#39;.&#39;)[col(&#39;.&#39;) - 1] == a:char        return &quot;\&lt;Right&gt;&quot;    else        return a:char    endifendfunctionfiletype plugin indent on &quot;打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; CTags的设定  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;let Tlist_Sort_Type = &quot;name&quot;    &quot; 按照名称排序  let Tlist_Use_Right_Window = 1  &quot; 在右侧显示窗口  let Tlist_Compart_Format = 1    &quot; 压缩方式  let Tlist_Exist_OnlyWindow = 1  &quot; 如果只有一个buffer，kill窗口也kill掉buffer  &quot;&quot;let Tlist_File_Fold_Auto_Close = 0  &quot; 不要关闭其他文件的tags  &quot;&quot;let Tlist_Enable_Fold_Column = 0    &quot; 不要显示折叠树  &quot;let Tlist_Show_One_File=1            &quot;不同时显示多个文件的tag，只显示当前文件的&quot;设置tags  set tags=tags;  set autochdir &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;其他东东&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;默认打开Taglist let Tlist_Auto_Open=0 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; Tag list (ctags) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; let Tlist_Ctags_Cmd = &#39;/usr/local/bin/ctags&#39; let Tlist_Show_One_File = 1 &quot;不同时显示多个文件的tag，只显示当前文件的 let Tlist_File_Fold_Auto_Close = 1let Tlist_Exit_OnlyWindow = 1 &quot;如果taglist窗口是最后一个窗口，则退出vim let Tlist_Use_Right_Window = 1 &quot;在右侧窗口中显示taglist窗口&quot; minibufexpl插件的一般设置let g:miniBufExplMapWindowNavVim = 1let g:miniBufExplMapWindowNavArrows = 1let g:miniBufExplMapCTabSwitchBufs = 1let g:miniBufExplModSelTarget = 1  nmap tl :Tlist&lt;cr&gt;&quot;python补全let g:pydiction_location = &#39;~/.vim/after/complete-dict&#39;let g:pydiction_menu_height = 20let Tlist_Ctags_Cmd=&#39;/usr/local/bin/ctags&#39;let g:miniBufExplMapWindowNavVim = 1let g:miniBufExplMapWindowNavArrows = 1let g:miniBufExplMapCTabSwitchBufs = 1let g:miniBufExplModSelTarget = 1set iskeyword+=.set termencoding=utf-8set encoding=utf8set fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030autocmd FileType python set omnifunc=pythoncomplete#Complete&quot;set nocompatible               &quot; be iMproved&quot;filetype off                   &quot; required!let g:html_indent_inctags = &quot;html,body,head,tbody&quot;let g:html_indent_script1 = &quot;inc&quot;let g:html_indent_style1 = &quot;inc&quot;filetype plugin indent on     &quot; required!&quot;&quot;ctrlp设置&quot;set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.pyc,*.png,*.jpg,*.gif     &quot; MacOSX/Linuxset wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe,*.pyc,*.png,*.jpg,*.gif  &quot; Windowslet g:ctrlp_custom_ignore = &#39;\v[\/]\.(git|hg|svn)$&#39;let g:ctrlp_custom_ignore = &#39;\v\.(exe|so|dll)$&#39;let g:ctrlp_extensions = [&#39;funky&#39;]let NERDTreeIgnore=[&#39;\.pyc&#39;]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;set sw=4
set ts=4
set et
set smarttab
set smartindent
set lbr
set fo+=mB
set sm
set selection=inclusive
set wildmenu
set mousemod
      
    
    </summary>
    
    
      <category term="文档" scheme="http://www.zzw1024.top/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="vim" scheme="http://www.zzw1024.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>《STL源码剖析》——第七、八章：仿函数与接配器</title>
    <link href="http://www.zzw1024.top/2019/12/24/stl-yuan-ma-pou-xi-di-qi-ba-zhang-fang-han-shu-yu-jie-pei-qi/"/>
    <id>http://www.zzw1024.top/2019/12/24/stl-yuan-ma-pou-xi-di-qi-ba-zhang-fang-han-shu-yu-jie-pei-qi/</id>
    <published>2019-12-24T01:29:30.000Z</published>
    <updated>2019-12-24T01:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章：仿函数"><a href="#第七章：仿函数" class="headerlink" title="第七章：仿函数"></a>第七章：仿函数</h1><h2 id="7-1、仿函数（函数对象）概观"><a href="#7-1、仿函数（函数对象）概观" class="headerlink" title="7.1、仿函数（函数对象）概观"></a>7.1、仿函数（函数对象）概观</h2><p>STL仿函数的分类，若以操作数（operand）的个数划分，可分为一元和二元仿函数，若以功能划分，可分为算术运算（Arithmetic）、关系运算（Rational）、逻辑运算（Logical）三大类。任何应用程序欲使用STL内建的仿函数，都必须含人&lt; functiona1 &gt;头文件，SGI则将它们实际定义于&lt; st1_function.h &gt;文件中。以下分别描述。<br>重载 () 所以函数的对象 使用（）像函数调用是类 而不是普通的函数<br><strong>内部记录状态：</strong><br>作为类型 与模板进行配合使用  </p><ol><li>函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可内联编译，性能好。用函数指针几乎不可能</li><li>模版函数对象使函数对象具有通用性，这也是它的优势之一</li></ol><h2 id="7-2、可配接（adaptable）的关键"><a href="#7-2、可配接（adaptable）的关键" class="headerlink" title="7.2、可配接（adaptable）的关键"></a>7.2、可配接（adaptable）的关键</h2><ul><li><p>unary_function<br>unary_function用来呈现一元函数的参数型别和回返值型别。其定义非常简单：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000914459-1414387869.png" alt=""></p></li><li><p>binary_function<br>binary_function 用来呈现二元函数的第一参数型别、第二参数型别，以及回返值型别。其定义非常简单：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000925773-1298919017.png" alt=""></p></li></ul><h2 id="7-3、算术类（Arithmetic）仿函数"><a href="#7-3、算术类（Arithmetic）仿函数" class="headerlink" title="7.3、算术类（Arithmetic）仿函数"></a>7.3、算术类（Arithmetic）仿函数</h2><p>STL内建的“算术类仿函数”，支持加法、减法、乘法、除法、模数（余数，modulus）和否定（negation）运算。除了“否定”运算为一元运算，其它都是二元运算。</p><ul><li>加法：plus<T></li><li>减法：minus<T></li><li>乘法：multiplies<T></li><li>除法：divides<T></li><li>模取（modulus）：modulus<T></li><li>否定（negation）：negate<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000940335-1676139172.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000955791-618196543.png" alt=""></p><h2 id="7-4、关系运算类（Relational）仿函数"><a href="#7-4、关系运算类（Relational）仿函数" class="headerlink" title="7.4、关系运算类（Relational）仿函数"></a>7.4、关系运算类（Relational）仿函数</h2><p>STL内建的“关系运算类仿函数”支持了等于、不等于、大于、大于等于、小于、小于等于六种运算。每一个都是二元运算。</p><ul><li>等于（equality）：equal_to<T></li><li>不等于（inequality）：not_equal_tocT&gt;</li><li>大于（greater than）：greater<T></li><li>大于或等于（greater than or equal）：greater_-equal<T></li><li>小于（less than）：1ess<T></li><li>小于或等于（less than or equal）：1ess_equal<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001007466-1276806188.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001020777-765884354.png" alt=""></p><h2 id="7-5、逻辑运算类（Logical）仿函数"><a href="#7-5、逻辑运算类（Logical）仿函数" class="headerlink" title="7.5、逻辑运算类（Logical）仿函数"></a>7.5、逻辑运算类（Logical）仿函数</h2><p>STL内建的“逻辑运算类仿函数”支持了逻辑运算中的 And、or、Not三种运算，其中And和or为二元运算，Not为一元运算。</p><ul><li>逻辑运算And：1ogical_and<T></li><li>逻辑运算or：1ogical_or<T></li><li>逻辑运算Not:logical_not<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001032087-1471946754.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001043598-1146445021.png" alt=""></p><h2 id="7-6、证同（identity）、选择（select）、投射（project）"><a href="#7-6、证同（identity）、选择（select）、投射（project）" class="headerlink" title="7.6、证同（identity）、选择（select）、投射（project）"></a>7.6、证同（identity）、选择（select）、投射（project）</h2><ul><li><p>identity<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001057404-685324224.png" alt=""></p></li><li><p>select<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001110220-114459234.png" alt=""></p></li><li><p>project<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001119469-1357538208.png" alt=""></p></li></ul><h2 id="7-7、自建函数function"><a href="#7-7、自建函数function" class="headerlink" title="7.7、自建函数function"></a>7.7、自建函数function</h2><ul><li><p>包装普通函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">g_Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> g_Minus<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>包装模板函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>T <span class="token function">g_Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> g_Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>包装lambda表达式</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> g_Minus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>int main()<br>{<br>    function&lt;int(int, int)&gt; f = g_Minus;<br>    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1<br>    return 1;<br>}</p><pre><code>* 包装函数对象**非模板类型：**```cppstruct Minus{    int operator() (int i, int j)    {        return i - j;    }};int main(){    function&lt;int(int, int)&gt; f = Minus();    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1    return 1;}</code></pre><p><strong>模板类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> Minus<span class="token punctuation">{</span>    T <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>包装类静态成员函数</li><li><em>非模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>模板类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>    <span class="token keyword">static</span> T <span class="token function">Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>包装类对象成员函数</li><li><em>非模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">int</span> <span class="token function">Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Math m<span class="token punctuation">;</span>   function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token operator">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><em>模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>   T <span class="token function">Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>int main()<br>{<br>    Math m;<br>    function&lt;int(int, int)&gt; f = bind(&amp;Math::Minus<int>, &amp;m, placeholders::_1, placeholders::_2);<br>    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1<br>    return 1;<br>}</p><pre><code># 第x章：匿名函数（lambda）* 格式： [](){};</code></pre><p>[ ](int val){ cout &lt;&lt; val “”; }<br>//匿名函数  lambda表达式  <a href=""></a>{};<br>for_each(v.begin(), v.end(), [](int val) { cout &lt;&lt; val &lt;&lt; “ “; });</p><pre><code>* 捕获：需要捕获的参数放置在[ ]中！！！```[a](int b){return a+b;}```[ ]中为需要捕获的参数，一般存在与函数体中！！！* 传参放置在（）中：```cpppint a = 45;int sum = [a](int b){return a+b;};cout &lt;&lt; sum (14)&lt;&lt; endl;</code></pre><p>注意：<br>捕获参数a需自己定义，调用函数不需写明！<br>而传参需要调用函数传入进去！！！<br>( )中一般使用的是容器中的元素。   </p><pre class="line-numbers language-cpp"><code class="language-cpp">eg<span class="token operator">:</span>string ss<span class="token punctuation">;</span><span class="token keyword">float</span> f<span class="token punctuation">;</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span>m<span class="token punctuation">;</span>vecot<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span>v<span class="token punctuation">;</span><span class="token keyword">auto</span> pt<span class="token operator">=</span><span class="token function">find_if</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ss<span class="token punctuation">]</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span>ps<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> ps<span class="token punctuation">.</span>second<span class="token operator">==</span>ss<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pt<span class="token operator">=</span><span class="token function">find_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">float</span> fa<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> fa <span class="token operator">==</span> f<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>lambda表达式语法定义</li></ul><p>lambda表达式的语法定义如下：<br><code>[capture] （parameters） mutable -&gt;return-type {statement};</code></p><ol><li><p>[capture]: 捕捉列表。捕捉列表总是出现在lambda函数的开始处。实质上，[]是lambda引出符（即独特的标志符）<br>　　编译器根据该引出符判断接下来的代码是否是lambda函数<br>　　捕捉列表能够捕捉上下文中的变量以供lambda函数使用<br>　　捕捉列表由一个或多个捕捉项组成，并以逗号分隔，捕捉列表一般有以下几种形式：   </p><ul><li><p>[]：默认不捕获任何变量；</p></li><li><p>[=]：默认以值捕获所有变量；</p></li><li><p>[&amp;]：默认以引用捕获所有变量；</p></li><li><p>[x]：仅以值捕获x，其它变量不捕获；</p></li><li><p>[&amp;x]：仅以引用捕获x，其它变量不捕获；</p></li><li><p>[=, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；</p></li><li><p>[&amp;, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；</p></li><li><p>[this]：通过引用捕获当前对象（其实是复制指针）；</p></li><li><p>[*this]：通过传值方式捕获当前对象；</p><p>　　- &lt;1&gt; [var] 表示值传递方式捕捉变量var</p><ul><li>&lt;2&gt; [=] 表示值传递方式捕捉所有父作用域的变量（包括this指针） 【即该作用域中说所有的变量】</li><li>&lt;3&gt; [&amp;var] 表示引用传递捕捉变量var</li><li>&lt;4&gt; [&amp;] 表示引用传递捕捉所有父作用域的变量（包括this指针）<pre><code>  讲解一下使用&amp;的作用</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">5678</span><span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> f<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>k<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">return</span> i<span class="token operator">+</span>j<span class="token operator">+</span>k<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>k<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  输出为：1234，记住，当生命lambda声明时，参数已经捕获完毕，即i为值传递，不可改变，j,k为引用传递，可以改变，故最终传入的参数为：  i=1234, j=2, k=3;</code></pre>　　- &lt;5&gt; [this] 表示值传递方式捕捉当前的this指针,    当要使用类成员时，不能使用[=]进行捕获，需使用[this]来捕获      <ul><li>&lt;6&gt; [=，&amp;a，&amp;b] 表示以引用传递的方式捕捉变量 a 和 b，而以值传递方式捕捉其他所有的变量  </li><li>&lt;7&gt; [&amp;，a，this] 表示以值传递的方式捕捉 a 和 this，而以引用传递方式捕捉其他所有变量   <pre><code>备注：父作用域是指包含lambda函数的语句块{ }    </code></pre>  另外，需要注意的是，捕捉列表不允许变量重复传递。下面的例子就是典型的重复，会导致编译错误：<br>  [=， a] 这里 = 已经以值传递方式捕捉了所有的变量，那么再捕捉 a 属于重复<br>  [&amp;，&amp;this] 这里 &amp; 已经以引用传递方式捕捉了所有变量，那么再捕捉 this 属于重复   </li></ul></li></ul></li></ul></li><li><p>parameters）:参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号（）一起省略</p></li><li><p>mutable : mutable修饰符。默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性（后面有详解）在使用该修饰符时，参数列表不可省略（即使参数为空）</p></li><li><p>-&gt;return-type : 返回类型。用追踪返回类型形式声明函数的返回类型。　出于方便，不需要返回值的时候也可以连同符号-&gt;一起省略　　此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导</p></li><li><p>{statement} : 函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量,在lambda函数的定义中，参数列表和返回类型都是可选的部分，而捕捉列表和函数体都可能为空<br>那么，在极端情况下，C++11中最为简单的lambda函数只需要声明为：　[] {};</p><ul><li><p>当使用多个捕获时：<br>  当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。<br>  当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了&amp;），则显式捕获命名变量必须采用值方式，因此不能在其名字前使用&amp;。类似的，如果隐式捕获采用的是值方式（使用了=），则显式捕获命名变量必须采用引用方式，即，在名字前使用&amp;。<br>  默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表：<br>  <code>auto f=[v1]()mutable{return ++vl;};</code></p></li><li><p>声明返回类型：<br>默认返回为void类型，当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型；<br><code>[](int i)-&gt;int{if (i&lt;0)return-i;else return i;}</code></p></li></ul></li></ol><h1 id="第八章：配接器（adapters）"><a href="#第八章：配接器（adapters）" class="headerlink" title="第八章：配接器（adapters）"></a>第八章：配接器（adapters）</h1><h2 id="8-1、配接器之概观与分类"><a href="#8-1、配接器之概观与分类" class="headerlink" title="8.1、配接器之概观与分类"></a>8.1、配接器之概观与分类</h2><ul><li><p>应用于容器，container adapters</p></li><li><p>应用于迭代器，iterator adapters<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001308017-749591728.png" alt=""></p></li><li><p>应用于仿函数，functor adapters<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001318958-461090507.png" alt=""></p></li></ul><h2 id="8-2、container-adapters"><a href="#8-2、container-adapters" class="headerlink" title="8.2、container adapters"></a>8.2、container adapters</h2><ul><li><p>stack<br>stack的底层由deque构成。从以下接口可清楚看出stack与deque的关系：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{</span><span class="token keyword">protected</span>：Sequence c；<span class="token comment" spellcheck="true">//底层容器</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>queue<br>queue的底层由deque构成。从以下接口可清楚看出queue与deque的关系：   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">=</span>deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">queue</span><span class="token punctuation">{</span><span class="token keyword">protected</span>：Sequence c；<span class="token comment" spellcheck="true">//底层容器</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="8-3、iterator-adapters"><a href="#8-3、iterator-adapters" class="headerlink" title="8.3、iterator adapters"></a>8.3、iterator adapters</h2><ul><li><p>insert iterators</p></li><li><p>reverse iterators<br>所谓 reverse iterator，就是将迭代器的移动行为倒转。如果STL算法接受的不是一般正常的迭代器，而是这种逆向迭代器，它就会以从尾到头的方向来处理序列中的元素。例如：<br>//将所有元素逆向拷贝到ite所指位置上<br>//rbegin（）和rend（）与reverse_iterator有关copy（id.rbegin（），id.rend（），ite）；看似单纯，实现时却大有文章。  </p></li><li><p>stream iterators<br>所谓 stream iterators，可以将迭代器绑定到一个stream（数据流）对象身上。<br>绑定到istream对象（例如std:：cin）者，称为istream iterator，拥有输人能力；<br>绑定到ostream对象（例如std:：cout）者，称为ostream_iterator，拥有输出能力。   </p></li></ul><h2 id="8-4、function-adapters"><a href="#8-4、function-adapters" class="headerlink" title="8.4、function adapters"></a>8.4、function adapters</h2><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001339871-20879902.png" alt=""></p><ul><li>对返回值进行逻辑否定：not1，not2</li><li>对参数进行绑定：bindls t，bind2nd</li><li>用于函数合成：compose1，compose2 </li><li>用于函数指针：ptr_fun</li></ul><p>定义一个函数指针类型。<br>比如你有三个函数：   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"你好!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">bye</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"再见！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"好的！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>typdef void (*funcptr)(void);</code><br><code>typede[函数返回类型][*函数指针名][函数参数类型]</code><br>这样就构造了一个通用的函数<br>你用的时候可以这样：  </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>funcptr words<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&amp;</span>hello<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bye<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ok<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将函数指针存入</span>funcptr fun <span class="token operator">=</span> words<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>就会显示“你好！”；<span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>就会显示“再见！”；<span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>就会显示“好的！”<span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sayHelloPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> sayHello<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//其中，括号是必不可少的</span>    <span class="token punctuation">(</span><span class="token operator">*</span>sayHelloPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于成员函数指针：memfun，mem fun_ref</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第七章：仿函数&quot;&gt;&lt;a href=&quot;#第七章：仿函数&quot; class=&quot;headerlink&quot; title=&quot;第七章：仿函数&quot;&gt;&lt;/a&gt;第七章：仿函数&lt;/h1&gt;&lt;h2 id=&quot;7-1、仿函数（函数对象）概观&quot;&gt;&lt;a href=&quot;#7-1、仿函数（函数对象）概观&quot; c
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL源码剖析" scheme="http://www.zzw1024.top/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>《STL源码剖析》——第五、六章：关联容器与算法</title>
    <link href="http://www.zzw1024.top/2019/12/24/stl-yuan-ma-pou-xi-di-wu-liu-zhang-guan-lian-rong-qi-yu-suan-fa/"/>
    <id>http://www.zzw1024.top/2019/12/24/stl-yuan-ma-pou-xi-di-wu-liu-zhang-guan-lian-rong-qi-yu-suan-fa/</id>
    <published>2019-12-24T01:27:56.000Z</published>
    <updated>2019-12-24T01:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章、关联容器"><a href="#第五章、关联容器" class="headerlink" title="第五章、关联容器"></a>第五章、关联容器</h1><h2 id="5-0、关联容器"><a href="#5-0、关联容器" class="headerlink" title="5.0、关联容器"></a>5.0、关联容器</h2><ul><li><p>标准的STL关联式容器分为set（集合）和map（映射表）两大类，以及这两大类的衍生体multiset（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。</p></li><li><p>SGISTL还提供了一个不在标准规格之列的关联式容器：hash_table（散列表），以及以此hash_table为底层机制而完成的hash_set（散列集合）、hash_map（散列映射表）、hash_multiset（散列多键集合）、hash_multimap（散列多键映射表）。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235640834-174846146.png" alt=""></p></li><li><p>所谓关联式容器，观念上类似关联式数据库：每笔数据（每个元素）都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器内部结构（可能是RB-tree，也可能是hash-table）便依照其键值大小，以某种特定规则将这个元素放置于适当位置。关联式容器没有所谓头尾（只有最大元素和最小元素），所以不会有所谓 push_back()、push_front()、pop_back()、pop_front()、begin()【即无法通过*.begin()取出数据】、endt()这样的操作行为。</p></li></ul><h2 id="5-1、树的导览"><a href="#5-1、树的导览" class="headerlink" title="5.1、树的导览"></a>5.1、树的导览</h2><p>即讲解数据结构中的二叉树、二叉搜索树、平衡二叉树。。。</p><h2 id="5-2、RB-tree（红黑树）"><a href="#5-2、RB-tree（红黑树）" class="headerlink" title="5.2、RB-tree（红黑树）"></a>5.2、RB-tree（红黑树）</h2><h3 id="红黑树定义及其特性"><a href="#红黑树定义及其特性" class="headerlink" title="红黑树定义及其特性"></a>红黑树定义及其特性</h3><ol><li>每个节点或是黑色或是红色 </li><li>根节点是黑色 </li><li>每个叶节点是黑色（叶节点为空节点） </li><li>如果一个节点是红色，则它的两个子节点必须是黑色 </li><li>从任意的一个节点到该节点的所有叶节点的路径包含相同数目的黑色节点</li><li>红黑树是一种平衡二叉树，当不是完全的平衡二叉树，红黑树只要求最多三次旋转来尽可能达到平衡<br> 【也就是说没有规定左子树与右子树的高度差必须&lt;=1!!!!!!】</li></ol><ul><li>迭代器</li><li><em>operator++*</em><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235713829-442804034.png" alt=""></li></ul><p><strong>operator–</strong><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235737458-1520435092.png" alt=""></p><p><strong>自身迭代器</strong><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235806708-1498398018.png" alt=""></p><p>关于红黑树的具体数据结构，请看<a href="http://zzw1024.top/2019/12/22/hong-hei-shu/" target="_blank" rel="noopener"><strong>博文</strong></a></p><h2 id="5-3、-set"><a href="#5-3、-set" class="headerlink" title="5.3、 set"></a>5.3、 set</h2><ul><li>set底层是由红黑树构造的 </li><li>set key值不能重复</li><li>set中的key值不允许改变</li><li>STL特别提供了一组set/multiset相关算法，包括交集set_intersection、联集set_union、差集 set_difference、对称差集set_symmetric_difference。</li></ul><h2 id="5-4、map"><a href="#5-4、map" class="headerlink" title="5.4、map"></a>5.4、map</h2><ul><li>map不可以通过迭代器修改键值，但可以修改实值</li><li>map拥有list的某些性质：即增删改查其迭代器不会失效</li><li>map几乎是在调用RBTree的接口函数</li><li>map底层仍然是红黑树构造的</li></ul><h2 id="5-5、multiset"><a href="#5-5、multiset" class="headerlink" title="5.5、multiset"></a>5.5、multiset</h2><ul><li>与set一样，只不过是允许键值存在重复</li></ul><h2 id="5-6、multimap"><a href="#5-6、multimap" class="headerlink" title="5.6、multimap"></a>5.6、multimap</h2><p>与map一样，但允许键值重复</p><h2 id="5-7-、hashtable"><a href="#5-7-、hashtable" class="headerlink" title="5.7 、hashtable"></a>5.7 、hashtable</h2><ul><li>详细讲解请见<a href="http://zzw1024.top/2019/12/23/hash-biao-xiang-jie/" target="_blank" rel="noopener"><strong>博文</strong></a>      </li><li>hashtable没有向后的迭代器operator–()</li></ul><h2 id="5-8、hash-set"><a href="#5-8、hash-set" class="headerlink" title="5.8、hash_set"></a>5.8、hash_set</h2><p>hash_set拥有set的功能，底层使用的是hashtable，且不排序</p><h2 id="5-9、hash-map"><a href="#5-9、hash-map" class="headerlink" title="5.9、hash_map"></a>5.9、hash_map</h2><p>hash_map拥有map的功能，但底层是由hashtable组成的，且无排序功能</p><h2 id="5-10、hash-multiset"><a href="#5-10、hash-multiset" class="headerlink" title="5.10、hash_multiset"></a>5.10、hash_multiset</h2><ul><li>与multiset功能完全相同，其底层换成了hashtable</li><li>与hash_set的区别就是可以键值重复</li></ul><h2 id="5-11、-hash-multimap"><a href="#5-11、-hash-multimap" class="headerlink" title="5.11、 hash_multimap"></a>5.11、 hash_multimap</h2><p>hash_multimap与multimap的功能完全类似，但底层是以hashmap基本</p><h1 id="第六章-算法algorithms"><a href="#第六章-算法algorithms" class="headerlink" title="第六章 算法algorithms"></a>第六章 算法algorithms</h1><h2 id="6-1、概述"><a href="#6-1、概述" class="headerlink" title="6.1、概述"></a>6.1、概述</h2><ul><li><p>算法的五大特征如下：</p><ul><li>有穷性（Finiteness）。算法的有穷性是指算法必须能在执行有限个步骤之后终止；</li><li>确切性(Definiteness)。算法的每一步骤必须有确切的定义；</li><li>输入项(Input)。一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；</li><li>输出项(Output)。一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；</li><li>可行性(Effectiveness)。算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）。</li></ul></li><li><p>时间复杂度<br>时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为O(n)），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于常数时间内的操作（对应时间复杂度O(1)）。</p></li></ul><p>在化简某算法时间复杂度表达式时需遵循以下规则：<br>对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如O(n^2)+O(n)可化简为O(n^2)，O(n)+O(1)可化简为O(n)<br>可省去样本量前的常量系数，如O(2n)可化简为O(n)，O(8)可化简为O(1),对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如O(logm)+O(n^2)不能化简为O(n^2)或O(logm)。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为O(logm)，因为表达式增量是由样本量决定的。</p><ul><li><p>额外空间复杂度<br>算法额外空间复杂度指的是对于输入样本，经过算法操作需要的额外空间。比如使用冒泡排序对一个数组排序，期间只需要一个临时变量temp，那么该算法的额外空间复杂度为O(1)。又如归并排序，在排序过程中需要创建一个与样本数组相同大小的辅助数组，尽管在排序过后该数组被销毁，但该算法的额外空间复杂度为O(n)。</p></li><li><p>算法：<br>算法主要是由头文件<algorithm> <functional> <numeric>组成。<br><algorithm>是所有 STL 头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等…<br><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.<br><functional> 定义了一些模板类,用以声明函数对象。          </p></li><li><p>STL算法概况</p></li><li><p><em>质变指定是算法的稳定性*</em><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235934523-639435368.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235940226-890758197.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000001776-1055970874.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000010021-477313739.png" alt=""></p></li><li><p>质变的算法——会改变操作对象之值<br>所有的STL算法都作用在由迭代器[first，last）所标示出来的区间上。所谓“质变算法”，是指运算过程中会更改区间内（迭代器所指）的元素内容。诸如拷贝（copy）、互换（swap）、替换（replace）、填写（fill）、删除（remove）、排列组合（permutation）、分割（partition）、随机重排（random shuffling）、排序（sort）等算法，都属此类。</p></li><li><p>不质变的算法——不改变操作对象之值<br>所有的STL算法都作用在由迭代器[first，last）所标示出来的区间上。所谓“非质变算法”，是指运算过程中不会更改区间内（迭代器所指）的元素内容。<br>诸如查找（find）、匹配（search）、计数（count）、巡访（for_each）、比较（equal，mismatch）、寻找极值（max，min）等算法，都属此类。但是如果你在for_each（巡访每个元素）算法身上应用一个会改变元素内容的仿函数（functor）。   </p></li></ul><h2 id="6-2、算法的泛化过程"><a href="#6-2、算法的泛化过程" class="headerlink" title="6.2、算法的泛化过程"></a>6.2、算法的泛化过程</h2><ul><li>算法函数传参最好是传引用参数，这样可以避免由于对象的庞大而付出大的代价</li><li>这样的find（）很好，几乎适用于任何容器——只要该容器允许指针指入，而指针们又都支持以下四种find（）函数中出现的操作行为：<ul><li>inequality（判断不相等）操作符</li><li>dereferencelm（提领，取值）操作符</li><li>prefix increment（前置式递增）操作符</li><li>copy（复制）行为（以便产a’x生函数的返回值）</li></ul></li></ul><h2 id="6-3、数值算法"><a href="#6-3、数值算法" class="headerlink" title="6.3、数值算法"></a>6.3、数值算法<stl numeric.h></h2><ul><li><p>头文件<numeric><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000202562-1209119902.png" alt="">    </p></li><li><p>accumlate<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000222791-1493346367.png" alt=""></p></li></ul><p>算法accumulate用来计算init和[first，last）内所有元素的总和。注意，你一定得提供一个初始值init，这么做的原因之一是当[first，last）为空区间时仍能获得一个明确定义的值。如果希望计算[first，1ast）中所有数值的总和，应该将init设为0.</p><ul><li>adjacent_difference<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000240388-361851450.png" alt=""></li></ul><p>算法adjacent_difference用来计算[first，last）中相邻元素的差额。也就是说，它将<em>first 赋值给</em>result，并针对[first+1，last）内的每个迭代器i，将<em>i-</em>（i-1）之值赋值给*（result+（i-first））。<br>注意，你可以采用就地（in place）运算方式，也就是令result等于first。</p><ul><li><p>inner_product<br>算法inner_product能够计算[first1，last1）和[first2，first2+<br>（1ast1-first1））的一般内积（generalized inner product）。注意，你一定得提供初值init。这么做的原因之一是当[first，last）为空时，仍可获得一个明确定义的结果。如果你想计算两个vectors的一般内积，应该将init设为0.</p></li><li><p>partical_sum<br>算法partial_sum用来计算局部总和。它会将<em>first赋值给</em>result，将<em>first和</em>（first+1）的和赋值给*（result+1），依此类推。注意，result可以等于first，这使我们得以完成就地（in place）计算。在这种情况下它是一个质变算法（mutating algorithm）。</p></li></ul><p>运算中的总和首先初始为*first，然后赋值给<em>result。对于<br>[first+1，last）中每个迭代器i，从头至尾依序执行sum=sum+</em>i（第一版本）或sum=binary_op（sum，<em>i）（第二版本），然后再将sum赋值给</em>（result+（i-first））。此式所用之二元仿函数不必满足交换律（commutative）和结合律（associative）。所有运算行为的顺序都有明确设定。<br>本算法返回输出区间的最尾端位置：result+（last-first）。</p><ul><li><p>power<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000323728-288517597.png" alt=""></p></li><li><p>itoa<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000336197-1995376542.png" alt=""></p></li></ul><h2 id="6-4、基本算法"><a href="#6-4、基本算法" class="headerlink" title="6.4、基本算法"></a>6.4、基本算法<stl algobase.h></h2><ul><li><p>for_each</p></li><li><p>equal</p></li><li><p>fill</p></li><li><p>fill_n</p></li><li><p>iter_swap</p></li><li><p>lexicographical_compare</p><ul><li>以“字典排列方式”对两个序列[first1，last1）和tfirst2，1ast2）进行比较。比较操作针对两序列中的对应位置上的元素进行，并持续直到<ul><li>（1）某一组对应元素彼此不相等；</li><li>（2）同时到达1ast1和last2（当两序列的大小相同）；</li><li>（3）到达1ast1或last2（当两序列的大小不同）。</li></ul></li></ul></li><li><p>当这个函数在对应位置上发现第一组不相等的元素时，有下列几种可能：</p><ul><li>如果第一序列的元素较小，返回true.否则返回false。</li><li>如果到达last1而尚未到达last2，返回true。</li><li>如果到达last2而尚未到达last1，返回false。</li><li>如果同时到达last1和last2（换句话说所有元素都匹配），返回false；</li></ul></li><li><p>max</p></li><li><p>min</p></li><li><p>mism atch</p></li></ul><p>用来平行比较两个序列，指出两者之间的第一个不匹配点。返回一对迭代器，分别指向两序列中的不匹配点，如下图。如果两序列的所有对应元素都匹配，返回的便是两序列各自的last迭代器。缺省情况下是以equality操作符来比较元素；但第二版本允许用户指定比较操作。如果第二序列的元素个数比第一序列多，多出来的元素忽略不计。如果第二序列的元素个数比第一序列少，会发生未可预期的行为。</p><ul><li>swap</li><li>copy<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000358486-2111604671.png" alt=""></li></ul><h2 id="6-5、set相关算法"><a href="#6-5、set相关算法" class="headerlink" title="6.5、set相关算法"></a>6.5、set相关算法</h2><p>STL一共提供了四种与set（集合）相关的算法，分别是并集（union）、交集（intersection）、差集（difference）、对称差集（symmetric difference）。</p><h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><p>算法set_union可构造s1、s2之并集。也就是说，它能构造出集合s1Us2，此集合内含s1或s2内的每一个元素。s1、s2及其并集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此，如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现max（m，n）次，其中n个来自s1，其余来自s2。</p><p>set_union 是一种稳定（stable）操作，意思是输入区间内的每个元素的相对顺序都不会改变。set-union有两个版本，差别在于如何定义某个元素小于另一个元素。</p><h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><p>算法 set_intersection可构造s1、s2之交集。也就是说，它能构造出集合s1 n s2，此集合内含同时出现于s1和s2内的每一个元素。s1、s2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现min（m，n）次，并且全部来自s1。</p><p>set_intersection 是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和s1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。</p><h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><p>算法 set_difference可构造s1、s2之差集。也就是说，它能构造出集合s1-s2，此集合内含“出现于s1但不出现于s2”的每一个元素。s1、s2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现max（n-m，0）次，并且全部来自S1。</p><h3 id="set-difference-1"><a href="#set-difference-1" class="headerlink" title="set_difference"></a>set_difference</h3><p>是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和S1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p><h3 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h3><p>算法setsymmetric_difference 可构造s1、s2之对称差集。也就是说，它能构造出集合（S1-S2）U（S2-S1），此集合内含“出现于s1但不出现于s2”<br>以及“出现于s2但不出现于s1”的每一个元素。S1、S2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现ln-ml次。如果n&gt;m，输出区间内的最后n-m个元素将由s1复制而来，如果n&lt; m则输出区间内的最后m-n个元素将由s2复制而来。在STL set容器内，m≤1且n&lt;=1。</p><p>setsymmetric_difference 是一种稳定（stable）操作，意思是输入区间内的元素相对顺序不会被改变。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operators进行比较，第二版本采用仿函数comp。</p><h2 id="6-6、heap算法"><a href="#6-6、heap算法" class="headerlink" title="6.6、heap算法"></a>6.6、heap算法</h2><h2 id="6-7、其它算法"><a href="#6-7、其它算法" class="headerlink" title="6.7、其它算法"></a>6.7、其它算法</h2><p>深入源代码之前，先观察每一个算法的表现，是个比较好的学习方式。以下程序示范本节每一个算法的用法。程序中有时使用STL内建的仿函数（functors，如less，greater，equeal_to）和配接器（adapters，如bind2nd），有时使用自定义的仿函数（如display，even_by_two）。</p><ul><li><p>adjacent find<br>找出第一组满足条件的相邻元素。这里所谓的条件，在版本一中是指“两元素相等”，在版本二中允许用户指定一个二元运算，两个操作数分别是相邻的第一元素和第二元素。</p></li><li><p>count<br>运用equality操作符，将[first，last）区间内的每一个元素拿来和指定值value比较，并返回与value相等的元素个数。</p></li><li><p>count_if<br>将指定操作（一个仿函数）pred实施于[first，1ast）区间内的每一个元素身上，并将“造成pred之计算结果为true”的所有元素的个数返回。</p></li><li><p>find</p></li><li><p>find it</p></li><li><p>find_end</p></li><li><p>find_first of</p></li><li><p>for_each</p></li><li><p>generate</p></li><li><p>generate_n</p></li><li><p>includes（应用于有序区间）</p></li><li><p>max element</p></li><li><p>merge（应用于有序区间）</p></li><li><p>min_element</p></li><li><p>partition</p></li></ul><p>partition 会将区间[first，last）中的元素重新排列。所有被一元条件运算pred判定为true的元素，都会被放在区间的前段，被判定为false的元素，都会被放在区间的后段。这个算法并不保证保留元素的原始相对位置。如果需要保留原始相对位置，应使用stable_partition。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000454758-820817564.png" alt=""></p><ul><li><p>remove移除（但不删除）<br>移除[first，1ast）之中所有与value相等的元素。这一算法并不真正从容器中删除那些元素（换句话说容器大小并未改变），而是将每一个不与value相等（也就是我们并不打算移除）的元素轮番赋值给first之后的空间。返回值Fonwarditerator 标示出重新整理后的最后元素的下一位置。<br>例如序列<br>{0，1，0，2，0，3，0，4]，如果我们执行remove（），希望移除所有0值元素，执行结果将是{1，23，4，0，3.0.4]。每一个与0不相等的元素，1，2，3，4，分别被拷贝到第一、二、三、四个位置上。第四个位置以后不动，换句话说是第四个位置之后是这一算法留下的残余数据。返回值Forwardlterator 指向第五个位置。如果要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase（）member function。注意，array 不适合使用remove（）和remove_if（），因为array无法缩小尺寸，导致残余数据永远存在。对array而言，较受欢迎的算法是remove_copy（）和</p></li><li><p>remove_copy</p></li><li><p>remove_if</p></li><li><p>remove_copy.if</p></li><li><p>replace</p></li><li><p>replace_copy</p></li><li><p>replace if</p></li><li><p>replace_copy._if</p></li><li><p>reverse</p></li><li><p>reverse_copy</p></li><li><p>rotate<br>将[first，middle）内的元素和[middle，last）内的元素互换。middle所指的元素会成为容器的第一个元素。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000526836-1762719892.png" alt=""></p></li><li><p>rotate_copy</p></li><li><p>search</p></li><li><p>search_n</p></li></ul><p>在序列[first，last）所涵盖的区间中，查找“连续count个符合条件之元素”所形成的子序列，并返回一个迭代器指向该子序列起始处。如果找不到这样的子序列，就返回迭代器last。上述所谓的“某条件”，在search_n版本一指的是相等条件“equality”，在search_n版本二指的是用户指定的某个二元运算（以仿函数呈现）。</p><p>例如，面对序列{10，8，8，7，2，8，7，2，2，8，7，0}，查找“连续两个8”所形成的子序列起点，可以这么写：<br>iter1 = search_n（iv.begin（），iv.end（），2，8）；</p><p>查找“连续三个小于8的元素”所形成的子序列起点，可以这么写：<br>iter2 = search_n（iv.begin（），iv.end（），3，8，1ess&lt; int &gt;（）；</p><ul><li><p>swap_ranges</p></li><li><p>transform</p></li><li><p>unique</p></li><li><p>unique_copy</p></li><li><p>lower_bound（应用于有序区间）<br>这是二分查找（binary search）的一种版本，试图在已排序的（first，last）中寻找元素value。如果[first，last）具有与value相等的元素（s），便返回一个迭代器，指向其中第一个元素。如果没有这样的元素存在，便返回“假设这样的元素存在时应该出现的位置”。也就是说，它会返回一个迭代器，指向第一个“不小于value”的元素。如果value大于[first，last）内的任何一个元素，则返回last。以稍许不同的观点来看1ower_bound，其返回值是“在不破坏排序状态的原则下，可插入value的第一个位置”。 </p></li><li><p>upper_bound（应用于有序区间）<br>算法upper_bound是二分查找（binary search）法的一个版本。它试图在已排序的[first，last）中寻找value。更明确地说，它会返回“在不破坏顺序的情况下，可插入value的最后一个合适位置”。</p></li><li><p>binary_search（应用于有序区间）<br>算法binary_search 是一种二分查找法，试图在已排序的[first，last）中寻找元素value。如果[first，last）内有等同于value的元素，便返回true，否则返回false。</p></li></ul><p>返回单纯的bool或许不能满足你，前面所介绍的lower_bound和upper_bound能够提供额外的信息。事实上binary_search便是利用lower_bound先找出“假设value存在的话，应该出现的位置”，然后再对比该位置上的值是否为我们所要查找的目标，并返回对比结果。</p><ul><li>next_permutation<br>STL提供了两个用来计算排列组合关系的算法，分别是nextpermucation和 prev_permutation。首先我们必须了解什么是“下一个”排列组合，什么是“前一个”排列组合。</li></ul><p>考虑三个字符所组成的序列（a，b，c）。这个序列有六个可能的排列组合：abc，acb，bac，bca，cab，cba。这些排列组合根据less-than操作符做字典顺序（lexicographical）的排序。也就是说，abc名列第一，因为每一个元素都小于其后的元素。</p><p>next_permutation（）会取得[first，last）所标示之序列的下一个排列组合。如果没有下一个排列组合，便返回false；否则返回true。</p><ul><li><p>prev_permutation<br>所谓“前一个”排列组合，其意义已在上一节阐述。实际做法简述如下，其中所用的符号如图6-8所示。首先，从最尾端开始往前寻找两个相邻元素，令第一元素为<em>i，第二元素为</em>ii，且满足*i&gt;*ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个小于*i的元素，令为*j，将i，j元素对调，再将ii之后的所有元素颠倒排列。此即所求之“前一个”排列组合。</p></li><li></li><li><p>random_shufle<br>这个算法将[first，last）的元素次序随机重排。也就是说，在N！种可能的元素排列顺序中随机选出一种，此处N为last-first。</p></li></ul><p>N个元素的序列，其排列方式有N！种，random_shuffle会产生一个均匀分布，因此任何一个排列被选中的机率为1/N！。这很重要，因为有不少算法在其第一阶段过程中必须获得序列的随机重排，但如果其结果未能形成“在N！个可能排列上均匀分布（uniform distribution）”，便很容易造成算法的错误。</p><ul><li><p>partial_sort/partial_sort<br>本算法接受一个middle 迭代器（位于序列[first，last）之内），然后重新安排[first，last），使序列中的middle-first个最小元素以递增顺序排序，置于（first，middle）内。其余1ast-middle个元素安置于[middle，last）中，不保证有任何特定顺序。</p></li><li><p>sort<br>STL的sort 算法，数据量大时采用Quick Sort，分段递归排序。<br>一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷（overhead），就改用Insertion Sort。<br>如果递归层次过深，还会改用Heap Sort。</p></li><li><p>equal_range（应用于有序区间）<br>算法equal_range是二分查找法的一个版本，试图在已排序的[first，last）中寻找value。它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即1ower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound）。因此，[i，j）内的每个元素都等同于value，而且[i，j）是(first，last)之中符合此一性质的最大子区间。<br>于是，算法lower_bound返回区间A的第一个迭代器，算法upper_bound返回区间A的最后元素的下一位置，算法equalrange则是以pair的形式将两者都返回。</p></li><li><p>inplace_merge（应用于有序区间）<br>如果两个连接在一起的序列[first，middle）和[middle，last）都已排序，那么inplacemerge可将它们结合成单一一个序列，并仍保有序性（sorted）。</p></li></ul><p>如果原先两个序列是递增排序，执行结果也会是递增排序，如果原先两个序列是递减排序，执行结果也会是递减排序。</p><p>和merge一样，inplace_merge也是一种稳定（stable）操作。每个作为数据来源的子序列中的元素相对次序都不会变动；如果两个子序列有等同的元素，第一序列的元素会被排在第二序列元素之前。</p><ul><li>nth_element<br>这个算法会重新排列[first，last），使迭代器nth所指的元素，与“整个<br>[first，1ast）完整排序后，同一位置的元素”同值。此外并保证（nth，last）内没有任何一个元素小于（更精确地说是不大于）[first，nth）内的元素，但对于[first，nth）和[nth，last）两个子区间内的元素次序则无任何保证一—这一点也是它与partial_sort很大的不同处。以此观之，nth_element比较近似partition 而非 sort 或 partial_sort。</li></ul><p>例如，假设有序列{22，30，30，17，33，40，17，23，22，12，20}，以下操作：<br>nth_element(iv.begin()，iv.begin()+5，iv.end())；便是将小于*(iv.begin()+5)(本例为40)的元素置于该元素之左，其余置于该元素之右，并且不保证维持原有的相对位置。获得的结果为{20，12，22，17，17，<br>22，23，30，30，33，40]。执行完毕后的5th个位置上的元素值22，与整个序列完整排序后{12，17，17，20，22，22，23，30，30，33，40]的5th个位置上的元素值相同。</p><ul><li>6.7.13 merge sort<br>以上的排序算法详见<a href="http://zzw1024.top/2019/12/23/shi-da-jing-dian-pai-xu-suan-fa/" target="_blank" rel="noopener"><strong>博文</strong></a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第五章、关联容器&quot;&gt;&lt;a href=&quot;#第五章、关联容器&quot; class=&quot;headerlink&quot; title=&quot;第五章、关联容器&quot;&gt;&lt;/a&gt;第五章、关联容器&lt;/h1&gt;&lt;h2 id=&quot;5-0、关联容器&quot;&gt;&lt;a href=&quot;#5-0、关联容器&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL源码剖析" scheme="http://www.zzw1024.top/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="http://www.zzw1024.top/2019/12/23/shi-da-jing-dian-pai-xu-suan-fa/"/>
    <id>http://www.zzw1024.top/2019/12/23/shi-da-jing-dian-pai-xu-suan-fa/</id>
    <published>2019-12-23T11:46:39.000Z</published>
    <updated>2019-12-23T11:46:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响排序性能的要素："><a href="#影响排序性能的要素：" class="headerlink" title="影响排序性能的要素："></a>影响排序性能的要素：</h2><p>时间性能<br>辅助空间<br>算法的复杂度</p><h2 id="简单排序【n-2】"><a href="#简单排序【n-2】" class="headerlink" title="简单排序【n^2】"></a>简单排序【n^2】</h2><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><p>第一趟：<br>从第一个记录开始，通过n-1次关键字比较，从n个记录中选出最小的并和第一个记录交换；<br>第二趟：<br>从第二个记录开始，通过n-2次关键字比较，从n -1个记录中选出最小的并和第二个记录交换；<br>复杂度稳稳的是0(n2)，几乎被抛弃      </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">SimpleSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> minV <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minV <span class="token operator">></span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                minV <span class="token operator">=</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），故名“冒泡排序”。每一次排序都将最大的数排到最后【最前】            </p><p><strong>算法稳定性</strong><br>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>  T temp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i  <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j  <span class="token operator">&lt;</span> len <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//之所以是-i，是因为每一次j的循环都将最大的数冒出到最后，所以后面的i个数是已经完成了排序的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j  <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                temp  <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j  <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j  <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>改进：</strong><br>使用一个标记，一旦某次j循环遍历中没有进行数据交换，那么数据是提前有序了，使用flag进行标记提前结束循环。  </p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序（Selection sort）是一种简单直观的排序算法。<br>它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。【好像就是前面的简单排序】          </p><p><strong>稳定性:</strong><br>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。          </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                index <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!=</span> i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            v<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。   </p><p>插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p><p><strong>插入排序的基本思想是：</strong><br>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：   </p><ul><li>从第一个元素开始，该元素可以认为已经被排序；   </li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；   </li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；  </li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；   </li><li>将新元素插入到该位置后；     </li></ul><h4 id="直接插入排序："><a href="#直接插入排序：" class="headerlink" title="直接插入排序："></a>直接插入排序：</h4><p>直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。<br><strong>直接插入排序的算法思路：</strong>   </p><ol><li>设置监视哨temp，将待插入记录的值赋值给temp；</li><li>设置开始查找的位置j = i-1,从判断比较的i位置的前一个数开始比较；</li><li>在数组中进行搜索，搜索中将第j个记录后移，直至temp≥r[j].key为止；</li><li>将temp插入r[j+1]的位置上。   </li></ol><p>直接插入排序算法:   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//临时哨兵</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        temp <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从i的前一位开始从后向前比较</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                v<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向后移</span>            <span class="token keyword">else</span>                <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//找到位置了</span>        v<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意，j前移动了</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="折半插入排序（二分插入排序）"><a href="#折半插入排序（二分插入排序）" class="headerlink" title="折半插入排序（二分插入排序）"></a>折半插入排序（二分插入排序）</h4><p>算法的基本过程：    </p><ol><li>计算 0 ~ i-1 的中间点，用 i 索引处的元素与中间值进行比较，如果 i 索引处的元素大，说明要插入的这个元素应该在中间值和刚加入i索引之间，反之，就是在刚开始的位置到中间值的位置，这样很简单的完成了折半；   </li><li>在相应的半个范围里面找插入的位置时，不断的用（1）步骤缩小范围，不停的折半，范围依次缩小为 1/2 1/4 1/8 …….快速的确定出第 i 个元素要插在什么地方；      </li><li>确定位置之后，将整个序列后移，并将元素插入到相应位置。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232332714-1361581688.png" alt=""><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iterator></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> biIter<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">insertion_sort</span> <span class="token punctuation">(</span>biIter begin<span class="token punctuation">,</span> biIter end<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>biIter<span class="token operator">></span><span class="token operator">::</span>value_type value_type<span class="token punctuation">;</span> biIter bond <span class="token operator">=</span> begin<span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>bond<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> bond <span class="token operator">!=</span> end<span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>bond<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     value_type key <span class="token operator">=</span> <span class="token operator">*</span>bond<span class="token punctuation">;</span>     biIter ins <span class="token operator">=</span> bond<span class="token punctuation">;</span>     biIter pre <span class="token operator">=</span> ins<span class="token punctuation">;</span>     std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>ins <span class="token operator">!=</span> begin <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>pre <span class="token operator">></span> key<span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token operator">*</span>ins <span class="token operator">=</span> <span class="token operator">*</span>pre<span class="token punctuation">;</span>         std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>ins<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token operator">*</span>ins <span class="token operator">=</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。<br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。      </p><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；<br>然后，取第二个增量<code>d2 &lt; d1</code>重复上述的分组和排序，直至所取的增量 =1<br><code>(&lt;…&lt;d2&lt;d1)</code>，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法一般的初次取序列的一半为增量，以后每次减半，直到增量为1。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232357154-1789458743.png" alt=""></p><p><strong>稳定性:</strong><br>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。每次插入排序都是把跨度为gap的所有数组成一个数组进行插入排序，一定记得位置别弄错</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//gap为组的跨度，初始取长度的一半，此后每一次都折半取</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//对于每个跨度为gap的数据进行插入排序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> gap<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//每次i与跨度为gap的j一起比较</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> gap<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">+</span><span class="token operator">=</span>gap<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//j对应的是i的跨度为gap的数值</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//后比前小，应该向前插入</span>                <span class="token punctuation">{</span>                    <span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">-</span> gap<span class="token punctuation">,</span> temp <span class="token operator">=</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//temp哨兵</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        v<span class="token punctuation">[</span>k <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//后移</span>                        k <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    v<span class="token punctuation">[</span>k <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//k-gap了，故需加上gap</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；   即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。   </p><p><strong>算法稳定性:</strong><br>在归并排序中，相等的元素的顺序不会改变，所以它是稳定的算法。</p><p>归并操作的工作原理如下：[数组1小，数组1的数字上，否则数组2的数上]    </p><ul><li>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列     </li><li>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置    </li><li>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232503712-79710875.png" alt=""></li></ul><p>两个数组进行归并</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//两个数组进行归并</span><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> iL<span class="token punctuation">,</span> <span class="token keyword">int</span> iR<span class="token punctuation">,</span> <span class="token keyword">int</span> jL<span class="token punctuation">,</span> <span class="token keyword">int</span> jR<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//此处的L，R分别为两个小数组的边界</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">temp</span><span class="token punctuation">(</span>jR <span class="token operator">-</span> iL <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开辟大小为两个数组的大小空间</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> iL<span class="token punctuation">,</span> j <span class="token operator">=</span> jL<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> iR <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> jR<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//此处的等号保证了算法的稳定性，使得相同数值前后位置不变</span>            temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> iR<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//数组1未完</span>        temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> jR<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//数组2未完</span>        temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> iL<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> jR<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">,</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将排好序的数据赋值给原数组</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自底向上：非递归版【小数组到大数组】</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//step为小数组的大小，此处step的代表为两个小数组的大小，故定是2的倍数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> step <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> step <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//1&amp;1组，2&amp;2组，4&amp;4组。。。。</span>    <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//一定是从1与1的数组开始！！！不然就没法保证排序了</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> step<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//sort(v + i, v + min(i + step, n));//直接使用自带的sort函数进行排序</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> step <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//中间节点</span>                <span class="token function">Merge</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">+</span> step <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> step <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>i <span class="token operator">+</span> step <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从i开始，在跨度为step中分为两个小数组进行归并</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自顶向下：递归版【大数组到小数组】</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//一定不能等于</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> L <span class="token operator">+</span> <span class="token punctuation">(</span>R <span class="token operator">-</span> L<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//求中点</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对左边进行递归切分成小数组</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对右边进行递归切分成小数组</span>        <span class="token function">Merge</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将左右两边进行归并</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序（Quicksort）是对冒泡排序的一种改进。快速排序由C. A. R. Hoare在1960年提出。<br><strong>它的基本思想是：</strong><br>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。    </p><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。          </p><p><strong>一趟快速排序的算法是：</strong>  </p><ul><li>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</li><li>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</li><li>3）从j开始向前搜索，即由后开始向前搜索(j–)，直到找到第一个小于key的值A[j]，将A[j]和A[i]的值交换；</li><li>4）从i开始向后搜索，即由前开始向后搜索(i++)，直到找到第一个大于key的A[i]，将A[i]和A[j]的值交换；</li><li>5）重复第3、4步，直到i==j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232745511-1716928742.png" alt=""></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//对区间进行划分</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//int p = round(1.0*rand() / RAND_MAX * (R - L) + L);//选取随机位置的数为基准值</span>    <span class="token comment" spellcheck="true">//swap(v[L], v[p]);//将基准值换到最左边</span>    <span class="token keyword">int</span> key <span class="token operator">=</span> v<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一般默认使用最左端的值为基准值</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token operator">></span>key<span class="token punctuation">)</span><span class="token operator">--</span>R<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从右向左，直到找到比key小的数</span>        v<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将小的数移到左边</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key<span class="token punctuation">)</span><span class="token operator">++</span>L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从左向右，直到找到比key大数</span>        v<span class="token punctuation">[</span>R<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将大的数移到右边</span>    <span class="token punctuation">}</span>    v<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//key在中间的位置</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回中点坐标</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对左子区间进行快速排序</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对右子区间进行快速排序</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三平均分区法"><a href="#三平均分区法" class="headerlink" title="三平均分区法"></a>三平均分区法</h3><p>关于这一改进的最简单的描述大概是这样的：与一般的快速排序方法不同，它并不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。这一改进对于原来的快速排序算法来说，主要有两点优势：     </p><ol><li>首先，它使得最坏情况发生的几率减小了。</li><li>其次，未改进的快速排序算法为了防止比较时数组越界，在最后要设置一个哨点。  </li></ol><h3 id="根据分区大小调整算法"><a href="#根据分区大小调整算法" class="headerlink" title="根据分区大小调整算法"></a>根据分区大小调整算法</h3><p>这一方面的改进是针对快速排序算法的弱点进行的。快速排序对于小规模的数据集性能不是很好。可能有人认为可以忽略这个缺点不计，因为大多数排序都只要考虑大规模的适应性就行了。但是快速排序算法使用了分治技术，最终来说大的数据集都要分为小的数据集来进行处理。由此可以得到的改进就是，当数据集较小时，不必继续递归调用快速排序算法，而改为调用其他的对于小规模数据集处理能力较强的排序算法来完成。   </p><h3 id="不同的分区方案考虑"><a href="#不同的分区方案考虑" class="headerlink" title="不同的分区方案考虑"></a>不同的分区方案考虑</h3><p>对于快速排序算法来说，实际上大量的时间都消耗在了分区上面，因此一个好的分区实现是非常重要的。尤其是当要分区的所有的元素值都相等时，一般的快速排序算法就陷入了最坏的一种情况，也即反复的交换相同的元素并返回最差的中轴值。无论是任何数据集，只要它们中包含了很多相同的元素的话，这都是一个严重的问题，因为许多“底层”的分区都会变得完全一样。         </p><p>对于这种情况的一种改进办法就是将分区分为三块而不是原来的两块：一块是小于中轴值的所有元素，一块是等于中轴值的所有元素，另一块是大于中轴值的所有元素。   </p><p>另一种简单的改进方法是，当分区完成后，如果发现最左和最右两个元素值相等的话就避免递归调用而<br>采用其他的排序算法来完成。  </p><h3 id="并行的快速排序"><a href="#并行的快速排序" class="headerlink" title="并行的快速排序"></a>并行的快速排序</h3><p>由于快速排序算法是采用分治技术来进行实现的，这就使得它很容易能够在多台处理机上并行处理。<br>在大多数情况下，创建一个线程所需要的时间要远远大于两个元素比较和交换的时间，因此，快速排序的并行算法不可能为每个分区都创建一个新的线程。一般来说，会在实现代码中设定一个阀值，如果分区的元素数目多于该阀值的话，就创建一个新的线程来处理这个分区的排序，否则的话就进行递归调用来排序。    </p><h3 id="随机化快排"><a href="#随机化快排" class="headerlink" title="随机化快排"></a>随机化快排</h3><p>快速排序的最坏情况基于每次划分对主元的选择。基本的快速排序选取第一个元素作为主元。这样在数组已经有序的情况下，每次划分将得到最坏的结果。一种比较常见的优化方法是随机化算法，即随机选取一个元素作为主元。这种情况下虽然最坏情况仍然是O(n^2)，但最坏情况不再依赖于输入数据，而是由于随机函数取值不佳。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n)。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn)的期望时间复杂度。一位前辈做出了一个精辟的总结：“随机化快速排序可以满足一个人一辈子的人品需求。”<br>随机化快速排序的唯一缺点在于，一旦输入数据中有很多的相同数据，随机化的效果将直接减弱。对于极限情况，即对于n个相同的数排序，随机化快速排序的时间复杂度将毫无疑问的降低到O(n^2)。解决方法是用一种方法进行扫描，使没有交换的情况下主元保留在原位置。      </p><h3 id="平衡快排"><a href="#平衡快排" class="headerlink" title="平衡快排"></a>平衡快排</h3><p>每次尽可能地选择一个能够代表中值的元素作为关键数据，然后遵循普通快排的原则进行比较、替换和递归。通常来说，选择这个数据的方法是取开头、结尾、中间3个数据，通过比较选出其中的中值。取这3个值的好处是在实际问题中，出现近似顺序数据或逆序数据的概率较大，此时中间数据必然成为中值，而也是事实上的近似中值。万一遇到正好中间大两边小（或反之）的数据，取的值都接近最值，那么由于至少能将两部分分开，实际效率也会有2倍左右的增加，而且利于将数据略微打乱，破坏退化的结构。     </p><h3 id="外部快排"><a href="#外部快排" class="headerlink" title="外部快排"></a>外部快排</h3><p>与普通快排不同的是，关键数据是一段buffer，首先将之前和之后的M/2个元素读入buffer并对该buffer中的这些元素进行排序，然后从被排序数组的开头（或者结尾）读入下一个元素，假如这个元素小于buffer中最小的元素，把它写到最开头的空位上；假如这个元素大于buffer中最大的元素，则写到最后的空位上；否则把buffer中最大或者最小的元素写入数组，并把这个元素放在buffer里。保持最大值低于这些关键数据，最小值高于这些关键数据，从而避免对已经有序的中间的数据进行重排。完成后，数组的中间空位必然空出，把这个buffer写入数组中间空位。然后递归地对外部更小的部分，循环地对其他部分进行排序。       </p><h3 id="三路基数快排"><a href="#三路基数快排" class="headerlink" title="三路基数快排"></a>三路基数快排</h3><p>（Three-way Radix Quicksort，也称作Multikey Quicksort、Multi-key Quicksort）：结合了基数排序（radix sort，如一般的字符串比较排序就是基数排序）和快排的特点，是字符串排序中比较高效的算法。该算法被排序数组的元素具有一个特点，即multikey，如一个字符串，每个字母可以看作是一个key。算法每次在被排序数组中任意选择一个元素作为关键数据，首先仅考虑这个元素的第一个key（字母），然后把其他元素通过key的比较分成小于、等于、大于关键数据的三个部分。然后递归地基于这一个key位置对“小于”和“大于”部分进行排序，基于下一个key对“等于”部分进行排序。    </p><h2 id="堆排序【整个过程都是倒着来的】"><a href="#堆排序【整个过程都是倒着来的】" class="headerlink" title="堆排序【整个过程都是倒着来的】"></a>堆排序【整个过程都是倒着来的】</h2><p>堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于等于（或者大于等于）它的父节点。<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；<br>或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。          </p><p><strong>堆具有完全二叉树的概念：</strong><br>即：树的叶子节点必须从左向右依次补充！中间不能有空叶子！<br>用数组来表示一棵完全二叉树：       </p><pre class="line-numbers language-cpp"><code class="language-cpp">arry<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//不越界的情况下！ 【下角标从0开始】</span>i的左节点：<span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i的右节点：<span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>i的父节点：（i<span class="token number">-1</span>）<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>堆排序算法思想：</strong><br>将向量中存储的数据看成一棵完全二叉树，利用完全二叉树中双亲节点和孩子节点之间的内在关系选择关键字最小的记录。</p><ul><li>将待排序的序列构造成一个大顶堆【或小顶堆】，称为建堆的过程。</li><li>此时，整个序列的最大值【最小值】就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），即交换v[0],  v[n-1]</li><li>然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。</li><li>如此反复执行，直到交换v[0], v[1]。便能得到一个有序序列了。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232826228-214612324.png" alt=""></li></ul><h3 id="将一个数组中的数字按大根堆的顺序排列："><a href="#将一个数组中的数字按大根堆的顺序排列：" class="headerlink" title="将一个数组中的数字按大根堆的顺序排列："></a>将一个数组中的数字按大根堆的顺序排列：</h3><ol><li>换父节点：<br>遍历数组，比较array[i]与其父节点array[（i-1）/2 ]的大小，若大于父节点，则与父节点交换，并且同样向回比，比较父节点与祖父节点的大小，知道头部。。。。</li><li>换子节点：<br>在准备将数字加入树之前，与自己未来的孩子比较。<br>即，当array[i]准备入树时，找到自己的两个孩子，array[2<em>i+1],array[2</em>i+2],与孩子中最大的值进行比较，若自己小于孩子中的最大值，则交换!然后孩子继续与自己的孩子比较！</li></ol><h3 id="大根堆排序："><a href="#大根堆排序：" class="headerlink" title="大根堆排序："></a>大根堆排序：</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//向下调整</span><span class="token keyword">void</span> <span class="token function">downAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> L <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//i为父节点，j为左子节点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> R<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> R <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//若有右节点，且右节点大，那么就选右节点,即选取最大的子节点与父节点对比</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//选取了右节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//孩子节点都比父节点小，满足条件，无需调整</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//不满足的话，那么我就将最大孩子节点j与父节点i对调,</span>        <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i <span class="token operator">=</span> j<span class="token punctuation">;</span>        j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续向下遍历</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//建堆</span><span class="token keyword">void</span> <span class="token function">createHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>        <span class="token function">downAdjust</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">createHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//建堆</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从最后开始交换，直到只剩下最后一个数字</span>    <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//每次都将最大值放到最后</span>        <span class="token function">downAdjust</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将前0-i个数字重新构成大根堆</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小根堆排序："><a href="#小根堆排序：" class="headerlink" title="小根堆排序："></a>小根堆排序：</h3><p>与大根堆排序是一样的【但排序结果为从大到小排序】<br>只需要在downAdjust()中将父节点与子节点的大小比较改变一下   </p><h3 id="删除堆顶元素："><a href="#删除堆顶元素：" class="headerlink" title="删除堆顶元素："></a>删除堆顶元素：</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//删除堆顶元素</span><span class="token keyword">void</span> <span class="token function">deleteTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//也就是堆顶使用最后一个数值来替代</span>    <span class="token function">downAdjust</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//然后对前n-1个数进行排序</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加元素："><a href="#添加元素：" class="headerlink" title="添加元素："></a>添加元素：</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//向上调整</span><span class="token keyword">void</span>  <span class="token function">upAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span>  i <span class="token operator">=</span> R<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//i为欲调整结点，j为其父亲</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> L<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//父节点小了，那么就将孩子节点调上来</span>        <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> j<span class="token punctuation">;</span>            j <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续向上遍历</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token comment" spellcheck="true">//无需调整</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span>  x<span class="token punctuation">)</span><span class="token punctuation">{</span>    v<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将新加入的值放置在数组的最后，切记保证数组空间充足</span>    <span class="token function">upAdjust</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向上调整新加入的结点n</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。<br>它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。 当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n<em>log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n</em>log(n)), 如归并排序，堆排序）   </p><p>计数排序对输入的数据有附加的限制条件：</p><ol><li>输入的线性表的元素属于有限偏序集S；</li><li>设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。<br>在这两个条件下，计数排序的复杂性为O(n)。     </li></ol><p>找出待排序的数组中最大和最小的元素；<br>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；[计数]<br>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。[放出去一个，那么就计数减少一个]    </p><p>计数排序算法是一个稳定的排序算法。   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">CountSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> minN <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> maxN <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//找出最大值与最小值</span>    <span class="token punctuation">{</span>        minN <span class="token operator">=</span> minN <span class="token operator">&lt;</span> a <span class="token operator">?</span> minN <span class="token operator">:</span> a<span class="token punctuation">;</span>        maxN <span class="token operator">=</span> maxN <span class="token operator">></span> a <span class="token operator">?</span> maxN <span class="token operator">:</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">nums</span><span class="token punctuation">(</span>maxN <span class="token operator">-</span> minN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//以空间换取时间，用来计算每个数的数量</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span>        <span class="token operator">++</span>nums<span class="token punctuation">[</span>a <span class="token operator">-</span> minN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将数赋给原数组</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span>            v<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> minN<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。<br>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。   </p><p><strong>桶排序 (Bucket sort)的工作的原理：</strong><br>假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序  </p><p><strong>数据结构设计：</strong><br>链表可以采用很多种方式实现，通常的方法是动态申请内存建立结点，但是针对这个算法，桶里面的链表结果每次扫描后都不同，就有很多链表的分离和重建。如果使用动态分配内存，则由于指针的使用，安全性低。<br>所以，使用了数组来模拟链表（当然牺牲了部分的空间，但是操作却是简单了很多，稳定性也大大提高了）。共十个桶，所以建立一个二维数组，行向量的下标0—9代表了10个桶，每个行形成的一维数组则是桶的空间。     </p><p>平均情况下桶排序以线性时间运行。像基数排序一样，桶排序也对输入作了某种假设，因而运行得很快。具体来说，基数排序假设输入是由一个小范围内的整数构成，而桶排序则假设输入由一个随机过程产生，该过程将元素一致地分布在区间[0，1)上。 桶排序的思想就是把区间[0，1)划分成n个相同大小的子区间，或称桶，然后将n个输入数分布到各个桶中去。因为输入数均匀分布在[0，1)上，所以一般不会有很多数落在一个桶中的情况。为得到结果，先对各个桶中的数进行排序，然后按次序把各桶中的元素列出来即可。   </p><p>在桶排序算法的代码中，假设输入是含n个元素的数组A，且每个元素满足0≤ A[i]&lt;1。<br>另外还需要一个辅助数组B[O..n-1]来存放链表实现的桶，并假设可以用某种机制来维护这些表。   </p><p><strong>算法思想：</strong><br>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；<br>遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；<br>从不是空的桶里把排好序的数据拼接起来。<br>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232944991-274909653.png" alt=""></p><p>对N个关键字进行桶排序的时间复杂度分为两个部分：<br>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。<br>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为<code>∑ O(Ni*logNi)</code> 。  </p><p>其中Ni 为第i个桶的数据量。<br>很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到<code>O(N*logN)了)</code>。</p><p>因此，我们需要尽量做到下面两点：<br>(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。<br>(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。    当然，做到这一点很不容易，数据量巨大的情况下，f(k)   函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。  </p><p>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：<br><code>O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)</code><br>当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。<br>总结：桶排序的平均时间复杂度为线性的O(N+C)，其中<code>C=N*(logN-logM)</code>。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。当然桶排序的空间复杂度为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">BucketSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> minN <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> maxN <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//找出最大值与最小值</span>    <span class="token punctuation">{</span>        minN <span class="token operator">=</span> minN <span class="token operator">&lt;</span> a <span class="token operator">?</span> minN <span class="token operator">:</span> a<span class="token punctuation">;</span>        maxN <span class="token operator">=</span> maxN <span class="token operator">></span> a <span class="token operator">?</span> maxN <span class="token operator">:</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token function">bucket</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxN<span class="token operator">-</span>minN<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除数是按照数据范围进行调整的</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将数据放入对应的桶中</span>        bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>a <span class="token operator">-</span> minN<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucket<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token function">sort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分别对每个桶进行排序，可以使用任意的排序算法，个人感觉没必要使用复杂的排序算法</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> bucket<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将数据赋予原数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> b <span class="token operator">:</span> a<span class="token punctuation">)</span>            v<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序（radix sort）属于“分配式排序”（distribution sort），基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。   </p><p><strong>过程：</strong><br>取得数组中的最大数，并取得位数；<br>arr为原始数组，从最低位开始取每个位组成radix数组；<br>对radix进行计数排序（利用计数排序适用于小范围数的特点）；    </p><p>源数据：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233027963-1766286128.png" alt=""><br>第一次排序：【按个位数】<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233032416-1559345928.png" alt=""><br>还原：【底下的先出来】<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233042559-1408220568.png" alt=""><br>再排：【按十位数】<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233047290-1231896371.png" alt=""><br>再次还原：【底下的先出来】<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233052548-1962580255.png" alt=""></p><p><strong>最高位优先</strong>(Most Significant Digit first)法，简称MSD法：<br>先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。   </p><p><strong>最低位优先</strong>(Least Significant Digit first)法，简称LSD法：     先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//基数排序</span><span class="token keyword">void</span> <span class="token function">RadixSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> maxBit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最大的位数</span>    <span class="token keyword">int</span> bit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先从个位开始</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里我就偷懒直接使用string来转换</span>        maxBit <span class="token operator">=</span> maxBit <span class="token operator">></span> len <span class="token operator">?</span> maxBit <span class="token operator">:</span> len<span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxBit<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最大的数有多少位就进行多少次排序</span>    <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存放位数上数值相同的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span>            count<span class="token punctuation">[</span><span class="token punctuation">(</span>a <span class="token operator">%</span> <span class="token punctuation">(</span>bit <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">/</span> bit<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//按照第bit位上进行排序</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> count<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> b <span class="token operator">:</span> a<span class="token punctuation">)</span>                v<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将数据放回</span>        bit <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向前一位</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序算法总结："><a href="#排序算法总结：" class="headerlink" title="排序算法总结："></a>排序算法总结：</h2><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233123515-993860531.png" alt=""></p><ul><li>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233133750-173981905.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233155386-551809284.png" alt=""></li></ul><p>名词及数据解释：  </p><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li><li>log为log2</li><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ul><p>从算法的简单性来看，我们将7种算法分为两类：</p><ul><li>简单算法：冒泡、简单选择、直接插入。</li><li>改进算法：希尔、堆、归并、快速。</li><li>比较排序：快速排序、归并排序、堆排序、冒泡排序。</li></ul><p>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。<br>非比较排序：计数排序、基数排序、桶排序</p><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li></ul><p>所谓的稳定性：<br>就是维持相同数字在排序过程中的相对位置。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233225976-15046075.png" alt=""><br>是稳定的，以为111的相对位置未被打乱。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233229777-1913348815.png" alt=""><br>不是稳定的，因为555的相对位置打乱了。</p><p><strong>意义：</strong><br>在比较数据的属性时，比如年龄、身高、体重,若按身高排序，然后再按年龄排序，在稳定性下，相同年龄的两人会安上次身高的排序放置！！！</p><p><strong>怎么选用排序算法</strong></p><ul><li>在排序数据&lt;60时，会选择插入排序，当数据量很大时，先选择归并等算法，当数据分支小于60时，立马使用插入排序。</li><li>从空间复杂度来考虑：首选堆排序，其次是快速排序，最后是归并排序。</li><li>若从稳定性来考虑，应选取归并排序，因为堆排序和快速排序都是不稳定的。</li><li>若从平均情况下的排序速度考虑，应该选择快速排序。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;影响排序性能的要素：&quot;&gt;&lt;a href=&quot;#影响排序性能的要素：&quot; class=&quot;headerlink&quot; title=&quot;影响排序性能的要素：&quot;&gt;&lt;/a&gt;影响排序性能的要素：&lt;/h2&gt;&lt;p&gt;时间性能&lt;br&gt;辅助空间&lt;br&gt;算法的复杂度&lt;/p&gt;
&lt;h2 id=&quot;简单排
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.zzw1024.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="http://www.zzw1024.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>hash表详解</title>
    <link href="http://www.zzw1024.top/2019/12/23/hash-biao-xiang-jie/"/>
    <id>http://www.zzw1024.top/2019/12/23/hash-biao-xiang-jie/</id>
    <published>2019-12-23T01:59:35.000Z</published>
    <updated>2019-12-23T01:59:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表结构讲解："><a href="#哈希表结构讲解：" class="headerlink" title="哈希表结构讲解："></a>哈希表结构讲解：</h2><p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>记录的存储位置 = <strong>function(关键字)</strong><br>这里的对应关系function称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。   </p><p>哈希表hashtable(key，value)  就是把Key通过一个固定的算法函数function既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，<strong>取余</strong>结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。） 而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标 <strong>(仍通过映射哈希函数function)</strong> ，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。 </p><h2 id="Hash的应用："><a href="#Hash的应用：" class="headerlink" title="Hash的应用："></a>Hash的应用：</h2><ol><li><p>Hash主要用于信息安全领域中==加密算法==，它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做Hash值. 也可以说，Hash就是找到一种数据内容和数据存放地址之间的映射关系。</p></li><li><p>查找：<br>哈希表，又称为散列，是一种更加快捷的查找技术。我们之前的查找，都是这样一种思路：集合中拿出来一个元素，看看是否与我们要找的相等，如果不等，缩小范围，继续查找。而哈希表是完全另外一种思路：当我知道key值以后，我就可以直接计算出这个元素在集合中的位置，根本不需要一次又一次的查找！</p></li></ol><p>举一个例子，假如我的数组A中，第i个元素里面装的key就是i，那么数字3肯定是在第3个位置，数字10肯定是在第10个位置。哈希表就是利用利用这种基本的思想，建立一个从key到位置的函数，然后进行直接计算查找。</p><ol start="3"><li>Hash表在海量数据处理中有着广泛应用。</li></ol><h2 id="Hash的特点："><a href="#Hash的特点：" class="headerlink" title="Hash的特点："></a>Hash的特点：</h2><p>Hash Table的查询速度非常的快，几乎是==O(1) 的时间复杂度==。<br>hash就是找到一种数据内容和数据存放地址之间的映射关系。   </p><h3 id="散列法：元素特征转变为数组下标的方法。"><a href="#散列法：元素特征转变为数组下标的方法。" class="headerlink" title="散列法：元素特征转变为数组下标的方法。"></a>散列法：元素特征转变为数组下标的方法。</h3><p>我想大家都在想一个很严重的问题：“如果两个字符串在哈希表中对应的位置相同怎么办？”,毕竟一个数组容量是有限的，这种可能性很大。解决该问题的方法很多，我首先想到的就是用“链表”。我遇到的很多算法都可以转化成链表来解决，只要在<strong>哈希表的每个入口挂一个链表</strong>，保存所有对应的字符串就OK了。</p><h3 id="散列表的查找步骤-："><a href="#散列表的查找步骤-：" class="headerlink" title="散列表的查找步骤 ："></a>散列表的查找步骤 ：</h3><p>当存储记录时，通过散列函数计算出记录的散列地址<br>当查找记录时，我们通过同样的是散列函数计算记录的散列地址，并按此散列地址访问该记录   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//////////////////*********怎样判断一个数是否存在hash表中///////</span>即使用hash映射函数进行查找，当查找某个位置为空或者查找整个hash表完毕即表示该数不存在hash表中<span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token punctuation">(</span>x <span class="token operator">+</span> j <span class="token operator">*</span> j<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">]</span> <span class="token operator">==</span> x <span class="token operator">||</span> v<span class="token punctuation">[</span><span class="token punctuation">(</span>x <span class="token operator">+</span> j <span class="token operator">*</span> j<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//==0表示不存在，我就死在这点上了</span>     <span class="token keyword">break</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关键字——散列函数（哈希函数）——散列地址"><a href="#关键字——散列函数（哈希函数）——散列地址" class="headerlink" title="关键字——散列函数（哈希函数）——散列地址"></a>关键字——散列函数（哈希函数）——散列地址</h3><p><strong>优点</strong>：一对一的查找效率很高；</p><p><strong>缺点</strong>：一个关键字可能对应多个散列地址；需要查找一个范围时，效果不好。</p><p><strong>散列冲突</strong>：不同的关键字经过散列函数的计算得到了相同的散列地址。</p><p>==好的散列函数=计算简单+分布均匀（计算得到的散列地址分布均匀）m==</p><p>哈希表是种数据结构，它可以提供快速的插入操作和查找操作。 </p><h2 id="Hash优缺点："><a href="#Hash优缺点：" class="headerlink" title="Hash优缺点："></a>Hash优缺点：</h2><p><strong>优点：</strong><br>不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即O(1）的时间级。实际上，这只需要几条机器指令。</p><p>哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。</p><p>如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。</p><p><strong>缺点：</strong><br>它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。 </p><h2 id="常见的散列法："><a href="#常见的散列法：" class="headerlink" title="常见的散列法："></a>常见的散列法：</h2><p>元素特征转变为数组下标的方法就是散列法。散列法当然不止一种，下面列出三种比较常用的：</p><h3 id="1、除法【求余】散列法"><a href="#1、除法【求余】散列法" class="headerlink" title="1、除法【求余】散列法"></a>1、除法【求余】散列法</h3><p>最直观的一种，公式：<br><strong>index = value % 16</strong><br>学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。<br>一般哈希表的大小为素数，因为素数不存在因子，所以大大减少了位置冲突的概率</p><h3 id="2、MAD法"><a href="#2、MAD法" class="headerlink" title="2、MAD法"></a>2、MAD法</h3><p>除余法存在的不足<br>除余法虽能一定程度保证词条均匀分布，但从关键码空间到散列地址空间依然残留有一定的连续性，如 相邻关键码对应散列地址也相邻。<br>因此便有mad法，若常数ab选取得当，可以很好地克服除余法的这种连续性。除余法也可以看作Mad法a=1和b=0的特例，只是两个常数并未发挥实质作用。<br><img src="https://img-blog.csdnimg.cn/20191121225601879.jpg" alt=""><br>表达式:<br><strong>hash(key) = (a*key+b) % M</strong>， 其中M仍为素数,a&gt;0,b&gt;0，且a % M != 0</p><h3 id="3、数字分析法（selecting-digits）"><a href="#3、数字分析法（selecting-digits）" class="headerlink" title="3、数字分析法（selecting digits）"></a>3、数字分析法（selecting digits）</h3><p>注：<br>以下各方法为保证落在合法的散列地址空间上，最后通常还需对表长M取余。<br>思路:<br>从关键码key特定进制的展开中抽取特定的若干位，构成整型地址。<br>表达式:<br>例：选取key十进制展开中的奇数位<br><strong>hash(123456789) = 13579</strong>   </p><h3 id="4、平方取中法（mid-square）"><a href="#4、平方取中法（mid-square）" class="headerlink" title="4、平方取中法（mid-square）"></a>4、平方取中法（mid-square）</h3><p>思路:<br>从关键码key的平方的十进制或二进制展开中取居中的若干位，构成一个整型地址。<br>表达式:<br>例：取平方并用十进制展开中的居中3位作为散列地址<br><strong>123^2 = 15129，hash(123) = 512</strong>                  </p><h3 id="5、折叠法（folding）"><a href="#5、折叠法（folding）" class="headerlink" title="5、折叠法（folding）"></a>5、折叠法（folding）</h3><p>思路:<br>将关键码的十进制或二进制展开分割成等宽的若干段，取其总和作为散列地址。<br>表达式:<br>例：以十进制三个数位为分割单位<br><strong>hash(123456789) = 123+456+789 = 1368</strong>                       </p><h3 id="6、异或法（xor）"><a href="#6、异或法（xor）" class="headerlink" title="6、异或法（xor）"></a>6、异或法（xor）</h3><p>思路:<br>将关键码的二进制展开分割成等宽的若干段，经异或运算得到散列地址。<br>表达式:<br>例：以二进制三个数位为分割单位<br><strong>hash(411) = hash(110011011b) = 110^011^011 = 110b = 6</strong> </p><h3 id="7、平方散列法"><a href="#7、平方散列法" class="headerlink" title="7、平方散列法"></a>7、平方散列法</h3><p>求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：<br><strong>index = (value * value) &gt;&gt; 28</strong><br>（右移，除以2^28。记法：左移变大，是乘。右移变小，是除。）<br>如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的index都是0——非常失败。也许你还有个问题，value如果很大，value * value不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取index。</p><h3 id="8、斐波那契（Fibonacci）散列法"><a href="#8、斐波那契（Fibonacci）散列法" class="headerlink" title="8、斐波那契（Fibonacci）散列法"></a>8、斐波那契（Fibonacci）散列法</h3><p>平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。        </p><ol><li>对于16位整数而言，这个乘数是40503 </li><li>对于32位整数而言，这个乘数是2654435769 </li><li>对于64位整数而言，这个乘数是11400714819323198485</li></ol><p>这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,377, 610， 987, 1597, 2584, 4181, 6765, 10946，…。另外，斐波那契数列的值和太阳系八大行星的轨道半径的比例出奇吻合。</p><p>对我们常见的32位整数而言，公式：<br><strong>index = (value * 2654435769) &gt;&gt; 28</strong></p><p>如果用这种斐波那契散列法的话，那上面的图就变成这样了：<br><img src="https://img-blog.csdnimg.cn/20191121225628874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>注：用斐波那契散列法调整之后会比原来的取摸散列法好很多。      </p><p>适用范围:<br>快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。          </p><p>基本原理及要点:<br>hash函数选择，针对字符串，整数，排列，具体相应的hash方法。<br>碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。     </p><h2 id="散列冲突的解决方案："><a href="#散列冲突的解决方案：" class="headerlink" title="散列冲突的解决方案："></a>散列冲突的解决方案：</h2><ol><li><p>建立一个缓冲区，把凡是拼音重复的人放到缓冲区中。当我通过名字查找人时，发现找的不对，就在缓冲区里找。</p></li><li><p>进行再探测。就是在其他地方查找。探测的方法也可以有很多种。</p><ul><li><p>在找到查找位置的index的index-1，index+1位置查找，index-2，index+2查找，依次类推。这种方法称为线性再探测。</p><ul><li><p>在查找位置index周围随机的查找。称为随机在探测。</p></li><li><p>再哈希。就是当冲突时，采用另外一种映射方式来查找。</p></li></ul><p>这个程序中是通过取模来模拟查找到重复元素的过程。对待重复元素的方法就是再哈希：对当前key的位置+7。最后，可以通过全局变量来判断需要查找多少次。我这里通过依次查找26个英文字母的小写计算的出了总的查找次数。显然，当总的查找次数/查找的总元素数越接近1时，哈希表更接近于一一映射的函数，查找的效率更高。 </p></li></ul></li></ol><h2 id="哈希冲突解决办法："><a href="#哈希冲突解决办法：" class="headerlink" title="哈希冲突解决办法："></a>哈希冲突解决办法：</h2><p>冲突必然的!<br>因为用短位(散列地址空间)表示长位数据(关键码空间)，肯定会出现冲突。比如 常见的 MD5码，一共就128bit，但却要表示无限的数据的散列码，因此必然会出现不同数据具有相同MD5码的情况。<br>如果遇到冲突，哈希表一般是怎么解决的呢？具体方法有很多，百度也会有一堆，最常用的就是开发定址法和链地址法。</p><p>冲突排解策略分为以下两种类型：           </p><ol><li><p><strong>开放定址(open addressing) / 闭散列(closed hashing)：</strong><br> 散列地址空间对所有词条开放（即 桶单元允许装hash(key)不对应的词条）；词条存储地址(散列地址)仅限于散列表所覆盖的范围之内。<br> 如：线性试探、查找链法等。<br> 注：因闭散列不得使用附加空间的原因，装填因子通常&lt;=0.5     </p></li><li><p><strong>封闭定址(closed addressing) / 开散列(open hashing)：</strong><br> 散列地址空间只对对应的词条开放；词条存储地址不局限于散列表范围之内。<br> 如：多槽位法、独立链法、公共溢出区等</p></li></ol><h3 id="1、多槽位法（multiple-slots）"><a href="#1、多槽位法（multiple-slots）" class="headerlink" title="1、多槽位法（multiple slots）"></a>1、多槽位法（multiple slots）</h3><p>思路:<br><img src="https://img-blog.csdnimg.cn/20191121225802634.jpg" alt=""><br>每个桶本身再细分为若干槽位，用于存放彼此冲突的词条。每个桶槽位的词典结构为向量，因此整体物理存储结构类似于二维数组。             如：put操作，首先通过hash(key)定位到对应的桶单元，并在该桶内部槽位中进一步查找key，若没找到，则创建新词条插入到该桶的空闲槽位中。<br>缺点:      </p><ul><li>绝大多数的槽位都处于空闲状态，造成空间浪费。若桶被细分为k个槽位，则装填因子将直接降低为原来的1/k.</li><li>很难实现确定应该细分为多少个槽位，才能保证够用。</li></ul><h3 id="2、-独立链法-separate-chaining-拉链法"><a href="#2、-独立链法-separate-chaining-拉链法" class="headerlink" title="2、 独立链法(separate chaining) / 拉链法"></a>2、 独立链法(separate chaining) / 拉链法</h3><p>思路:<br><img src="https://img-blog.csdnimg.cn/20191121225828805.jpg" alt=""><br>与多槽位思想类似，但每个桶的子词典是使用链表实现，令彼此冲突的词条互相串接。<br><strong>优点：</strong><br>能灵活动态地调整子词典的规模，有效地使用空间。<br><strong>缺点:</strong><br>空间未必连续分布，会导致系统缓存失效。<br><img src="https://img-blog.csdnimg.cn/20191121225854306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="3、公共溢出区"><a href="#3、公共溢出区" class="headerlink" title="3、公共溢出区"></a>3、公共溢出区</h3><p>原理:<br><img src="https://img-blog.csdnimg.cn/20191121225934334.jpg" alt=""><br>在原散列表之外另设一个词典结构$D_{overflow}$，插入词条一旦发生冲突，则转存到该词典中。$D_{overflow}$相当于存放冲突词条的公共缓冲池。</p><h3 id="4-线性探查法-【Linear-Probing】"><a href="#4-线性探查法-【Linear-Probing】" class="headerlink" title="4.线性探查法 【Linear Probing】"></a>4.线性探查法 【Linear Probing】</h3><p>当得到key的hash值H(key)，但是表中下标为H(key)的位置已经被某个其他元素使用了，那么就检查下一个位置H(key) + 1 是否被占，如果没有，就使用这个位置；否则就继续检查下一个位置（也就是将hash值H(key)不断加1）。如果检查过程中超过了表长，那么就回到表的首位继续循环，直到找到一个可以使用的位置，或者是发现表中所有位置都已被使用。显然，这个做法容易导致扎堆，即表中连续若干个位置都被使用，这在一定程度上会降低效率。 </p><h3 id="5-采用平方探查法【Quadratic-Probing】"><a href="#5-采用平方探查法【Quadratic-Probing】" class="headerlink" title="5.采用平方探查法【Quadratic Probing】"></a>5.采用平方探查法【Quadratic Probing】</h3><p>通过将给定元素值对表长的余数作为在哈希表中的插入位置，如果出现冲突，采用平方探查法解决。平方探查法的具体过程是，假设给定元素值为a，表长为M，插入位置为a%M，假设a%M位置已有元素，即发生冲突，则查找<br>(a+1^2)%M，(a-1^2)%M，   (a+2^2)%M，(a-2^2)%M，⋯⋯，   (a+k^2)%M，(a-k^2)%M直至查找到一个可进行插入的位置，否则当查找到(a+k^2)%M，(a-k^2)%M仍然不能插入则该元素插入失败。其中 k&lt;=M/2 【有的是k&lt;M】  </p><p>此方法中，hashtable的大小为素数</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="具体查找逻辑"><a href="#具体查找逻辑" class="headerlink" title="具体查找逻辑"></a>具体查找逻辑</h3><p>查找链(probing chain)：对于待查找的key，从hash(key)桶单元开始，直接空桶结束的顺序序列。       </p><ol><li>经hash(key)算得的当前桶单元，若关键码相等，则成功返回。      </li><li>当前桶单元非空，但关键码不等，则转入下一桶单元继续试探。         </li><li>当前桶为空，则返回查找失败。             </li></ol><p><strong>注：</strong><br>相互冲突的关键码比属于同一查找链（即中途不包含空桶），但同一查找链的关键码未必相互冲突。多组各自冲突的关键码所对应的查找链，有可能相互交织和重叠。<br><strong>优点：</strong><br>具体由良好的数据局部性，试探地桶单元在物理空间上依次连贯，系统缓存能发挥作用。</p><h3 id="懒惰删除："><a href="#懒惰删除：" class="headerlink" title="懒惰删除："></a>懒惰删除：</h3><p>定义：<br>从词典删除词条时，暂时并不实际将桶置空，而是额外维护一个删除标记Bitmap，标记该桶已删除。<br>为什么需要懒惰删除？<br>因为查找链中任何一环的缺失，都会导致后续词条的“丢失”，即无法找到已存在词条；同时因为开销问题，不可能每次删除操作都对查找链进行维护重建（在扩容时，才重建链）。<br>因此懒惰删除机制既能保证查找链的完整，也不需要太多开销。<br>加入懒惰删除后，操作逻辑的变化：         </p><ol><li>在删除等操作查询指定词条时，判断失败的条件变为：为空且不带懒惰删除标记。           </li><li>在插入操作时，找空桶过程中，判断桶为空条件为：带有懒惰标记或当前桶为空。        </li></ol><h3 id="d-left-hashing："><a href="#d-left-hashing：" class="headerlink" title="d-left hashing："></a>d-left hashing：</h3><p>其中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。<br>2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同 时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个 位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key 存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。 </p><h3 id="问题实例（海量数据处理）"><a href="#问题实例（海量数据处理）" class="headerlink" title="问题实例（海量数据处理）"></a>问题实例（海量数据处理）</h3><p>我们知道hash 表在海量数据处理中有着广泛的应用，下面，请看另一道百度面试题：<br>题目：海量日志数据，提取出某日访问百度次数最多的那个IP。<br>方案：IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。           </p><h2 id="hash-map的使用："><a href="#hash-map的使用：" class="headerlink" title="hash_map的使用："></a>hash_map的使用：</h2><p>hash函数系统自带的类型函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">></span> <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token operator">></span><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">short</span><span class="token operator">></span><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">></span> <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span> <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通的hash使用：  </p><pre class="line-numbers language-cpp"><code class="language-cpp">hash_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>map1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自定义hash函数的使用：</p><pre class="line-numbers language-cpp"><code class="language-cpp">hash_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token punctuation">,</span> hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> equal_to<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> mymap<span class="token punctuation">;</span> hash函数的自定义与默认函数：<span class="token keyword">struct</span> str_hash<span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//自写hash函数    </span>     size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token keyword">const</span>       <span class="token punctuation">{</span>           <span class="token keyword">unsigned</span> <span class="token keyword">long</span> __h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                     __h <span class="token operator">=</span> <span class="token number">107</span><span class="token operator">*</span>__h <span class="token operator">+</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token function">size_t</span><span class="token punctuation">(</span>__h<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// struct str_hash</span><span class="token comment" spellcheck="true">// {    //自带的string hash函数   </span><span class="token comment" spellcheck="true">//          size_t operator()(const string&amp; str) const    </span><span class="token comment" spellcheck="true">//          {  </span><span class="token comment" spellcheck="true">//                   return __stl_hash_string(str.c_str());  </span><span class="token comment" spellcheck="true">//          }    </span><span class="token comment" spellcheck="true">// };</span><span class="token comment" spellcheck="true">//  struct hash&lt;int> </span><span class="token comment" spellcheck="true">//  {        //自带的int hash函数   </span><span class="token comment" spellcheck="true">//     size_t operator()(int __x) const { return __x; }</span><span class="token comment" spellcheck="true">// }; </span><span class="token keyword">struct</span> str_equal  <span class="token comment" spellcheck="true">//即压入数据时，去重的比较函数</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//string 判断相等函数  </span>     <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token keyword">const</span>       <span class="token punctuation">{</span>                 <span class="token keyword">return</span> s1<span class="token operator">==</span>s2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span> 注意hash函数只指的是第一个元素类型 hash_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span>str_hash<span class="token punctuation">,</span>str_equal<span class="token operator">></span> map2<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="hash-map的案例——布隆过滤器"><a href="#hash-map的案例——布隆过滤器" class="headerlink" title="hash_map的案例——布隆过滤器"></a>hash_map的案例——布隆过滤器</h2><p>不安全网页的黑名单包含100亿个黑名单网页，每个网页的URL最多占用64B。现在想要实现一种网页过滤系统，可以根据网页的URL判断该网页是否在黑名单上，请设计该系统。<br>要求如下：            </p><ul><li>该系统允许有万分之一以下的判断失误率。         </li><li>使用的额外空间不要超过30GB。            </li><li>如果将这100亿个URL通过数据库或哈希表保存起来，就可以对每条URL进行查询，但是每个URL有64B，数量是100亿个，所以至少需要640GB的空间，不满足要求2。         </li></ul><p>如果面试者遇到网页黑名单系统、垃圾邮件过滤系统，爬虫的网页判重系统等题目，又看到系统容忍一定程度的失误率，但是对空间要求比较严格，那么很可能是面试官希望面试者具备布隆过滤器的知识。一个布隆过滤器精确地代表一个集合，并可以精确判断一个元素是否在集合中。注意，只是精确代表和精确判断，到底有多精确呢？则完全在于你具体的设计，但想做到完全正确是不可能的。布隆过滤器的优势就在于使用很少的空间就可以将准确率做到很高的程度。该结构由Burton Howard Bloom于1970年提出。  </p><p>那么什么是布隆过滤器呢？</p><p>假设有一个长度为m的bit类型的数组，即数组的每个位置只占一个bit，如果我们所知，每一个bit只有0和1两种状态，如图所示：<br><img src="https://img-blog.csdnimg.cn/20191121230117995.jpg" alt=""></p><p>再假设一共有k个哈希函数，这些函数的输出域S都大于或等于m，并且这些哈希函数都足够优秀且彼此之间相互独立（将一个哈希函数的计算结果乘以6除以7得出的新哈希函数和原函数就是相互独立的）。那么对同一个输入对象（假设是一个字符串，记为URL），经过k个哈希函数算出来的结果也是独立的。可能相同，也可能不同，但彼此独立。对算出来的每一个结果都对m取余（%m），然后在bit array 上把相应位置设置为1（我们形象的称为涂黑）。如图所示<br><img src="https://img-blog.csdnimg.cn/20191121230129649.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>我们把bit类型的数组记为bitMap。至此，一个输入对象对bitMap的影响过程就结束了，也就是bitMap的一些位置会被涂黑。接下来按照该方法，处理所有的输入对象（黑名单中的100亿个URL）。每个对象都可能把bitMap中的一些白位置涂黑，也可能遇到已经涂黑的位置，遇到已经涂黑的位置让其继续为黑即可。处理完所有的输入对象后，可能bitMap中已经有相当多的位置被涂黑。至此，一个布隆过滤器生成完毕，这个布隆过滤器代表之前所有输入对象组成的集合。 </p><p>那么在检查阶段时，如何检查一个对象是否是之前的某一个输入对象呢（判断一个URL是否是黑名单中的URL）？假设一个对象为a，想检查它是否是之前的输入对象，就把a通过k个哈希函数算出k个值，然后把k个值都取余（%m），就得到在[0,m-1]范围伤的k个值。接下来在bitMap上看这些位置是不是都为黑。如果有一个不为黑，说明a一定不再这个集合里。如果都为黑，说明a在这个集合里，但可能误判。<br>再解释具体一点，如果a的确是输入对象 ，那么在生成布隆过滤器时，bitMap中相应的k个位置一定已经涂黑了，所以在检查阶段，a一定不会被漏过，这个不会产生误判。会产生误判的是，a明明不是输入对象，但如果在生成布隆过滤器的阶段因为输入对象过多，而bitMap过小，则会导致bitMap绝大多数的位置都已经变黑。那么在检查a时，可能a对应的k个位置都是黑的，从而错误地认为a是输入对象（即是黑名单中的URL）。通俗地说，布隆过滤器的失误类型是“宁可错杀三千，绝不放过一个”。</p><p>布隆过滤器到底该怎么生成呢？只需记住下列三个公式即可：<br>对于输入的数据量n（这里是100亿）和失误率p（这里是万分之一），布隆过滤器的大小<br>m：m = - (n*lnp)/(ln2*ln2)，计算结果向上取整（这道题m=19.19n，向上取整为20n，即需要2000亿个bit，也就是25GB）<br>需要的哈希函数的个数k：k = ln2 * m/n = 0.7 * m/n（这道题k = 0.7 * 20n/n = 14）<br>由于前两步都进行了向上取整，那么由前两步确定的布隆过滤器的真正失误率p：p = (1 - e^(-nk/m))^k </p><h2 id="一致性哈希算法的基本原理"><a href="#一致性哈希算法的基本原理" class="headerlink" title="一致性哈希算法的基本原理"></a>一致性哈希算法的基本原理</h2><p><strong>题目</strong></p><p>工程师常使用服务器集群来设计和实现数据缓存，以下是常见的策略：<br>无论是添加、查询还是珊瑚数据，都先将数据的id通过哈希函数换成一个哈希值，记为key<br>如果目前机器有N台，则计算key%N的值，这个值就是该数据所属的机器编号，无论是添加、删除还是查询操作，都只在这台机器上进行。<br>请分析这种缓存策略可能带来的问题，并提出改进的方案。      </p><p><strong>解析</strong>    </p><p>题目中描述的缓存从策略的潜在问题是，如果增加或删除机器时（N变化）代价会很高，所有的数据都不得不根据id重新计算一遍哈希值，并将哈希值对新的机器数进行取模啊哦做。然后进行大规模的数据迁移。<br>为了解决这些问题，下面介绍一下一致性哈希算法，这时一种很好的数据缓存设计方案。我们假设数据的id通过哈希函数转换成的哈希值范围是2^32，也就是0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形，那么一个数据id在计算出哈希值之后认为对应到环中的一个位置上，如图所示<br><img src="https://img-blog.csdnimg.cn/20191121230147583.jpg" alt=""></p><p>接下来想象有三台机器也处在这样一个环中，这三台机器在环中的位置根据机器id（主机名或者主机IP，是主机唯一的就行）设计算出的哈希值对2^32取模对应到环上。那么一条数据如何确定归属哪台机器呢？我们可以在该数据对应环上的位置顺时针寻找离该位置最近的机器，将数据归属于该机器上:<br><img src="https://img-blog.csdnimg.cn/2019112123020021.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=" "></p><p>这样的话，如果删除machine2节点，则只需将machine2上的数据迁移到machine3上即可，而不必大动干戈迁移所有数据。当添加节点的时候，也只需将新增节点到逆时针方向新增节点前一个节点这之间的数据迁移给新增节点即可。 </p><p>但这时还是存在如下两个问题：</p><p>机器较少时，通过机器id哈希将机器对应到环上之后，几个机器可能没有均分环<br><img src="https://img-blog.csdnimg.cn/20191121230241965.jpg" alt=""><br>那么这样会导致负载不均。</p><p>增加机器时，可能会打破现有的平衡：<br><img src="https://img-blog.csdnimg.cn/2019112123025041.jpg" alt=""> </p><p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一台机器通过不同的哈希函数计算出多个哈希值，对多个位置都放置一个服务节点，称为虚拟节点。</p><p>具体做法：比如对于machine1的IP192.168.25.132（或机器名），计算出192.168.25.132-1、192.168.25.132-2、192.168.25.132-3、192.168.25.132-4的哈希值，然后对应到环上，其他的机器也是如此，这样的话节点数就变多了，根据哈希函数的性质，平衡性自然会变好：<br><img src="https://img-blog.csdnimg.cn/20191121230259813.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>此时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，比如上图的查找表。当某一条数据计算出归属于m2-1时再根据查找表的跳转，数据将最终归属于实际的m1节点。</p><p>基于一致性哈希的原理有很多种具体的实现，包括Chord算法、KAD算法等，有兴趣的话可以进一步学习。</p><h2 id="RandomPool"><a href="#RandomPool" class="headerlink" title="RandomPool"></a>RandomPool</h2><p>设计一种结构，在该结构中有如下三个功能：        </p><ul><li>inserrt(key)：将某个key加入到该结构中，做到不重复加入。          </li><li>delete(key)：将原本在结构中的某个key移除。    </li><li>getRandom()：等概率随机返回结构中的任何一个key。<br>要求：insert、delete和getRandom方法的时间复杂度都是O(1)<br>思路：使用两个哈希表和一个变量size，一个表存放某key的标号，另一个表根据根据标号取某个key。size用来记录结构中的数据量。加入key时，将size作为该key的标号加入到两表中；删除key时，将标号最大的key替换它并将size–；随机取key时，将size范围内的随机数作为标号取key。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">RandomPool</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span>T <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">getPrint</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">getPrint</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>hash_map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>KeyMap<span class="token punctuation">;</span>hash_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span>IndexMap<span class="token punctuation">;</span><span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RandomPool<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>KeyMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> KeyMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>KeyMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size<span class="token punctuation">;</span>IndexMap<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"add succeed!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"add filed!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RandomPool<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">del</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">auto</span> ptr <span class="token operator">=</span> KeyMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> KeyMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete filed! there is not exsite the key!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//交换查找到元素与最后一个元素</span>T temp <span class="token operator">=</span> IndexMap<span class="token punctuation">[</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最后一个元素的关键词,同时将hash表中的元素删除了</span><span class="token keyword">int</span> index <span class="token operator">=</span> KeyMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//要删除元素的位置</span>KeyMap<span class="token punctuation">[</span>temp<span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">;</span>IndexMap<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将最后一个元素替换要删除元素的位置</span><span class="token comment" spellcheck="true">//正式删除</span>KeyMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>IndexMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>IndexMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>T RandomPool<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the map is empty!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">99</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">99</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//随机生成一个位置</span><span class="token keyword">return</span> IndexMap<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RandomPool<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">getPrint</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>KeyMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> KeyMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the key is not exsite!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> KeyMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RandomPool<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">getPrint</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>IndexMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">==</span> IndexMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the key is not exsite!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> IndexMap<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>code <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"lang-java"</span><span class="token operator">></span>import java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RandomPool</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">public</span> HashMap<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Integer<span class="token operator">></span> keySignMap<span class="token punctuation">;</span><span class="token keyword">public</span> HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Object<span class="token operator">></span> signKeyMap<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">RandomPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keySignMap <span class="token operator">=</span> <span class="token keyword">new</span> HashMap<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>signKeyMap <span class="token operator">=</span> <span class="token keyword">new</span> HashMap<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//不重复添加</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>keySignMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    keySignMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    signKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>keySignMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object lastKey <span class="token operator">=</span> signKeyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">--</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> deleteSign <span class="token operator">=</span> keySignMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        keySignMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>lastKey<span class="token punctuation">,</span> deleteSign<span class="token punctuation">)</span><span class="token punctuation">;</span>        signKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>deleteSign<span class="token punctuation">,</span> lastKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        keySignMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        signKeyMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> Object <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> signKeyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="认识一致性哈希"><a href="#认识一致性哈希" class="headerlink" title="认识一致性哈希"></a>认识一致性哈希</h2><p>使用二分法，找到hash值大于等于该值的hash值的服务器即为管理该值的服务器<br>一致性哈希的应用：<br>当我们要添加或减少服务器时，一般操作是将已存的值重新计算hash值，然后取mod，来决定管理该数据的服务器，代价太高，时间太长</p><p>于是使用一个环来减少操作：<br>将hash范围组成一个环，如图所示，然后将服务器按其hash值按顺序数组中，<br>然后每输入一个数据，根据其hash值，使用二分法将其放入刚刚&gt;=该数hash值的服务器。<br>当添加服务器时，【假如添加一个服务器mx在m1-m2之间】只需要将原m1-m2中一部分小于mx的数据改为有mx来管理。<br>如何确保服务器负载均衡【因为服务器的hash值不均匀】？<br>使用一致hash<br>将每个服务器产生N个虚拟服务器，如1000个，则有3个服务器就有3000个虚拟服务器，然后让3000个虚拟去负载整个hash范围，那么这三个服务器的虚拟服务器所管理的数据就几乎均分分布在整个hash域中<br>那么就认为这3个服务器的负载均衡。<br>添加与删除原理也是如此。              </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;哈希表结构讲解：&quot;&gt;&lt;a href=&quot;#哈希表结构讲解：&quot; class=&quot;headerlink&quot; title=&quot;哈希表结构讲解：&quot;&gt;&lt;/a&gt;哈希表结构讲解：&lt;/h2&gt;&lt;p&gt;哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.zzw1024.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="hash" scheme="http://www.zzw1024.top/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://www.zzw1024.top/2019/12/22/hong-hei-shu/"/>
    <id>http://www.zzw1024.top/2019/12/22/hong-hei-shu/</id>
    <published>2019-12-22T15:44:03.000Z</published>
    <updated>2019-12-22T15:44:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>红黑树的起源，自然是二叉查找树了，这种树结构从根节点开始，左子节点小于它，右子节点大于它。每个节点都符合这个特性，所以易于查找，是一种很好的数据结构。但是它有一个问题，就是容易偏向某一侧，这样就像一个链表结构了，失去了树结构的优点，查找时间会变坏。</p><p>所以我们都希望树结构都是矮矮胖胖的，像这样：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232256511-1770822469.png" alt=""></p><p>而不是像这样：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232306279-1089139086.png" alt=""></p><p>在这种需求下，平衡树（AVL）的概念就应运而生了。<br>红黑树就是一种平衡树，它可以保证二叉树基本符合矮矮胖胖的结构，但是理解红黑树之前，必须先了解另一种树，叫2-3树，红黑树背后的逻辑就是它。</p><p>好吧来看2-3树吧。<br>2-3树是二叉查找树的变种，树中的2和3代表两种节点，以下表示为2-节点和3-节点。<br>2-节点即普通节点：包含一个元素，两条子链接。<br>3-节点则是扩充版，包含2个元素和三条链接：两个元素A、B，左边的链接指向小于A的节点，中间的链接指向介于A、B值之间的节点，右边的链接指向大于B的节点。<br>2-节点：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232349973-1733377438.png" alt=""><br>3-节点：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232431538-1959600684.png" alt=""></p><p>在这两种节点的配合下，2-3树可以保证在插入值过程中，任意叶子节点到根节点的距离都是相同的。完全实现了矮胖矮胖的目标。怎么配合的呢，下面来看2-3树的构造过程。<br>所谓构造，就是从零开始一个节点一个节点的插入。<br>在二叉查找树中，插入过程从根节点开始比较，小于节点值往右继续与左子节点比，大于则继续与右子节点比，直到某节点左或右子节点为空，把值插入进去。这样无法避免偏向问题。在2-3树中，插入的过程是这样的。<br>如果将值插入一个2-节点，则将2-节点扩充为一个3-节点。<br>如果将值插入一个3-节点，分为以下几种情况。</p><p>(1).3-节点没有父节点，即整棵树就只有它一个三节点。此时，将3-节点扩充为一个4-节点，即包含三个元素的节点，然后将其分解，变成一棵二叉树。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232507203-1019263925.png" alt=""><br>此时二叉树依然保持平衡。   </p><p>(2).3-节点有一个2-节点的父节点，此时的操作是，3-节点扩充为4-节点，然后分解4-节点，然后将分解后的新树的父节点融入到2-节点的父节点中去。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232523136-1704921855.png" alt=""></p><p>(3).3-节点有一个3-节点的父节点，此时操作是：3-节点扩充为4-节点，然后分解4-节点，新树父节点向上融合，上面的3-节点继续扩充，融合，分解，新树继续向上融合，直到父节点为2-节点为止，如果向上到根节点都是3-节点，将根节点扩充为4-节点，然后分解为新树，至此，整个树增加一层，仍然保持平衡。   </p><p>第三种情况稍微复杂点，为了便于直观理解，现在我们从零开始构建2-3树，囊括上面所有的情况，看完所以步骤后，你也可以自己画一画。</p><p>我们将{7,8,9,10,11,12}中的数值依次插入2-3树，画出它的过程：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232557632-860740846.png" alt=""></p><p>所以，2-3树的设计完全可以保证二叉树保持矮矮胖胖的状态，保持其性能良好。但是，将这种直白的表述写成代码实现起来并不方便，因为要处理的情况太多。这样需要维护两种不同类型的节点，将链接和其他信息从一个节点复制到另一个节点，将节点从一种类型转换为另一种类型等等。</p><p>因此，红黑树出现了，红黑树的背后逻辑就是2-3树的逻辑，但是由于用红黑作为标记这个小技巧，最后实现的代码量并不大。(但是，要直接理解这些代码是如何工作的以及背后的道理，就比较困难了。所以你一定要理解它的演化过程，才能真正的理解红黑树)</p><p>我们来看看红黑树和2-3树的关联，首先，最台面上的问题，红和黑的含义。红黑树中，所有的节点都是标准的2-节点，为了体现出3-节点，这里将3-节点的两个元素用左斜红色的链接连接起来，即连接了两个2-节点来表示一个3-节点。这里红色节点标记就代表指向其的链接是红链接，黑色标记的节点就是普通的节点。</p><p>所以才会有那样一条定义，叫“从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点”，因为红色节点是可以与其父节点合并为一个3-节点的，红黑树实现的其实是一个完美的黑色平衡，如果你将红黑树中所有的红色链接放平，那么它所有的叶子节点到根节点的距离都是相同的。所以它并不是一个严格的平衡二叉树，但是它的综合性能已经很优秀了。</p><p>借一张别人的图来看：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232626189-455918211.png" alt=""></p><p>红链接放平：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232643426-1761684491.png" alt=""></p><p>所以，红黑树的另一种定义是满足下列条件的二叉查找树：</p><ol><li>链接均为左链接。</li><li>没有任何一个结点同时和两条红链接相连。(这样会出现4-节点)</li><li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li></ol><h1 id="红黑树（一）——基本概念"><a href="#红黑树（一）——基本概念" class="headerlink" title="红黑树（一）——基本概念"></a>红黑树（一）——基本概念</h1><h2 id="1-红黑树基本特性"><a href="#1-红黑树基本特性" class="headerlink" title="1. 红黑树基本特性"></a>1. 红黑树基本特性</h2><h3 id="1-1-红黑树定义"><a href="#1-1-红黑树定义" class="headerlink" title="1.1 红黑树定义"></a>1.1 红黑树定义</h3><p>红黑树是一种特殊的二叉树，且必须要满足以下几个特性：  </p><ol><li>每个节点或是黑色或是红色 </li><li>根节点是黑色 </li><li>每个叶节点是黑色（叶节点为空节点） </li><li>如果一个节点是红色，则它的两个子节点必须是黑色 </li><li>从任意的一个节点到该节点的所有叶节点的路径包含相同数目的黑色节点</li><li>红黑树是一种平衡二叉树，当不是完全的平衡二叉树，红黑树只要求最多三次旋转来尽可能达到平衡    【也就是说没有规定左子树与右子树的高度差必须&lt;=1!!!!!!】</li></ol><h3 id="1-2-红黑树时间复杂度"><a href="#1-2-红黑树时间复杂度" class="headerlink" title="1.2 红黑树时间复杂度"></a>1.2 红黑树时间复杂度</h3><p>定理：红黑树的时间复杂度为0（log2n）。<br>定义：   </p><ol><li>h（v）为以节点v为根节点的子树的高度。   </li><li>bh（v）为从节点v到其子树叶节点路径中黑色节点的数量。  </li></ol><p>根据特性5可知，bh（v）是唯一值。<br>又根据特性4可知，从一个节点到其叶节点路径上的黑色节点数目≥路径上的红色节点数目。也就是说h（x）≤2bh（x）</p><p>引理：以v为根节点的红黑树，至少有2bh（v）-1 个内部节点。<br>使用数学归纳法证明引理：</p><ol><li>当树的高度h=0时，内部节点个数为0，bh（v）=0，则2bh（v）-1=0，显然满足内部节点个数≥2bh（v）-1.</li><li>当h&gt;0，且当h-1时，包含的内部节点数至少为2bh（v）-1-1，<br>那么对于根节点x，其左子树的内部节点个数至少为2bh（v）-1-1，其右子节点的内部节点个数至少为2bh（v）-1-1，则高度为h，内部节点个数至少为（2bh（v）-1-1）+（2hb（v）-1-1）+1=2bh（v）-1。引理得证。</li></ol><p>根据引理可以得出，一个节点数为n的红黑树，bh（v）≤log2（n+1）。又因为h（x）≤2bh（x），可得，h≤2log2（n+1）。<br><strong>（结论1）</strong>红黑树是一种特殊的二又树，对于有n个节点的二又树而言，当其为满二又树时，树的高度最小。</p><p>满二又树的节点数量与高度的关系为n=2h-1。<br>那么可以得出，h≥log2（n+1）。<br><strong>（结论2）</strong>由结论1和结论2可知，log2（n+1）≤h≤2log2（n+1）。<br>所以，红黑树的时间复杂度为：0（log2n）   </p><h3 id="1-3-节点结构定义"><a href="#1-3-节点结构定义" class="headerlink" title="1.3  节点结构定义"></a>1.3  节点结构定义</h3><p>红黑树的节点结构与一般的二叉树类似，但是多了一个标记颜色的变量。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> RBTColor<span class="token punctuation">{</span>RED<span class="token punctuation">,</span> BLACK<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">RBTNode</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    RBTColor color<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 颜色</span>    T key<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 关键字(键值)</span>    RBTNode <span class="token operator">*</span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左孩子</span>    RBTNode <span class="token operator">*</span>right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右孩子</span>    RBTNode <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 父结点</span>    <span class="token function">RBTNode</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> RBTColor c<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>p<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>l<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token function">key</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">color</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">left</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">right</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-红黑树旋转操作"><a href="#2-红黑树旋转操作" class="headerlink" title="2. 红黑树旋转操作"></a>2. 红黑树旋转操作</h2><p>红黑树的旋转操作目的是在插入或删除节点后，尽可能的保持红黑树的特性。旋转操作分为左旋和右旋。</p><h3 id="2-1-左旋操作"><a href="#2-1-左旋操作" class="headerlink" title="2.1 左旋操作"></a>2.1 左旋操作</h3><p>左旋操作效果如图所示。左旋操作会使当前节点与其右子节点位置互换。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232959347-1985378619.png" alt=""></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">leftRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 设置x的右孩子为y</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>y <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的左孩子” 设为 “x的右孩子”；</span><span class="token comment" spellcheck="true">// 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    y<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的父亲” 设为 “y的父亲”</span>y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    root <span class="token operator">=</span> y<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “x的父亲” 是空节点，则将y设为根节点</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> x<span class="token punctuation">)</span>        x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span>    <span class="token keyword">else</span>        x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将 “x” 设为 “y的左孩子”</span>y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将 “x的父节点” 设为 “y”</span>x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-右旋操作"><a href="#2-2-右旋操作" class="headerlink" title="2.2 右旋操作"></a>2.2 右旋操作</h3><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233024036-941160549.png" alt=""><br>右旋操作效果如图所示。右旋操作会使当前节点与其左子节点位置互换。 </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">rightRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 设置x是当前节点的左孩子。</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的右孩子” 设为 “y的左孩子”；</span><span class="token comment" spellcheck="true">// 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”</span>y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    x<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的父亲” 设为 “x的父亲”</span>x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    root <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “y的父亲” 是空节点，则将x设为根节点</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>        y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”</span>    <span class="token keyword">else</span>        y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将 “y” 设为 “x的右孩子”</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将 “y的父节点” 设为 “x”</span>y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本篇文章主要介绍了红黑树的基本概念，包括红黑树的定义、时间复杂度及其证明、节点定义和旋转操作。 </p><h1 id="红黑树（二）——数据操作"><a href="#红黑树（二）——数据操作" class="headerlink" title="红黑树（二）——数据操作"></a>红黑树（二）——数据操作</h1><h2 id="1-查找"><a href="#1-查找" class="headerlink" title="1. 查找"></a>1. 查找</h2><p>红黑树的查找方式很简单，是一个递归过程。如果查找的元素小于当前节点，那么查找其左子树；如果查找的元素大于当前元素，则查找其右子树。查找的时间复杂度为O(log2n)。</p><h2 id="2-插入"><a href="#2-插入" class="headerlink" title="2. 插入"></a>2. 插入</h2><p>（图例：C表示当前节点，P表示父节点，U表示叔节点，G表示祖父节点）</p><p>插入操作首先需要通过查找操作找到合适的插入点，然后插入新节点。如果在插入节点后，发生了违背红黑树特性的情况时，需要对红黑树进行旋转染色等操作，使其重新满足特性。</p><h3 id="2-1-插入新节点"><a href="#2-1-插入新节点" class="headerlink" title="2.1 插入新节点"></a>2.1 插入新节点</h3><p><strong>第一步:</strong><br>将红黑树当作一颗二叉查找树，将节点插入。<br>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。</p><p><strong>第二步：</strong><br>将插入的节点着色为”红色”。<br>为什么着色成红色，而不是黑色呢？为什么呢？我们需要重新温习一下红黑树的特性：</p><ul><li>(1) 每个节点或者是黑色，或者是红色。</li><li>(2) 根节点是黑色。</li><li>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</li><li>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。</li><li>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ul><p>将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。</p><p><strong>第三步:</strong><br>通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。<br>第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>对于”特性(4)”，是有可能违背的！<br>那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* * 将结点插入到红黑树中** 参数说明：*     root 红黑树的根结点*     node 插入的结点        */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span><span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    y <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;</span> x<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>        x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token keyword">else</span>        x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span><span class="token punctuation">}</span>    node<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;</span> y<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>        y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">else</span>        y<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span>    root <span class="token operator">=</span> node<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 2. 设置节点的颜色为红色</span>node<span class="token operator">-</span><span class="token operator">></span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3. 将它重新修正为一颗二叉查找树</span><span class="token function">insertFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-调整子树"><a href="#2-2-调整子树" class="headerlink" title="2.2 调整子树"></a>2.2 调整子树</h3><p>那么，在违反了特性4的时候，新节点的父节点为红色节点。根据特性2可知，父节点不是根节点，则新节点必有祖父节点。<br>又根据特性3可推论出红色节点必有两个黑色子节点（空节点为黑色）。<br>此时会出现两种情况：叔节点为红色、叔节点为黑色。   </p><p>####（1）父节点与叔节点都为红色的情况<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233221783-1425102515.png" alt=""></p><p>在这种情况下，需要将父节点和叔节点变为黑色，再将祖父节点变为红色。这样，图上所展示的子树就满足了红黑树的特性。如下图所示。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233244262-855036277.png" alt=""><br>但是这里又可能会产生新的违法特性情况，因为祖父节点变成了红色，那么它可能会造成违反特性4的情况。所以，这里就将祖父节点作为当前节点，进行新一轮的调整操作。</p><p>####（2）父节点为红色, 叔节点为黑色的情况<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233302841-610895399.png" alt=""></p><p>在这种情况下，对其调整的核心就是保持父节点分支符合特性4，而叔节点分支保持符合特性5。<br><strong>第一步，旋转。</strong><br>对祖父节点进行左旋或者右旋。如果父节点是祖父节点的右子节点，那么对祖父节点进行左旋；否则，对祖父节点进行右旋。 </p><p><strong>第二步，染色。</strong><br>将祖父节点染为红色，而父节点染为黑色。<br>进过这两步，上图的情况会转换为下图所示。  </p><p>可以看出，父节点这一分支进过调整后，当前节点与父节点的颜色不再是连续红色，满足特性4。而叔节点这一分支的黑色节点数目没有发生变化，满足特性5。<br>对原祖父节点的父节点来说，该子树没有发生违反特性的变化。该子树调整完成。</p><h3 id="2-3-检查根节点"><a href="#2-3-检查根节点" class="headerlink" title="2.3 检查根节点"></a>2.3 检查根节点</h3><p>当上述调整执行完后，还有最后一步，就是检查是否满足特性2。这一步只需要将根节点染成黑色就可以，无需再多加判断。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** 红黑树插入修正函数** 在向红黑树中插入节点之后(失去平衡)，再调用该函数；* 目的是将它重新塑造成一颗红黑树。** 参数说明：*     root 红黑树的根*     node 插入的结点        // 对应《算法导论》中的z*/</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insertFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token operator">*</span>gparent<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若“父节点存在，并且父节点的颜色是红色”</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    gparent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//若“父节点”是“祖父节点的左孩子”</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> gparent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>        <span class="token punctuation">{</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>uncle <span class="token operator">=</span> gparent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                 <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">==</span> node<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>            <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>            parent <span class="token operator">=</span> node<span class="token punctuation">;</span>            node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是左孩子。</span>        <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span><span class="token comment" spellcheck="true">//若“z的父节点”是“z的祖父节点的右孩子”</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>        <span class="token punctuation">{</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>uncle <span class="token operator">=</span> gparent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>               <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是左孩子</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>            <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>            parent <span class="token operator">=</span> node<span class="token punctuation">;</span>            node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是右孩子。</span>        <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 将根节点设为黑色</span><span class="token function">rb_set_black</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-删除"><a href="#3-删除" class="headerlink" title="3. 删除"></a>3. 删除</h2><p>（图例：D表示当前节点，P表示父节点，B表示兄弟节点，BR表示兄弟节点的右子节点，BL表示兄弟节点的左子节点）</p><p>删除操作要比插入操作略微复杂一些。因为删除的节点可能是出现在树的中间层的节点，此时删除该节点会遇到很复杂的情况。所以，在删除节点的时候，需要先对红黑树进行一些调整，使得删除节点对整个树的影响降到最低。</p><h3 id="第一步：将红黑树当作一颗二叉查找树，将节点删除。"><a href="#第一步：将红黑树当作一颗二叉查找树，将节点删除。" class="headerlink" title="第一步：将红黑树当作一颗二叉查找树，将节点删除。"></a>第一步：将红黑树当作一颗二叉查找树，将节点删除。</h3><p>这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：</p><ol><li>被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</li><li>被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</li><li>被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</li></ol><h3 id="第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。"><a href="#第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。" class="headerlink" title="第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。"></a>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</h3><p>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p><h3 id="3-1-替换删除节点"><a href="#3-1-替换删除节点" class="headerlink" title="3.1 替换删除节点"></a>3.1 替换删除节点</h3><p>首先根据BST删除节点的规则，使用当前节点左子树的最大值节点【最右】或者右子树的最小值节点【最左】代替其删除（这两个节点是其子树中数值上最贴近当前节点数值的节点）。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233453271-1165499223.png" alt=""><br>为了方便讲解，我们默认采用的是右子树的最小值节点代替。<br>那么现在需要考虑的情况就减少了，只可能会出现以下几种情况（因为需要满足红黑树特性）： </p><ol><li>无子节点，节点为红色 </li><li>无子节点，节点为黑色 </li><li>只有右子节点，右子节点为红色，节点本身为黑色<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233513067-1819268508.png" alt=""><br>情况1，只需要直接删除节点就可以。 </li></ol><p>情况2，删除节点后，违反了红黑树特性5，需要调整（不考虑待删除节点为根节点的情况） </p><p>情况3，用右子节点占据待删除节点，再将其染成黑色即可，不违反红黑树特性。   </p><p>在这三种情况中，情况1和情况3比较简单，不需要多余的调整。情况2则需要后续的调整步骤使其满足红黑树特性。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* * 删除结点(node)，并返回被删除的结点** 参数说明：*     root 红黑树的根结点*     node 删除的结点*/</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>child<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>RBTColor color<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 被删除节点的"左右孩子都不为空"的情况。</span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 被删节点的后继节点。(称为"取代节点")</span>    <span class="token comment" spellcheck="true">// 用它来取代"被删节点"的位置，然后再将"被删节点"去掉。</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>replace <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 获取后继节点</span>    replace <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>replace<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        replace <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// "node节点"不是根节点(只有根节点不存在父节点)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>            <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> replace<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> replace<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// "node节点"是根节点，更新根节点。</span>        root <span class="token operator">=</span> replace<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// child是"取代节点"的右孩子，也是需要"调整的节点"。</span>    <span class="token comment" spellcheck="true">// "取代节点"肯定不存在左孩子！因为它是一个后继节点。</span>    child <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>    color <span class="token operator">=</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// "被删除节点"是"它的后继节点的父节点"</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// child不为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span>            <span class="token function">rb_set_parent</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>        replace<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token function">rb_set_parent</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> replace<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    replace<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    replace<span class="token operator">-</span><span class="token operator">></span>color <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>color<span class="token punctuation">;</span>    replace<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    node<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>        <span class="token function">removeFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> node<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    child <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span><span class="token keyword">else</span>     child <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>parent <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>color <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>color<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span>    child<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// "node节点"不是根节点</span><span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>        parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token keyword">else</span>        parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span>    root <span class="token operator">=</span> child<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>    <span class="token function">removeFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-调整红黑树"><a href="#3-2-调整红黑树" class="headerlink" title="3.2 调整红黑树"></a>3.2 调整红黑树</h3><p>上述情况2的调整比较复杂。下面对各种情况进行讲解。<br>根据红黑树的特性5，待删除节点必然有兄弟节点。下面根据其兄弟节点所在分支的不同，来分情况讨论。<br>（以下是以关注节点为父节点的左子节点进行描述，如果遇到关注节点为父节点的右子节点的情况，则镜像处理） </p><h4 id="（1）兄弟节点为红色"><a href="#（1）兄弟节点为红色" class="headerlink" title="（1）兄弟节点为红色"></a>（1）兄弟节点为红色</h4><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233549386-1589251368.png" alt=""></p><p>先对父节点进行左旋操作，然后将父节点染成红色，兄弟节点染成黑色。此时就转换为了（4），之后按照（4）继进行调整。</p><p>（2）兄弟节点为黑色，远侄节点为红色<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233611890-1654034424.png" alt=""></p><p>这种情况下，不需要考虑父节点的颜色。<br><strong>第一步：</strong>对父节点P进行左旋操作<br><strong>第二步：</strong>将父节点P与兄弟节点B的颜色互换<br><strong>第三步：</strong>将兄弟节点的右子节点BR染成黑色<br>可以看到，经过这三步的调整后，直接删除节点D后满足红黑树的特性，调整完成。</p><p>####（3）兄弟节点为黑色，远侄节点为黑色，近侄节点为红色<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233722212-1190684847.png" alt=""><br>这种情况下，先对兄弟节点B进行右旋操作，然后BL节点染成黑色，B节点染成红色。此时的状况就和（2）一样了。之后就通过（2）的调整方式进行调整。</p><p>####（4）父节点为红色，兄弟节点为黑色，兄弟节点无子节点<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233738972-2030598122.png" alt=""><br>这种情况下，将父节点P染成黑色，再将兄弟节点染成红色。<br>经过这样的操作后，除去节点D后，以P为根节点的子树的黑节点深度没有发生。调整完成。</p><p>####（5）父节点为黑色，兄弟节点为黑色，兄弟节点无子节点<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233753018-2072912921.png" alt=""><br>这种情况下，为了在删除节点D后使以P为根节点的子树能满足红黑树特性5，将兄弟节点B染成红色。但是这样操作后，以P为根节点的子树的黑色节点深度变小了。所以需要继续调整。<br>因为P节点子树的黑色深度发生了减少，可以把其当作待删除节点，那么此时就以P节点为关注节点进行进一步调整。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** 红黑树删除修正函数** 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；* 目的是将它重新塑造成一颗红黑树。** 参数说明：*     root 红黑树的根*     node 待修正的节点*/</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">removeFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>other<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>node <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> node <span class="token operator">!=</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_is_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> parent<span class="token punctuation">;</span>            parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>                other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>            <span class="token function">rb_set_color</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> root<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_is_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> parent<span class="token punctuation">;</span>            parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>                other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>                    <span class="token function">rb_set_color</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> root<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span>    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-检查根节点及删除节点"><a href="#3-3-检查根节点及删除节点" class="headerlink" title="3.3 检查根节点及删除节点"></a>3.3 检查根节点及删除节点</h3><p>经过上述的调整后，此时基本满足了红黑树的特性。但是存在根节点变成红色的情况。所以需要将根节点染成黑色的操作。<br>最后，执行删除操作，将待删除节点删掉。</p><p>###4. 总结<br>本篇文章讲解了红黑树的数据操作，包括除了左旋”、”右旋”、”添加”、”删除”、”遍历”、”查找”、”打印”、”最小值”、”最大值”、”创建”、”销毁”等接口。<br><strong>注意：</strong><br>红黑树中的private中的函数都是public中函数的内部实现函数，也就是说，为了确保红黑树的封装，几乎所有的操作都是在内部的私有属性函数中完成的，而public中的函数仅仅只是一个接口而已</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * C++ 语言: 红黑树 * * @author skywang * @date 2013/11/07 */</span>    <span class="token macro property">#<span class="token directive keyword">ifndef</span> _RED_BLACK_TREE_HPP_</span><span class="token macro property">#<span class="token directive keyword">define</span> _RED_BLACK_TREE_HPP_ </span>    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iomanip></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>    <span class="token keyword">enum</span> RBTColor<span class="token punctuation">{</span>RED<span class="token punctuation">,</span> BLACK<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">RBTNode</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        RBTColor color<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 颜色</span>        T key<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 关键字(键值)</span>        RBTNode <span class="token operator">*</span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左孩子</span>        RBTNode <span class="token operator">*</span>right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右孩子</span>        RBTNode <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 父结点</span>    <span class="token function">RBTNode</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> RBTColor c<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>p<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>l<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token operator">:</span>            <span class="token function">key</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">color</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">left</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">right</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">RBTree</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span><span class="token operator">:</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>mRoot<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根结点</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">~</span><span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 前序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 中序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 后序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (递归实现)查找"红黑树"中键值为key的节点</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">search</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// (非递归实现)查找"红黑树"中键值为key的节点</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">iterativeSearch</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 查找最小结点：返回最小结点的键值。</span>        T <span class="token function">minimum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 查找最大结点：返回最大结点的键值。</span>        T <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 找结点(x)的后继结点。即，查找"红黑树中数据值大于该结点"的"最小结点"。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">successor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 找结点(x)的前驱结点。即，查找"红黑树中数据值小于该结点"的"最大结点"。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">predecessor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将结点(key为节点键值)插入到红黑树中</span>        <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 删除结点(key为节点键值)</span>        <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 销毁红黑树</span>        <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印红黑树</span>        <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token comment" spellcheck="true">// 前序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 中序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 后序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (递归实现)查找"红黑树x"中键值为key的节点</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">search</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// (非递归实现)查找"红黑树x"中键值为key的节点</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">iterativeSearch</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 查找最小结点：返回tree为根结点的红黑树的最小结点。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">minimum</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 查找最大结点：返回tree为根结点的红黑树的最大结点。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">maximum</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左旋</span>        <span class="token keyword">void</span> <span class="token function">leftRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 右旋</span>        <span class="token keyword">void</span> <span class="token function">rightRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 插入函数</span>        <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 插入修正函数</span>        <span class="token keyword">void</span> <span class="token function">insertFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除函数</span>        <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除修正函数</span>        <span class="token keyword">void</span> <span class="token function">removeFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 销毁红黑树</span>        <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印红黑树</span>        <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">,</span> T key<span class="token punctuation">,</span> <span class="token keyword">int</span> direction<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">define</span> rb_parent(r)   ((r)->parent)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_color(r) ((r)->color)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_is_red(r)   ((r)->color==RED)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_is_black(r)  ((r)->color==BLACK)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_set_black(r)  do { (r)->color = BLACK; } while (0)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_set_red(r)  do { (r)->color = RED; } while (0)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_set_parent(r,p)  do { (r)->parent = (p); } while (0)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_set_color(r,c)  do { (r)->color = (c); } while (0)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*  * 构造函数 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">mRoot</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    mRoot <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 析构函数 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token operator">~</span><span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 前序遍历"红黑树" */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">preOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span> tree<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token punctuation">;</span>        <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 中序遍历"红黑树" */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">inOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">inOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span> tree<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token punctuation">;</span>        <span class="token function">inOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 后序遍历"红黑树" */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">postOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">postOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">postOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span> tree<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">postOrder</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * (递归实现)查找"红黑树x"中键值为key的节点 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">search</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token constant">NULL</span> <span class="token operator">||</span> x<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">==</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> x<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">search</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">search</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * (非递归实现)查找"红黑树x"中键值为key的节点 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">iterativeSearch</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">!=</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> x<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        <span class="token keyword">else</span>            x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">iterativeSearch</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">iterativeSearch</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 查找最小结点：返回tree为根结点的红黑树的最小结点。 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">minimum</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        tree <span class="token operator">=</span> tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token keyword">return</span> tree<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>T RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">minimum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> p<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*  * 查找最大结点：返回tree为根结点的红黑树的最大结点。 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">maximum</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        tree <span class="token operator">=</span> tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token keyword">return</span> tree<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>T RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">maximum</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> p<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 找结点(x)的后继结点。即，查找"红黑树中数据值大于该结点"的"最小结点"。 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">successor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">minimum</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果x没有右孩子。则x有以下两种可能：</span>    <span class="token comment" spellcheck="true">// (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。</span>    <span class="token comment" spellcheck="true">// (02) x是"一个右孩子"，则查找"x的最低的父结点，并且该父结点要具有左孩子"，找到的这个"最低的父结点"就是"x的后继结点"。</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> y <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        x <span class="token operator">=</span> y<span class="token punctuation">;</span>        y <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*  * 找结点(x)的前驱结点。即，查找"红黑树中数据值小于该结点"的"最大结点"。 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">predecessor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果x存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">maximum</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果x没有左孩子。则x有以下两种可能：</span>    <span class="token comment" spellcheck="true">// (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。</span>    <span class="token comment" spellcheck="true">// (01) x是"一个左孩子"，则查找"x的最低的父结点，并且该父结点要具有右孩子"，找到的这个"最低的父结点"就是"x的前驱结点"。</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> y <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        x <span class="token operator">=</span> y<span class="token punctuation">;</span>        y <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 对红黑树的节点(x)进行左旋转 * * 左旋示意图(对节点x进行左旋)： *      px                              px *     /                               / *    x                               y                 *   /  \      --(左旋)-->           / \                # *  lx   y                          x  ry      *     /   \                       /  \ *    ly   ry                     lx  ly   * * */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">leftRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置x的右孩子为y</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>y <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的左孩子” 设为 “x的右孩子”；</span>    <span class="token comment" spellcheck="true">// 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”</span>    x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        y<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的父亲” 设为 “y的父亲”</span>    y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        root <span class="token operator">=</span> y<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “x的父亲” 是空节点，则将y设为根节点</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> x<span class="token punctuation">)</span>            x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span>        <span class="token keyword">else</span>            x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将 “x” 设为 “y的左孩子”</span>    y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的父节点” 设为 “y”</span>    x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 对红黑树的节点(y)进行右旋转 * * 右旋示意图(对节点y进行左旋)： *            py                               py *           /                                / *          y                                x                   *         /  \      --(右旋)-->            /  \                     # *        x   ry                           lx   y   *       / \                                   / \                   # *      lx  rx                                rx  ry *  */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">rightRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置x是当前节点的左孩子。</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的右孩子” 设为 “y的左孩子”；</span>    <span class="token comment" spellcheck="true">// 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”</span>    y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        x<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的父亲” 设为 “x的父亲”</span>    x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        root <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “y的父亲” 是空节点，则将x设为根节点</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>            y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”</span>        <span class="token keyword">else</span>            y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将 “y” 设为 “x的右孩子”</span>    x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的父节点” 设为 “x”</span>    y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 红黑树插入修正函数 * * 在向红黑树中插入节点之后(失去平衡)，再调用该函数； * 目的是将它重新塑造成一颗红黑树。 * * 参数说明： *     root 红黑树的根 *     node 插入的结点        // 对应《算法导论》中的z */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insertFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token operator">*</span>gparent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若“父节点存在，并且父节点的颜色是红色”</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        gparent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//若“父节点”是“祖父节点的左孩子”</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> gparent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>            <span class="token punctuation">{</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>uncle <span class="token operator">=</span> gparent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">==</span> node<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> node<span class="token punctuation">;</span>                node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是左孩子。</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">else</span><span class="token comment" spellcheck="true">//若“z的父节点”是“z的祖父节点的右孩子”</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>            <span class="token punctuation">{</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>uncle <span class="token operator">=</span> gparent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是左孩子</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> node<span class="token punctuation">;</span>                node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是右孩子。</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将根节点设为黑色</span>    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 将结点插入到红黑树中 * * 参数说明： *     root 红黑树的根结点 *     node 插入的结点        // 对应《算法导论》中的node */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        y <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;</span> x<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        <span class="token keyword">else</span>            x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    node<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;</span> y<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>            y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token keyword">else</span>            y<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        root <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 设置节点的颜色为红色</span>    node<span class="token operator">-</span><span class="token operator">></span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3. 将它重新修正为一颗二叉查找树</span>    <span class="token function">insertFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 将结点(key为节点键值)插入到红黑树中 * * 参数说明： *     tree 红黑树的根结点 *     key 插入结点的键值 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>z<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果新建结点失败，则返回。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>z<span class="token operator">=</span><span class="token keyword">new</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>BLACK<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token function">insert</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 红黑树删除修正函数 * * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数； * 目的是将它重新塑造成一颗红黑树。 * * 参数说明： *     root 红黑树的根 *     node 待修正的节点 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">removeFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>other<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>node <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> node <span class="token operator">!=</span> root<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_is_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>                <span class="token function">rb_set_color</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> root<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_is_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>                <span class="token function">rb_set_color</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> root<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token function">rb_set_black</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 删除结点(node)，并返回被删除的结点 * * 参数说明： *     root 红黑树的根结点 *     node 删除的结点 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>child<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>    RBTColor color<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 被删除节点的"左右孩子都不为空"的情况。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 被删节点的后继节点。(称为"取代节点")</span>        <span class="token comment" spellcheck="true">// 用它来取代"被删节点"的位置，然后再将"被删节点"去掉。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>replace <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取后继节点</span>        replace <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>replace<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            replace <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// "node节点"不是根节点(只有根节点不存在父节点)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>                <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> replace<span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> replace<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">else</span>             <span class="token comment" spellcheck="true">// "node节点"是根节点，更新根节点。</span>            root <span class="token operator">=</span> replace<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// child是"取代节点"的右孩子，也是需要"调整的节点"。</span>        <span class="token comment" spellcheck="true">// "取代节点"肯定不存在左孩子！因为它是一个后继节点。</span>        child <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>        color <span class="token operator">=</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// "被删除节点"是"它的后继节点的父节点"</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> node<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// child不为空</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span>                <span class="token function">rb_set_parent</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>    replace<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token function">rb_set_parent</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> replace<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    replace<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>        replace<span class="token operator">-</span><span class="token operator">></span>color <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>color<span class="token punctuation">;</span>        replace<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        node<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>            <span class="token function">removeFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> node<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        child <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token keyword">else</span>         child <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    parent <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>    color <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>color<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span>        child<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// "node节点"不是根节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>            parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>        <span class="token keyword">else</span>            parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        root <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>        <span class="token function">removeFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 删除红黑树中键值为key的节点 * * 参数说明： *     tree 红黑树的根结点 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 查找key对应的节点(node)，找到的话就删除该节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token function">remove</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 销毁红黑树 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">destroy</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">destroy</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">destroy</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> tree<span class="token punctuation">;</span>    tree<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">destroy</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 打印"二叉查找树" * * key        -- 节点的键值  * direction  --  0，表示该节点是根节点; *               -1，表示该节点是它的父结点的左孩子; *                1，表示该节点是它的父结点的右孩子。 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">,</span> T key<span class="token punctuation">,</span> <span class="token keyword">int</span> direction<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>direction<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// tree是根节点</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> tree<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;&lt;</span> <span class="token string">"(B) is root"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">else</span>                <span class="token comment" spellcheck="true">// tree是分支节点</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> tree<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;&lt;</span>  <span class="token punctuation">(</span><span class="token function">rb_is_red</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token operator">?</span><span class="token string">"(R)"</span><span class="token operator">:</span><span class="token string">"(B)"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" is "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> key <span class="token operator">&lt;&lt;</span> <span class="token string">"'s "</span>  <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>direction<span class="token operator">==</span><span class="token number">1</span><span class="token operator">?</span><span class="token string">"right child"</span> <span class="token operator">:</span> <span class="token string">"left child"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> tree<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">print</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>tree<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mRoot <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> mRoot<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;红黑树的起源，自然是二叉查找树了，这种树结构从根节点开始，左子节点小于它，右子节点大于它。每个节点都符合这个特性，所以易于查找，是一种很好的
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.zzw1024.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="红黑树" scheme="http://www.zzw1024.top/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
</feed>
