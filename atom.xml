<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自由の翼</title>
  <icon>https://www.gravatar.com/avatar/4b22ce9ec4999fcb091d9b70473733a4</icon>
  <subtitle>书的海洋遨游，知识的世界飞翔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zzw1024.top/"/>
  <updated>2020-02-19T14:40:46.000Z</updated>
  <id>http://www.zzw1024.top/</id>
  
  <author>
    <name>自由の翼</name>
    <email>819342493@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode——012 Integer to Roman</title>
    <link href="http://www.zzw1024.top/2020/02/19/leetcode-012-integer-to-roman/"/>
    <id>http://www.zzw1024.top/2020/02/19/leetcode-012-integer-to-roman/</id>
    <published>2020-02-19T14:40:46.000Z</published>
    <updated>2020-02-19T14:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><pre><code>Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000</code></pre><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9. </li><li>X can be placed before L (50) and C (100) to make 40 and 90. </li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><p><strong>Example 1:</strong></p><pre><code>Input: 3Output: &quot;III&quot;</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: 4Output: &quot;IV&quot;</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: 9Output: &quot;IX&quot;</code></pre><p><strong>Example 4:</strong></p><pre><code>Input: 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3.</code></pre><p><strong>Example 5:</strong></p><pre><code>Input: 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</code></pre><p><strong>Solution</strong></p><p>将罗马数字表示中的复杂部分列举出来即可。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">intToRoman</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>values <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">900</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span>reps <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"M"</span><span class="token punctuation">,</span><span class="token string">"CM"</span><span class="token punctuation">,</span><span class="token string">"D"</span><span class="token punctuation">,</span><span class="token string">"CD"</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">,</span><span class="token string">"XC"</span><span class="token punctuation">,</span><span class="token string">"L"</span><span class="token punctuation">,</span><span class="token string">"XL"</span><span class="token punctuation">,</span><span class="token string">"X"</span><span class="token punctuation">,</span><span class="token string">"IX"</span><span class="token punctuation">,</span><span class="token string">"V"</span><span class="token punctuation">,</span><span class="token string">"IV"</span><span class="token punctuation">,</span><span class="token string">"I"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">>=</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                num <span class="token operator">-</span><span class="token operator">=</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                res <span class="token operator">+</span><span class="token operator">=</span> reps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Sym
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.zzw1024.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——010 Regular Expression Matching</title>
    <link href="http://www.zzw1024.top/2020/02/19/leetcode-010-regular-expression-matching/"/>
    <id>http://www.zzw1024.top/2020/02/19/leetcode-010-regular-expression-matching/</id>
    <published>2020-02-19T14:05:32.000Z</published>
    <updated>2020-02-19T14:05:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*‘.</p><p>‘.’ Matches any single character.<br>‘*‘ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).   </p><p>Note:<br>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.   </p><p><strong>Example 1:</strong></p><pre><code>Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</code></pre><p><strong>Example 4:</strong></p><pre><code>Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.</code></pre><p><strong>Example 5:</strong></p><pre><code>Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false</code></pre><p><strong>Solution</strong><br>方法一：</p><ul><li>若p的长度为1，若s长度也为1，且相同或是p为 ‘.’ 则返回 true，反之返回 false。  </li><li>若p的第二个字符不为 * ，若此时s为空返回 false，否则判断首字符是否匹配，<br>且从各自的第二个字符开始调用递归函数匹配。   </li><li>若p的第二个字符为 * ，进行下列循环，条件是若s不为空且首字符匹配（包括 p[0] 为点），<br>调用递归函数匹配s和去掉前两个字符的p（这样做的原因是假设此时的星号的作用是让前面<br>的字符出现0次，验证是否匹配），若匹配返回 true，否则s去掉首字母（因为此时首字母匹配了，<br>我们可以去掉s的首字母，而p由于星号的作用，可以有任意个首字母，所以不需要去掉），<br>继续进行循环。   </li><li>返回调用递归函数匹配s和去掉前两个字符的p的结果（这么做的原因是处理星号无法匹配的内容，<br>比如 s = “ab”, p = “ab”，直接进入 while 循环后，我们发现 “ab” 和 “b” 不匹配，所以s变成 “b”，  那么此时跳出循环后，就到最后的 return 来比较 “b” 和 “b” 了，返回 true。再举个例子，  比如 s = “”, p = “a”，由于s为空，不会进入任何的 if 和 while，只能到最后的 return 来比较了，  返回 true，正确）。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//记住，‘*’打头没有任何用处</span>        <span class="token punctuation">{</span>            <span class="token keyword">bool</span> f1 <span class="token operator">=</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//即，将‘*’视为不起任何作用，直接匹配后面的字符</span>            <span class="token keyword">bool</span> f2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第一个匹配上了，之所以不去除p的第一个字母，是因为‘*’可以当作0个第一个字母匹配</span>            <span class="token keyword">return</span> f1 <span class="token operator">||</span> f2<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//return isMatch(s, p.substr(2)) || (!s.empty() &amp;&amp; (s[0] == p[0] || p[0] == '.') &amp;&amp; isMatch(s.substr(1), p));</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token comment" spellcheck="true">//第二个字母不为‘*’，那么就一个个按要求匹配</span>            <span class="token keyword">return</span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：DP解法：<br>我们也可以用 DP 来解，定义一个二维的 DP 数组，其中 dp[i][j] 表示 s[0, i) 和 p[0, j) 是否 match，    然后有下面三种情况：   </p><ol><li>dp[i][j] = dp[i - 1][j - 1]； if p[j - 1] != ‘*‘ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’); 即,字母不是为‘*’，且字符匹配上了,那就决定与前面的字符是否匹配上了                     </li><li>dp[i][j] = dp[i][j - 2]；if p[j - 1] == ‘*‘ and the pattern repeats for 0 times;即，前面的‘*’号作废，因为’*‘前面的字符匹配上了           </li><li>dp[i][j] = dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’)；if p[j - 1] == ‘*‘ and the pattern repeats for at least 1 times.<br>   即，‘*’的前面字母与此时的字母匹配上了，那么就将‘*’前面的字母至少复制一次             <pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">bool</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string p<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">>></span><span class="token function">dp</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//都为空时</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'*'</span><span class="token punctuation">)</span>                 dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> p<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">else</span>                 dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> p<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="字符匹配" scheme="http://www.zzw1024.top/tags/%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——011 Container With Most Water</title>
    <link href="http://www.zzw1024.top/2020/02/19/leetcode-011-container-with-most-water/"/>
    <id>http://www.zzw1024.top/2020/02/19/leetcode-011-container-with-most-water/</id>
    <published>2020-02-19T14:05:03.000Z</published>
    <updated>2020-02-19T14:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- password: --><p><strong>Description</strong></p><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.  </p><p>Note: You may not slant the container and n is at least 2. </p><p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><p><strong>Example:</strong></p><pre><code>Input: [1,8,6,2,5,4,8,3,7]Output: 49</code></pre><p><strong>Solution</strong></p><p>水桶原理，即水桶的容量取决于最短的那块木板。<br>左右不停的寻找最高边缘即可。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> maxV <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            maxV <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxV<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">--</span>j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxV<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- password: --&gt;

&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given n non-negative integers a1, a2, …, an , where each represents a point at co
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="数组容器" scheme="http://www.zzw1024.top/tags/%E6%95%B0%E7%BB%84%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——009 Palindrome Number</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-009-palindrome-number/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-009-palindrome-number/</id>
    <published>2020-01-03T15:20:33.000Z</published>
    <updated>2020-01-03T15:20:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><pre><code>Input: 121Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.Follow up:</code></pre><p>Coud you solve it without converting the integer to a string?</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//水题咯</span><span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//负数和尾数为0都不是回文数字</span>    <span class="token keyword">double</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        num <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> num <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> s<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backw
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="回文" scheme="http://www.zzw1024.top/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——008 String to Integer (atoi)</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-008-string-to-integer-atoi/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-008-string-to-integer-atoi/</id>
    <published>2020-01-03T15:15:24.000Z</published>
    <updated>2020-01-03T15:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>** Description **</p><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;42&quot;Output: 42</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;   -42&quot;Output: -42Explanation: The first non-whitespace character is &#39;-&#39;, which is the minus sign.             Then take as many numerical digits as possible, which gets 42.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.</code></pre><p><strong>Example 4:</strong></p><pre><code>Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &#39;w&#39;, which is not a numerical              digit or a +/- sign. Therefore no valid conversion could be performed.</code></pre><p><strong>Example 5:</strong></p><pre><code>Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.             Thefore INT_MIN (−231) is returned.</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">Solution <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用来防止溢出的</span>        <span class="token keyword">bool</span> isBegan <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//是否开始了</span>        <span class="token keyword">int</span> isMinus <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是否是负数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isBegan <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//还没有开始</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isBegan <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">||</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第一次遇到负号</span>                isMinus <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是负数</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token comment" spellcheck="true">//不是数字</span>                <span class="token keyword">return</span> res <span class="token operator">*</span> isMinus<span class="token punctuation">;</span>            isBegan <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开始了</span>            <span class="token comment" spellcheck="true">//判断是否越界    </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>res <span class="token operator">*</span> isMinus<span class="token punctuation">)</span> <span class="token operator">&lt;</span> INT_MIN<span class="token punctuation">)</span><span class="token keyword">return</span> INT_MIN<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> isMinus <span class="token operator">></span> INT_MAX<span class="token punctuation">)</span><span class="token keyword">return</span> INT_MAX<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">*</span> isMinus<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;** Description **&lt;/p&gt;
&lt;p&gt;Implement atoi which converts a string to an integer.&lt;/p&gt;
&lt;p&gt;The function first discards as many whitespace char
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.zzw1024.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——007 Reverse Integer</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-007-reverse-integer/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-007-reverse-integer/</id>
    <published>2020-01-03T14:26:05.000Z</published>
    <updated>2020-01-03T14:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1:</strong></p><pre><code>Input: 123Output: 321</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: -123Output: -321</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: 120Output: 21Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</code></pre><p><strong>Solution:</strong></p><p>翻转一个带字符整数<br>最高数值为【-2^31 - 2^31-1】32位系统，由于int型的数值范围是 -2147483648～2147483647，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> rev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pop <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        x <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rev <span class="token operator">></span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rev <span class="token operator">==</span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">></span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rev <span class="token operator">&lt;</span> INT_MIN <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rev <span class="token operator">==</span> INT_MIN <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        rev <span class="token operator">=</span> rev <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> pop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> rev<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">></span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="数值" scheme="http://www.zzw1024.top/tags/%E6%95%B0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——006 ZigZag Conversion</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-006-zigzag-conversion/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-006-zigzag-conversion/</id>
    <published>2020-01-03T14:21:05.000Z</published>
    <updated>2020-01-03T14:21:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><pre><code>P   A   H   NA P L S I I GY   I   R</code></pre><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><p>** Example 1: **</p><p>Input: s = “PAYPALISHIRING”, numRows = 3<br>Output: “PAHNAPLSIIGYIR”</p><p>** Example 2: **</p><p>Input: s = “PAYPALISHIRING”, numRows = 4<br>Output: “PINALSIGYAHRPI”<br>Explanation:</p><pre><code>P     I    NA   L S  I GY A   H RP     I</code></pre><p>** Solution: **</p><p>注意输入的字母排序是按照倒着的N排序的，然后让你根据这个倒置的N的图形进行按行排序输出<br>按照半个N，即:一个竖和一个行的循环将数据输入到每一行中<br>比如输入：0，1，2，3，4，5，6，7，8，9，10；4行<br>其形状为<br>0            6<br>1        5    7<br>2    4        8    10<br>3            9<br>按照半个N，即0，1，2，3 与4，5 为循环，然后确定半个N的大小为size = 2 * numRows - 2 = 6<br>半个N的下竖为, 存入行[i%size]，上斜存入[size - i % size];</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">convert</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> numRows <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> s<span class="token punctuation">;</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token function">rows</span><span class="token punctuation">(</span>numRows<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> numRows <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//半个N的大小</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> id <span class="token operator">=</span> i <span class="token operator">%</span> size<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> numRows<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//竖下</span>                rows<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token comment" spellcheck="true">//斜上</span>                rows<span class="token punctuation">[</span>size <span class="token operator">-</span> id<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> str <span class="token operator">:</span> rows<span class="token punctuation">)</span>            res <span class="token operator">+</span><span class="token operator">=</span> str<span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.zzw1024.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——005 Longest Palindromic Substring</title>
    <link href="http://www.zzw1024.top/2020/01/03/leetcode-005-longest-palindromic-substring/"/>
    <id>http://www.zzw1024.top/2020/01/03/leetcode-005-longest-palindromic-substring/</id>
    <published>2020-01-03T02:56:06.000Z</published>
    <updated>2020-01-03T02:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>** Example 1: **</p><pre><code>Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.</code></pre><p>** Example 2: **</p><pre><code>Input: &quot;cbbd&quot;Output: &quot;bb&quot;</code></pre><p>** Solution: **</p><p>使用中将对称思路<br>及从头开始遍历，对于每个字母进行左右向外扩散，判断是不是回文子串<br>注意，向外扩散有两种方式，第一种，就是以该字母为中心向外扩散，第二种就是该字母和其右端的字母开始进行向外扩散   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">help</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//奇数类型的中心向两边扩撒</span>            <span class="token function">help</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//偶数类型的中心向两边扩撒            </span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">help</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>res<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token operator">--</span>L<span class="token punctuation">;</span>            <span class="token operator">++</span>R<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>L <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="回文" scheme="http://www.zzw1024.top/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——003 Longest Substring Without Repeating Characters</title>
    <link href="http://www.zzw1024.top/2020/01/02/leetcode-003-longest-substring-without-repeating-characters/"/>
    <id>http://www.zzw1024.top/2020/01/02/leetcode-003-longest-substring-without-repeating-characters/</id>
    <published>2020-01-02T15:08:38.000Z</published>
    <updated>2020-01-02T15:08:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a string, find the length of the longest substring without repeating characters.</p><p>** Example 1: **</p><pre><code>Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. </code></pre><p>** Example 2: **</p><pre><code>Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1.</code></pre><p>** Example 3: **</p><pre><code>Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3.              Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</code></pre><p>** Solution: **</p><p>使用unordered_map来记录重复字母出现的最右端位置，然后使用现在的位置减去重复字母位置，中间就是没有重复字母的子串了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> L <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用来记录字母出现的最右端位置</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                L <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i <span class="token operator">-</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;
&lt;p&gt;** Exam
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.zzw1024.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——002 Add Two Numbers</title>
    <link href="http://www.zzw1024.top/2020/01/02/leetcode-002-add-two-numbers/"/>
    <id>http://www.zzw1024.top/2020/01/02/leetcode-002-add-two-numbers/</id>
    <published>2020-01-02T14:24:58.000Z</published>
    <updated>2020-01-02T14:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>** Example: **</p><pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.</code></pre><p>** Solution: **</p><p>题目很简单，直接相加就行</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记住，这是带头节点的</span>        ListNode <span class="token operator">*</span>p <span class="token operator">=</span> result<span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> l1<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//进位</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">||</span> p2<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span>p1 <span class="token operator">?</span> p1<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>p2 <span class="token operator">?</span> p2<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token punctuation">;</span>            p<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            p1 <span class="token operator">=</span> p1 <span class="token operator">?</span> p1<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2 <span class="token operator">?</span> p2<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            p<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are store
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.zzw1024.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——001 Two Sum</title>
    <link href="http://www.zzw1024.top/2020/01/02/leetcode-001-two-sum/"/>
    <id>http://www.zzw1024.top/2020/01/02/leetcode-001-two-sum/</id>
    <published>2020-01-02T14:08:35.000Z</published>
    <updated>2020-01-02T14:08:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>** Example: ** </p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><p>** Solution: **</p><p>可以使用最简单的暴力法</p><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    v1 <span class="token operator">=</span> nums<span class="token punctuation">;</span>    <span class="token keyword">int</span> num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p1 <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>        p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>        num1 <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v1<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            num2 <span class="token operator">=</span> v2<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            v2<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num1 <span class="token operator">+</span> num2<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>                v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>                f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific tar
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="目标和" scheme="http://www.zzw1024.top/tags/%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>视频下载神器</title>
    <link href="http://www.zzw1024.top/2020/01/01/shi-pin-xia-zai-shen-qi/"/>
    <id>http://www.zzw1024.top/2020/01/01/shi-pin-xia-zai-shen-qi/</id>
    <published>2020-01-01T14:25:42.000Z</published>
    <updated>2020-01-01T14:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="youtube-dl："><a href="#youtube-dl：" class="headerlink" title="youtube-dl："></a>youtube-dl：</h2><p>Youtube-dl是谷歌github上的一个开源项目，它是一款轻量级的命令行下载实用工具，阿刚曾在乐软博客里文章《不仅仅是youtube，youtube-dl在线视频下载神器》一文章，详细介绍过Youtube-dl。 </p><p>作为一款命令行视频下载神器，Youtube-dl功能强大，可解析下载包括youtube、youku、腾讯视频、爱奇艺等国内外上百个视频网站，它甚至还支持XXX网站的视频解析与下载，比如阿刚经常用它下载XXX片子~~</p><p>youtube-dl支持Winodws ，linux和mac平台。安装配置简单，在Windows平台上，你只需下载youtube-dl.exe并为其创建系统变量，就可以通过CMD输入youtube-dl命令来下载视频了。</p><p>youtube-dl支持的命令众多，在Github项目主页上大家可以查阅命令，或者直接键入”Youtube-dl -h”查看帮助说明。</p><p><strong>常用命令</strong></p><pre><code>youtube-dl --list-extractors #查看支持网站列表youtube-dl -U #程序升级youtube-dl --get-format URL #获取视频格式youtube-dl -F URL #获取所有格式youtube-dl -o 输出路径</code></pre><p>如果你要下载视频，只需键入命令”youtube-dl +视频地址”</p><p>默认情况下，youtube-dl会自动选择下载最高画质。　　</p><p>【安装使用】：</p><p><strong>window：</strong></p><p>安装有pip3的环境后，直接输入 pip install you-get就可以使用</p><pre><code>youtube-dl  url </code></pre><p><strong>Liunx：</strong></p><p>解压后可以直接使用：</p><pre><code>youtube-dl url</code></pre><p>或者使用 sudo  apt install youtube-dl</p><p>。。。。。貌似不能用了</p><h2 id="you-get"><a href="#you-get" class="headerlink" title="you-get"></a>you-get</h2><p>youget下载</p><p>you-get是一款开源在线视频下载工具，与youtubedl相同，同样是一款轻量级多平台命令行工具，you-get支持众多视频网站，包含 41 家国内主流视频、音乐网站，如 优酷土豆、爱奇艺、腾讯视频、芒果TV 、网易云音乐等等。</p><p>you-get有三种安装方式，如果你电脑安装了Python，可以通过pip3 install </p><p>you-get命令一键安装。Windows平台还可通过Chocolatey来一键安装。当然还有最简单直接的exe文件（需创建变量）</p><p>you-get支持的命令非常丰富，使用最简单的命令you-get +视频网址，即可解析下载视频~~</p><p>默认情况下，you-get自动解析下载最佳画质的视频。同样在下载完成后，you-get会自动调用ffmpeg合并视频。　　</p><p>【安装使用】：</p><p><strong>window：</strong></p><p>安装有pip3的环境后，直接输入 pip install you-get就可以使用</p><p>you-get url</p><p><strong>Liunx：</strong></p><p>解压后可以直接使用：</p><p>you-get url</p><p>或者使用 sudo  apt install you-get</p><p>。。。。实测还能使用</p><h2 id="ykdl："><a href="#ykdl：" class="headerlink" title="ykdl："></a>ykdl：</h2><p>由于视频网站规则不断变换，无论是神器youtube-dl，you-get，经常莫名其妙无法解析视频，尤其是you-get，优酷某些特殊视频，在解析时经常出现”客户端无权播放-201”</p><p>这种情况下，我们可以试试ykdl。</p><p>ykdl——顾名思义，一款专注于国内优酷视频的命令行下载工具。阿刚这些天试用下来，在优酷视频解析下载方面ykdl的表现更为强大，至少在写这篇文章时，某些优酷视频，youtube-dl和you-get要么只能解析下载前几分钟，要么直接无法解析。</p><p>常用命令</p><pre><code>　　-h, --help　　　　　　　　　　 显示帮助信息　　-l, --playlist　　　　　　　　 下载播放列表　　-i, --info　　　　　　　　　　　　显示视频信息　　-J, --json　　　　　　　　　　 以json格式显示视频信息.　　-F --FORMAT,　　　　　　 视频格式　　-o --OUTPUT_DIR,　　　　设置视频下载的保存路径　　-O --OUTPUT_NAME, 设置视频输出的名称　　-p --PLAYER,　　　　　　　　直接调用mpv播放器播放视频　　ykdl的命令并不太多，但足够我们使用，最简单的命令　　ykdl+视频网址，可一键解析下载视频。　　</code></pre><p>【安装使用】：</p><p><strong>window：</strong></p><p>安装有pip3的环境后，直接输入 pip install ykdl就可以使用</p><p>ykdl url </p><p><strong>Liunx：</strong></p><p>解压后可以直接使用：</p><p>ydkl url</p><p>或者使用 sudo  apt install ykdl 下载再使用</p><p>。。。。貌似失效了</p><h2 id="annie"><a href="#annie" class="headerlink" title="annie:"></a>annie:</h2><p>下载　　</p><p>annie是GitHub上一个开源项目，是一款专注于在线视频下载的轻量级命令行工具。annie支持解析下载包括youtube、优酷、爱奇艺、腾讯视频、抖音等国内外17个在线视频网站。</p><p>annie支持的命令相当多，下面阿刚简单的介绍几个常用的命令。</p><p>直接下载一个视频：</p><p>如果你想下载多个链接视频，那么就在后面加上多个链接　</p><pre><code>annie https://www.bilibili.com/video/av45654043</code></pre><p>列举视频所有清晰度，但不下载：</p><pre><code>annie -i https://www.bilibili.com/video/av45654043</code></pre><p>根据列举出来的清晰度，下载指定清晰度的视频：</p><ul><li>比如列表显示的1080P视频<pre><code>annie -f 80 https://www.bilibili.com/video/av45654043</code></pre></li></ul><p>一般视频都默认下载到当前目录，如果你想下载到其它目录，需要在下载时候，加一个-o参数，后面带上文件夹路径即可。</p><ul><li>比如下载到桌面C:\Users\Rats\Desktop文件夹，Linux路径写法为/root/Rats<pre><code>annie -o C:\Users\Rats\Desktop -f 80 https://www.bilibili.com/video/av45654043</code></pre></li></ul><p>如果是下载bilibili电视剧，可以在后面加一个-p参数，然后可以将所有集数一起下载。</p><ul><li><p>列出该集数的电视剧所有集数清晰度等信息</p><pre><code>annie -i -p https://www.bilibili.com/bangumi/play/ep133269</code></pre></li><li><p>下载1到20集1080P视频</p><pre><code>annie -f 80 -p -start 1 -end 20 https://www.bilibili.com/bangumi/play/ep133269</code></pre></li></ul><p>目前播放列表暂时只支持B站和youtube。</p><p>你也可以将你需要下载的链接存放到bz.txt文件里，然后使用命令一起下载：</p><ul><li><p>列出所有链接信息</p><pre><code>annie -F /root/bz.txt -i</code></pre></li><li><p>下载1080p视频</p><pre><code>annie -f 80 -F /root/bz.txt</code></pre></li></ul><p>如果你下载的视频，比如需要会员啥的，就需要Cookies了，这里补充下优酷会员下载视频方法。</p><p>首先登录优酷账号，然后获取Cookies，只需要P_pck_rm参数即可，再新建一个文本cookie.txt，格式如下：</p><ul><li>后面为该值参数<pre><code>P_pck_rm=moerats</code></pre></li></ul><p>接下来在命令中加上-c cookie.txt参数解析地址并下载视频：</p><ul><li><p>获取视频格式列表</p><pre><code>annie -i -c cookie.txt https://v.youku.com/v_show/id_*.html</code></pre></li><li><p>根据自己需求下载指定清晰度视频</p><pre><code>annie -f mp4hd3v2-guoyu -c cookie.txt https://v.youku.com/v_show/id_*.html</code></pre></li></ul><p>【安装使用】：</p><p><strong>window：</strong></p><p>下载解压后，将文件根目录添加到用户的环境变量中</p><p>annie  rul</p><p><strong>Liunx：</strong></p><p>下载后解压后可以直接使用</p><p>。。。。实测，功能巨强！！！！</p><h2 id="Video-Download-Manager"><a href="#Video-Download-Manager" class="headerlink" title="Video Download Manager"></a>Video Download Manager</h2><p>如果你实在不喜欢命令行工具，那么这款使用youtube-dl+you-get为核心的工具一定可以满足你的需求。</p><p>你无需理会那些让人抓狂的命令，只需复制粘贴视频地址即可解析下载。</p><p>【安装使用】：</p><p>直接百度下载安装就行</p><p>。。。。不爱用</p><p>如何下载VIP视频</p><p>以上的使用都一样：</p><p>通过加载cookies获取播放权限，实现视频解析和下载。也就是说，首先你必须要有个VIP账户。</p><ul><li><p>step1:</p><p>  获取Cookies</p><p>  首先登陆会员账号，快捷键F12，打开开发者工具。选择”Network”，F5快捷键重新加载页面，选择视频播放页面，将Headers里的Cookies信息全部复制，保存为txt文件，比如Cookies.txt</p></li><li><p>step2:</p><p>  加载Cookies</p><p>  通过annie -c命令加载已保存的Cookies.txt文件。即可成功解析B站大会员视频，如图中</p><p>  （B站登陆账户最高可观看1080P视频，大会员可看1080P+视频）</p></li></ul><hr><p>指定下载储存的文件位置：</p><p>[命令] -o   [位置]   [视频地址url]<br>***s</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;youtube-dl：&quot;&gt;&lt;a href=&quot;#youtube-dl：&quot; class=&quot;headerlink&quot; title=&quot;youtube-dl：&quot;&gt;&lt;/a&gt;youtube-dl：&lt;/h2&gt;&lt;p&gt;Youtube-dl是谷歌github上的一个开源项目，它是一款轻量
      
    
    </summary>
    
    
      <category term="软件神器" scheme="http://www.zzw1024.top/categories/%E8%BD%AF%E4%BB%B6%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="视频" scheme="http://www.zzw1024.top/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>《More Effective C++》——读书笔记</title>
    <link href="http://www.zzw1024.top/2020/01/01/more-effective-c-du-shu-bi-ji/"/>
    <id>http://www.zzw1024.top/2020/01/01/more-effective-c-du-shu-bi-ji/</id>
    <published>2020-01-01T07:38:48.000Z</published>
    <updated>2020-01-01T07:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基础议题-Basics"><a href="#一、基础议题-Basics" class="headerlink" title="一、基础议题(Basics)"></a>一、基础议题(Basics)</h2><h3 id="1、仔细区别-pointers【指针】-和-references"><a href="#1、仔细区别-pointers【指针】-和-references" class="headerlink" title="1、仔细区别 pointers【指针】 和 references"></a>1、仔细区别 pointers【指针】 和 references</h3><p>二者之间的区别是：在任何情况下都不能用指向空值的引用，而指针则可以；指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变</p><p>在以下情况下使用指针：一是存在不指向任何对象的可能性；二是需要能够在不同的时刻指向不同的对象</p><p>在以下情况使用引用：总是指向一个对象且一旦指向一个对象之后就不会改变指向；重载某个操作符时，使用指针会造成语义误解</p><h3 id="2、最好使用-C-转型操作符"><a href="#2、最好使用-C-转型操作符" class="headerlink" title="2、最好使用 C++ 转型操作符"></a>2、最好使用 C++ 转型操作符</h3><p>为解决 C 旧式转型的缺点（允许将任何类型转为任何类型，且难以辨识），C++ 导入 4 个新的转型操作符（cast operators）：</p><p>static_cast , const_cast , dynamic_cast , reinterpret_cast：分别是常规类型转换，去常量转换，继承转换，函数指针转换</p><p>static_cast：功能上基本上与C风格的类型转换一样强大，含义也一样但是不能把struct转换成int类型或者把double类型转换成指针类型另外，它不<br>能从表达式中去除const属性。用来针对一个继承体系做向下的安全转换，目标类型必须为指针或者引用。基类中要有虚函数，否则会编译出错；static_cast则没有这个限制。原因是：存在虚函数，说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。必须保证源类型跟目标类型本来就是一致的，否则返回 null 指针。这个函数使用的是RTTI机制，所以编译器必须打开这个选项才能编译。</p><p>const_cast：用于类型转换掉表达式的const或volatileness属性但是不能用它来完成修改这两个属性之外的事情</p><p>dynamic_cast：用于安全地沿着类的继承关系向下类型转换失败的转换将返回空指针或者抛出异常</p><p>reinterpret_cast：这个操作符被用于的类型转换的转换结果时实现时定义因此，使用它的代码很难移植最普通的用途就是在函数指针之间进行转换</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//想要使用 dynamic_cast ，基类中必须有虚函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//i == 3</span><span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pj <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//int *pj = (int*)(&amp;j);     //等同于上面</span>    <span class="token operator">*</span>pj <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//虽然 *pj的地址和 j 的地址是一样的，但是值却不一样。</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>pj<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//20</span>    cout<span class="token operator">&lt;&lt;</span>j<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//10</span>B <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>D<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FunPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>FunPtr<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fun<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//尽量避免使用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、绝对不要以多态方式处理数组"><a href="#3、绝对不要以多态方式处理数组" class="headerlink" title="3、绝对不要以多态方式处理数组"></a>3、绝对不要以多态方式处理数组</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"base print()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"derived print()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果没有此句，执行将正确，因为基类对象和子类对象长度相同  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> B array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B barray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span>barray<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D darray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span>darray<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>array[i] 其实是一个指针算术表达式的简写，它代表的其实是 *(array+i)，array是一个指向数组起始处的指针。在 for 里遍历 array 时，必须要知道每个元素之间相差多少内存，而编译器则根据传入参数来计算得知为 sizeof(B)，而如果传入的是派生类数组对象，它依然认为是 sizeof(B)，除非正好派生类大小正好与基类相同，否则运行时会出现错误。但是如果我们设计软件的时候，不要让具体类继承具体类的话，就不太可能犯这种错误。（理由是，一个类的父类一般都会是一个抽象类，抽象类不存在数组） </p><h3 id="4、避免无用的-default-constructors"><a href="#4、避免无用的-default-constructors" class="headerlink" title="4、避免无用的 default constructors"></a>4、避免无用的 default constructors</h3><p>没有缺省构造函数造成的问题：通常不可能建立对象数组，对于使用非堆数组，可以在定义时提供必要的参数。另一种方法是使用指针数组，但是必须删除数组里的每个指针指向的对象，而且还增加了内存分配量。</p><p>提供无意义的缺省构造函数会影响类的工作效率，成员函数必须测试所有的部分是否都被正确的初始化。</p><h2 id="二、操作符-Operators"><a href="#二、操作符-Operators" class="headerlink" title="二、操作符(Operators)"></a>二、操作符(Operators)</h2><h3 id="5、对定制的“类型转换函数”保持警觉"><a href="#5、对定制的“类型转换函数”保持警觉" class="headerlink" title="5、对定制的“类型转换函数”保持警觉"></a>5、对定制的“类型转换函数”保持警觉</h3><p>定义类似功能的函数，而抛弃隐式类型转换，使得类型转换必须显示调用。例如 String类没有定义对Char*的隐式转换，而是用c_str函数来实施这个转换。拥有单个参数（或除第一个参数外都有默认值的多参数）构造函数的类，很容易被隐式类型转换，最好加上 explicit 防止隐式类型转换。</p><h3 id="6、区别-increment-decrement-操作符的前置和后置形式"><a href="#6、区别-increment-decrement-操作符的前置和后置形式" class="headerlink" title="6、区别 increment/decrement 操作符的前置和后置形式"></a>6、区别 increment/decrement 操作符的前置和后置形式</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>id <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//返回值为 const ，以避免 a++++这种形式</span>        <span class="token comment" spellcheck="true">//因为第二个 operator++ 所改变的对象是第一个 operator++ 返回的对象</span>        <span class="token comment" spellcheck="true">//最终结果其实也只是累加了一次，a++++ 也还是相当于 a++，这是违反直觉的</span>        <span class="token keyword">const</span> A <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            A a <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>id <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">++</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//++++a;   也是允许的，但 a++++ 不允许。</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">++</span><span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后置operator++(int) 的叠加是不允许的，原因有两个：一是与内建类型行为不一致（内建类型支持前置叠加)；二是其效果跟调用一次 operator++(int) 效果一样，这是违反直觉的。另外，后置式操作符使用 operator++(int)，参数的唯一目的只是为了区别前置式和后置式而已，当函数被调用时，编译器传递一个0作为int参数的值传递给该函数。<br>处置用户定制类型时，尽可能使用前置式，因为后置式会产生一个临时对象。</p><h3 id="7、千万不要重载-amp-amp-和-操作符"><a href="#7、千万不要重载-amp-amp-和-操作符" class="headerlink" title="7、千万不要重载 &amp;&amp;, || 和 , 操作符"></a>7、千万不要重载 &amp;&amp;, || 和 , 操作符</h3><pre><code>int *pi = NULL;if(pi != 0 &amp;&amp; cout&lt;&lt;*pi&lt;&lt;endl) { }</code></pre><p>上面的代码不会报错，虽然 pi 是空指针，但 &amp;&amp; 符号采用”骤死式”评估方式，如果 pi == 0 的话，不会执行后面的语句。</p><p>不要重载这些操作符，是因为我们无法控制表达式的求解优先级，不能真正模仿这些运算符。操作符重载的目的是使程序更容易阅读，书写和理解，而不是来迷惑其他人。如果没有一个好理由重载操作符，就不要重载。而对于&amp;&amp;，||和“，”，很难找到一个好理由。 </p><h3 id="8、了解各种不同意义的-new-和-delete"><a href="#8、了解各种不同意义的-new-和-delete" class="headerlink" title="8、了解各种不同意义的 new 和 delete"></a>8、了解各种不同意义的 new 和 delete</h3><p>new 操作符的执行过程：</p><ol><li>调用operator new分配内存 ；//这一步可以使用 operator new 或 placement new 重载。</li><li>调用构造函数生成类对象；</li><li>返回相应指针。</li></ol><p>函数 operator new 通常声明如下： </p><p>void * operator new(size_t size);　　//第一个参数必须为 size_t，表示需要分配多少内存。</p><p>返回值为void型指针，表示这个指针指向的内存中的数据的类型要由用户来指定。比如内存分配函数malloc函数返回的指针就是void *型，用户在使用这个指针的时候，要进行强制类型转换，如（int *)malloc(1024)。任何类型的指针都可以直接赋给 void * 变量，而不必强制转换。如果函数的参数可以为任意类型的指针，则可以声明为 void * 了。 </p><p>void 有两个地方可以使用，第一是函数返回值，第二是作为无参函数的参数。（因为在C语言中，可以给无参函数传任意类型的参数，而且C语言中，没有指定函数返回值时，默认返回为 int 值）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"size: "</span><span class="token operator">&lt;&lt;</span>size<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span>std<span class="token operator">::</span>string str<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"size: "</span><span class="token operator">&lt;&lt;</span>size <span class="token operator">&lt;&lt;</span><span class="token string">"\nname: "</span> <span class="token operator">&lt;&lt;</span> str<span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    User<span class="token operator">*</span> user1 <span class="token operator">=</span> <span class="token keyword">new</span> User<span class="token punctuation">;</span>    User<span class="token operator">*</span> user2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token string">"JIM"</span><span class="token punctuation">)</span>User<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>    pi <span class="token operator">=</span> p<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>pi<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、异常-Exceptions"><a href="#三、异常-Exceptions" class="headerlink" title="三、异常(Exceptions)"></a>三、异常(Exceptions)</h2><h3 id="9、利用-destructors-避免泄漏资源"><a href="#9、利用-destructors-避免泄漏资源" class="headerlink" title="9、利用 destructors 避免泄漏资源"></a>9、利用 destructors 避免泄漏资源</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">void</span> <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>pi<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">try</span>    <span class="token punctuation">{</span>        <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果此处抛出异常而未处理，则无法执行 delete 语句，造成内存泄漏。</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>        <span class="token keyword">throw</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">delete</span> pi<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 一个函数在堆里申请内存到释放内存的过程中，如果发生异常，如果自己不处理而只交给调用程序处理，则可能由于未调用 delete 导致内存泄漏。上面的方法可以解决这一问题，不过这样的代码使人看起来心烦且难于维护，而且必须写双份的 delete 语句。函数返回时局部对象总是释放（调用其析构函数），无论函数是如何退出的。（仅有的一种例外是当调用 longjmp 时，而 longjmp 这个缺点也是C++最初支持异常处理的原因）</p><p>所以这里使用智能指针或类似于智能指针的对象是比较好的办法：</p><ul><li>auto_ptr; — 基本被弃用.</li><li>shared_ptr; — 共享指针, 引用计数为零就销毁对象空间.</li><li>weak_ptr; — weak_ptr是用来解决shared_ptr相互引用时的死锁问题. 弱引用不会增加引用计数.</li><li>unique_ptr; — unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权.<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">void</span> <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ap</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用 auto_ptr 包装一下</span>  std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>pi<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>上面的代码看起来简洁多了，因为 auto_ptr 会在离开作用域时调用其析构函数，析构函数中会做 delete 动作。  </p><h3 id="10、在-constructors-内阻止资源泄漏"><a href="#10、在-constructors-内阻止资源泄漏" class="headerlink" title="10、在 constructors 内阻止资源泄漏"></a>10、在 constructors 内阻止资源泄漏</h3><p>这一条讲得其实是捕获构造函数里的异常的重要性。</p><p><strong>堆栈辗转开解（stack-unwinding）：</strong>如果一个函数中出现异常，在函数内即通过 try..catch 捕捉的话，可以继续往下执行；如果不捕捉就会抛出（或通过 throw 显式抛出）到外层函数，则当前函数会终止运行，释放当前函数内的局部对象（局部对象的析构函数就自然被调用了），外层函数如果也没有捕捉到的话，会再次抛出到更外层的函数，该外层函数也会退出，释放其局部对象……如此一直循环下去，直到找到匹配的 catch 子句，如果找到 main 函数中仍找不到，则退出程序。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> userid_<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> username_ <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string address_ <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token function">userid</span><span class="token punctuation">(</span>userid_<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">username</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            username <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>username_<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//构造函数里抛出异常的话，由于对象没有构造完成，不会执行析构函数</span>            address <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>address_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//此例中不会执行,会导致内存泄漏</span>        <span class="token punctuation">{</span>            <span class="token keyword">delete</span> username<span class="token punctuation">;</span>            <span class="token keyword">delete</span> address<span class="token punctuation">;</span>            std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~B()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> userid<span class="token punctuation">;</span>        std<span class="token operator">::</span>string<span class="token operator">*</span> username<span class="token punctuation">;</span>        std<span class="token operator">::</span>string<span class="token operator">*</span> address<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> C++拒绝为没有完成构造函数的对象调用析构函数，原因是避免开销，因为只有在每个对象里加一些字节来记录构造函数执行了多少步，它会使对象变大，且减慢析构函数的运行速度。</p><p>一般建议不要在构造函数里做过多的资源分配，而应该把这些操作放在一个类似于 init 的成员函数中去完成。这样当 init 成员函数抛出异常时，如果对象是在栈上，析构函数仍会被调用(异常会自动销毁局部对象，调用局部对象的析构函数，见下面)，如果是在堆上，需要在捕获异常之后 delete 对象来调用析构函数。</p><h3 id="11、禁止异常流出-destructors-之外"><a href="#11、禁止异常流出-destructors-之外" class="headerlink" title="11、禁止异常流出 destructors 之外"></a>11、禁止异常流出 destructors 之外</h3><p>这一条讲得其实是捕获析构函数里的异常的重要性。第一是防止程序调用 terminate 终止（这里有个名词叫：堆栈辗转开解 stack-unwinding）；第二是析构函数内如果发生异常，则异常后面的代码将不执行，无法确保我们完成我们想做的清理工作。</p><p>之前我们知道，析构函数被调用，会发生在对象被删除时，如栈对象超出作用域或堆对象被显式 delete (还有继承体系中，virtual 基类析构函数会在子类对象析构时调用)。除此之外，在异常传递的堆栈辗转开解（stack-unwinding）过程中，异常处理系统也会删除局部对象，从而调用局部对象的析构函数，而此时如果该析构函数也抛出异常，C++程序是无法同时处理两个异常的，就会调用 terminate()终止程序(会立即终止，连局部对象也不释放)。另外，如果异常被抛出，析构函数可能未执行完毕，导致一些清理工作不能完成。</p><p>所以不建议在析构函数中抛出异常，如果异常不可避免，则应在析构函数内捕获，而不应当抛出。 场景再现如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> T<span class="token punctuation">{</span>    <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"T()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">"init() throw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~T() begin"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">"~T() throw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~T() end"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pi<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        T t<span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下面也会引发 terminate</span>    <span class="token comment" spellcheck="true">/*    try    {        int *p2 = new int[1000000000000L];    }catch(std::bad_alloc&amp;)    {        std::cout&lt;&lt;"bad_alloc"&lt;&lt;std::endl;    }    */</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">terminate_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"my terminate_handler()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">set_terminate</span><span class="token punctuation">(</span>terminate_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12、了解-“抛出一个-exception-”-与-“传递一个参数”-或-“调用一个虚函数”之间的差异"><a href="#12、了解-“抛出一个-exception-”-与-“传递一个参数”-或-“调用一个虚函数”之间的差异" class="headerlink" title="12、了解 “抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异"></a>12、了解 “抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异</h3><p>抛出异常对象，到 catch 中，有点类似函数调用，但是它有几点特殊性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>        <span class="token keyword">throw</span> pi<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pi指向的对象是静态的，所以才能抛出指针</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果抛出的是 int 对象的异常，是不能用 double 类型接收的，这一点跟普通函数传参不一样。异常处理中，支持的类型转换只有两种，一种是上面例子中演示的从”有型指针”转为”无型指针”，所以用 const void* 可以捕捉任何指针类型的 exception。另一种是继承体系中的类转换，可见下一条款的例子。<br>另外，它跟虚拟函数有什么不同呢？异常处理可以出现多个 catch 子句，而匹配方式是按先后顺序来匹配的（所以如 exception 异常一定要写在 runtime_error异常的后面，如果反过来的话，runtime_error异常语句永远不会执行），而虚函数则是根据虚函数表来的。</p><h3 id="13、以-by-reference-方式捕捉-exceptions"><a href="#13、以-by-reference-方式捕捉-exceptions" class="headerlink" title="13、以 by reference 方式捕捉 exceptions"></a>13、以 by reference 方式捕捉 exceptions</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>id <span class="token operator">=</span> b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里是静态对象</span>    <span class="token keyword">throw</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//只有该对象是静态对象或全局对象时，才能以指针形式抛出</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">try</span><span class="token punctuation">{</span>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>B<span class="token operator">*</span> b<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//这里以指针形式接收</span> <span class="token punctuation">{</span>     std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>b<span class="token operator">-</span><span class="token operator">></span>id<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出3</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用指针方式来捕捉异常，上面的例子效率很高，没有产生临时对象。但是这种方式只能运用于全局或静态的对象（如果是 new 出来的堆中的对象也可以，但是该何时释放呢？）身上，否则的话由于对象离开作用域被销毁，catch中的指针指向不复存在的对象。接下来看看对象方式和指针方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"print():B"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"D copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"print():D"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    D d<span class="token punctuation">;</span>    <span class="token keyword">throw</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>B b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//注意这里</span>    <span class="token punctuation">{</span>        b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子会输出：</p><p>可是如果把 catch(B b) 改成 catch(B&amp; b) 的话，则会输出：</p><p>该条款的目的就是告诉我们，请尽量使用引用方式来捕捉异常，它可以避免 new 对象的删除问题，也可以正确处理继承关系的多态问题，还可以减少异常对象的复制次数。 </p><h3 id="14、明智运用-exception-specifications"><a href="#14、明智运用-exception-specifications" class="headerlink" title="14、明智运用 exception specifications"></a>14、明智运用 exception specifications</h3><p>C++提供了一种异常规范，即在函数后面指定要抛出的异常类型，可以指定多个：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//必须这样声明，而不能是 void fun(void);</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//说明可能抛出 int 和 double 异常</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>d<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="15、了解异常处理的成本"><a href="#15、了解异常处理的成本" class="headerlink" title="15、了解异常处理的成本"></a>15、了解异常处理的成本</h3><p>大致的意思是，异常的开销还是比较大的，只有在确实需要用它的地方才去用。</p><h2 id="四、效率-Efficiency"><a href="#四、效率-Efficiency" class="headerlink" title="四、效率(Efficiency)"></a>四、效率(Efficiency)</h2><h3 id="16、谨记-80-20-法则"><a href="#16、谨记-80-20-法则" class="headerlink" title="16、谨记 80-20 法则"></a>16、谨记 80-20 法则</h3><p>大致的意思是说，程序中80%的性能压力可能会集中在20%左右的代码处。那怎么找出这20%的代码来进行优化呢？可以通过Profiler分析程序等工具来测试，而不要凭感觉或经验来判断。</p><h3 id="17、考虑使用-lazy-evaluation（缓式评估）"><a href="#17、考虑使用-lazy-evaluation（缓式评估）" class="headerlink" title="17、考虑使用 lazy evaluation（缓式评估）"></a>17、考虑使用 lazy evaluation（缓式评估）</h3><p>懒惰计算法的含义是拖延计算的时间，等到需要时才进行计算其作用为：能避免不需要的对象拷贝，通过使用operator[]区分出读写操作，避免不需要的数据库读取操作，避免不需要的数字操作但是，如果计算都是重要的，懒惰计算法可能会减慢速度并增加内存的使用</p><h3 id="18、分期摊还预期的计算成本"><a href="#18、分期摊还预期的计算成本" class="headerlink" title="18、分期摊还预期的计算成本"></a>18、分期摊还预期的计算成本</h3><ul><li><p>over-eager evaluation, 如果程序常常用到某个计算, 设计一份数据结构以便能够及有效率地处理需求</p></li><li><p>(caching)利用告诉缓存暂存使用频率高的内容.</p></li><li><p>caching是分期摊还预期计算成本的一种做法. 预先取出是另一种做法. ◦系统调用往往比进程内的函数调用慢.</p></li><li><p>较快的速度往往导致较大的内存, 空间交换时间.</p></li><li><p>较大对象比较不容易塞入虚内存分页(virtual memory page)或缓存分页(cache page). ◦对象变大可能会降低性能, 因为换页活动会增加,<br>缓存命中率(cache hit rate)会降低. </p></li></ul><h3 id="19、了解临时对象的来源"><a href="#19、了解临时对象的来源" class="headerlink" title="19、了解临时对象的来源"></a>19、了解临时对象的来源</h3><p>C++真正所谓的临时对象是不可见的——只要产生一个 non-heap object 而没有为它命名，就产生了一个临时对象。它一般产生于两个地方：</p><p>一是函数参数的隐式类型转换，</p><p>二是函数返回对象时。 </p><p>任何时候，只要你看到一个 reference-to-const参数，就极可能会有一个临时对象被产生出来绑定至该参数上；任何时候，只要你看到函数返回一个对象，就会产生临时对象（并于稍后销毁）。</p><h3 id="20、协助完成“返回值优化-RVO-”"><a href="#20、协助完成“返回值优化-RVO-”" class="headerlink" title="20、协助完成“返回值优化(RVO)”"></a>20、协助完成“返回值优化(RVO)”</h3><p>不要在一个函数里返回一个局部对象的地址，因为它离开函数体后就析构了。不过在GCC下可以正常运行，无论是否打开优化；而在VS2010中如果关闭优化，就会看到效果。</p><p>这个条款想说的是：const Test fun(){ return Test(); } 比 const Test fun(){Test test; return test; }  好，更能使编译器进行优化。<br>不过现在看来，在经过编译器优化之后，这两个好像已经没有什么区别了。</p><h3 id="21、利用重载技术避免隐式类型转换"><a href="#21、利用重载技术避免隐式类型转换" class="headerlink" title="21、利用重载技术避免隐式类型转换"></a>21、利用重载技术避免隐式类型转换</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b1<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>id <span class="token operator">+</span> b2<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//const B operator+(const B&amp; b1,int i)    //如果重载此方法，就不会产生临时对象了</span><span class="token comment" spellcheck="true">//{</span><span class="token comment" spellcheck="true">//  return B(b1.id + i);</span><span class="token comment" spellcheck="true">//}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    B b3 <span class="token operator">=</span> b1<span class="token operator">+</span> b2<span class="token punctuation">;</span>    B b4 <span class="token operator">=</span> b1 <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//会把 6 先转换成B对象，产生临时对象</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="22、考虑以操作符复合形式-op-取代其独身形式-op"><a href="#22、考虑以操作符复合形式-op-取代其独身形式-op" class="headerlink" title="22、考虑以操作符复合形式(op=)取代其独身形式(op)"></a>22、考虑以操作符复合形式(op=)取代其独身形式(op)</h3><p>使用 operator+= 的实现来实现 operator= ，其它如果 operator*=、operator-= 等类似。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        B<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            id <span class="token operator">+</span><span class="token operator">=</span>  b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>id<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b1<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不用声明为 B 的 friend 函数,而且只需要维护 operator+= 即可。</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>B<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token operator">=</span> b2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里要去掉b1的const属性，才能带入operator+= 中的 this 中</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b3</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>b1<span class="token operator">+</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10    这里进行 operator+ 操作，会改变 b1 的值，这个不应该吧</span>    b1<span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//10</span>    b3<span class="token operator">+</span><span class="token operator">=</span>b1<span class="token punctuation">;</span>    b3<span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//110</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="23、考虑使用其它程序库"><a href="#23、考虑使用其它程序库" class="headerlink" title="23、考虑使用其它程序库"></a>23、考虑使用其它程序库</h3><p>提供类似功能的程序库，可能在效率、扩充性、移植性和类型安全方面有着不同的表现。比如说 iostream 和 stdio 库，所以选用不同的库可能会大幅改善程序性能。</p><h3 id="24、了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification-的成本"><a href="#24、了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification-的成本" class="headerlink" title="24、了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本"></a>24、了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本</h3><p>在使用虚函数时，大部分编译器会使用所谓的 virtual tables 和 virtual table pointers ，通常简写为 vtbls 和 vptrs 。vtbl 通常是由 “函数指针” 架构而成的数组，每一个声明（或继承）虚函数的类都有一个 vtbl ，而其中的条目就是该 class 的各个虚函数实现体的指针。<br>虚函数的第一个成本：必须为每个拥有虚函数的类耗费一个 vtbl 空间，其大小视虚函数的个数（包括继承而来的）而定。不过，一个类只会有一个 vtbl 空间，所以一般占用空间不是很大。</p><p>不要将虚函数声明为 inline ，因为虚函数是运行时绑定的，而 inline 是编译时展开的，即使你对虚函数使用 inline ，编译器也通常会忽略。<br>虚函数的第二个成本：必须为每个拥有虚函数的类的对象，付出一个指针的代价，即 vptr ，它是一个隐藏的 data member，用来指向所属类的 vtbl。</p><p>调用一个虚函数的成本，基本上和通过一个函数指针调用函数相同，虚函数本身并不构成性能上的瓶颈。</p><p>虚函数的第三个成本：事实上等于放弃了 inline。（如果虚函数是通过对象被调用，倒是可以 inline，不过一般都是通过对象的指针或引用调用的）</p><ul><li><p>虚函数真正的运行时期成本发生在和inlining互动的时候. 虚函数不应该inline. ◦因为inline函数需要在编译器将函数本体拷贝, 而virtual意味着等待, 直到运行期才知道运行谁.</p></li><li><p>多重继承往往导致虚基类的需求(virtual base class), 会形成更复杂和特殊的虚表.</p></li><li><p>一个类只需一份RTTI信息(运行时类型识别), 当某种类型至少拥有一个虚函数, 才能保证检验该对象的动态类型. </p><ul><li><p>RTTI的设计理念根据类的虚表(vtbl)来实现的.</p></li><li><p>RTTI的空间成本只需在每个类的虚表(vtbl)内增加一个条目, 即一个类型信息(type_info)对象空间.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> B1 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B2 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B3 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> <span class="token keyword">virtual</span> B1<span class="token punctuation">,</span> <span class="token keyword">virtual</span> B2<span class="token punctuation">,</span> <span class="token keyword">virtual</span> B3 <span class="token punctuation">{</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B1<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//8</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B2<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//4</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//4</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//16</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//D 中只包含了三个 vptr ，D和B1共享了一个。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="五、技术-Techniques-Idioms-Patterns"><a href="#五、技术-Techniques-Idioms-Patterns" class="headerlink" title="五、技术(Techniques,Idioms,Patterns)"></a>五、技术(Techniques,Idioms,Patterns)</h2><h3 id="25、将-constructor-和-non-member-functions-虚化"><a href="#25、将-constructor-和-non-member-functions-虚化" class="headerlink" title="25、将 constructor 和 non-member functions 虚化"></a>25、将 constructor 和 non-member functions 虚化</h3><p>这里所谓的虚拟构造函数，并不是真的指在构造函数前面加上 virtual 修饰符，而是指能够根据传入不同的参数建立不同继承关系类型的对象。<br>被派生类重定义的虚函数可以与基类的虚函数具有不同的返回类型。所以所谓的虚拟复制构造函数，可以在基类里声明一个 virtual B* clone() const = 0 的纯虚函数，在子类中实现 virtual D* clone() const {return new D(*this);}</p><p>同样的，非成员函数虚化，这里也并不是指使用 virtual 来修饰非成员函数。比如下面这个输出 list 中多态对象的属性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">value</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">virtual</span> ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span><span class="token operator">:</span>        string value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D1</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">D1</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token string">"protect value"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//子类构造函数中，要先调用基类构造函数初始化基类</span>        ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>id<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//如果基类虚函数是 const 方法，则这里也必须使用 const 修饰</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D2</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">D2</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token string">"protect value"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//子类构造函数中，要先调用基类构造函数初始化基类</span>        ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>id<span class="token punctuation">;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span> lt<span class="token punctuation">;</span>    D1 <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D2 <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>    lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d2<span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>it <span class="token operator">!=</span> lt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//D1   D2</span>        it<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，即使给每一个继承类单独实现友元的 operator&lt;&lt; 方法，也不能实现动态绑定，只会调用基类的方法。那么，在基类里写 operator&lt;&lt; 用 virtual 修饰不就行了吗？遗憾的，虚函数不能是友元。</p><h3 id="26、限制某个-class-所能产生的对象数量"><a href="#26、限制某个-class-所能产生的对象数量" class="headerlink" title="26、限制某个 class 所能产生的对象数量"></a>26、限制某个 class 所能产生的对象数量</h3><p>只有一个对象：使用单一模式，将类的构造函数声明为private，再声明一个静态函数，该函数中有一个类的静态对象不将该静态对象放在类中原因是放在函数中时，执行函数时才建立对象，并且对象初始化时间确定的，即第一次执行该函数时另外，该函数不能声明为内联，如果内联可能造成程序的静态对象拷贝超过一个限制对象个数：建立一个基类，构造函数中计数加一，若超过最大值则抛出异常；析构函数中计数减一</p><p>编程点滴：</p><p>将模板类的定义和实现放在一个文件中，否则将造成引用未定义错误（血的教训）；</p><p>静态数据成员需要先声明再初始化；</p><p>用常量值作初始化的有序类型的const静态数据成员是一个常量表达式（可以作为数组定义的维数）；</p><p>构造函数中抛出异常，将导致静态数组成员重新初始化</p><h3 id="27、要求（或禁止）对象产生于-heap-中"><a href="#27、要求（或禁止）对象产生于-heap-中" class="headerlink" title="27、要求（或禁止）对象产生于 heap 中"></a>27、要求（或禁止）对象产生于 heap 中</h3><p>析构函数私有，有一个致命问题：妨碍了继承和组合（内含）。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span>    <span class="token comment" spellcheck="true">//禁止对象产生于 heap 中</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B1"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B2</span>    <span class="token comment" spellcheck="true">//要求对象产生于 heap 中</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//模拟的析构函数</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token operator">~</span><span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//B1* b1  = new B1; //Error!</span>    B1 b1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//B2 b2;    //Error</span>    B2<span class="token operator">*</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> B2<span class="token punctuation">;</span>    b2<span class="token operator">-</span><span class="token operator">></span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="28、Smart-Pointer（智能指针）"><a href="#28、Smart-Pointer（智能指针）" class="headerlink" title="28、Smart Pointer（智能指针）"></a>28、Smart Pointer（智能指针）</h3><ul><li><p>智能指针是一个看起来, 用起来, 感觉起来都像内建指针, 但是提供了更多机能的一种对象. </p><ul><li>资源管理;</li><li>自动的重复写码工作.</li></ul></li><li><p>以智能指针取代C++内建指针: </p><ul><li>构造和析构: 何时被产生以及何时被销毁.</li><li>赋值和复制(Assignment and Copying), 复制和赋值其所指对象, 执行所谓的深拷贝(deep copy).</li><li>解引用(Dereferencing): 智能指针有权决定所指之物发生了什么事情. </li><li>采用lazy fetching方法.</li></ul></li><li><p>远程过程调用(remote procedure calls, RPC).</p></li><li><p>只能指针的构造, 赋值和析构 </p><ul><li>只有当确定要将对象所有权传递给函数的某个参数时, 才应该以by value方式传递auto_ptrs.</li></ul></li><li><p>实现解引操作符(Dereferencing Operators): </p><ul><li>返回引用值.</li></ul></li><li><p>测试智能指针是否为null: </p><ul><li>提供一个隐式类型转换操作符来进行测试.</li></ul></li><li><p>将智能指针(smart pointers) 转换为内建指针(Dumb Pointers). </p><ul><li>不要提供对内建指针的隐式转换操作符, 除非不得已.</li></ul></li><li><p>智能指针(Smart Pointers)和继承有关的类型转换 </p><ul><li>每个只能指针有个隐式类型转换操作符, 用来转换至另一个只能指针类.</li><li>函数调用的自变量匹配规则;</li><li>隐式类型转换函数;</li><li>template函数的暗自实例化;</li><li>成员函数模板(member function templates)等技术.</li></ul></li><li><p>智能指针与const: </p><ul><li>const用来修饰被指之物, 或是指针本身, 或是两者都可以. 智能指针也具有同样的弹性.</li><li>对于智能指针只有一个地方可以放置const: 只能放置与指针身上, 不能置于所指的对象.</li><li>non-const转换至const是安全的, 从const转换至non-const则不安全.</li></ul></li><li><p>自己实现的智能指针不容易实现, 了解和维护.</p></li></ul><h3 id="29、Reference-counting（引用计数）"><a href="#29、Reference-counting（引用计数）" class="headerlink" title="29、Reference counting（引用计数）"></a>29、Reference counting（引用计数）</h3><p>使用引用计数后，对象自己拥有自己，当没有人再使用它时，它自己自动销毁自己因此，引用计数是个简单的垃圾回收体系</p><p>在基类中调用delete this将导致派生类的对象被销毁</p><p>写时拷贝：与其它对象共享一个值直到写操作时才拥有自己的拷贝它是Lazy原则的特例</p><p>精彩的类层次结构：<br>RCObject类提供计数操作；<br>StringValue包含指向数据的指针并继承RCObject的计数操作；<br>RCPtr是一个灵巧指针，封装了本属于String的一些计数操作</p><h3 id="30、Proxy-classes（替身类、代理类）"><a href="#30、Proxy-classes（替身类、代理类）" class="headerlink" title="30、Proxy classes（替身类、代理类）"></a>30、Proxy classes（替身类、代理类）</h3><ul><li><p>凡是用来代表(象征)其他对象的对象, 常被称为proxy object(替身对象), 替身对象的类称为代理类. </p><ul><li>二维数组是观念上并不存在的一维数组.</li></ul></li><li><p>读取动作是所谓的右值运用(rvalue usage); 写动作是所谓的左值运用(lvalue usages).</p></li><li><p>返回字符串中字符的proxy, 而不返回字符本身.</p></li><li><p>对于一个proxy, 只有3间事情可做: </p><ul><li>产生它;</li><li>以它作为赋值动作的目标(接收端).</li><li>以其他方式使用它.</li></ul></li><li><p>Proxy 类很适合用来区分operator[]的左值运用和右值运用.</p></li><li><p>对proxy取址所获得的指针类型和对真是对象取址所获得的指针类型不同.</p></li><li><p>用户将proxy传递给接受引用到非const对象的函数.</p></li><li><p>ploxies难以完全取代真正对象的最后一个原因在于隐式类型转换.</p></li><li><p>proxy 对象是一种临时对象, 需要被产生和被销毁.</p></li><li><p>类的身份从与真实对象合作转移到与替身对象(proxies)合作, 往往会造成类语义的改变, 因为proxy 对象所展现的行为常常和真正的行为有些隐微差异.</p></li></ul><h3 id="31、让函数根据一个以上的对象类型来决定如何虚化"><a href="#31、让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="31、让函数根据一个以上的对象类型来决定如何虚化"></a>31、让函数根据一个以上的对象类型来决定如何虚化</h3><ul><li><p>面向对象函数调用机制(mutil-method): 根据所希望的多个参数而虚化的函数; — C++暂时不支持.</p></li><li><p>消息派分(message dispatch): 虚函数调用动作.</p></li><li><p>虚函数+RTTI(运行时期类型辨识): </p><ul><li>虚函数可以实现single dispatch, 利用typeid操作符来获取一个类的类型参数值.</li></ul></li><li><p>虚函数被发明的主要原因: </p><ul><li>把生产及维护”以类型为行事基准的函数”的负荷, 从程序员转移给编译器.</li></ul></li><li><p>只用虚函数: </p><ul><li>将double dispatching以两个single dispatches(两个分离的虚函数调用)实现出来: <ul><li>一个用来决定第一对象的动态类型.</li><li>另一个用来决定第二对象的动态类型.</li></ul></li><li>编译器必须根据此函数所获得的自变量的静态类型(被声明时的类型), 才能解析出哪一组函数被调用.</li></ul></li></ul><h2 id="六、杂项讨论-Miscellany"><a href="#六、杂项讨论-Miscellany" class="headerlink" title="六、杂项讨论(Miscellany)"></a>六、杂项讨论(Miscellany)</h2><h3 id="32、在未来时态下发展程序"><a href="#32、在未来时态下发展程序" class="headerlink" title="32、在未来时态下发展程序"></a>32、在未来时态下发展程序</h3><p>要用语言提供的特性来强迫程序符合设计，而不要指望使用者去遵守约定。比如禁止继承，禁止复制，要求类的实例只能创建在堆中等等。处理每个类的赋值和拷贝构造函数，如果这些函数是难以实现的，则声明它们为私有。</p><p>所提供的类的操作和函数有自然的语法和直观的语义，和内建类型（如 int）的行为保持一致。</p><p>尽可能写可移植性的代码，只有在性能极其重要时不可移植的结构才是可取的。</p><p>多为未来的需求考虑，尽可能完善类的设计。</p><h3 id="33、将非尾端类设计为抽象类"><a href="#33、将非尾端类设计为抽象类" class="headerlink" title="33、将非尾端类设计为抽象类"></a>33、将非尾端类设计为抽象类</h3><p>如果有一个实体类公有继承自另一个实体类，应该将两个类的继承层次改为三个类的继承层次，通过创造一个新的抽象类并将其它两个实体类都从它继承因此，设计类层次的一般规则是：非尾端类应该是抽象类在处理外来的类库，可能不得不违反这个规则</p><p>编程点滴：抽象类的派生类不能是抽象类；实现纯虚函数一般不常见，但对纯虚析构函数，它必须实现</p><h3 id="34、如何在同一个程序中结合-C-和-C"><a href="#34、如何在同一个程序中结合-C-和-C" class="headerlink" title="34、如何在同一个程序中结合 C++ 和 C"></a>34、如何在同一个程序中结合 C++ 和 C</h3><ul><li><p>结合C++和C程序需要考虑的问题: </p><ul><li>名称重整(name mangling): <ul><li>名称重整(name mangling)是C++中的一种程序, 为每个函数编出独一无二的名称.</li><li>绝不要重整其他语言编写函数的名称.</li><li>压制名称重整(name mangling), 必须在C++中使用extern “C” { … }指令. — 进行C连接.</li><li>不同编译器以不同的方法进行重整名称.        </li></ul></li><li>static的初始化: <ul><li>在main之前执行的代码: static class对象, 全局对象, namespace内的对象, 文件范围(file scope)内的对象, 其构造函数都在main函数之前执行.</li></ul></li></ul></li><li><p>动态内存分配: </p><ul><li>C++中使用new和delete, C中使用malloc和free.</li></ul></li><li><p>数据结构的兼容性: </p><ul><li>structs可以安全地在C++和C之间往返.</li></ul></li><li><p>在同一程序中混用C++和C, 应该记住以下几个简单规则: </p><ul><li>确定C++和C编译器产出兼容的目标文件(object file).</li><li>将双方都使用的函数声明为extern “C”.</li><li>如果可能, 尽量在C++中撰写main.</li><li>总是以delete删除new返回的内存, 总是以free释放malloc返回的内存.</li><li>将两个语言间的数据结构传递限制于C所能了解的形式; C++structs如果内涵非虚函数, 倒是不受此限制.</li></ul></li></ul><h3 id="35、让自己习惯于标准-C-语言"><a href="#35、让自己习惯于标准-C-语言" class="headerlink" title="35、让自己习惯于标准 C++ 语言"></a>35、让自己习惯于标准 C++ 语言</h3><ul><li><p>新的语言特性: </p><ul><li>RTTI, 命名空间(namespace), bool, 关键字mutable, 关键字explicit, enums作为重载函数的自变量所引发的类型晋升转换, 在类中为const static成员变量设定初值.</li></ul></li><li><p>STL(standard template library) — C++标准程序库中最大的组成部分. </p><ul><li>迭代器(iterators)是一种行为类似指针的对象, 针对STL 容器而定义.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基础议题-Basics&quot;&gt;&lt;a href=&quot;#一、基础议题-Basics&quot; class=&quot;headerlink&quot; title=&quot;一、基础议题(Basics)&quot;&gt;&lt;/a&gt;一、基础议题(Basics)&lt;/h2&gt;&lt;h3 id=&quot;1、仔细区别-pointers【指针】
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++提升" scheme="http://www.zzw1024.top/tags/c-%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》——读书笔记</title>
    <link href="http://www.zzw1024.top/2020/01/01/effective-c-du-shu-bi-ji/"/>
    <id>http://www.zzw1024.top/2020/01/01/effective-c-du-shu-bi-ji/</id>
    <published>2020-01-01T07:38:26.000Z</published>
    <updated>2020-01-01T07:38:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h3><ul><li>C语言</li><li>面对对象</li><li>C++模板</li><li>STL容器</li></ul><h3 id="尽量以const，enum，inline替换-define"><a href="#尽量以const，enum，inline替换-define" class="headerlink" title="尽量以const，enum，inline替换#define"></a>尽量以const，enum，inline替换#define</h3><ol><li>const的好处： <ol><li>define直接常量替换，出现编译错误不易定位(不知道常量是哪个变量)</li><li>define没有作用域，const有作用域提供了封装性</li></ol></li><li>enum的好处： <ol><li>提供了封装性</li><li>编译器肯定不会分配额外内存空间(其实const也不会)</li></ol></li><li>inline的好处： <ol><li>define宏函数容易造成误用(下面有个例子)</li></ol></li></ol><p>//define误用举例</p><pre><code>#define MAX(a, b) a &gt; b ? a : bint a = 5, b = 0;MAX(++a, b) //a++调用2次MAX(++a, b+10) //a++调用一次</code></pre><p>然而，了解宏的机制以后，我们也可以用宏实现特殊的技巧。例如：C++反射，TEST</p><h3 id="宏实现工厂模式"><a href="#宏实现工厂模式" class="headerlink" title="宏实现工厂模式"></a>宏实现工厂模式</h3><ol><li>需要一个全局的map用于存储类的信息以及创建实例的函数</li><li>需要调用全局对象的构造函数用于注册</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>register_fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CCFactory</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">NewInstance</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> map_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>class_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>it <span class="token operator">==</span> map_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span>      <span class="token keyword">return</span> it<span class="token operator">-</span><span class="token operator">></span><span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Register</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">,</span> register_fun func<span class="token punctuation">)</span><span class="token punctuation">{</span>    map_<span class="token punctuation">[</span>class_name<span class="token punctuation">]</span> <span class="token operator">=</span> func<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">static</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> register_fun<span class="token operator">></span> map_<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> register_fun<span class="token operator">></span> CCFactory<span class="token operator">::</span>map_<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Register</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Register</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">,</span> register_fun func<span class="token punctuation">)</span><span class="token punctuation">{</span>    CCFactory<span class="token operator">::</span><span class="token function">Register</span><span class="token punctuation">(</span>class_name<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> REGISTER_CLASS(class_name); \  const Register class_name_register(#class_name, []()->void *{return new class_name;});</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h3><ol><li>const定义接口，防止误用</li><li>const成员函数，代表这个成员函数承诺不会改变对象值 <ol><li>const成员只能调用const成员函数(加-fpermissive编译选项就可以了)</li><li>非const成员可以调用所有成员函数</li></ol></li></ol><p>尽量使用const来修饰函数名和参数变量名</p><p>尽量使用const来修饰类名<br><code>void function(classA  test);  //classA为自定义的类型</code></p><p>这样使用值传参的缺点：</p><ul><li>会导致自定义类型的构造函数和析构函数多次被调用，当自定义类型的构造函数和析构函数比较费时的时候，效率比较底下。</li><li>在传递派生类时容易产生对象被切割的问题。</li></ul><p>建议：<br><code>void function(const classA &amp;s);</code></p><p>优点：</p><ul><li>可以回避自定义类型的构造和析构函数的调用，不会影响效率。</li><li>不会产生对象切割问题，因为引用的底层其实就是指针，在内存中只有一份实例。</li></ul><p>原则：</p><ul><li>如果可以的话，尽量传递 const 的引用作为函数的参数。</li><li>不要将这个条款应用在内置类型上，对于内置类型(int double)，pass-by-value更适合。</li></ul><h3 id="确定对象使用前已被初始化"><a href="#确定对象使用前已被初始化" class="headerlink" title="确定对象使用前已被初始化"></a>确定对象使用前已被初始化</h3><ol><li>内置类型需要定义时初始化</li><li>最好使用初始化序列(序列顺序与声明顺序相同)，而不是在构造函数中赋值</li><li>跨编译单元定义全局对象不能确保初始化顺序 </li></ol><p>将static对象放入一个函数<br>Fuck&amp; fuck(){<br>    static Fuck f;<br>    return f;<br>}</p><h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="了解C-默默编调用了哪些函数"><a href="#了解C-默默编调用了哪些函数" class="headerlink" title="了解C++默默编调用了哪些函数"></a>了解C++默默编调用了哪些函数</h3><p>如果类中没有定义，程序却调用了，编译器会产生一些函数</p><ul><li><p>一个 default 构造函数</p></li><li><p>一个 copy 构造函数</p></li><li><p>一个 copy assignment 操作符</p></li><li><p>一个析构函数(non virtual)</p></li><li><p>如果自己构造了带参数的构造函数，编译器不会产生default构造函数</p></li><li><p>base class如果把拷贝构造函数或者赋值操作符设置为private，不会产生这两个函数</p></li><li><p>含有引用成员变量或者const成员变量不产生赋值操作符</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Fuck</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>  std<span class="token operator">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用定义后不能修改绑定对象</span>  <span class="token keyword">const</span> std<span class="token operator">::</span>string con_str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//const对象定义后不能修改</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>将默认生成的函数声明为private，或者C++ 11新特性”=delete”</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Uncopyable</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Uncopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h3><ol><li>给多态基类应该主动声明virtual析构函数</li><li>非多态基类，没有virtual函数，不要声明virtual析构函数</li></ol><h3 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h3><p>构造函数可以抛出异常，析构函数不能抛出异常。</p><p>因为析构函数有两个地方可能被调用。一是用户调用，这时抛出异常完全没问题。二是前面有异常抛出，正在清理堆栈，调用析构函数。这时如果再抛出异常，两个异常同时存在，异常处理机制只能terminate().</p><p>构造函数抛出异常，会有内存泄漏吗？</p><p>不会</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第二步，调用构造函数构造对象</span>    <span class="token keyword">new</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>T<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// placement new: 只调用T的构造函数</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 释放第一步分配的内存</span>    <span class="token keyword">throw</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 重抛异常，通知应用程序</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绝不在构造和析构过程中调用virtual函数"><a href="#绝不在构造和析构过程中调用virtual函数" class="headerlink" title="绝不在构造和析构过程中调用virtual函数"></a>绝不在构造和析构过程中调用virtual函数</h3><p>构造和析构过程中，虚表指针指向的虚表在变化。调用的是对应虚表指针指向的函数。</p><h3 id="令operator-返回一个reference-to-this"><a href="#令operator-返回一个reference-to-this" class="headerlink" title="令operator= 返回一个reference to *this"></a>令operator= 返回一个reference to *this</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x，y，z；x<span class="token operator">=</span>y<span class="token operator">=</span>z<span class="token operator">=</span><span class="token number">15</span>；同样有趣的是，赋值采用右结合律，x<span class="token operator">=</span>（y<span class="token operator">=</span>（z<span class="token operator">=</span><span class="token number">15</span>））；Widget<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span>（<span class="token keyword">const</span> Widget<span class="token operator">&amp;</span>rhs）<span class="token comment" spellcheck="true">//返回类型是个reference，</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token operator">*</span><span class="token keyword">this</span>；<span class="token operator">/</span>返回左侧对象<span class="token punctuation">}</span><span class="token operator">*</span> 在<span class="token keyword">operator</span><span class="token operator">=</span> 里处理自我赋值Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span>    ···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制对象时务忘其每一个成分"><a href="#复制对象时务忘其每一个成分" class="headerlink" title="复制对象时务忘其每一个成分"></a>复制对象时务忘其每一个成分</h3><ol><li>记得实现拷贝构造函数和赋值操作符的时候，调用base的相关函数</li><li>可以让拷贝构造函数和赋值操作符调用一个共同的函数，例如init</li></ol><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h3><ol><li>为了防止资源泄漏，请使用RAII对象，在构造函数里面获得资源，在析构函数里面释放资源</li><li>shared_ptr，unique_lock都是RAII对象</li></ol><h3 id="在资源管理类小心copy行为"><a href="#在资源管理类小心copy行为" class="headerlink" title="在资源管理类小心copy行为"></a>在资源管理类小心copy行为</h3><ul><li>常见的RAII对象copy行为 <ol><li>禁止copy</li><li>引用计数</li><li>深度复制</li><li>转移资源拥有权</li></ol></li></ul><h3 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h3><p>用户可能需要原始资源作为参数传入某个接口。有两种方式：</p><ul><li>提供显示调用接口</li><li>提供隐式转换接口(不推荐)</li></ul><h3 id="成对使用new和delete要采用相同的格式"><a href="#成对使用new和delete要采用相同的格式" class="headerlink" title="成对使用new和delete要采用相同的格式"></a>成对使用new和delete要采用相同的格式</h3><p>new和delete对应；new []和delete []对应</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//前面还分配了4个字节代表数组的个数</span><span class="token keyword">int</span> <span class="token operator">*</span>A <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前面分配了8个字节，分别代表对象的个数和Object的大小</span>Object <span class="token operator">*</span>O <span class="token operator">=</span> <span class="token keyword">new</span> Object<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="以独立的语句将newd对象置入智能指针"><a href="#以独立的语句将newd对象置入智能指针" class="headerlink" title="以独立的语句将newd对象置入智能指针"></a>以独立的语句将newd对象置入智能指针</h3><p>调用std::make_shared，而不要调用new，防止new Obeject和传入智能指针的过程产生异常<br>process(new Widget, priority);</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//其实这样也可以，独立的语句</span>shard_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">process</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="让接口容易被正确使用，不易被误用"><a href="#让接口容易被正确使用，不易被误用" class="headerlink" title="让接口容易被正确使用，不易被误用"></a>让接口容易被正确使用，不易被误用</h3><ol><li>好的接口很容易被正确使用，不容易被误用。努力达成这些性质(例如 explicit关键字)</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容</li><li>“防治误用”b包括建立新类型，限制类型上的操作，束缚对象值，以及消除用户的资源管理责任</li><li>shared_ptr支持定制deleter，需要灵活使用</li></ol><ul><li>宁以pass-by-refrence-to-const替换pass-by-value</li></ul><p>1.尽量以pass-by-reference-to-const替换pass-by-value，比较高效，并且可以避免切割问题<br>2.以上规则并不使用内置类型，以及STL迭代器，和函数对象。它们采用pass-by-value更合适(其实采用pass-by-reference-to-const也可以)<br>对象以by value的方式传递，其实际意义是由该对象的copy constructor决定的。这可能会使pass-by-value成为成本很高的动作。<br>以pass by reference，还可以避免所谓的“切割slicing问题”，又称为“upcasting问题”。详见《Thingking in C＋＋》P629<br>pass by reference是一件美妙的事情，但会导致某些复杂性。最知名的问题就是aliasing(别名问题)，见条款17。某些情况下必须pass by value。references的底层几乎都是指针完成，所以passing by reference通常意味着传递的是指针。如果有个小对象，例如一个int，那么pass by value可能比pass by reference的效率更高一些。  </p><ul><li>必须返回对象时，别妄想返回其reference</li></ul><p>1.不要返回pointer或者reference指向一个on stack对象(被析构)<br>2.不要返回pointer或者reference指向一个on heap对象(需要用户delete，我觉得必要的时候也不是不可以)<br>3.不要返回pointer或者reference指向local static对象，却需要多个这样的对象(static只能有一份)</p><ul><li>将成员变量申明为private</li></ul><p>1.切记将成员变量申明为private<br>2.protected并不比public更有封装性(用户可能继承你的base class)</p><h3 id="宁以non-member，non-friend替换member"><a href="#宁以non-member，non-friend替换member" class="headerlink" title="宁以non-member，non-friend替换member"></a>宁以non-member，non-friend替换member</h3><p>作者说多一个成员函数，就多一分破坏封装性，好像有点道理，但是我们都没有这样遵守。直接写member函数方便一些。</p><h3 id="若所有参数都需要类型转换，请为此采用non-member函数"><a href="#若所有参数都需要类型转换，请为此采用non-member函数" class="headerlink" title="若所有参数都需要类型转换，请为此采用non-member函数"></a>若所有参数都需要类型转换，请为此采用non-member函数</h3><p>如果调用member函数，就使得第一个参数的类失去一次类型转换的机会。</p><h3 id="考虑写一个不抛出异常的swap函数"><a href="#考虑写一个不抛出异常的swap函数" class="headerlink" title="考虑写一个不抛出异常的swap函数"></a>考虑写一个不抛出异常的swap函数</h3><ol><li><p>当std::swap效率不高(std::swap调用拷贝构造函数和赋值操作符，如果是深拷贝，效率不会高)，提供一个swap成员函数，并确定不会抛出异常。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token keyword">const</span> Obj<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//深拷贝}</span> Obj<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Obj<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>深拷贝<span class="token keyword">private</span><span class="token operator">:</span> OtherClass <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果提供一个member swap，也该提供一个non-member swap用来调用前者</p></li></ol><ol start="3"><li><p>调用swap时应该针对std::swap使用using声明式，然后调用swap不带任何”命名空间修饰”</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Obj<span class="token operator">&amp;</span> o1<span class="token punctuation">,</span> Obj<span class="token operator">&amp;</span> o2<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这样可以让编译器自己决定调用哪个swap，万一用户没有实现针对Obj的swap，还能调用std::swap</span> <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span> <span class="token function">swap</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>不要往std命名空间里面加东西</p></li></ol><h3 id="在constructor中尽量以initialization动作取代assignment动作"><a href="#在constructor中尽量以initialization动作取代assignment动作" class="headerlink" title="在constructor中尽量以initialization动作取代assignment动作"></a>在constructor中尽量以initialization动作取代assignment动作</h3><p>【尽量使用初始化列表来代替赋值】<br>const members和reference members只能被初始化，不能够被赋值（assigned）。这个时候，如果在构造函数中要对其初始化时必须用member initialization list。 另外，从效率方面考虑，也建议用以initialization动作取代assignment动作。<br>例外的情况：</p><ol><li>static class member不应该在构造函数中初始化。</li><li>如果有很多built-in type类型的class member要初始化，建议使用assignment，这和initialization在效率上没有什么区别，而且容易维护。</li><li>initialization list中的members初始化次序应该和其在class内的声明次序相同</li></ol><p>class members系以它们在class内的声明次序来初始化，和它们在member initialization list中出现的次序完全无关。基类的成员变量永远在继承类成员变量之前被初始化，所以如果运用了继承，你应该在member intialization lists起始处列出base class的初始设定值。</p><p>结论是：对象被初始化时，如果你希望确实掌握真正发生了什么事，请以class内的members声明次序，将各个memebers列于initialization list中。    </p><h3 id="区分member-functions，non-member-functions和friend-functions三者"><a href="#区分member-functions，non-member-functions和friend-functions三者" class="headerlink" title="区分member functions，non-member functions和friend functions三者"></a>区分member functions，non-member functions和friend functions三者</h3><p>member functions和non-member functions的区别是：member functions可以是虚函数，而non-member functions不可以。<br>在一个类中，只要能够避免friend函数，就应该尽量避免，“因为就像真实世界一样，朋友带来的麻烦常常多于其价值。”：）^_^</p><ol><li>虚拟函数必须是class members。</li><li>绝不要让operator&gt;&gt;和operator&lt;&lt;成为members。</li><li>如果non-member functions需要用到class的non-public members，让它成为class的friend functions。   </li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="尽可能延后变量定义式出现的时间"><a href="#尽可能延后变量定义式出现的时间" class="headerlink" title="尽可能延后变量定义式出现的时间"></a>尽可能延后变量定义式出现的时间</h3><p>C语言推荐在函数开始的时候定义所有变量(最开始的C语言编译器要求，现在并不需要)，C++推荐在使用对象前才定义对象</p><h3 id="尽量少做转型动作"><a href="#尽量少做转型动作" class="headerlink" title="尽量少做转型动作"></a>尽量少做转型动作</h3><ol><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。</li><li>如果转型是必要的，试着将它隐藏于某个函数后。客户可以随时调用该函数，而不需要将转型放入自己的代码。</li><li>使用C++风格的转型。</li></ol><h3 id="避免返回handles指向对象内部成分"><a href="#避免返回handles指向对象内部成分" class="headerlink" title="避免返回handles指向对象内部成分"></a>避免返回handles指向对象内部成分</h3><p>简单说，就是成员函数返回指针或者非const引用不要指向成员变量，这样会破坏封装性</p><h3 id="为“异常安全”而努力是值得的"><a href="#为“异常安全”而努力是值得的" class="headerlink" title="为“异常安全”而努力是值得的"></a>为“异常安全”而努力是值得的</h3><ul><li><p>“异常安全函数”承诺即使发生异常也不会有资源泄漏。在这个基础下，它有3个级别 </p><ol><li>基本保证：抛出异常，需要用户处理程序状态改变(自己写代码保证这个级别就行了把)</li><li>强烈保证：抛出异常，程序状态恢复到调用前</li><li>不抛异常：内置类型的操作就绝不会抛出异常</li></ol></li><li><p>“强烈保证”往往可以通过copy-and-swap实现，但是”强烈保证”并非对所有函数都具有实现意义</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//我反正从来没有这样写过</span><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>  Object <span class="token function">new_obj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  new_obj<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token function">swap</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> new_obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="透彻了解inline函数的里里外外"><a href="#透彻了解inline函数的里里外外" class="headerlink" title="透彻了解inline函数的里里外外"></a>透彻了解inline函数的里里外外</h3><p>这里插播一个C++处理定义的重要原则，一处定义原则：</p><ul><li><p>全局变量，静态数据成员，非内联函数和成员函数只能整个程序定义一次</p></li><li><p>类类型(class，struct,union)，内联函数可以每个翻译单元定义一次 </p><ol><li>template类的成员函数或者template函数，定义在头文件中，编译器可以帮忙去重</li><li>普通类的template函数，定义在头文件中，需要加inline</li></ol></li><li><p>inline应该限制在小的，频繁调用的函数上</p></li><li><p>inline只是给编译器的建议，编译器不一定执行</p></li></ul><h3 id="将文件的编译依存关系降到最低"><a href="#将文件的编译依存关系降到最低" class="headerlink" title="将文件的编译依存关系降到最低"></a>将文件的编译依存关系降到最低</h3><ol><li>支持”编译依存最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes(impl对象提供服务)和Interface classes。</li></ol><p>其实就是使用前置声明，下面有个需要注意的点</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Obj.h</span><span class="token keyword">class</span> <span class="token class-name">ObjImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>ObjImpl<span class="token operator">></span> pObjImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上面的写法会报错，因为编译器会再.h文件里面产生默认的析构函数，</span><span class="token comment" spellcheck="true">//析构函数要调用ObjImpl的析构函数，然后我们现在只有声明式，不能调用ObjImpl的实现。</span><span class="token comment" spellcheck="true">//下面的实现才是正确的</span><span class="token comment" spellcheck="true">//Obj.h</span><span class="token keyword">class</span> <span class="token class-name">ObjImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//声明</span>    <span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>ObjImpl<span class="token operator">></span> pObjImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Obj.cpp</span><span class="token comment" spellcheck="true">//现在可以看到ObjImpl的实现</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;ObjImpl></span></span>Obj<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于STL的对象不需要前置声明。</p><h2 id="继承与面对对象设计"><a href="#继承与面对对象设计" class="headerlink" title="继承与面对对象设计"></a>继承与面对对象设计</h2><h3 id="确定你的public继承塑模出is-a模型"><a href="#确定你的public继承塑模出is-a模型" class="headerlink" title="确定你的public继承塑模出is-a模型"></a>确定你的public继承塑模出is-a模型</h3><p>public继承意味着is-a。适用于base class身上的每一个函数也一定适用于derived class。</p><h3 id="避免遮掩继承而来的名称"><a href="#避免遮掩继承而来的名称" class="headerlink" title="避免遮掩继承而来的名称"></a>避免遮掩继承而来的名称</h3><p>子作用域会遮掩父作用域的名称。一般来讲，我们可以有以下几层作用域</p><ul><li>global作用域</li><li>namespace作用域 <ul><li>Base class作用域 <ul><li>Drive class作用域 <ul><li>成员函数 <ul><li>控制块作用域</li></ul></li></ul></li></ul></li><li>非成员函数作用域 <ul><li>控制块作用域</li></ul></li></ul></li></ul><p>注意：遮掩的是上一层作用域的名称，重载(不同参数)的函数也会直接遮掩</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//会遮掩f1()，子类并没有继承f1()</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Drive d<span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>可以通过<span class="token keyword">using</span>声明式或者<span class="token keyword">inline</span>转交解决这一问题<span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//using 声明式</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token operator">::</span>f1<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//inline转交</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Base<span class="token operator">::</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区分接口继承和实现继承"><a href="#区分接口继承和实现继承" class="headerlink" title="区分接口继承和实现继承"></a>区分接口继承和实现继承</h3><ol><li>纯虚函数：提供接口继承 <ol><li>Drived class必须实现纯虚函数</li><li>不能构造含有纯虚函数的类</li><li>纯虚函数可以有成员变量</li><li>可以给纯虚函数提供定义(wtf)</li></ol></li><li>虚函数：提供接口继承和默认的实现继承</li><li>非虚函数：提供了接口继承和强制的实现继承(最好不要在Drived class重新定义非虚函数)</li></ol><p>在编写自己的 class 时，你应该明白提供下面 3 种类型函数的理由</p><ul><li>pure virtual function</li><li>virtual function</li><li>no-virtual function</li></ul><p>何时提供 pure virtual function？</p><p>要求派生类只继承接口时，提供纯虚函数。【就像下单函数一样，其作用就是提供接口让你来重写】</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span>vitrual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>；何时提供 <span class="token keyword">virtual</span> function？要求派生类只继承接口和缺省实现时，提供虚函数。<span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span>vitrual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>何时提供 no-virtual function？</p><p>要求派生类只继承接口的强制实现时，提供非虚函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原则</strong></p><ul><li>纯虚函数指定接口继承。//这跟XTP中的订阅反馈函数的重载一样</li><li>虚函数指定接口和缺省实现继承。  //</li><li>非虚函数指定接口的强制实现继承。</li><li>接口继承和实现继承不同。</li></ul><h3 id="考虑virtual函数以外的选择"><a href="#考虑virtual函数以外的选择" class="headerlink" title="考虑virtual函数以外的选择"></a>考虑virtual函数以外的选择</h3><pre class="line-numbers language-cpp"><code class="language-cpp">non<span class="token operator">-</span><span class="token keyword">virtual</span> interface：提供非虚接口<span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优点：</strong></p><ul><li>可以在调用虚函数的前后，做一些准备工作(抽出一段重复代码)</li><li>提供良好的ABI兼容性</li></ul><h3 id="聊一聊ABI兼容性"><a href="#聊一聊ABI兼容性" class="headerlink" title="聊一聊ABI兼容性"></a>聊一聊ABI兼容性</h3><p>我们知道，程序库的优势之一是库版本升级，只要保证借口的一致性，用户不用修改任何代码。<br>一般一个设计完好的程序库都会提供一份C语言接口，为什么呢，我们来看看C++ ABI有哪些脆弱性。</p><ul><li>虚函数的调用方式，通常是 vptr/vtbl 加偏移量调用</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Object.h</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>···    <span class="token keyword">virtual</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第3个虚函数</span>···<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用户代码</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Object <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> Object<span class="token punctuation">;</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//编译器：vptr[3]()</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//如果加了虚函数，用户代码根据偏移量找到的是newfun函数</span><span class="token comment" spellcheck="true">//Object.h</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>···    <span class="token keyword">virtual</span> <span class="token function">newfun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第3个虚函数</span>    <span class="token keyword">virtual</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第4个虚函数</span>···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>name mangling 名字粉碎实现重载</li></ul><p>C++没有为name mangling制定标准。例如void fun(int)，有的编译器定为fun_int_，有的编译器指定为fun%int%。<br>因此，C++接口的库要求用户必须和自己使用同样的编译器(这个要求好过分)</p><ul><li>其实C语言接口也不完美</li></ul><p>例如struct和class。编译阶段，编译器将struct或class的对象对成员的访问通过偏移量来实现</p><h3 id="使用std-fun提供回调"><a href="#使用std-fun提供回调" class="headerlink" title="使用std::fun提供回调"></a>使用std::fun提供回调</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> doInterface<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="古典策略模式"><a href="#古典策略模式" class="headerlink" title="古典策略模式"></a>古典策略模式</h3><p>用另外一个继承体系替代</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        p<span class="token operator">-</span><span class="token operator">></span><span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    BaseInterface <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BaseInterface</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绝不重新定义继承而来的non-virtual函数"><a href="#绝不重新定义继承而来的non-virtual函数" class="headerlink" title="绝不重新定义继承而来的non-virtual函数"></a>绝不重新定义继承而来的non-virtual函数</h3><p>记住就行</p><h3 id="绝不重新定义继承而来的缺省参数值"><a href="#绝不重新定义继承而来的缺省参数值" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Drive "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                                                                 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                                                          Base <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> Drive<span class="token punctuation">;</span>                                                               b<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//   vptr[0](1)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Drive 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺省参数值是静态绑定</li><li>虚函数是动态绑定</li><li>遵守这条规定防止出错</li></ul><h3 id="通过复合塑模出has-a或者”根据某物实现出”"><a href="#通过复合塑模出has-a或者”根据某物实现出”" class="headerlink" title="通过复合塑模出has-a或者”根据某物实现出”"></a>通过复合塑模出has-a或者”根据某物实现出”</h3><ol><li>复合的意义和public完全不一样</li><li>根据某物实现出和is-a的区别：</li></ol><p>这个也是什么时候使用继承，什么时候使用复合。复合代表使用了这个对象的某些方法，但是却不想它的接口入侵。</p><h3 id="明智而审慎地使用private继承"><a href="#明智而审慎地使用private继承" class="headerlink" title="明智而审慎地使用private继承"></a>明智而审慎地使用private继承</h3><ol><li>private继承是”根据某物实现出“</li><li>唯一一个使用private继承的理由就是，可以使用空白基类优化技术，节约内存空间</li></ol><h3 id="C-对空类的处理"><a href="#C-对空类的处理" class="headerlink" title="C++对空类的处理"></a>C++对空类的处理</h3><p>C++ 设计者在设计这门语言要求所有的对象必须要有不同的地址(C语言没有这个要求)。C++编译器的实现方式是给让空类占据一个字节。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//8个字节</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    Base b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4个字节</span>classObject <span class="token operator">:</span> <span class="token keyword">private</span> Base<span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="明智而审慎地使用多重继承"><a href="#明智而审慎地使用多重继承" class="headerlink" title="明智而审慎地使用多重继承"></a>明智而审慎地使用多重继承</h3><p>首先我们来了解一下多重继承的内存布局。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//包含A对象</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B对象</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,C对象</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,A,B,C,D对象</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span><span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C<span class="token punctuation">{</span><span class="token punctuation">}</span>由于菱形继承，基类被构造了两次。其实，C<span class="token operator">++</span>也提供了针对菱形继承的解决方案的<span class="token comment" spellcheck="true">//包含A对象</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B对象</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,C对象</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B,C,D对象</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span><span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C<span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用虚继承，B,C对象里面会产生一个指针指向唯一一份A对象。这样付出的代价是必须再运行期根据这个指针的偏移量寻找A对象。</p><p>多重继承唯一的那么一点点用就是一个Base class提供public继承，另一个Base class提供private继承。(还是没什么用啊，干嘛不适用复合)</p><h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="了解隐式接口和编译期多态"><a href="#了解隐式接口和编译期多态" class="headerlink" title="了解隐式接口和编译期多态"></a>了解隐式接口和编译期多态</h3><ol><li>接口：强制用户实现某些函数</li><li>多态：相同的函数名，却有不同的实现</li><li>继承和模板都支持接口和多态</li><li>对继承而言，接口是显式的，以函数为中心，多态发生在运行期；</li><li>对模板而言，接口是隐式的，多态表现在template具象化和函数重载<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//这里接口要求T必须实现operator ></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T <span class="token function">max</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="了解typename的双重意义"><a href="#了解typename的双重意义" class="headerlink" title="了解typename的双重意义"></a>了解typename的双重意义</h3><ol><li>声明template参数时，前缀关键字class和typename可以互换</li><li>使用typename表明嵌套类型(防止产生歧义)</li></ol><p><strong>第一层：</strong>作为类模板的参数时，与 class 功能相同。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyTYpe</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个定义完全相同。</p><p><strong>第二层：</strong> typename 可以让模板里面定义嵌套从属名称的类型变成有效的类型，因为 C++ 的解析器在模板中遇到嵌套从属类型时，默认认为它是无效的类型。</p><p>例如：无效的嵌套从属类型</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>        T<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要认为指定它为有效的嵌套从属类型</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">typename</span> T<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况 当你想在 template 中指定一个有效的嵌套从属类型名称，只需要在嵌套从属类型前面加上 typename 关键字即可。<br><strong>例外</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">*</span> 不得在 base <span class="token keyword">class</span> <span class="token class-name">list</span> 中使用 <span class="token keyword">typename</span><span class="token comment" spellcheck="true">/* 错误用法 */</span><span class="token keyword">class</span> <span class="token class-name">Deriver</span> <span class="token operator">:</span> <span class="token keyword">public</span> <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>MyType<span class="token punctuation">;</span><span class="token operator">*</span> 不得在 member initialization list 中使用 <span class="token keyword">typename</span><span class="token keyword">class</span> <span class="token class-name">Deriver</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>MyType<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment" spellcheck="true">/* 错误用法 */</span>  <span class="token keyword">explicit</span> <span class="token function">Deriver</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">MyType</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原则</strong></p><ul><li><p>class 和 typename 在声明模板参数时作用相同。</p></li><li><p>使用 typename 标识嵌套从属类型，但是不得在 base class list 和 member initialization list 中使用。</p></li></ul><h3 id="学习处理模板化基类内的名称"><a href="#学习处理模板化基类内的名称" class="headerlink" title="学习处理模板化基类内的名称"></a>学习处理模板化基类内的名称</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>                                                                        <span class="token keyword">public</span><span class="token operator">:</span>                                                                              <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>                                                             <span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>                                                    <span class="token keyword">public</span><span class="token operator">:</span>                                                                            <span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span><span class="token punctuation">{</span>                                                            <span class="token comment" spellcheck="true">//error 编译器不知道基类有print函数</span>    <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解决方案</span><span class="token comment" spellcheck="true">//this->print();</span><span class="token comment" spellcheck="true">//using Base&lt;T>::print</span><span class="token comment" spellcheck="true">//base&lt;T>::print直接调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将参数无关代码抽离template"><a href="#将参数无关代码抽离template" class="headerlink" title="将参数无关代码抽离template"></a>将参数无关代码抽离template</h3><ol><li>非类型模板参数造成的代码膨胀：以函数参数或者成员变量替换</li><li>类型模板参数造成的代码膨胀：特化它们，让含义相近的类型模板参数使用同一份底层代码。例如int，long, const int</li></ol><h3 id="运用成员函数模版接收所有兼容类型"><a href="#运用成员函数模版接收所有兼容类型" class="headerlink" title="运用成员函数模版接收所有兼容类型"></a>运用成员函数模版接收所有兼容类型</h3><p>我们来考虑一下智能指针的拷贝构造函数和赋值操作符怎么实现。它需要子类的智能指针能够隐式转型为父类智能指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//拷贝构造函数，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//赋值操作符，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//声明正常的拷贝构造函数</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span>；    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    T <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用成员函数模版生成“可接受所有兼容类型”的函数</li><li>即使有了“泛化拷贝构造函数”和“泛化的赋值操作符”，仍然需要声明正常的拷贝构造函数和赋值操作符</li><li>在一个类模版内，template名称可被用来作为作为“template和其参数”的简略表达式</li></ul><h3 id="所有参数需要类型转换的时候请为模版定义非成员函数"><a href="#所有参数需要类型转换的时候请为模版定义非成员函数" class="headerlink" title="所有参数需要类型转换的时候请为模版定义非成员函数"></a>所有参数需要类型转换的时候请为模版定义非成员函数</h3><ol><li>当我们编写一个模版类，某个相关函数都需要类型转换，需要把这个函数定义为非成员函数</li><li>但是模版的类型推到遇见了问题，需要把这个函数声明为友元函数帮助推导</li><li>模版函数只有声明编译器不会帮忙具现化，所以我们需要实现的是友元模版函数<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">{</span> … <span class="token keyword">friend</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">Rational</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">GetNumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">.</span><span class="token function">GetNumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         a<span class="token punctuation">.</span><span class="token function">GetDenominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">.</span><span class="token function">GetDenominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> …<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="请使用traits-classes表现类型信息"><a href="#请使用traits-classes表现类型信息" class="headerlink" title="请使用traits classes表现类型信息"></a>请使用traits classes表现类型信息</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">ccSizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> type_traits<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>size<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>traits采用类模版和特化的方式，为不同的类型提供了相同的类型抽象(都由size)</li><li>为某些类型提供编译期测试，例如is_fundamental(是否为内置类型)</li></ul><h2 id="模版元编程"><a href="#模版元编程" class="headerlink" title="模版元编程"></a>模版元编程</h2><p>本质上就是函数式编程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//上楼梯，每次上一步或者两步，有多少种</span><span class="token keyword">int</span> <span class="token function">climb</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//元编程，采用类模版</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>n <span class="token operator">+</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-2</span><span class="token operator">></span><span class="token operator">::</span>n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>C++元编程可以将计算转移到编译期，执行速度迅速(缺陷？)</li></ul><h2 id="函数调用的栈结构："><a href="#函数调用的栈结构：" class="headerlink" title="函数调用的栈结构："></a>函数调用的栈结构：</h2><p>当编译器为函数调用生成代码时，首先将参数从右至左压栈，然后是函数返回的地址（Return Address）压栈，同时在函数内部，生成代码来将堆栈指针移动（向上或向下，这要视机器而定），为函数的本地变量提供存储空间。当函数调用完毕，栈指针将移动到函数（Return Address）的位置，这样函数的本地变量出栈。那么函数的返回值（尤其是一个自定义的类型）存放在什么地方？答案是将函数的返回值作为一个参数压栈，直接将返回值的信息拷贝至该参数中。这个答案没有解决所有的问题，但它效率很高。</p><p>下面是一个函数调用的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> f（<span class="token keyword">int</span> x，<span class="token keyword">char</span> c）；<span class="token keyword">int</span> g＝f（a，b）；看一下它对应的汇编代码：push b；push a；call f（）；add sp，<span class="token number">4</span>；mov g，<span class="token keyword">register</span> a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先是两个参数压栈，然后调用函数，完了将参数出栈，将返回值放在寄存器中（因为int是built-in type），传递给返回值g。这与上面讲的函数调用的过程稍有不同。插一句：前段时间碰到很多次stack overflow的错误，搞死我了。但是当我理解了函数调用背后的故事后，stack overflow的问题终于暂时解决了。</p><p>何为copy constructor？</p><p>当需要从一个已存在的对象创建另一个对象时，会调用copy constructor。当然，我们也可以阻止这样的行为。忠告中会讲到。<br>看下面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//copy constructor</span><span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//assignment operator</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">char</span> <span class="token operator">*</span>m_data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果缺少了copy constructor和assignment operator，当进行复制时会进行bitcopy，也就是按位进行拷贝。试想如果上面的类中没有copy constructor和assignment operator，调用如下语句时的问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">String a（“hello”）；<span class="token comment" spellcheck="true">//m_data指向字符串“hello”</span>String b（“World”）；<span class="token comment" spellcheck="true">//m_data指向字符串“world”</span>b＝a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样，经过bitcopy，a和b中的m_data都指向“hello”，“world”没人管了，Memory Leak！！！而且，当a或b中的一个调用了析构函数后，“hello”所在的内存将被释放，这样另一个中的指针指向了一片非法内存！！！</p><p>忠告：如果class的成员变量中含有任何指针，请为这个类写copy constructor和assignment operator。但是你如果确信你的class不会执行copy和assignment动作，这时候写copy constructor和assignment operator会觉得有点得不偿失，这时候将copy-construction（No definition）声明为private，将阻止使用值传递方式(pass an object of your class by value)。呵呵，我知道这个时候你的头在游泳了。</p><h2 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h2><h3 id="了解new-handler的行为"><a href="#了解new-handler的行为" class="headerlink" title="了解new-handler的行为"></a>了解new-handler的行为</h3><p>new和malloc对比：</p><ul><li>new构造对象，malloc不会</li><li>new分配不出内存会抛异常，malloc返回NULL</li><li>new分配不出内存可以调用用户设置的new-handler，malloc没有<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> std<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>new_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回旧的handler</span>  new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以为每个类设置专属new handler</li></ul><h3 id="了解new和delete合理的替换时机"><a href="#了解new和delete合理的替换时机" class="headerlink" title="了解new和delete合理的替换时机"></a>了解new和delete合理的替换时机</h3><p>C++中对象的构造和析构经历了都两个阶段</p><ul><li>operator new, operator delete：分配和释放内存</li><li>调用构造函数，调用析构函数</li></ul><p>替换new和delete的理由，就是需要收集分配内存的资源信息</p><h3 id="编写符合常规的new和delete"><a href="#编写符合常规的new和delete" class="headerlink" title="编写符合常规的new和delete"></a>编写符合常规的new和delete</h3><ol><li>operator new应该内含一个无穷循环尝试分配内存，如果无法满足，就调用new-handler。class版本要处理“比正确大小更大的(错误)申请”</li><li>operator deleter应该处理Null。classz专属版本还要处理“比正确大小更小的(错误)申请”</li></ol><h3 id="写了operator-new也要写相应的operator-delete"><a href="#写了operator-new也要写相应的operator-delete" class="headerlink" title="写了operator new也要写相应的operator delete"></a>写了operator new也要写相应的operator delete</h3><p>我们知道，new一个对象要经历两步。如果在调用构造函数失败，编译器会寻找一个“带相同额外参数”的operator delete，否则就不调用，造成资源泄漏</p><p>我觉得这个条款讲的不是太通俗，所以我决定来个“俗”点的：<br>重载new和delete时必须要做到的，这里的重载包括（参见《Thinking in C++》）：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Overloading global <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>Overloading <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span> fro a <span class="token keyword">class</span><span class="token punctuation">;</span>Overloading <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span> <span class="token keyword">for</span> arrays。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不过现在有了这练习上乘内功的口诀，就不怕走火入魔了。</p><p>口诀：</p><ol><li>正确的返回值</li><li>内存不足，调用错误处理函数</li><li>不索求任何内存时的调用</li><li>避免不经意遮掩了“正常”形式的new(见条款9)</li></ol><h3 id="问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？"><a href="#问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？" class="headerlink" title="问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？"></a>问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？</h3><p>解决：</p><ol><li><p>祭出inline函数，搞定！</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span><span class="token keyword">public</span>：<span class="token keyword">void</span> f（）；<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">,</span> new_handler p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//我们重载，为了区别，则多添加一个参数</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这是系统自己的</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为自己重载new添加的额外参数添加默认参数值，一样搞定！</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span><span class="token keyword">public</span>：<span class="token keyword">void</span> f（）；<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">,</span> new_handler p＝<span class="token number">0</span>）<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="绝不重新定义继承而来的缺省参数值-1"><a href="#绝不重新定义继承而来的缺省参数值-1" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Drive "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                                                                 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                                                          Base <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> Drive<span class="token punctuation">;</span>                                                               b<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//   vptr[0](1)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Drive 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺省参数值是静态绑定</li><li>虚函数是动态绑定</li><li>遵守这条规定防止出错</li></ul><h3 id="运用成员函数模版接收所有兼容类型-1"><a href="#运用成员函数模版接收所有兼容类型-1" class="headerlink" title="运用成员函数模版接收所有兼容类型"></a>运用成员函数模版接收所有兼容类型</h3><p>我们来考虑一下智能指针的拷贝构造函数和赋值操作符怎么实现。它需要子类的智能指针能够隐式转型为父类智能指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//拷贝构造函数，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//赋值操作符，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//声明正常的拷贝构造函数</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span>；    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    T <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用成员函数模版生成“可接受所有兼容类型”的函数</li><li>即使有了“泛化拷贝构造函数”和“泛化的赋值操作符”，仍然需要声明正常的拷贝构造函数和赋值操作符</li><li>在一个类模版内，template名称可被用来作为作为“template和其参数”的简略表达式</li></ul><h2 id="模版元编程-1"><a href="#模版元编程-1" class="headerlink" title="模版元编程"></a>模版元编程</h2><p>本质上就是函数式编程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//上楼梯，每次上一步或者两步，有多少种</span><span class="token keyword">int</span> <span class="token function">climb</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//元编程，采用类模版</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>n <span class="token operator">+</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-2</span><span class="token operator">></span><span class="token operator">::</span>n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++元编程可以将计算转移到编译期，执行速度迅速(缺陷？)</p><h2 id="STL使用小细节"><a href="#STL使用小细节" class="headerlink" title="STL使用小细节"></a>STL使用小细节</h2><h3 id="删除连续容器-vector-deque-string-的元素"><a href="#删除连续容器-vector-deque-string-的元素" class="headerlink" title="删除连续容器(vector,deque,string)的元素"></a>删除连续容器(vector,deque,string)的元素</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 当c是vector、string，删除value</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除</span><span class="token keyword">bool</span> <span class="token function">assertFun</span><span class="token punctuation">(</span>valuetype<span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove_if</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> assertFun<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 有时候我们不得不遍历去完成，并删除</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除list中某个元素"><a href="#删除list中某个元素" class="headerlink" title="删除list中某个元素"></a>删除list中某个元素</h3><pre class="line-numbers language-cpp"><code class="language-cpp">c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除    </span>c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>assertFun<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span> 删除关联容器<span class="token punctuation">(</span>set<span class="token punctuation">,</span>map<span class="token punctuation">)</span>中某个元素c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;让自己习惯C&quot;&gt;&lt;a href=&quot;#让自己习惯C&quot; class=&quot;headerlink&quot; title=&quot;让自己习惯C++&quot;&gt;&lt;/a&gt;让自己习惯C++&lt;/h2&gt;&lt;h3 id=&quot;视C-为一个语言联邦&quot;&gt;&lt;a href=&quot;#视C-为一个语言联邦&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++提升" scheme="http://www.zzw1024.top/tags/c-%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>软件记录</title>
    <link href="http://www.zzw1024.top/2020/01/01/ruan-jian-ji-lu/"/>
    <id>http://www.zzw1024.top/2020/01/01/ruan-jian-ji-lu/</id>
    <published>2020-01-01T07:37:38.000Z</published>
    <updated>2020-01-01T07:37:38.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>用来记录我喜爱的软件应用，仅限window用户</p><hr><hr><p><strong>所有软件直接百度至官网或者xxx贴中下载，因为链接总会死，所以此处不给附上链接</strong></p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ol><li><p><a href="https://www.google.com/intl/zh-CN/chrome/" target="_blank" rel="noopener">Goole Chrome</a><br> 你们的最爱</p></li><li><p><a href="https://browser.360.cn/ee/" target="_blank" rel="noopener">360极速浏览器</a><br> 我的最爱</p></li></ol><h3 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h3><ol><li><p><a href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener">Visual Studio</a><br> 社区版免费，支持各类语言，C的爹</p></li><li><p><a href="https://ww2.mathworks.cn/products/matlab.html" target="_blank" rel="noopener">MATLAB</a><br> 数据分析</p></li><li><p><a href="https://www.anaconda.com" target="_blank" rel="noopener">Anaconda</a><br> 机器学习、爬虫</p></li><li><p><a href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">PyCharm</a><br> python的爹</p></li><li><p><a href="https://www.netsarang.com/zh/xshell/" target="_blank" rel="noopener">Xshell&amp;shell家族</a><br> linux服务器远程必备</p></li><li><p><a href="https://www.qt.io/download" target="_blank" rel="noopener">QT</a><br> 界面开发</p></li><li><p><a href="https://git-scm.com" target="_blank" rel="noopener">git</a><br> 仓库备份</p></li><li><p><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">VMware Workstation</a><br> 虚拟机</p></li><li><p><a href="https://cmake.org" target="_blank" rel="noopener">Cmake</a><br> C++项目不可少</p></li><li><p><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">sublime</a><br>代码编辑神器，我离不开了</p></li><li><p><a href="https://notepad-plus-plus.org/downloads/" target="_blank" rel="noopener">Notepad++</a><br>代码编辑器，界面风格巨丑</p></li><li><p><a href="https://www.ultraedit.com/#" target="_blank" rel="noopener">Ultra家族</a><br>代码对比，编辑，文件传输，泽家族都干</p></li></ol><h3 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h3><ol><li><p><a href="https://calibre-ebook.com" target="_blank" rel="noopener">calibre</a><br> 各类电子书的阅读神器</p></li><li><p><a href="https://www.office.com" target="_blank" rel="noopener">office</a><br> 呵呵🙂</p></li><li><p><a href="https://www.wps.cn" target="_blank" rel="noopener">WPS</a><br> 国产的？！真香😄</p></li><li><p><a href="https://products.office.com/zh-cn/visio/" target="_blank" rel="noopener">visio</a><br> 专业流程图，不要安装与office用一版本，会失败</p></li><li><p><a href="http://www.ctex.org/CTeXDownload" target="_blank" rel="noopener">LaTex</a><br> 就是LaTex，著名的论文排版神器</p></li></ol><h3 id="社交应用"><a href="#社交应用" class="headerlink" title="社交应用"></a>社交应用</h3><ol><li><p><a href="https://tim.qq.com/" target="_blank" rel="noopener">TIM</a><br> 替代QQ</p></li><li><p><a href="https://weixin.qq.com/" target="_blank" rel="noopener">微信</a><br> 你不用？！</p></li></ol><h3 id="下载神器"><a href="#下载神器" class="headerlink" title="下载神器"></a>下载神器</h3><ol><li><p><a href="https://pan.baidu.com" target="_blank" rel="noopener">百度网盘</a><br> 不是神器，渣渣，真香！</p></li><li><p><a href="https://www.xunlei.com" target="_blank" rel="noopener">迅雷</a><br> 无会员比死</p></li><li><p><a href="http://pandownload.com" target="_blank" rel="noopener">PanDownload</a><br> 希望崛起，貌似死了</p></li><li><p><a href="http://enfi.cloud" target="_blank" rel="noopener">ENFI下载器</a><br> 这是我唯一舍得花钱的网盘下载器</p></li><li><p><a href="https://www.apowersoft.cn/video-download-capture" target="_blank" rel="noopener">Apowersoft视频下载王</a><br> B站视频可下载</p></li></ol><h3 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h3><ol><li><p><a href="https://yasuo.360.cn" target="_blank" rel="noopener">360压缩</a><br> 速度不是盖的</p></li><li><p><a href="https://www.teamviewer.cn/cn/" target="_blank" rel="noopener">TeamView</a><br> 远程必备，安装时记得选择个人使用</p></li><li><p><a href="https://products.office.com/en-us/onenote/digital-note-taking-app" target="_blank" rel="noopener">OneNote</a><br> 个人认为最强大的笔记软件</p></li><li><p><a href="https://onedrive.live.com/about/en-US/" target="_blank" rel="noopener">OneDrive</a><br> 为了不让你的OneNote丢失，你必须后台一直开着它    </p></li><li><p><a href="https://daumpotplayer.com/download/" target="_blank" rel="noopener">PotPlayer</a><br> 视频播放神器，还有视频源哦</p></li></ol><h3 id="简直神器"><a href="#简直神器" class="headerlink" title="简直神器"></a>简直神器</h3><ol><li><p><a href="http://www.bingdian001.com" target="_blank" rel="noopener">fish</a><br> 百度文库的克星</p></li><li><p><a href="https://www.onlinedown.net/soft/1225142.htm" target="_blank" rel="noopener">DesktopNotes</a><br> 桌面便签必备</p></li><li><p><a href="https://justgetflux.com" target="_blank" rel="noopener">f.lux</a><br> 屏幕护眼</p></li><li><p><a href="https://tianruoocr.cn" target="_blank" rel="noopener">天若OCR</a><br> 截图文字识别神器</p></li><li><p><a href="https://zh.snipaste.com" target="_blank" rel="noopener">Snipaste</a><br> 一键截图，我的爱</p></li><li><p><a href="https://www.faststone.org/FSCaptureDetail.htm" target="_blank" rel="noopener">FSCapture</a><br> 长屏截图</p></li><li><p><a href="http://www.mathtype.cn" target="_blank" rel="noopener">Math Type</a><br> 公式编辑器</p></li><li><p><a href="https://www.pcworld.com/article/3202314/microsoft-onenote-add-ins-and-tools.html" target="_blank" rel="noopener">notegem2016</a><br> 配合OneNote笔记的一个神助攻</p></li><li><p><a href="https://download.cnet.com/TakeColor/3000-2192_4-10387506.html" target="_blank" rel="noopener">TakeColor</a><br> 颜色获取神器</p></li></ol><h3 id="软件下载网站"><a href="#软件下载网站" class="headerlink" title="软件下载网站"></a>软件下载网站</h3><ol><li><p><a href="https://apkpure.com/cn/search?q=APkpure&t=app" target="_blank" rel="noopener">apkpure</a><br> 需翻墙，良心的GoolePlay</p></li><li><p><a href="https://play.google.com/store?hl=zh-CN&tab=w81" target="_blank" rel="noopener">GoolePlay</a><br> 你知道的</p></li><li><p><a href="http://yx.bsh.me" target="_blank" rel="noopener">异星空间</a><br> 软件下载的好地址</p></li><li><p><a href="http://sj.qq.com/index.html" target="_blank" rel="noopener">应用宝</a><br> 腾讯的</p></li><li><p><a href="https://pc.qq.com" target="_blank" rel="noopener">腾讯软件中心</a><br> 腾讯的PC版</p></li><li><p><a href="http://www.carrotchou.blog" target="_blank" rel="noopener">胡萝卜周</a><br> 反正我粉了</p></li><li><p><a href="http://www.zdfans.com" target="_blank" rel="noopener">ZD423</a><br> 我是铁粉</p></li><li><p><a href="https://mirrors.tuna.tsinghua.edu.cn" target="_blank" rel="noopener">清华镜像</a><br> 很强的镜像网站</p></li><li><p><a href="https://www.coolapk.com" target="_blank" rel="noopener">酷安</a><br> 什么都别说，我手机安的就是酷安，所有软件都来自于它</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;用来记录我喜爱的软件应用，仅限window用户&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;所有软件直接百度至官网或者xxx贴中下载，因为链接总会死，所以此处不给附上链接&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;浏览器&quot;&gt;&lt;a href=&quot;#浏览器&quot; cl
      
    
    </summary>
    
    
      <category term="软件神器" scheme="http://www.zzw1024.top/categories/%E8%BD%AF%E4%BB%B6%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="安装" scheme="http://www.zzw1024.top/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——004-Median-of-Two-Sorted-Arrays</title>
    <link href="http://www.zzw1024.top/2019/12/30/leetcode-004-median-of-two-sorted-arrays/"/>
    <id>http://www.zzw1024.top/2019/12/30/leetcode-004-median-of-two-sorted-arrays/</id>
    <published>2019-12-30T15:07:07.000Z</published>
    <updated>2019-12-30T15:07:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Description</strong></p><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p><strong>Example 1:</strong></p><pre><code>nums1 = [1, 3]   nums2 = [2]   </code></pre><pre><code>The median is 2.0   </code></pre><p><strong>Example 2:</strong></p><pre><code>nums1 = [1, 2]   nums2 = [3, 4]   </code></pre><pre><code>The median is (2 + 3)/2 = 2.5</code></pre><p><strong>solution</strong><br>当一看到这道题的算法复杂度的限制为O(log(m+1)),<br>就可以排除将两个数组排序后再寻找中位数。<br>感觉题目又在提示我们使用二分法，但感觉此处没法使用二分法。  </p><p>我的方法就是一边排序一遍判断是否是位，即使用k来对数组A，B进行排序，<br>当k==（A+B）/2【数组大小】时，即可直接返回中位数，唯一值得注意的就是数组大小为奇数还是偶数的问题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>sum <span class="token operator">+</span><span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> sum <span class="token operator">+</span><span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReturn</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReturn</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReturn</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">isReturn</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">&amp;</span>sum<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> mid <span class="token operator">&amp;&amp;</span> s <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>借鉴</strong><br>借鉴一下<a href="https://github.com/grandyang/leetcode/issues/4" target="_blank" rel="noopener">大神</a>的思路,<br>使用递归求解，但大致思路和我一样。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">findKth</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums2<span class="token punctuation">[</span>j <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums1<span class="token punctuation">[</span>i <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> midVal1 <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums1<span class="token punctuation">[</span>i <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> midVal2 <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums2<span class="token punctuation">[</span>j <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>midVal1 <span class="token operator">&lt;</span> midVal2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> i <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">-</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> i<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> j <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k <span class="token operator">-</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;/p&gt;
&lt;p&gt;Find the median of t
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.zzw1024.top/categories/LeetCode/"/>
    
    
      <category term="中位数" scheme="http://www.zzw1024.top/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Chrome插件推荐</title>
    <link href="http://www.zzw1024.top/2019/12/30/chrome-cha-jian-tui-jian/"/>
    <id>http://www.zzw1024.top/2019/12/30/chrome-cha-jian-tui-jian/</id>
    <published>2019-12-30T11:42:46.000Z</published>
    <updated>2019-12-30T11:42:46.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>个人感觉极速360杠杆的，Chrome能的它也能，Chrome不能的它也能！！！</p><hr><hr><p>所有插件百度名字官网，或者到对应的浏览器扩展商城，或者Chrome应用商店下载；<br>下载解压后可以直接拖拽进浏览器即可。</p><hr><h3 id="插件神库"><a href="#插件神库" class="headerlink" title="插件神库"></a>插件神库</h3><p>找插件的必备之地</p><ol><li><p><a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">chrome网上应用商店</a><br> 墙的了就使,墙不了看下面</p></li><li><p><a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a><br> 油猴脚本插件的必选之地</p></li></ol><h3 id="万能插件"><a href="#万能插件" class="headerlink" title="万能插件"></a>万能插件</h3><ol><li><p><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">油猴Tampermonkey</a></p><p> 以下插件请到<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a>中下载</p><ul><li>CNKI中国知网PDF全文下载（特制版）<br>  知网论文下载必备</li><li>【全新升级】百度文库原文档免费下载<br>  百度文库下载必备</li><li>智能划词翻译<br>  网页翻译神器</li><li>网盘自动填写密码【威力加强版】<br>  度盘分享免密</li></ul></li></ol><h3 id="安全插件"><a href="#安全插件" class="headerlink" title="安全插件"></a>安全插件</h3><ol><li>360安全网银<br> 钓鱼网站必死</li></ol><h3 id="广告拦截"><a href="#广告拦截" class="headerlink" title="广告拦截"></a>广告拦截</h3><ol><li>广告终结者<br> 个人感觉还可以</li></ol><h3 id="下载神器"><a href="#下载神器" class="headerlink" title="下载神器"></a>下载神器</h3><ol><li>GitZip for github<br> github项目不再需要全部下载，直接双击相应文件名后的空白后，出现✔选中成功；<br> 选中完毕后，点击右下脚的大箭头即可下载</li></ol><h3 id="浏览器辅助"><a href="#浏览器辅助" class="headerlink" title="浏览器辅助"></a>浏览器辅助</h3><ol><li><p>smartUp手势<br> 这是chrome的短板，我弃之而去的理由</p></li><li><p>Stylish<br> 绚丽的goole主页</p></li></ol><h3 id="万能梯"><a href="#万能梯" class="headerlink" title="万能梯"></a>万能梯</h3><ol><li><p>Ghelper<br> 买了会员，你懂的，无限制，不买会员，goole随便玩</p></li><li><p>Hoxx VPN Proxy<br> 免费梯，速度还可以，推荐选择港地</p></li><li><p>skyZIP Proxy<br> 貌似死了</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;个人感觉极速360杠杆的，Chrome能的它也能，Chrome不能的它也能！！！&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;所有插件百度名字官网，或者到对应的浏览器扩展商城，或者Chrome应用商店下载；&lt;br&gt;下载解压后可以直接拖拽进浏览器即可。&lt;/p&gt;
&lt;hr&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="软件神器" scheme="http://www.zzw1024.top/categories/%E8%BD%AF%E4%BB%B6%E7%A5%9E%E5%99%A8/"/>
    
    
      <category term="插件" scheme="http://www.zzw1024.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>vim的配置</title>
    <link href="http://www.zzw1024.top/2019/12/24/vim-de-pei-zhi/"/>
    <id>http://www.zzw1024.top/2019/12/24/vim-de-pei-zhi/</id>
    <published>2019-12-24T02:08:33.000Z</published>
    <updated>2019-12-24T02:08:33.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>set sw=4set ts=4set etset smarttabset smartindentset lbrset fo+=mBset smset selection=inclusiveset wildmenuset mousemodel=popup&quot; 这里根据自己需要的插件来设置，以下是我的配置 &quot;&quot;&quot; YouCompleteMe:语句补全插件set runtimepath+=~/.vim/bundle/YouCompleteMeautocmd InsertLeave * if pumvisible() == 0|pclose|endif &quot;离开插入模式后自动关闭预览窗口&quot;let g:ycm_collect_identifiers_from_tags_files = 1           &quot; 开启 YCM基于标签引擎let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释与字符串中的内容也用于补全let g:syntastic_ignore_files=[&quot;.*\.py$&quot;]let g:ycm_seed_identifiers_with_syntax = 1                  &quot; 语法关键字补全let g:ycm_complete_in_comments = 1let g:ycm_confirm_extra_conf = 0                            &quot; 关闭加载.ycm_extra_conf.py提示let g:ycm_key_list_select_completion = [&#39;&lt;c-n&gt;&#39;, &#39;&lt;Down&gt;&#39;]  &quot; 映射按键,没有这个会拦截掉tab, 导致其他插件的tab不能用.let g:ycm_key_list_previous_completion = [&#39;&lt;c-p&gt;&#39;, &#39;&lt;Up&gt;&#39;]let g:ycm_complete_in_comments = 1                          &quot; 在注释输入中也能补全let g:ycm_complete_in_strings = 1                           &quot; 在字符串输入中也能补全let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释和字符串中的文字也会被收入补全let g:ycm_global_ycm_extra_conf=&#39;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#39;let g:ycm_show_diagnostics_ui = 0                           &quot; 禁用语法检查inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;CR&gt;&quot;             &quot; 回车即选中当前项nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;     &quot; 跳转到定义处let g:ycm_min_num_of_chars_for_completion=2                 &quot; 从第2个键入字符就开始罗列匹配项&quot;au FileType php setlocal dict+=~/.vim/dict/php_funclist.dictau FileType css setlocal dict+=~/.vim/dict/css.dictau FileType c setlocal dict+=~/.vim/dict/c.dictau FileType cpp setlocal dict+=~/.vim/dict/cpp.dictau FileType scale setlocal dict+=~/.vim/dict/scale.dictau FileType javascript setlocal dict+=~/.vim/dict/javascript.dictau FileType html setlocal dict+=~/.vim/dict/javascript.dictau FileType html setlocal dict+=~/.vim/dict/css.dict&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 显示相关  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;syntax onset cul &quot;高亮光标所在行set cucset shortmess=atI   &quot; 启动的时候不显示那个援助乌干达儿童的提示  set go=             &quot; 不要图形按钮  &quot;color desert     &quot; 设置背景主题  color ron     &quot; 设置背景主题  &quot;color torte     &quot; 设置背景主题  &quot;set guifont=Courier_New:h10:cANSI   &quot; 设置字体  &quot;autocmd InsertLeave * se nocul  &quot; 用浅色高亮当前行  autocmd InsertEnter * se cul    &quot; 用浅色高亮当前行  set ruler           &quot; 显示标尺  set showcmd         &quot; 输入的命令显示出来，看的清楚些  &quot;set whichwrap+=&lt;,&gt;,h,l   &quot; 允许backspace和光标键跨越行边界(不建议)  set scrolloff=3     &quot; 光标移动到buffer的顶部和底部时保持3行距离  set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)}   &quot;状态行显示的内容  set laststatus=2    &quot; 启动显示状态行(1),总是显示状态行(2)  &quot;set foldenable      &quot; 允许折叠  &quot;&quot;set foldmethod=manual   &quot; 手动折叠  set nocompatible  &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限  &quot; 显示中文帮助if version &gt;= 603    set helplang=cn    set encoding=utf-8endif&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop=4&quot; 统一缩进为4set softtabstop=4set shiftwidth=4&quot; 使用空格代替制表符set expandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history=1000&quot;搜索逐字符高亮set hlsearchset incsearch&quot;语言设置set langmenu=zh_CN.UTF-8set helplang=cn&quot; 总是显示状态行set cmdheight=2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+=!&quot; 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-&quot; 字符间插入的像素行数目&quot;markdown配置au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn}   set filetype=mkdau BufRead,BufNewFile *.{go}   set filetype=goau BufRead,BufNewFile *.{js}   set filetype=javascript&quot;rkdown to HTML  nmap md :!~/.vim/markdown.pl % &gt; %.html &lt;CR&gt;&lt;CR&gt;nmap fi :!firefox %.html &amp; &lt;CR&gt;&lt;CR&gt;nmap \ \ccvmap \ \cc&quot;将tab替换为空格nmap tt :%s/\t/    /g&lt;CR&gt;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新文件标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.rb,*.java,*.py exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle()     &quot;如果文件类型为.sh文件     if &amp;filetype == &#39;sh&#39;         call setline(1,&quot;\#!/bin/bash&quot;)         call append(line(&quot;.&quot;), &quot;&quot;)     elseif &amp;filetype == &#39;python&#39;        call setline(1,&quot;#!/usr/bin/env python&quot;)        call append(line(&quot;.&quot;),&quot;# coding=utf-8&quot;)        call append(line(&quot;.&quot;)+1, &quot;&quot;)     elseif &amp;filetype == &#39;ruby&#39;        call setline(1,&quot;#!/usr/bin/env ruby&quot;)        call append(line(&quot;.&quot;),&quot;# encoding: utf-8&quot;)        call append(line(&quot;.&quot;)+1, &quot;&quot;)        &quot;    elseif &amp;filetype == &#39;mkd&#39;        &quot;        call setline(1,&quot;&lt;head&gt;&lt;meta charset=\&quot;UTF-8\&quot;&gt;&lt;/head&gt;&quot;)    else         call setline(1, &quot;/*************************************************************************&quot;)         call append(line(&quot;.&quot;), &quot;    &gt; File Name: &quot;.expand(&quot;%&quot;))         call append(line(&quot;.&quot;)+1, &quot;    &gt; Author: zzw &quot;)         call append(line(&quot;.&quot;)+2, &quot;    &gt; Mail: 819342493@qq.com&quot;)         call append(line(&quot;.&quot;)+3, &quot;    &gt; Created Time: &quot;.strftime(&quot;%c&quot;))         call append(line(&quot;.&quot;)+4, &quot; ************************************************************************/&quot;)         call append(line(&quot;.&quot;)+5, &quot;&quot;)    endif    if expand(&quot;%:e&quot;) == &#39;cpp&#39;        call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;)        call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;)        call append(line(&quot;.&quot;)+8, &quot;&quot;)    endif    if &amp;filetype == &#39;c&#39;        call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;)        call append(line(&quot;.&quot;)+7, &quot;&quot;)    endif    if expand(&quot;%:e&quot;) == &#39;h&#39;        call append(line(&quot;.&quot;)+6, &quot;#ifndef _&quot;.toupper(expand(&quot;%:r&quot;)).&quot;_H&quot;)        call append(line(&quot;.&quot;)+7, &quot;#define _&quot;.toupper(expand(&quot;%:r&quot;)).&quot;_H&quot;)        call append(line(&quot;.&quot;)+8, &quot;#endif&quot;)    endif    if &amp;filetype == &#39;java&#39;        call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%:r&quot;))        call append(line(&quot;.&quot;)+7,&quot;&quot;)    endif    &quot;新建文件后，自动定位到文件末尾endfunc autocmd BufNewFile * normal G&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;键盘命令&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;:nmap &lt;silent&gt; &lt;F9&gt; &lt;ESC&gt;:Tlist&lt;RETURN&gt;&quot; shift tab pagesmap &lt;S-Left&gt; :tabp&lt;CR&gt;map &lt;S-Right&gt; :tabn&lt;CR&gt;map! &lt;C-Z&gt; &lt;Esc&gt;zzimap! &lt;C-O&gt; &lt;C-Y&gt;,map &lt;C-A&gt; ggVG$&quot;+ymap &lt;Esc&gt;&lt;Esc&gt; :w&lt;CR&gt;map &lt;F12&gt; gg=Gmap &lt;C-w&gt; &lt;C-w&gt;wimap &lt;C-k&gt; &lt;C-y&gt;,imap &lt;C-t&gt; &lt;C-q&gt;&lt;TAB&gt;imap &lt;C-j&gt; &lt;ESC&gt;&quot; 选中状态下 Ctrl+c 复制&quot;map &lt;C-v&gt; &quot;*paimap &lt;C-v&gt; &lt;Esc&gt;&quot;*paimap &lt;C-a&gt; &lt;Esc&gt;^imap &lt;C-e&gt; &lt;Esc&gt;$vmap &lt;C-c&gt; &quot;+yset mouse=v&quot;set clipboard=unnamed&quot;去空行  nnoremap &lt;F2&gt; :g/^\s*$/d&lt;CR&gt; &quot;比较文件  nnoremap &lt;C-F2&gt; :vert diffsplit &quot;nnoremap &lt;Leader&gt;fu :CtrlPFunky&lt;Cr&gt;&quot;nnoremap &lt;C-n&gt; :CtrlPFunky&lt;Cr&gt;&quot;列出当前目录文件  map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt; :NERDTreeToggle&lt;CR&gt;&quot;打开树状文件目录  map &lt;C-F3&gt; \be  :autocmd BufRead,BufNewFile *.dot map &lt;F5&gt; :w&lt;CR&gt;:!dot -Tjpg -o %&lt;.jpg % &amp;&amp; eog %&lt;.jpg  &lt;CR&gt;&lt;CR&gt; &amp;&amp; exec &quot;redr!&quot;&quot;C，C++ 按F5编译运行map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc()    exec &quot;w&quot;    if &amp;filetype == &#39;c&#39;        exec &quot;!g++ % -o %&lt;&quot;        exec &quot;!time ./%&lt;&quot;    elseif &amp;filetype == &#39;cpp&#39;        exec &quot;!g++ % -std=c++11 -o %&lt;&quot;        exec &quot;!time ./%&lt;&quot;    elseif &amp;filetype == &#39;java&#39;         exec &quot;!javac %&quot;         exec &quot;!time java %&lt;&quot;    elseif &amp;filetype == &#39;sh&#39;        :!time bash %    elseif &amp;filetype == &#39;python&#39;        exec &quot;!time python2.7 %&quot;    elseif &amp;filetype == &#39;html&#39;        exec &quot;!firefox % &amp;&quot;    elseif &amp;filetype == &#39;go&#39;        &quot;        exec &quot;!go build %&lt;&quot;        exec &quot;!time go run %&quot;    elseif &amp;filetype == &#39;mkd&#39;        exec &quot;!~/.vim/markdown.pl % &gt; %.html &amp;&quot;        exec &quot;!firefox %.html &amp;&quot;    endifendfunc&quot;C,C++的调试map &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb()    exec &quot;w&quot;    exec &quot;!g++ % -std=c++11 -g -o %&lt;&quot;    exec &quot;!gdb ./%&lt;&quot;endfunc&quot;代码格式优化化map &lt;F6&gt; :call FormartSrc()&lt;CR&gt;&lt;CR&gt;&quot;定义FormartSrc()func FormartSrc()    exec &quot;w&quot;    if &amp;filetype == &#39;c&#39;        exec &quot;!astyle --style=ansi -a --suffix=none %&quot;    elseif &amp;filetype == &#39;cpp&#39; || &amp;filetype == &#39;hpp&#39;        exec &quot;r !astyle --style=ansi --one-line=keep-statements -a --suffix=none %&gt; /dev/null 2&gt;&amp;1&quot;    elseif &amp;filetype == &#39;perl&#39;        exec &quot;!astyle --style=gnu --suffix=none %&quot;    elseif &amp;filetype == &#39;py&#39;||&amp;filetype == &#39;python&#39;        exec &quot;r !autopep8 -i --aggressive %&quot;    elseif &amp;filetype == &#39;java&#39;        exec &quot;!astyle --style=java --suffix=none %&quot;    elseif &amp;filetype == &#39;jsp&#39;        exec &quot;!astyle --style=gnu --suffix=none %&quot;    elseif &amp;filetype == &#39;xml&#39;        exec &quot;!astyle --style=gnu --suffix=none %&quot;    else        exec &quot;normal gg=G&quot;        return    endif    exec &quot;e! %&quot;endfunc&quot;结束定义FormartSrc&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;实用设置&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 设置当文件被改动时自动载入set autoread&quot; quickfix模式autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;&quot;代码补全 set completeopt=preview,menu &quot;允许插件  filetype plugin on&quot;共享剪贴板  set clipboard=unnamed &quot;从不备份  set nobackup&quot;make 运行:set makeprg=g++\ -Wall\ \ %&quot;自动保存set autowriteset ruler                   &quot; 打开状态栏标尺set cursorline              &quot; 突出显示当前行set magic                   &quot; 设置魔术set guioptions-=T           &quot; 隐藏工具栏set guioptions-=m           &quot; 隐藏菜单栏&quot;set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&amp;fileformat}\ %{&amp;encoding}\ %c:%l/%L%)\&quot; 设置在状态行显示的信息set foldcolumn=0set foldmethod=indent set foldlevel=3 set foldenable              &quot; 开始折叠&quot; 不要使用vi的键盘模式，而是vim自己的set nocompatible&quot; 语法高亮set syntax=on&quot; 去掉输入错误的提示声音set noeb&quot; 在处理未保存或只读文件的时候，弹出确认set confirm&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop=4&quot; 统一缩进为4set softtabstop=4set shiftwidth=4&quot; 不要用空格代替制表符set noexpandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history=1000&quot;禁止生成临时文件set nobackupset noswapfile&quot;搜索忽略大小写set ignorecase&quot;搜索逐字符高亮set hlsearchset incsearch&quot;行内替换set gdefault&quot;编码设置set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936&quot;语言设置set langmenu=zh_CN.UTF-8set helplang=cn&quot; 我的状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)}set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]&quot; 总是显示状态行set laststatus=2&quot; 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+=!&quot; 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-&quot; 字符间插入的像素行数目set linespace=0&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 使回格键（backspace）正常处理indent, eol, start等set backspace=2&quot; 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0&quot; 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\ ,stl:\ ,stlnc:\&quot; 高亮显示匹配的括号set showmatch&quot; 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1&quot; 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3&quot; 为C程序提供自动缩进set smartindent&quot; 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile *  setfiletype txt&quot;自动补全:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;=ClosePair(&#39;)&#39;)&lt;CR&gt;&quot;:inoremap { {&lt;CR&gt;}&lt;ESC&gt;O&quot;:inoremap } &lt;c-r&gt;=ClosePair(&#39;}&#39;)&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;=ClosePair(&#39;]&#39;)&lt;CR&gt;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i:inoremap &#39; &#39;&#39;&lt;ESC&gt;ifunction! ClosePair(char)    if getline(&#39;.&#39;)[col(&#39;.&#39;) - 1] == a:char        return &quot;\&lt;Right&gt;&quot;    else        return a:char    endifendfunctionfiletype plugin indent on &quot;打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; CTags的设定  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;let Tlist_Sort_Type = &quot;name&quot;    &quot; 按照名称排序  let Tlist_Use_Right_Window = 1  &quot; 在右侧显示窗口  let Tlist_Compart_Format = 1    &quot; 压缩方式  let Tlist_Exist_OnlyWindow = 1  &quot; 如果只有一个buffer，kill窗口也kill掉buffer  &quot;&quot;let Tlist_File_Fold_Auto_Close = 0  &quot; 不要关闭其他文件的tags  &quot;&quot;let Tlist_Enable_Fold_Column = 0    &quot; 不要显示折叠树  &quot;let Tlist_Show_One_File=1            &quot;不同时显示多个文件的tag，只显示当前文件的&quot;设置tags  set tags=tags;  set autochdir &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;其他东东&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;默认打开Taglist let Tlist_Auto_Open=0 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; Tag list (ctags) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; let Tlist_Ctags_Cmd = &#39;/usr/local/bin/ctags&#39; let Tlist_Show_One_File = 1 &quot;不同时显示多个文件的tag，只显示当前文件的 let Tlist_File_Fold_Auto_Close = 1let Tlist_Exit_OnlyWindow = 1 &quot;如果taglist窗口是最后一个窗口，则退出vim let Tlist_Use_Right_Window = 1 &quot;在右侧窗口中显示taglist窗口&quot; minibufexpl插件的一般设置let g:miniBufExplMapWindowNavVim = 1let g:miniBufExplMapWindowNavArrows = 1let g:miniBufExplMapCTabSwitchBufs = 1let g:miniBufExplModSelTarget = 1  nmap tl :Tlist&lt;cr&gt;&quot;python补全let g:pydiction_location = &#39;~/.vim/after/complete-dict&#39;let g:pydiction_menu_height = 20let Tlist_Ctags_Cmd=&#39;/usr/local/bin/ctags&#39;let g:miniBufExplMapWindowNavVim = 1let g:miniBufExplMapWindowNavArrows = 1let g:miniBufExplMapCTabSwitchBufs = 1let g:miniBufExplModSelTarget = 1set iskeyword+=.set termencoding=utf-8set encoding=utf8set fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030autocmd FileType python set omnifunc=pythoncomplete#Complete&quot;set nocompatible               &quot; be iMproved&quot;filetype off                   &quot; required!let g:html_indent_inctags = &quot;html,body,head,tbody&quot;let g:html_indent_script1 = &quot;inc&quot;let g:html_indent_style1 = &quot;inc&quot;filetype plugin indent on     &quot; required!&quot;&quot;ctrlp设置&quot;set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.pyc,*.png,*.jpg,*.gif     &quot; MacOSX/Linuxset wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe,*.pyc,*.png,*.jpg,*.gif  &quot; Windowslet g:ctrlp_custom_ignore = &#39;\v[\/]\.(git|hg|svn)$&#39;let g:ctrlp_custom_ignore = &#39;\v\.(exe|so|dll)$&#39;let g:ctrlp_extensions = [&#39;funky&#39;]let NERDTreeIgnore=[&#39;\.pyc&#39;]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;set sw=4
set ts=4
set et
set smarttab
set smartindent
set lbr
set fo+=mB
set sm
set selection=inclusive
set wildmenu
set mousemod
      
    
    </summary>
    
    
      <category term="文档" scheme="http://www.zzw1024.top/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="vim" scheme="http://www.zzw1024.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>《STL源码剖析》——第七、八章：仿函数与接配器</title>
    <link href="http://www.zzw1024.top/2019/12/24/stl-yuan-ma-pou-xi-di-qi-ba-zhang-fang-han-shu-yu-jie-pei-qi/"/>
    <id>http://www.zzw1024.top/2019/12/24/stl-yuan-ma-pou-xi-di-qi-ba-zhang-fang-han-shu-yu-jie-pei-qi/</id>
    <published>2019-12-24T01:29:30.000Z</published>
    <updated>2019-12-24T01:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章：仿函数"><a href="#第七章：仿函数" class="headerlink" title="第七章：仿函数"></a>第七章：仿函数</h1><h2 id="7-1、仿函数（函数对象）概观"><a href="#7-1、仿函数（函数对象）概观" class="headerlink" title="7.1、仿函数（函数对象）概观"></a>7.1、仿函数（函数对象）概观</h2><p>STL仿函数的分类，若以操作数（operand）的个数划分，可分为一元和二元仿函数，若以功能划分，可分为算术运算（Arithmetic）、关系运算（Rational）、逻辑运算（Logical）三大类。任何应用程序欲使用STL内建的仿函数，都必须含人&lt; functiona1 &gt;头文件，SGI则将它们实际定义于&lt; st1_function.h &gt;文件中。以下分别描述。<br>重载 () 所以函数的对象 使用（）像函数调用是类 而不是普通的函数<br><strong>内部记录状态：</strong><br>作为类型 与模板进行配合使用  </p><ol><li>函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可内联编译，性能好。用函数指针几乎不可能</li><li>模版函数对象使函数对象具有通用性，这也是它的优势之一</li></ol><h2 id="7-2、可配接（adaptable）的关键"><a href="#7-2、可配接（adaptable）的关键" class="headerlink" title="7.2、可配接（adaptable）的关键"></a>7.2、可配接（adaptable）的关键</h2><ul><li><p>unary_function<br>unary_function用来呈现一元函数的参数型别和回返值型别。其定义非常简单：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000914459-1414387869.png" alt=""></p></li><li><p>binary_function<br>binary_function 用来呈现二元函数的第一参数型别、第二参数型别，以及回返值型别。其定义非常简单：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000925773-1298919017.png" alt=""></p></li></ul><h2 id="7-3、算术类（Arithmetic）仿函数"><a href="#7-3、算术类（Arithmetic）仿函数" class="headerlink" title="7.3、算术类（Arithmetic）仿函数"></a>7.3、算术类（Arithmetic）仿函数</h2><p>STL内建的“算术类仿函数”，支持加法、减法、乘法、除法、模数（余数，modulus）和否定（negation）运算。除了“否定”运算为一元运算，其它都是二元运算。</p><ul><li>加法：plus<T></li><li>减法：minus<T></li><li>乘法：multiplies<T></li><li>除法：divides<T></li><li>模取（modulus）：modulus<T></li><li>否定（negation）：negate<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000940335-1676139172.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000955791-618196543.png" alt=""></p><h2 id="7-4、关系运算类（Relational）仿函数"><a href="#7-4、关系运算类（Relational）仿函数" class="headerlink" title="7.4、关系运算类（Relational）仿函数"></a>7.4、关系运算类（Relational）仿函数</h2><p>STL内建的“关系运算类仿函数”支持了等于、不等于、大于、大于等于、小于、小于等于六种运算。每一个都是二元运算。</p><ul><li>等于（equality）：equal_to<T></li><li>不等于（inequality）：not_equal_tocT&gt;</li><li>大于（greater than）：greater<T></li><li>大于或等于（greater than or equal）：greater_-equal<T></li><li>小于（less than）：1ess<T></li><li>小于或等于（less than or equal）：1ess_equal<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001007466-1276806188.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001020777-765884354.png" alt=""></p><h2 id="7-5、逻辑运算类（Logical）仿函数"><a href="#7-5、逻辑运算类（Logical）仿函数" class="headerlink" title="7.5、逻辑运算类（Logical）仿函数"></a>7.5、逻辑运算类（Logical）仿函数</h2><p>STL内建的“逻辑运算类仿函数”支持了逻辑运算中的 And、or、Not三种运算，其中And和or为二元运算，Not为一元运算。</p><ul><li>逻辑运算And：1ogical_and<T></li><li>逻辑运算or：1ogical_or<T></li><li>逻辑运算Not:logical_not<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001032087-1471946754.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001043598-1146445021.png" alt=""></p><h2 id="7-6、证同（identity）、选择（select）、投射（project）"><a href="#7-6、证同（identity）、选择（select）、投射（project）" class="headerlink" title="7.6、证同（identity）、选择（select）、投射（project）"></a>7.6、证同（identity）、选择（select）、投射（project）</h2><ul><li><p>identity<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001057404-685324224.png" alt=""></p></li><li><p>select<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001110220-114459234.png" alt=""></p></li><li><p>project<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001119469-1357538208.png" alt=""></p></li></ul><h2 id="7-7、自建函数function"><a href="#7-7、自建函数function" class="headerlink" title="7.7、自建函数function"></a>7.7、自建函数function</h2><ul><li><p>包装普通函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">g_Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> g_Minus<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>包装模板函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>T <span class="token function">g_Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> g_Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>包装lambda表达式</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> g_Minus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>int main()<br>{<br>    function&lt;int(int, int)&gt; f = g_Minus;<br>    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1<br>    return 1;<br>}</p><pre><code>* 包装函数对象**非模板类型：**```cppstruct Minus{    int operator() (int i, int j)    {        return i - j;    }};int main(){    function&lt;int(int, int)&gt; f = Minus();    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1    return 1;}</code></pre><p><strong>模板类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> Minus<span class="token punctuation">{</span>    T <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>包装类静态成员函数</li><li><em>非模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>模板类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>    <span class="token keyword">static</span> T <span class="token function">Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>包装类对象成员函数</li><li><em>非模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">int</span> <span class="token function">Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Math m<span class="token punctuation">;</span>   function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token operator">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><em>模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>   T <span class="token function">Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>int main()<br>{<br>    Math m;<br>    function&lt;int(int, int)&gt; f = bind(&amp;Math::Minus<int>, &amp;m, placeholders::_1, placeholders::_2);<br>    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1<br>    return 1;<br>}</p><pre><code># 第x章：匿名函数（lambda）* 格式： [](){};</code></pre><p>[ ](int val){ cout &lt;&lt; val “”; }<br>//匿名函数  lambda表达式  <a href=""></a>{};<br>for_each(v.begin(), v.end(), [](int val) { cout &lt;&lt; val &lt;&lt; “ “; });</p><pre><code>* 捕获：需要捕获的参数放置在[ ]中！！！```[a](int b){return a+b;}```[ ]中为需要捕获的参数，一般存在与函数体中！！！* 传参放置在（）中：```cpppint a = 45;int sum = [a](int b){return a+b;};cout &lt;&lt; sum (14)&lt;&lt; endl;</code></pre><p>注意：<br>捕获参数a需自己定义，调用函数不需写明！<br>而传参需要调用函数传入进去！！！<br>( )中一般使用的是容器中的元素。   </p><pre class="line-numbers language-cpp"><code class="language-cpp">eg<span class="token operator">:</span>string ss<span class="token punctuation">;</span><span class="token keyword">float</span> f<span class="token punctuation">;</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span>m<span class="token punctuation">;</span>vecot<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span>v<span class="token punctuation">;</span><span class="token keyword">auto</span> pt<span class="token operator">=</span><span class="token function">find_if</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ss<span class="token punctuation">]</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span>ps<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> ps<span class="token punctuation">.</span>second<span class="token operator">==</span>ss<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pt<span class="token operator">=</span><span class="token function">find_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">float</span> fa<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> fa <span class="token operator">==</span> f<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>lambda表达式语法定义</li></ul><p>lambda表达式的语法定义如下：<br><code>[capture] （parameters） mutable -&gt;return-type {statement};</code></p><ol><li><p>[capture]: 捕捉列表。捕捉列表总是出现在lambda函数的开始处。实质上，[]是lambda引出符（即独特的标志符）<br>　　编译器根据该引出符判断接下来的代码是否是lambda函数<br>　　捕捉列表能够捕捉上下文中的变量以供lambda函数使用<br>　　捕捉列表由一个或多个捕捉项组成，并以逗号分隔，捕捉列表一般有以下几种形式：   </p><ul><li><p>[]：默认不捕获任何变量；</p></li><li><p>[=]：默认以值捕获所有变量；</p></li><li><p>[&amp;]：默认以引用捕获所有变量；</p></li><li><p>[x]：仅以值捕获x，其它变量不捕获；</p></li><li><p>[&amp;x]：仅以引用捕获x，其它变量不捕获；</p></li><li><p>[=, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；</p></li><li><p>[&amp;, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；</p></li><li><p>[this]：通过引用捕获当前对象（其实是复制指针）；</p></li><li><p>[*this]：通过传值方式捕获当前对象；</p><p>　　- &lt;1&gt; [var] 表示值传递方式捕捉变量var</p><ul><li>&lt;2&gt; [=] 表示值传递方式捕捉所有父作用域的变量（包括this指针） 【即该作用域中说所有的变量】</li><li>&lt;3&gt; [&amp;var] 表示引用传递捕捉变量var</li><li>&lt;4&gt; [&amp;] 表示引用传递捕捉所有父作用域的变量（包括this指针）<pre><code>  讲解一下使用&amp;的作用</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">5678</span><span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> f<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>k<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">return</span> i<span class="token operator">+</span>j<span class="token operator">+</span>k<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>k<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  输出为：1234，记住，当生命lambda声明时，参数已经捕获完毕，即i为值传递，不可改变，j,k为引用传递，可以改变，故最终传入的参数为：  i=1234, j=2, k=3;</code></pre>　　- &lt;5&gt; [this] 表示值传递方式捕捉当前的this指针,    当要使用类成员时，不能使用[=]进行捕获，需使用[this]来捕获      <ul><li>&lt;6&gt; [=，&amp;a，&amp;b] 表示以引用传递的方式捕捉变量 a 和 b，而以值传递方式捕捉其他所有的变量  </li><li>&lt;7&gt; [&amp;，a，this] 表示以值传递的方式捕捉 a 和 this，而以引用传递方式捕捉其他所有变量   <pre><code>备注：父作用域是指包含lambda函数的语句块{ }    </code></pre>  另外，需要注意的是，捕捉列表不允许变量重复传递。下面的例子就是典型的重复，会导致编译错误：<br>  [=， a] 这里 = 已经以值传递方式捕捉了所有的变量，那么再捕捉 a 属于重复<br>  [&amp;，&amp;this] 这里 &amp; 已经以引用传递方式捕捉了所有变量，那么再捕捉 this 属于重复   </li></ul></li></ul></li></ul></li><li><p>parameters）:参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号（）一起省略</p></li><li><p>mutable : mutable修饰符。默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性（后面有详解）在使用该修饰符时，参数列表不可省略（即使参数为空）</p></li><li><p>-&gt;return-type : 返回类型。用追踪返回类型形式声明函数的返回类型。　出于方便，不需要返回值的时候也可以连同符号-&gt;一起省略　　此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导</p></li><li><p>{statement} : 函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量,在lambda函数的定义中，参数列表和返回类型都是可选的部分，而捕捉列表和函数体都可能为空<br>那么，在极端情况下，C++11中最为简单的lambda函数只需要声明为：　[] {};</p><ul><li><p>当使用多个捕获时：<br>  当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。<br>  当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了&amp;），则显式捕获命名变量必须采用值方式，因此不能在其名字前使用&amp;。类似的，如果隐式捕获采用的是值方式（使用了=），则显式捕获命名变量必须采用引用方式，即，在名字前使用&amp;。<br>  默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表：<br>  <code>auto f=[v1]()mutable{return ++vl;};</code></p></li><li><p>声明返回类型：<br>默认返回为void类型，当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型；<br><code>[](int i)-&gt;int{if (i&lt;0)return-i;else return i;}</code></p></li></ul></li></ol><h1 id="第八章：配接器（adapters）"><a href="#第八章：配接器（adapters）" class="headerlink" title="第八章：配接器（adapters）"></a>第八章：配接器（adapters）</h1><h2 id="8-1、配接器之概观与分类"><a href="#8-1、配接器之概观与分类" class="headerlink" title="8.1、配接器之概观与分类"></a>8.1、配接器之概观与分类</h2><ul><li><p>应用于容器，container adapters</p></li><li><p>应用于迭代器，iterator adapters<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001308017-749591728.png" alt=""></p></li><li><p>应用于仿函数，functor adapters<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001318958-461090507.png" alt=""></p></li></ul><h2 id="8-2、container-adapters"><a href="#8-2、container-adapters" class="headerlink" title="8.2、container adapters"></a>8.2、container adapters</h2><ul><li><p>stack<br>stack的底层由deque构成。从以下接口可清楚看出stack与deque的关系：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{</span><span class="token keyword">protected</span>：Sequence c；<span class="token comment" spellcheck="true">//底层容器</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>queue<br>queue的底层由deque构成。从以下接口可清楚看出queue与deque的关系：   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">=</span>deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">queue</span><span class="token punctuation">{</span><span class="token keyword">protected</span>：Sequence c；<span class="token comment" spellcheck="true">//底层容器</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="8-3、iterator-adapters"><a href="#8-3、iterator-adapters" class="headerlink" title="8.3、iterator adapters"></a>8.3、iterator adapters</h2><ul><li><p>insert iterators</p></li><li><p>reverse iterators<br>所谓 reverse iterator，就是将迭代器的移动行为倒转。如果STL算法接受的不是一般正常的迭代器，而是这种逆向迭代器，它就会以从尾到头的方向来处理序列中的元素。例如：<br>//将所有元素逆向拷贝到ite所指位置上<br>//rbegin（）和rend（）与reverse_iterator有关copy（id.rbegin（），id.rend（），ite）；看似单纯，实现时却大有文章。  </p></li><li><p>stream iterators<br>所谓 stream iterators，可以将迭代器绑定到一个stream（数据流）对象身上。<br>绑定到istream对象（例如std:：cin）者，称为istream iterator，拥有输人能力；<br>绑定到ostream对象（例如std:：cout）者，称为ostream_iterator，拥有输出能力。   </p></li></ul><h2 id="8-4、function-adapters"><a href="#8-4、function-adapters" class="headerlink" title="8.4、function adapters"></a>8.4、function adapters</h2><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001339871-20879902.png" alt=""></p><ul><li>对返回值进行逻辑否定：not1，not2</li><li>对参数进行绑定：bindls t，bind2nd</li><li>用于函数合成：compose1，compose2 </li><li>用于函数指针：ptr_fun</li></ul><p>定义一个函数指针类型。<br>比如你有三个函数：   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"你好!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">bye</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"再见！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"好的！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>typdef void (*funcptr)(void);</code><br><code>typede[函数返回类型][*函数指针名][函数参数类型]</code><br>这样就构造了一个通用的函数<br>你用的时候可以这样：  </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>funcptr words<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&amp;</span>hello<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bye<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ok<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将函数指针存入</span>funcptr fun <span class="token operator">=</span> words<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>就会显示“你好！”；<span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>就会显示“再见！”；<span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>就会显示“好的！”<span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sayHelloPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> sayHello<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//其中，括号是必不可少的</span>    <span class="token punctuation">(</span><span class="token operator">*</span>sayHelloPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于成员函数指针：memfun，mem fun_ref</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第七章：仿函数&quot;&gt;&lt;a href=&quot;#第七章：仿函数&quot; class=&quot;headerlink&quot; title=&quot;第七章：仿函数&quot;&gt;&lt;/a&gt;第七章：仿函数&lt;/h1&gt;&lt;h2 id=&quot;7-1、仿函数（函数对象）概观&quot;&gt;&lt;a href=&quot;#7-1、仿函数（函数对象）概观&quot; c
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL源码剖析" scheme="http://www.zzw1024.top/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>《STL源码剖析》——第五、六章：关联容器与算法</title>
    <link href="http://www.zzw1024.top/2019/12/24/stl-yuan-ma-pou-xi-di-wu-liu-zhang-guan-lian-rong-qi-yu-suan-fa/"/>
    <id>http://www.zzw1024.top/2019/12/24/stl-yuan-ma-pou-xi-di-wu-liu-zhang-guan-lian-rong-qi-yu-suan-fa/</id>
    <published>2019-12-24T01:27:56.000Z</published>
    <updated>2019-12-24T01:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章、关联容器"><a href="#第五章、关联容器" class="headerlink" title="第五章、关联容器"></a>第五章、关联容器</h1><h2 id="5-0、关联容器"><a href="#5-0、关联容器" class="headerlink" title="5.0、关联容器"></a>5.0、关联容器</h2><ul><li><p>标准的STL关联式容器分为set（集合）和map（映射表）两大类，以及这两大类的衍生体multiset（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。</p></li><li><p>SGISTL还提供了一个不在标准规格之列的关联式容器：hash_table（散列表），以及以此hash_table为底层机制而完成的hash_set（散列集合）、hash_map（散列映射表）、hash_multiset（散列多键集合）、hash_multimap（散列多键映射表）。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235640834-174846146.png" alt=""></p></li><li><p>所谓关联式容器，观念上类似关联式数据库：每笔数据（每个元素）都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器内部结构（可能是RB-tree，也可能是hash-table）便依照其键值大小，以某种特定规则将这个元素放置于适当位置。关联式容器没有所谓头尾（只有最大元素和最小元素），所以不会有所谓 push_back()、push_front()、pop_back()、pop_front()、begin()【即无法通过*.begin()取出数据】、endt()这样的操作行为。</p></li></ul><h2 id="5-1、树的导览"><a href="#5-1、树的导览" class="headerlink" title="5.1、树的导览"></a>5.1、树的导览</h2><p>即讲解数据结构中的二叉树、二叉搜索树、平衡二叉树。。。</p><h2 id="5-2、RB-tree（红黑树）"><a href="#5-2、RB-tree（红黑树）" class="headerlink" title="5.2、RB-tree（红黑树）"></a>5.2、RB-tree（红黑树）</h2><h3 id="红黑树定义及其特性"><a href="#红黑树定义及其特性" class="headerlink" title="红黑树定义及其特性"></a>红黑树定义及其特性</h3><ol><li>每个节点或是黑色或是红色 </li><li>根节点是黑色 </li><li>每个叶节点是黑色（叶节点为空节点） </li><li>如果一个节点是红色，则它的两个子节点必须是黑色 </li><li>从任意的一个节点到该节点的所有叶节点的路径包含相同数目的黑色节点</li><li>红黑树是一种平衡二叉树，当不是完全的平衡二叉树，红黑树只要求最多三次旋转来尽可能达到平衡<br> 【也就是说没有规定左子树与右子树的高度差必须&lt;=1!!!!!!】</li></ol><ul><li>迭代器</li><li><em>operator++*</em><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235713829-442804034.png" alt=""></li></ul><p><strong>operator–</strong><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235737458-1520435092.png" alt=""></p><p><strong>自身迭代器</strong><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235806708-1498398018.png" alt=""></p><p>关于红黑树的具体数据结构，请看<a href="http://zzw1024.top/2019/12/22/hong-hei-shu/" target="_blank" rel="noopener"><strong>博文</strong></a></p><h2 id="5-3、-set"><a href="#5-3、-set" class="headerlink" title="5.3、 set"></a>5.3、 set</h2><ul><li>set底层是由红黑树构造的 </li><li>set key值不能重复</li><li>set中的key值不允许改变</li><li>STL特别提供了一组set/multiset相关算法，包括交集set_intersection、联集set_union、差集 set_difference、对称差集set_symmetric_difference。</li></ul><h2 id="5-4、map"><a href="#5-4、map" class="headerlink" title="5.4、map"></a>5.4、map</h2><ul><li>map不可以通过迭代器修改键值，但可以修改实值</li><li>map拥有list的某些性质：即增删改查其迭代器不会失效</li><li>map几乎是在调用RBTree的接口函数</li><li>map底层仍然是红黑树构造的</li></ul><h2 id="5-5、multiset"><a href="#5-5、multiset" class="headerlink" title="5.5、multiset"></a>5.5、multiset</h2><ul><li>与set一样，只不过是允许键值存在重复</li></ul><h2 id="5-6、multimap"><a href="#5-6、multimap" class="headerlink" title="5.6、multimap"></a>5.6、multimap</h2><p>与map一样，但允许键值重复</p><h2 id="5-7-、hashtable"><a href="#5-7-、hashtable" class="headerlink" title="5.7 、hashtable"></a>5.7 、hashtable</h2><ul><li>详细讲解请见<a href="http://zzw1024.top/2019/12/23/hash-biao-xiang-jie/" target="_blank" rel="noopener"><strong>博文</strong></a>      </li><li>hashtable没有向后的迭代器operator–()</li></ul><h2 id="5-8、hash-set"><a href="#5-8、hash-set" class="headerlink" title="5.8、hash_set"></a>5.8、hash_set</h2><p>hash_set拥有set的功能，底层使用的是hashtable，且不排序</p><h2 id="5-9、hash-map"><a href="#5-9、hash-map" class="headerlink" title="5.9、hash_map"></a>5.9、hash_map</h2><p>hash_map拥有map的功能，但底层是由hashtable组成的，且无排序功能</p><h2 id="5-10、hash-multiset"><a href="#5-10、hash-multiset" class="headerlink" title="5.10、hash_multiset"></a>5.10、hash_multiset</h2><ul><li>与multiset功能完全相同，其底层换成了hashtable</li><li>与hash_set的区别就是可以键值重复</li></ul><h2 id="5-11、-hash-multimap"><a href="#5-11、-hash-multimap" class="headerlink" title="5.11、 hash_multimap"></a>5.11、 hash_multimap</h2><p>hash_multimap与multimap的功能完全类似，但底层是以hashmap基本</p><h1 id="第六章-算法algorithms"><a href="#第六章-算法algorithms" class="headerlink" title="第六章 算法algorithms"></a>第六章 算法algorithms</h1><h2 id="6-1、概述"><a href="#6-1、概述" class="headerlink" title="6.1、概述"></a>6.1、概述</h2><ul><li><p>算法的五大特征如下：</p><ul><li>有穷性（Finiteness）。算法的有穷性是指算法必须能在执行有限个步骤之后终止；</li><li>确切性(Definiteness)。算法的每一步骤必须有确切的定义；</li><li>输入项(Input)。一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；</li><li>输出项(Output)。一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；</li><li>可行性(Effectiveness)。算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）。</li></ul></li><li><p>时间复杂度<br>时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为O(n)），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于常数时间内的操作（对应时间复杂度O(1)）。</p></li></ul><p>在化简某算法时间复杂度表达式时需遵循以下规则：<br>对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如O(n^2)+O(n)可化简为O(n^2)，O(n)+O(1)可化简为O(n)<br>可省去样本量前的常量系数，如O(2n)可化简为O(n)，O(8)可化简为O(1),对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如O(logm)+O(n^2)不能化简为O(n^2)或O(logm)。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为O(logm)，因为表达式增量是由样本量决定的。</p><ul><li><p>额外空间复杂度<br>算法额外空间复杂度指的是对于输入样本，经过算法操作需要的额外空间。比如使用冒泡排序对一个数组排序，期间只需要一个临时变量temp，那么该算法的额外空间复杂度为O(1)。又如归并排序，在排序过程中需要创建一个与样本数组相同大小的辅助数组，尽管在排序过后该数组被销毁，但该算法的额外空间复杂度为O(n)。</p></li><li><p>算法：<br>算法主要是由头文件<algorithm> <functional> <numeric>组成。<br><algorithm>是所有 STL 头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等…<br><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.<br><functional> 定义了一些模板类,用以声明函数对象。          </p></li><li><p>STL算法概况</p></li><li><p><em>质变指定是算法的稳定性*</em><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235934523-639435368.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235940226-890758197.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000001776-1055970874.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000010021-477313739.png" alt=""></p></li><li><p>质变的算法——会改变操作对象之值<br>所有的STL算法都作用在由迭代器[first，last）所标示出来的区间上。所谓“质变算法”，是指运算过程中会更改区间内（迭代器所指）的元素内容。诸如拷贝（copy）、互换（swap）、替换（replace）、填写（fill）、删除（remove）、排列组合（permutation）、分割（partition）、随机重排（random shuffling）、排序（sort）等算法，都属此类。</p></li><li><p>不质变的算法——不改变操作对象之值<br>所有的STL算法都作用在由迭代器[first，last）所标示出来的区间上。所谓“非质变算法”，是指运算过程中不会更改区间内（迭代器所指）的元素内容。<br>诸如查找（find）、匹配（search）、计数（count）、巡访（for_each）、比较（equal，mismatch）、寻找极值（max，min）等算法，都属此类。但是如果你在for_each（巡访每个元素）算法身上应用一个会改变元素内容的仿函数（functor）。   </p></li></ul><h2 id="6-2、算法的泛化过程"><a href="#6-2、算法的泛化过程" class="headerlink" title="6.2、算法的泛化过程"></a>6.2、算法的泛化过程</h2><ul><li>算法函数传参最好是传引用参数，这样可以避免由于对象的庞大而付出大的代价</li><li>这样的find（）很好，几乎适用于任何容器——只要该容器允许指针指入，而指针们又都支持以下四种find（）函数中出现的操作行为：<ul><li>inequality（判断不相等）操作符</li><li>dereferencelm（提领，取值）操作符</li><li>prefix increment（前置式递增）操作符</li><li>copy（复制）行为（以便产a’x生函数的返回值）</li></ul></li></ul><h2 id="6-3、数值算法"><a href="#6-3、数值算法" class="headerlink" title="6.3、数值算法"></a>6.3、数值算法<stl numeric.h></h2><ul><li><p>头文件<numeric><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000202562-1209119902.png" alt="">    </p></li><li><p>accumlate<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000222791-1493346367.png" alt=""></p></li></ul><p>算法accumulate用来计算init和[first，last）内所有元素的总和。注意，你一定得提供一个初始值init，这么做的原因之一是当[first，last）为空区间时仍能获得一个明确定义的值。如果希望计算[first，1ast）中所有数值的总和，应该将init设为0.</p><ul><li>adjacent_difference<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000240388-361851450.png" alt=""></li></ul><p>算法adjacent_difference用来计算[first，last）中相邻元素的差额。也就是说，它将<em>first 赋值给</em>result，并针对[first+1，last）内的每个迭代器i，将<em>i-</em>（i-1）之值赋值给*（result+（i-first））。<br>注意，你可以采用就地（in place）运算方式，也就是令result等于first。</p><ul><li><p>inner_product<br>算法inner_product能够计算[first1，last1）和[first2，first2+<br>（1ast1-first1））的一般内积（generalized inner product）。注意，你一定得提供初值init。这么做的原因之一是当[first，last）为空时，仍可获得一个明确定义的结果。如果你想计算两个vectors的一般内积，应该将init设为0.</p></li><li><p>partical_sum<br>算法partial_sum用来计算局部总和。它会将<em>first赋值给</em>result，将<em>first和</em>（first+1）的和赋值给*（result+1），依此类推。注意，result可以等于first，这使我们得以完成就地（in place）计算。在这种情况下它是一个质变算法（mutating algorithm）。</p></li></ul><p>运算中的总和首先初始为*first，然后赋值给<em>result。对于<br>[first+1，last）中每个迭代器i，从头至尾依序执行sum=sum+</em>i（第一版本）或sum=binary_op（sum，<em>i）（第二版本），然后再将sum赋值给</em>（result+（i-first））。此式所用之二元仿函数不必满足交换律（commutative）和结合律（associative）。所有运算行为的顺序都有明确设定。<br>本算法返回输出区间的最尾端位置：result+（last-first）。</p><ul><li><p>power<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000323728-288517597.png" alt=""></p></li><li><p>itoa<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000336197-1995376542.png" alt=""></p></li></ul><h2 id="6-4、基本算法"><a href="#6-4、基本算法" class="headerlink" title="6.4、基本算法"></a>6.4、基本算法<stl algobase.h></h2><ul><li><p>for_each</p></li><li><p>equal</p></li><li><p>fill</p></li><li><p>fill_n</p></li><li><p>iter_swap</p></li><li><p>lexicographical_compare</p><ul><li>以“字典排列方式”对两个序列[first1，last1）和tfirst2，1ast2）进行比较。比较操作针对两序列中的对应位置上的元素进行，并持续直到<ul><li>（1）某一组对应元素彼此不相等；</li><li>（2）同时到达1ast1和last2（当两序列的大小相同）；</li><li>（3）到达1ast1或last2（当两序列的大小不同）。</li></ul></li></ul></li><li><p>当这个函数在对应位置上发现第一组不相等的元素时，有下列几种可能：</p><ul><li>如果第一序列的元素较小，返回true.否则返回false。</li><li>如果到达last1而尚未到达last2，返回true。</li><li>如果到达last2而尚未到达last1，返回false。</li><li>如果同时到达last1和last2（换句话说所有元素都匹配），返回false；</li></ul></li><li><p>max</p></li><li><p>min</p></li><li><p>mism atch</p></li></ul><p>用来平行比较两个序列，指出两者之间的第一个不匹配点。返回一对迭代器，分别指向两序列中的不匹配点，如下图。如果两序列的所有对应元素都匹配，返回的便是两序列各自的last迭代器。缺省情况下是以equality操作符来比较元素；但第二版本允许用户指定比较操作。如果第二序列的元素个数比第一序列多，多出来的元素忽略不计。如果第二序列的元素个数比第一序列少，会发生未可预期的行为。</p><ul><li>swap</li><li>copy<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000358486-2111604671.png" alt=""></li></ul><h2 id="6-5、set相关算法"><a href="#6-5、set相关算法" class="headerlink" title="6.5、set相关算法"></a>6.5、set相关算法</h2><p>STL一共提供了四种与set（集合）相关的算法，分别是并集（union）、交集（intersection）、差集（difference）、对称差集（symmetric difference）。</p><h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><p>算法set_union可构造s1、s2之并集。也就是说，它能构造出集合s1Us2，此集合内含s1或s2内的每一个元素。s1、s2及其并集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此，如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现max（m，n）次，其中n个来自s1，其余来自s2。</p><p>set_union 是一种稳定（stable）操作，意思是输入区间内的每个元素的相对顺序都不会改变。set-union有两个版本，差别在于如何定义某个元素小于另一个元素。</p><h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><p>算法 set_intersection可构造s1、s2之交集。也就是说，它能构造出集合s1 n s2，此集合内含同时出现于s1和s2内的每一个元素。s1、s2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现min（m，n）次，并且全部来自s1。</p><p>set_intersection 是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和s1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。</p><h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><p>算法 set_difference可构造s1、s2之差集。也就是说，它能构造出集合s1-s2，此集合内含“出现于s1但不出现于s2”的每一个元素。s1、s2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现max（n-m，0）次，并且全部来自S1。</p><h3 id="set-difference-1"><a href="#set-difference-1" class="headerlink" title="set_difference"></a>set_difference</h3><p>是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和S1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p><h3 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h3><p>算法setsymmetric_difference 可构造s1、s2之对称差集。也就是说，它能构造出集合（S1-S2）U（S2-S1），此集合内含“出现于s1但不出现于s2”<br>以及“出现于s2但不出现于s1”的每一个元素。S1、S2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现ln-ml次。如果n&gt;m，输出区间内的最后n-m个元素将由s1复制而来，如果n&lt; m则输出区间内的最后m-n个元素将由s2复制而来。在STL set容器内，m≤1且n&lt;=1。</p><p>setsymmetric_difference 是一种稳定（stable）操作，意思是输入区间内的元素相对顺序不会被改变。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operators进行比较，第二版本采用仿函数comp。</p><h2 id="6-6、heap算法"><a href="#6-6、heap算法" class="headerlink" title="6.6、heap算法"></a>6.6、heap算法</h2><h2 id="6-7、其它算法"><a href="#6-7、其它算法" class="headerlink" title="6.7、其它算法"></a>6.7、其它算法</h2><p>深入源代码之前，先观察每一个算法的表现，是个比较好的学习方式。以下程序示范本节每一个算法的用法。程序中有时使用STL内建的仿函数（functors，如less，greater，equeal_to）和配接器（adapters，如bind2nd），有时使用自定义的仿函数（如display，even_by_two）。</p><ul><li><p>adjacent find<br>找出第一组满足条件的相邻元素。这里所谓的条件，在版本一中是指“两元素相等”，在版本二中允许用户指定一个二元运算，两个操作数分别是相邻的第一元素和第二元素。</p></li><li><p>count<br>运用equality操作符，将[first，last）区间内的每一个元素拿来和指定值value比较，并返回与value相等的元素个数。</p></li><li><p>count_if<br>将指定操作（一个仿函数）pred实施于[first，1ast）区间内的每一个元素身上，并将“造成pred之计算结果为true”的所有元素的个数返回。</p></li><li><p>find</p></li><li><p>find it</p></li><li><p>find_end</p></li><li><p>find_first of</p></li><li><p>for_each</p></li><li><p>generate</p></li><li><p>generate_n</p></li><li><p>includes（应用于有序区间）</p></li><li><p>max element</p></li><li><p>merge（应用于有序区间）</p></li><li><p>min_element</p></li><li><p>partition</p></li></ul><p>partition 会将区间[first，last）中的元素重新排列。所有被一元条件运算pred判定为true的元素，都会被放在区间的前段，被判定为false的元素，都会被放在区间的后段。这个算法并不保证保留元素的原始相对位置。如果需要保留原始相对位置，应使用stable_partition。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000454758-820817564.png" alt=""></p><ul><li><p>remove移除（但不删除）<br>移除[first，1ast）之中所有与value相等的元素。这一算法并不真正从容器中删除那些元素（换句话说容器大小并未改变），而是将每一个不与value相等（也就是我们并不打算移除）的元素轮番赋值给first之后的空间。返回值Fonwarditerator 标示出重新整理后的最后元素的下一位置。<br>例如序列<br>{0，1，0，2，0，3，0，4]，如果我们执行remove（），希望移除所有0值元素，执行结果将是{1，23，4，0，3.0.4]。每一个与0不相等的元素，1，2，3，4，分别被拷贝到第一、二、三、四个位置上。第四个位置以后不动，换句话说是第四个位置之后是这一算法留下的残余数据。返回值Forwardlterator 指向第五个位置。如果要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase（）member function。注意，array 不适合使用remove（）和remove_if（），因为array无法缩小尺寸，导致残余数据永远存在。对array而言，较受欢迎的算法是remove_copy（）和</p></li><li><p>remove_copy</p></li><li><p>remove_if</p></li><li><p>remove_copy.if</p></li><li><p>replace</p></li><li><p>replace_copy</p></li><li><p>replace if</p></li><li><p>replace_copy._if</p></li><li><p>reverse</p></li><li><p>reverse_copy</p></li><li><p>rotate<br>将[first，middle）内的元素和[middle，last）内的元素互换。middle所指的元素会成为容器的第一个元素。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000526836-1762719892.png" alt=""></p></li><li><p>rotate_copy</p></li><li><p>search</p></li><li><p>search_n</p></li></ul><p>在序列[first，last）所涵盖的区间中，查找“连续count个符合条件之元素”所形成的子序列，并返回一个迭代器指向该子序列起始处。如果找不到这样的子序列，就返回迭代器last。上述所谓的“某条件”，在search_n版本一指的是相等条件“equality”，在search_n版本二指的是用户指定的某个二元运算（以仿函数呈现）。</p><p>例如，面对序列{10，8，8，7，2，8，7，2，2，8，7，0}，查找“连续两个8”所形成的子序列起点，可以这么写：<br>iter1 = search_n（iv.begin（），iv.end（），2，8）；</p><p>查找“连续三个小于8的元素”所形成的子序列起点，可以这么写：<br>iter2 = search_n（iv.begin（），iv.end（），3，8，1ess&lt; int &gt;（）；</p><ul><li><p>swap_ranges</p></li><li><p>transform</p></li><li><p>unique</p></li><li><p>unique_copy</p></li><li><p>lower_bound（应用于有序区间）<br>这是二分查找（binary search）的一种版本，试图在已排序的（first，last）中寻找元素value。如果[first，last）具有与value相等的元素（s），便返回一个迭代器，指向其中第一个元素。如果没有这样的元素存在，便返回“假设这样的元素存在时应该出现的位置”。也就是说，它会返回一个迭代器，指向第一个“不小于value”的元素。如果value大于[first，last）内的任何一个元素，则返回last。以稍许不同的观点来看1ower_bound，其返回值是“在不破坏排序状态的原则下，可插入value的第一个位置”。 </p></li><li><p>upper_bound（应用于有序区间）<br>算法upper_bound是二分查找（binary search）法的一个版本。它试图在已排序的[first，last）中寻找value。更明确地说，它会返回“在不破坏顺序的情况下，可插入value的最后一个合适位置”。</p></li><li><p>binary_search（应用于有序区间）<br>算法binary_search 是一种二分查找法，试图在已排序的[first，last）中寻找元素value。如果[first，last）内有等同于value的元素，便返回true，否则返回false。</p></li></ul><p>返回单纯的bool或许不能满足你，前面所介绍的lower_bound和upper_bound能够提供额外的信息。事实上binary_search便是利用lower_bound先找出“假设value存在的话，应该出现的位置”，然后再对比该位置上的值是否为我们所要查找的目标，并返回对比结果。</p><ul><li>next_permutation<br>STL提供了两个用来计算排列组合关系的算法，分别是nextpermucation和 prev_permutation。首先我们必须了解什么是“下一个”排列组合，什么是“前一个”排列组合。</li></ul><p>考虑三个字符所组成的序列（a，b，c）。这个序列有六个可能的排列组合：abc，acb，bac，bca，cab，cba。这些排列组合根据less-than操作符做字典顺序（lexicographical）的排序。也就是说，abc名列第一，因为每一个元素都小于其后的元素。</p><p>next_permutation（）会取得[first，last）所标示之序列的下一个排列组合。如果没有下一个排列组合，便返回false；否则返回true。</p><ul><li><p>prev_permutation<br>所谓“前一个”排列组合，其意义已在上一节阐述。实际做法简述如下，其中所用的符号如图6-8所示。首先，从最尾端开始往前寻找两个相邻元素，令第一元素为<em>i，第二元素为</em>ii，且满足*i&gt;*ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个小于*i的元素，令为*j，将i，j元素对调，再将ii之后的所有元素颠倒排列。此即所求之“前一个”排列组合。</p></li><li></li><li><p>random_shufle<br>这个算法将[first，last）的元素次序随机重排。也就是说，在N！种可能的元素排列顺序中随机选出一种，此处N为last-first。</p></li></ul><p>N个元素的序列，其排列方式有N！种，random_shuffle会产生一个均匀分布，因此任何一个排列被选中的机率为1/N！。这很重要，因为有不少算法在其第一阶段过程中必须获得序列的随机重排，但如果其结果未能形成“在N！个可能排列上均匀分布（uniform distribution）”，便很容易造成算法的错误。</p><ul><li><p>partial_sort/partial_sort<br>本算法接受一个middle 迭代器（位于序列[first，last）之内），然后重新安排[first，last），使序列中的middle-first个最小元素以递增顺序排序，置于（first，middle）内。其余1ast-middle个元素安置于[middle，last）中，不保证有任何特定顺序。</p></li><li><p>sort<br>STL的sort 算法，数据量大时采用Quick Sort，分段递归排序。<br>一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷（overhead），就改用Insertion Sort。<br>如果递归层次过深，还会改用Heap Sort。</p></li><li><p>equal_range（应用于有序区间）<br>算法equal_range是二分查找法的一个版本，试图在已排序的[first，last）中寻找value。它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即1ower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound）。因此，[i，j）内的每个元素都等同于value，而且[i，j）是(first，last)之中符合此一性质的最大子区间。<br>于是，算法lower_bound返回区间A的第一个迭代器，算法upper_bound返回区间A的最后元素的下一位置，算法equalrange则是以pair的形式将两者都返回。</p></li><li><p>inplace_merge（应用于有序区间）<br>如果两个连接在一起的序列[first，middle）和[middle，last）都已排序，那么inplacemerge可将它们结合成单一一个序列，并仍保有序性（sorted）。</p></li></ul><p>如果原先两个序列是递增排序，执行结果也会是递增排序，如果原先两个序列是递减排序，执行结果也会是递减排序。</p><p>和merge一样，inplace_merge也是一种稳定（stable）操作。每个作为数据来源的子序列中的元素相对次序都不会变动；如果两个子序列有等同的元素，第一序列的元素会被排在第二序列元素之前。</p><ul><li>nth_element<br>这个算法会重新排列[first，last），使迭代器nth所指的元素，与“整个<br>[first，1ast）完整排序后，同一位置的元素”同值。此外并保证（nth，last）内没有任何一个元素小于（更精确地说是不大于）[first，nth）内的元素，但对于[first，nth）和[nth，last）两个子区间内的元素次序则无任何保证一—这一点也是它与partial_sort很大的不同处。以此观之，nth_element比较近似partition 而非 sort 或 partial_sort。</li></ul><p>例如，假设有序列{22，30，30，17，33，40，17，23，22，12，20}，以下操作：<br>nth_element(iv.begin()，iv.begin()+5，iv.end())；便是将小于*(iv.begin()+5)(本例为40)的元素置于该元素之左，其余置于该元素之右，并且不保证维持原有的相对位置。获得的结果为{20，12，22，17，17，<br>22，23，30，30，33，40]。执行完毕后的5th个位置上的元素值22，与整个序列完整排序后{12，17，17，20，22，22，23，30，30，33，40]的5th个位置上的元素值相同。</p><ul><li>6.7.13 merge sort<br>以上的排序算法详见<a href="http://zzw1024.top/2019/12/23/shi-da-jing-dian-pai-xu-suan-fa/" target="_blank" rel="noopener"><strong>博文</strong></a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第五章、关联容器&quot;&gt;&lt;a href=&quot;#第五章、关联容器&quot; class=&quot;headerlink&quot; title=&quot;第五章、关联容器&quot;&gt;&lt;/a&gt;第五章、关联容器&lt;/h1&gt;&lt;h2 id=&quot;5-0、关联容器&quot;&gt;&lt;a href=&quot;#5-0、关联容器&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.zzw1024.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL源码剖析" scheme="http://www.zzw1024.top/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
</feed>
