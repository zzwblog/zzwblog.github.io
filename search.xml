<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客——git项目推送多个仓库</title>
      <link href="/2020/06/10/bo-ke-git-xiang-mu-tui-song-duo-ge-cang-ku/"/>
      <url>/2020/06/10/bo-ke-git-xiang-mu-tui-song-duo-ge-cang-ku/</url>
      
        <content type="html"><![CDATA[<!-- password: --><p>转载:<a href="https://www.cnblogs.com/poloyy/p/12215199.html" target="_blank" rel="noopener">https://www.cnblogs.com/poloyy/p/12215199.html</a></p><h1 id="Gitee拉取Github仓库"><a href="#Gitee拉取Github仓库" class="headerlink" title="Gitee拉取Github仓库"></a>Gitee拉取Github仓库</h1><p>直接在Gitee中创建一个项目，然后再最后一行导入Github项目就阔以啦！<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131207560-500399712.png" alt=""></p><p>去到你的Github仓库复制https链接，直接粘贴就阔以啦<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131220912-39508480.png" alt=""></p><p>到此为止，在Gitee就已经创建好仓库啦</p><h1 id="本地配置推送方式"><a href="#本地配置推送方式" class="headerlink" title="本地配置推送方式"></a>本地配置推送方式</h1><ul><li>方式一：定义不同的远程仓库名称，然后分别推送 多次推送，配了几个远程仓库就推送几次 </li><li>方式二：在同一个远程仓库下添加另一个远程仓库的地址，然后推送 only一次推送 </li></ul><p>==以下情况均是本地只有单个ssh-key时的操作！！== </p><ol><li>方式一：多次推送</li></ol><ul><li>优点</li></ul><ul><li>想推哪个仓库就推哪个    </li><li>不想推哪个就不推哪个</li></ul><ul><li><p>缺点<br>推送仓库数量多时，时间成本高</p></li><li><p>1）.可以直接通过命令将本地项目和gitee项目关联<br><code>git remote add gitee 码云项目地址</code></p></li><li><p>2).也可以通过修改本地项目的配置文件</p><blockquote><p>a. 首先，进入到项目的 .git 文件夹，打开 config 文件<br>b. 然后，找到 [remote “origin”] ，复制一份remote到下面，修改remote的名字和url即可<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131603763-997002322.png" alt=""></p></blockquote></li></ul><p>为了避免冲突，将原始的remote名字也改掉，注意：remote的名字任意，但是在提交的时候要与这里对应<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131614188-1802431619.png" alt=""></p><ul><li><p>3).执行以下命令，可以看到配置的两个仓库<br><code>git remote</code></p></li><li><p>4).推送代码时，需要对两个仓库分别执行一次push命令，也就是多次推送</p><pre><code>git push github matser git push gitee master  </code></pre></li></ul><ol start="2"><li>方式二：一次推送</li></ol><ul><li><p>1).通过命令将码云项目地址添加到本地已有的remote下<br><code>git remote set-url --add origin 码云项目地址</code></p></li><li><p>2).也可以通过修改本地项目的配置文件<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131732930-127632063.png" alt=""></p></li><li><p>3).推送代码只需执行以下一条命令即可<br><code>git push</code></p></li></ul><h1 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h1><p>博主就是配完之后遇到了该问题，所以拿出来跟大家说说哈<br><code>git push的时有时候会出现错误[rejected] master -&gt; master (fetch first)</code><br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131745200-133461885.png" alt=""></p><p>此时可以输入： git push -f   进行解决错误，然后再： git push      </p><p>如果上述解决方式不管用也可以输入： git pull –rebase origin master  之后再进行 git push 即可。</p><h1 id="本地有多个ssh-key时"><a href="#本地有多个ssh-key时" class="headerlink" title="本地有多个ssh-key时"></a>本地有多个ssh-key时</h1><p>如果也想配多个ssh-key的话，可以参照这篇文章哦<br><code>https://www.cnblogs.com/poloyy/p/12189140.html</code></p><p>你需要更改两个地方</p><ul><li>第一：公钥配置文件，目录是： C:\Users\user.ssh 下的 config 文件</li></ul><p>现在多了gitee，所以对应的Host也要增加，如下图<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131816433-384293327.png" alt=""></p><p>我这里是两个ssh-key都会被Github和Gitee共用，正常来说是一个ssh-key指向一个仓库即可，譬如第一个key的Host配成Github的，第二个Key的Host配成Gitee<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131820697-1347076172.png" alt=""></p><ul><li>第二：需要修改在上面配置过的 config 文件，它在你的项目目录下的 .git 文件夹下</li></ul><p>原本只有一个ssh-key时，你的配置文件可能是这样的<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131831679-548241428.png" alt=""></p><p>当你有两个ssh-key时，你的配置文件就需要改成如下<br><img src="https://img2020.cnblogs.com/blog/1463063/202006/1463063-20200610131841795-1639237760.png" alt=""></p><p>最后将 Github_HOST 、 Gitee_HOST 替换成你自己配置里的Host地址。其余步骤都是一样的啦！这里就是要强调下，如果有多个ssh-key时，还得修改下配置文件而已~</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git, 推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客——博客搭建</title>
      <link href="/2020/06/09/bo-ke-bo-ke-da-jian/"/>
      <url>/2020/06/09/bo-ke-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<!-- password: --><blockquote><p>转载自博客：<a href="https://juejin.im/entry/5a574864f265da3e3c6c1217" target="_blank" rel="noopener">https://juejin.im/entry/5a574864f265da3e3c6c1217</a><br>侵权告知。</p></blockquote><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>在 Windows 环境下安装 Node.js 非常简单，仅须到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网下载</a>安装文件并执行即可完成安装。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c6feba58fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p>去<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git官网</a>根据你的电脑参数，下载对应版本。</p><p>下载完成，通过在命令行输入 git version 查看是否安装成功，有输出版本号说明安装成功。</p><p>鼠标邮件菜单里就多了Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行，我们选择Git Bash Here。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c6fea994bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c725a598e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="一、Hexo安装"><a href="#一、Hexo安装" class="headerlink" title="一、Hexo安装"></a>一、Hexo安装</h2><p>桌面右键鼠标，点击Git Bash Here，输入npm命令即可安装</p><pre><code>npm install hexo-cli -gnpm install hexo-deployer-git --save</code></pre><p>第一句是安装hexo，第二句是安装hexo部署到git page的deployer，两个都需要安装。</p><p>如下图即安装完成。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c728dda55c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="二、Hexo初始化配置"><a href="#二、Hexo初始化配置" class="headerlink" title="二、Hexo初始化配置"></a>二、Hexo初始化配置</h2><ul><li><p>创建Hexo文件夹<br>安装完成后，根据自己喜好建立目录（如F:\Blog\Hexo），直接进入F:\Blog\Hexo文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。<br><code>$ hexo init</code><br>安装 Hexo 完成后，Hexo 将会在指定文件夹中新建所需要的文件。Hexo文件夹下的目录如下：<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7293a169d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>本地查看效果<br>执行下面语句，执行完即可登录localhost:4000查看效果</p><pre><code>hexo generatehexo server</code></pre><p>登录localhost:4000，即可看到本地的效果如下：<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c72acc46d2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li></ul><h1 id="将博客部署到Github-Pages上"><a href="#将博客部署到Github-Pages上" class="headerlink" title="将博客部署到Github Pages上"></a>将博客部署到Github Pages上</h1><p>那么现在本地的博客已经搭建起来了，但是我们只可以通过本地连接查看我们的博客。那么我们现在需要做的就是把本地的博客发布到服务器上，让别人也可以连接我们的博客，而Github Pages就帮我完成了这件事情。但是Github Pages的代码就是寄存在Github上面的。那么接下来我们需要在Github上面创建一个新的项目。</p><h2 id="一、注册Github账户"><a href="#一、注册Github账户" class="headerlink" title="一、注册Github账户"></a>一、注册Github账户</h2><p>访问Github首页<br>点击右上角的 Sign Up，注册自己的账户</p><h2 id="二、创建项目代码库"><a href="#二、创建项目代码库" class="headerlink" title="二、创建项目代码库"></a>二、创建项目代码库</h2><p>注册完登陆后，我们就创建一个我们自己的Github Pages项目。点击New repository。<br>创建要点如下：<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7492a1849?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="三、配置SSH密钥"><a href="#三、配置SSH密钥" class="headerlink" title="三、配置SSH密钥"></a>三、配置SSH密钥</h2><p>配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下：</p><ol><li>第一步、看看是否存在SSH密钥(keys)<br>首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行:<br><code>$ cd ~/. ssh</code><br>检查你本机用户home目录下是否存在.ssh目录</li></ol><p>如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。</p><ol start="2"><li>第二步、创建一对新的SSH密钥(keys)<br><code>$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></li></ol><p>** 这将按照你提供的邮箱地址，创建一对密钥 ** </p><pre><code>Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</code></pre><p>直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如<code>/c/Users/you/.ssh/github_rsa</code></p><p>接着，根据提示，你需要输入密码和确认密码（说到这里，如果你很放心，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。所谓的最安全的密码，就是没有密码 哈哈）。相关提示如下：</p><pre><code>Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again]</code></pre><p>输入完成之后，屏幕会显示如下信息：</p><pre><code>Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</code></pre><ol start="3"><li>第三步、在GitHub账户中添加你的公钥<br>运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。<br><code>clip &lt; ~/.ssh/id_rsa.pub</code><br>接着：</li></ol><ul><li><p>1). 登陆GitHub,进入你的Account Settings.<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c74ea98dce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>2). 选择SSH Keys<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c75003310c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>3). 粘贴密钥，添加即可<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c758d3dd78?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li></ul><ol start="4"><li><p>第四步、测试<br>可以输入下面的命令，看看设置是否成功，<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>的部分不要修改：<br><code>$ ssh -T git@github.com</code><br>如果是下面的反馈：</p><pre><code>The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?</code></pre><p>不要紧张，输入yes就好，然后会看到：<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c76b83e076?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>第五步、设置用户信息<br>现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。<br>Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。</p><pre><code>$ git config --global user.name &quot;ryanlijianchang&quot;//用户名$ git config --global user.email  &quot;liji.anchang@163.com&quot;//填写自己的邮箱</code></pre></li><li><p>第六步、SSH Key配置成功<br>本机已成功连接到github。</p></li></ol><h2 id="四、将本地的Hexo文件更新到Github的库中"><a href="#四、将本地的Hexo文件更新到Github的库中" class="headerlink" title="四、将本地的Hexo文件更新到Github的库中"></a>四、将本地的Hexo文件更新到Github的库中</h2><ul><li><p>第一步、登录Github打开自己的项目 username.github.io<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c76bcbdef9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>第二步、打开之后，点击SSH，选择SSH类型地址<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c77317a936?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>第三步、复制地址<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c77a882a00?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>第四步、打开你一开始创建的Hexo文件夹（如F:\Blog\Hexo），用记事本打开刚文件夹下的_config.yml文件<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c787c11116?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>第五步、在配置文件里作如下修改，保存<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c78dc8dca4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li></ul><h2 id="第六步、在Hexo文件夹下执行："><a href="#第六步、在Hexo文件夹下执行：" class="headerlink" title="第六步、在Hexo文件夹下执行："></a>第六步、在Hexo文件夹下执行：</h2><pre><code>hexo ghexo d</code></pre><p>或者直接执行</p><pre><code>hexo g -d</code></pre><p>执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。对应的地址是 username.github.io(我的是：ryanlijianchang.github.io)。</p><p>假如这时候，报错 ERROR Deployer not found: git，那么就是你的deployer没有安装成功，你需要执行如下命令再安装一次：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>这样，你再执行hexo g -d，你的博客就部署到Github上了。</p><h2 id="第七步、在浏览器上输入自己的主页地址"><a href="#第七步、在浏览器上输入自己的主页地址" class="headerlink" title="第七步、在浏览器上输入自己的主页地址"></a>第七步、在浏览器上输入自己的主页地址</h2><p>在浏览器上输入Github Pager为我们生成的外链（例如我的是：ryanlijianchang.github.io/，而你的只需要把你的github用户名替换掉这个链接中的ryanlijianchang，因为我的用户名是这个，那么你自己的专属博客地址就是：https://[您的用户名].github.io/）即可看到自己的博客了。</p><p>当然，每一个人都可以通过这个地址访问到你的博客了。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c79436ba6a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h1 id="美化自己博客"><a href="#美化自己博客" class="headerlink" title="美化自己博客"></a>美化自己博客</h1><p>那么现在我们的博客已经挂在了Github服务器上面，别人已经可以通过地址来登陆我们的博客了，但是我们这时就有了新的需求，就是自己的博客并不好看，那怎么办的？这很简单，要知道很多前端开发者在Hexo框架下开发了很多的主题给我们使用，我们只需要把他们的主题克隆过来，然后通过修改配置文件即可达到我们所需要的效果。</p><p>那么我们应该怎么修改呢？</p><h2 id="一、进入Hexo的官网主题专栏"><a href="#一、进入Hexo的官网主题专栏" class="headerlink" title="一、进入Hexo的官网主题专栏"></a>一、进入<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo的官网</a>主题专栏</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7943f8189?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="二、挑选我们喜欢的主题"><a href="#二、挑选我们喜欢的主题" class="headerlink" title="二、挑选我们喜欢的主题"></a>二、挑选我们喜欢的主题</h2><p>可以看到有很多主题给我们选，我们只要选择喜欢的主题点击进去，然后进入到它的github地址，我们只要把这个地址复制下来(例如我是选择：hexo-theme-next这个主题)<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7ab832ba0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="三、克隆主题"><a href="#三、克隆主题" class="headerlink" title="三、克隆主题"></a>三、克隆主题</h2><p>再打开Hexo文件夹下的themes目录（F:\Blog\hexo\themes），右键Git Bash，在命令行输入:</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) </code></pre><p>下载中，等待下载完成：<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7b605e272?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="四、修改Hexo配置文件"><a href="#四、修改Hexo配置文件" class="headerlink" title="四、修改Hexo配置文件"></a>四、修改Hexo配置文件</h2><p>下载完成后，打开Hexo文件夹下的配置文件_config.yml</p><p>修改参数为：<code>theme: hexo-theme-next</code></p><h2 id="五、部署主题，本地查看效果"><a href="#五、部署主题，本地查看效果" class="headerlink" title="五、部署主题，本地查看效果"></a>五、部署主题，本地查看效果</h2><p>返回Hexo目录，右键Git Bash，输入</p><pre><code>hexo ghexo s</code></pre><p>打开浏览器，输入 Http://localhost:4000/ 即可看见我们的主题已经更换了。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7b86f3ce1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="六、如果效果满意，将它部署到Github上"><a href="#六、如果效果满意，将它部署到Github上" class="headerlink" title="六、如果效果满意，将它部署到Github上"></a>六、如果效果满意，将它部署到Github上</h2><p>打开Hexo文件夹，右键Git Bash，输入</p><pre><code>hexo clean   (必须要，不然有时因为缓存问题，服务器更新不了主题)hexo g -d</code></pre><h2 id="七、打开自己的主页，即可看到修改后的效果"><a href="#七、打开自己的主页，即可看到修改后的效果" class="headerlink" title="七、打开自己的主页，即可看到修改后的效果"></a>七、打开自己的主页，即可看到修改后的效果</h2><p>更多修改效果请查看对应主题的说明文档，点击此查看本主题(Next)对应的说明文档。</p><h1 id="在博客写文章"><a href="#在博客写文章" class="headerlink" title="在博客写文章"></a>在博客写文章</h1><h2 id="一、用hexo发表新文章"><a href="#一、用hexo发表新文章" class="headerlink" title="一、用hexo发表新文章"></a>一、用hexo发表新文章</h2><pre><code>$ hexo n &quot;文章标题&quot; </code></pre><p>其中 我的家 为文章标题，执行命令 hexo n “我的家” 后，会在项目 \Hexo\source_posts 中生成 我的家.md文件，用编辑器打开编写即可。</p><p>当然，也可以直接在\Hexo\source_posts中新建一个md文件，我就是这么做的。<br>写完后，推送到服务器上，执行以下命令即可在我们的站点看到新的文章。</p><pre><code>$ hexo g #生成$ hexo d #部署 # 可与hexo g合并为 hexo d -g</code></pre><h2 id="二、用Markdown写文章"><a href="#二、用Markdown写文章" class="headerlink" title="二、用Markdown写文章"></a>二、用Markdown写文章</h2><p>我们注意到在 \Hexo\source_posts 文件夹下存放着我们的文章，它们的格式都是以.md格式结尾的，没错，Hexo也是支持Markdown语法的，所以当我们需要写具有格式化的文章时，我们可以使用支持Markdown语法的编辑器进行文章编译，然后保存文件到 \Hexo\source_posts 文件夹下即可。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c7bd487097?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>复制进去之后，只要执行</p><pre><code>$ hexo d -g </code></pre><p>推送到我们的Github仓库即可。</p><h3 id="那么什么是Markdown？"><a href="#那么什么是Markdown？" class="headerlink" title="那么什么是Markdown？"></a>那么什么是Markdown？</h3><p>Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p><h3 id="Markdown有什么优点？"><a href="#Markdown有什么优点？" class="headerlink" title="Markdown有什么优点？"></a>Markdown有什么优点？</h3><ul><li>专注你的文字内容而不是排版样式。</li><li>轻松的导出 HTML、PDF 和本身的 .md 文件。</li><li>纯文本内容，兼容所有的文本编辑器与字处理软件。</li><li>可读，直观。适合所有人的写作语言。</li></ul><h3 id="我该用什么工具？"><a href="#我该用什么工具？" class="headerlink" title="我该用什么工具？"></a>我该用什么工具？</h3><ul><li>Windows下可以使用 MarkdownPad2。</li><li>在 Mac OS X 上，我建议你用 Mou 这款免费且十分好用的 Markdown 编辑器。</li><li>Web 端上，我强烈推荐 简书 这款产品。</li></ul><h3 id="关于Markdown的更多资料可以查看如下："><a href="#关于Markdown的更多资料可以查看如下：" class="headerlink" title="关于Markdown的更多资料可以查看如下："></a>关于Markdown的更多资料可以查看如下：</h3><ul><li><a href="https://sspai.com/post/25137" target="_blank" rel="noopener">认识与入门 Markdown</a></li><li><a href="https://www.douban.com/note/350126154/?type=like" target="_blank" rel="noopener">Markdown入门指南</a></li></ul><h2 id="三、配置博客"><a href="#三、配置博客" class="headerlink" title="三、配置博客"></a>三、配置博客</h2><p>在blog目录下，用sublime打开_config.yml文件，修改参数信息</p><pre><code># Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title:  #标题subtitle:  #副标题description:  #站点描述，给搜索引擎看的author:  #作者email:  #电子邮箱language: zh-CN #语言# URL #链接格式url:  #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮enable: true #是否启用line_number: true #显示行号tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy:type: gitrepo: 刚刚github创库地址.gitbranch: master</code></pre><p>特别提醒，在每个参数的：** 后都要加一个空格 **</p><p>修改网站相关信息</p><pre><code>title: 崔斯特测试所用博客subtitle: 副标题description: 网页描述author: 崔斯特language: zh-CNtimezone: Asia/Shanghai</code></pre><p>配置部署（我的是zhihuya，修改成自己的）</p><pre><code>deploy: type: gitrepo: https://github.com/zhihuya/zhihuya.github.io.gitbranch: master</code></pre><h2 id="四、发表文章"><a href="#四、发表文章" class="headerlink" title="四、发表文章"></a>四、发表文章</h2><p>在CMD中输入</p><pre><code>$ hexo new &quot;崔斯特测试文章&quot;INFO  Created: F:\test\blog\source\_posts\崔斯特测试文章.md</code></pre><p>找到该文章，打开，使用Markdown语法，该语法介绍可以查看利用HEXO搭建的博客及Markdown语法介绍</p><pre><code>---title: 崔斯特测试文章date: 2017-02-28 13:03:44tags:---</code></pre><p>这是一篇测试文章，欢迎关注作者博客[1]: <a href="https://zhangslob.github.io/" target="_blank" rel="noopener">https://zhangslob.github.io/</a><br>保存，然后执行下列步骤：</p><pre><code>F:\test\blog$ hexo cleanINFO  Deleted database.INFO  Deleted public folder.</code></pre><pre><code>F:\test\blog$ hexo generateINFO  Start processingINFO  Files loaded in 1.48 s#省略INFO  29 files generated in 4.27 s</code></pre><pre><code>F:\test\blog$ hexo serverINFO  Start processingINFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></pre><p>这个时候，打开<a href="http://localhost:4000/，发现刚才的文章已经成功了" target="_blank" rel="noopener">http://localhost:4000/，发现刚才的文章已经成功了</a><br><img src="https://pic2.zhimg.com/80/v2-95377f456e18451b96316edbdeccd985_hd.jpg" alt=""></p><p>最后一步，发布到网上，执行：</p><pre><code>F:\test\blog$ hexo deployINFO  Deploying: gitINFO  Clearing .deploy_git folder...INFO  Copying files from public folder...#省略</code></pre><p>其中会跳出Github登录，直接登录，如果没有问题输入zhihuya（换成你的）.<a href="http://github.io/" target="_blank" rel="noopener">http://github.io/</a><br><img src="https://pic4.zhimg.com/80/v2-9eca7f5fb9a05dbf76ba193a7e408a17_hd.jpg" alt=""></p><p><a href="https://zhihuya.github.io" target="_blank" rel="noopener">崔斯特测试所用博客</a></p><p>然后就可以看到已经发布了<br><img src="https://pic1.zhimg.com/80/v2-4e7b67ea48bde5e2661540624f792010_hd.jpg" alt=""></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇仅仅针对windows，Mac请移步20分钟教你使用hexo搭建github博客</p><p>发布文章的步骤：</p><ol><li><p>hexo new 创建文章</p></li><li><p>Markdown语法编辑文章</p></li><li><p>部署（所有打开CMD都是在blog目录下）</p><pre><code>hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo generate #生成hexo server #启动服务预览，非必要，可本地浏览网页hexo deploy #部署发布</code></pre><p>简写Tips：</p><pre><code>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署</code></pre><p>如果在执行 hexo deploy 后,出现 error deployer not found:github 的错误，执行：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>出错是正常的，出错了自己先百度或google，实在不知道的可以询问我。</p></li></ol><p>托管的话不仅有github可以用，还有个国内的<a href="http://coding.net可选" target="_blank" rel="noopener">http://coding.net可选</a></p><h1 id="将自己的域名关联到Github-Pages上"><a href="#将自己的域名关联到Github-Pages上" class="headerlink" title="将自己的域名关联到Github Pages上"></a>将自己的域名关联到Github Pages上</h1><p>很多朋友创建了自己的博客之后会选择买一个属于自己的域名，然后将自己域名绑定到自己的Github Pages博客上，其实这也并不难，只要你有个域名。</p><h2 id="一、购买域名"><a href="#一、购买域名" class="headerlink" title="一、购买域名"></a>一、购买域名</h2><p>如果你不是很有钱，在阿里云上，你只要几块钱就可以买到一个域名。</p><p>选择你喜欢的域名，然后购买即可。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c8529b7e80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>##二、配置CNAME文件<br>在 \hexo\source 文件夹下创建文件 CNAME （新建记事本文件命名CNAME，然后打开）</p><p>内容为你的域名，例如我的域名是：ryane.top<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c855add24e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>在Hexo文件夹提交</p><pre><code>hexo g -d</code></pre><h2 id="三、修改DNS的DNS"><a href="#三、修改DNS的DNS" class="headerlink" title="三、修改DNS的DNS"></a>三、修改DNS的DNS</h2><ol><li><p>如果你是在阿里云购买域名的话，请登录阿里云网站。打开个人中心，点击域名<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c856d6f09b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>选择管理<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c85bffa826?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>修改DNS为</p><pre><code>f1g1ns2.dnspod.net f1g1ns1.dnspod.net </code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c871f901d6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li></ol><h2 id="四、域名解析"><a href="#四、域名解析" class="headerlink" title="四、域名解析"></a>四、域名解析</h2><ol><li><p>打开<a href="https://www.dnspod.cn" target="_blank" rel="noopener">DNSPOD</a>，注册一个账户</p></li><li><p>点击添加域名，把你的域名添加进去，如无意外，添加完之后就是以下这个状态<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c8762afc03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>此时点击添加记录，添加两个记录，一个主机记录为@， 一个为www，而记录值都是填同一个，填你的博客主页对应的ip，添加完后如下。<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c8788184d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>但是如何获取ip值呢？打开运行，输入cmd，打开命令窗口输入 ping 主页地址 ， 红色部分即为你的ip值<br><img src="https://user-gold-cdn.xitu.io/2018/1/20/161117c88c7b5bba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p></li><li><p>将IP输入过去，然后会提示你到域名注册的地方修改DNS。等待生效，最迟72小时生效。即可通过你的域名浏览你的博客主页。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当你完成了你的博客之后，相信你的心情跟我刚做完的心情是一样的，即便很累，但是当自己的博客成型之后，自己还是有一个成就感的，那么完成后，以后的路还很长，真正想要自己博客能够积累人气，还得靠好的内容，所以认真写文章吧，相信你会受益于此的。</p><p>如果大家有什么问题的话，可以在我留言板下留言，我看到评论时会第一时间回答大家。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><a href="https://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="noopener">Markdown–入门指南</a></li><li><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="noopener">如何搭建一个独立博客——简明 Github Pages与 jekyll 教程 by cnfeat</a></li><li><a href="https://www.cnblogs.com/zhcncn/p/4097881.html" target="_blank" rel="noopener">Hexo搭建Github静态博客 by 金石开</a></li><li><a href="http://www.xuanfengge.com/using-ssh-key-link-github-photo-tour.html" target="_blank" rel="noopener">使用SSH密钥连接Github【图文教程】 by 轩枫</a></li></ul><blockquote><p>** 声明：**<br>由于本人初次接触这方面的知识，所以本文是转载的，若侵权，望留言，我必删之。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活杂记——诗分享：人生</title>
      <link href="/2020/06/09/sheng-huo-za-ji-shi-fen-xiang-ren-sheng/"/>
      <url>/2020/06/09/sheng-huo-za-ji-shi-fen-xiang-ren-sheng/</url>
      
        <content type="html"><![CDATA[<!-- password: --><pre><code>        喜欢一个人</code></pre><p>　　　　　　始于颜值，陷于才华;</p><p>　　　　　　忠于人品，痴于身体;</p><p>　　　　　　迷于声音，醉于深情;</p><p>　　　　最后，却，折于物质，败于现实。</p><p>　　</p><p>　　　　这世间万千滋味，早有先人尝遍；</p><p>　　　　　　读过多少警示名言；</p><p>　　　　我们还是会不由自主的重蹈覆辙；</p><p>　　　　　　走他们走过的路；</p><p>　　　　　　受他们受过的苦。</p>]]></content>
      
      
      <categories>
          
          <category> 生活杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活杂记——诗分享:活</title>
      <link href="/2020/06/09/sheng-huo-za-ji-shi-fen-xiang-huo/"/>
      <url>/2020/06/09/sheng-huo-za-ji-shi-fen-xiang-huo/</url>
      
        <content type="html"><![CDATA[<!-- password: --><p>如果羡慕成功者的富贵，</p><p>别一味模仿他们富贵后的事。</p><p>那些名牌表呀包呀酒呀车呀，</p><p>都是他们富贵后的事。</p><p>硬撑着模仿了，</p><p>也只能图个穷开心而已。</p><p>要模仿，</p><p>就模仿他们富贵前的事。</p><p>他们那些</p><p>鹰般的探索、</p><p>蛇般的专注、</p><p>蚁般的辛劳、</p><p>蛹般的耐心，</p><p>全是些风吹日晒灰头土脸的事！</p>]]></content>
      
      
      <categories>
          
          <category> 生活杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——关键路径详解</title>
      <link href="/2020/06/09/shu-ju-jie-gou-guan-jian-lu-jing-xiang-jie/"/>
      <url>/2020/06/09/shu-ju-jie-gou-guan-jian-lu-jing-xiang-jie/</url>
      
        <content type="html"><![CDATA[<!-- password: --><h1 id="AOV网："><a href="#AOV网：" class="headerlink" title="AOV网："></a>AOV网：</h1><p>顶点活动（Activity On Vertex，AOV）网是指用顶点表示活动，而用边集表示活动间优先关系的有向图。例如图10-57的先导课程示意图就是AOV网，其中图的顶点表示各项课程，也就是“活动”；有向边表示课程的先导关系，也就是“活动间的优先关系”。显然，图中不应当存在有向环，否则会让优先关系出现逻辑错误。<br><img src="https://img-blog.csdnimg.cn/20191122154223280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""><br>​</p><h1 id="AOE网："><a href="#AOE网：" class="headerlink" title="AOE网："></a>AOE网：</h1><p>边活动（Activity On Edge，AOE）网是指用带权的边集表示活动，而用顶点表示事件的有向图，其中边权表示完成活动需要的时间。例如图10-59中，边a1<del>a6表示需要学习的课程，也就是“活动”，边权表示课程学习需要消耗的时间；顶点V1</del>V6。表示到此刻为止前面的课程已经学完，后面的课程可以开始学习，也就是“事件”（如V5表示a4计算方法和a3实变函数已经学完，a6泛函分析可以开始学习。从另一个角度来看，a6只有当a4和a5都完成时才能开始进行，因此当a4计算方法学习完毕后必须等待a5实变函数学习完成后才能进入到a6泛函分析的学习），显然“事件”仅代表一个中介状态。<br><img src="https://img-blog.csdnimg.cn/2019112215324778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""><br>​</p><ul><li><p>源点：在AOE网中，没有入边的顶点称为源点；如顶点V1 </p></li><li><p>终点：在AOE网中，没有出边的顶点称为终点；如顶点V6 </p></li></ul><h1 id="AOE网的性质："><a href="#AOE网的性质：" class="headerlink" title="AOE网的性质："></a>AOE网的性质：</h1><ul><li><p>只有在进入某顶点的活动都已经结束，该顶点所代表的事件才发生；</p></li><li><p>只有在某顶点所代表的事件发生后，从该顶点出发的各活动才开始；</p></li></ul><p>AOE网中的<strong>最长路径被称为关键路径</strong>（强调：关键路径就是AOE网的最长路径），而把关键路径上的活动称为关键活动，显然关键活动会影响整个工程的进度。</p><h1 id="关键概念："><a href="#关键概念：" class="headerlink" title="关键概念："></a>关键概念：</h1><p>​<img src="https://img-blog.csdnimg.cn/201911221535246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""></p><ol><li>事件的最早发生时间ve[k]（earliest time of vertex）：即顶点vk的最早发生时间。</li></ol><p>从源点向终点方向计算</p><pre><code>ve[0] = 0ve[1] = ve[0] + a0 = 0 + 4 = 4ve[2] = max( ve[0] + a1, ve[1] + a2 ) = max(0 + 3, 4 + 2 = 6ve[3] = max(ve[1] + a4, ve[2] + a3) = max(4 + 6, 3 + 4) = 10</code></pre><ol start="2"><li>事件的最晚发生时间vl[k]（latest time of vertex）：即顶点vk的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期。</li></ol><p>从终点向源点方向计算</p><pre><code>vl[3] = ve[3] = 10vl[2] = vl[3] - a3 = 10 - 4 = 6vl[1] = min(vl[3] - a4, vl[2] - a2) = min(10-6, 6-2) = 4//之所以求最小，保证其他的点的最晚发生时间vl[0] = min(vl[2] - a1, vl[1] - a0) = min(4-4, 4-2) = 0 </code></pre><ol start="3"><li>活动的最早开工时间e[k]（earliest time of edge）：即弧ax的最早发生时间。</li></ol><p>5条边，5个活动</p><pre><code>e[0] = ve[0] = 0e[1] = ve[0] = 0e[2] = ve[1] = 4e[3] = ve[2] = 6e[4] = ve[1] = 4</code></pre><ol start="4"><li>活动的最晚开工时间l[k]（latest time of edge）：即弧ak的最晚发生时间，也就是不推迟工期的最晚开工时间。<pre><code>e[0] = v[1] - a0 = 4 - 4 = 0</code></pre></li></ol><p>e[1] = vl[2] - a1 = 6 - 3 = 3</p><p>e[2] = vl[2] - a2 = 6 - 2 = 4</p><p>e[3] = vl[3] - a3 = 10 - 4 = 6</p><p>e[4] = vl[3] - a4 = 10 - 6 = 4 </p><pre><code>活动的最早开始时间和最晚开始时间相等，则说明该活动时属于关键路径上的活动，即关键活动# 算法设计：关键路径算法是一种典型的动态规划法，设图G=(V, E)是个AOE网，结点编号为1,2,...,n，其中结点1与n 分别为始点和终点，ak=&lt;i, j&gt;∈E是G的一个活动。算法关键是确定活动的最早发生时间ve[k]和最晚发生时间vl[k]，进而获取顶点的最早开始时间e[k]和最晚开始时间l[k]。根据前面给出的定义，可推出活动的最早及最晚发生时间的计算方法：</code></pre><p>e(k) = ve(i) </p><p>l(k) = vl(j) - len(i,j)</p><pre><code>​![](https://img-blog.csdnimg.cn/20191122153716227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70)结点的最早发生时间的计算，需按拓扑次序递推：</code></pre><p>ve(1) = 0</p><p>ve(j) = MAX{ etv(i)+len(i, j) }</p><pre><code>对所有&lt;i,j&gt; ∈E的i  结点的最晚发生时间的计算，需按逆拓扑次序递推：</code></pre><p>vl(n) = ve(n)</p><p>vl(i) = MIN{vl(j) - len(i, j)} 对所有&lt;i,j&gt;∈E的j</p><pre><code>这种计算方法， 依赖于拓扑排序， 即计算ve( j) 前，应已求得j 的各前趋结点的ve值，而计算vl(i)前，应已求得i的各后继结点的vl值。ve的计算可在拓扑排序过程中进行，即在每输出一个结点i后，在删除i的每个出边&lt;i,j&gt;（即入度减1）的同时，执行</code></pre><p>if ( ve[i]+len(i,j)) &gt; ve[j] )</p><p>ve[j] = ve[i] + len(i,j)</p><pre><code>这时会发现，如果想要获得ve[j]的正确值，ve[il]\~ve[ik]必须已经得到。有什么办法能够在访问某个结点时保证它的前驱结点都已经访问完毕呢？没错，使用拓扑排序就可以办到。当按照拓扑序列计算ve数组时，总是能保证计算ve[i]的时候ve[il]~ve[ik]都已经得到。但是这时又碰到另一个问题，通过前驱结点去寻找所有后继结点很容易，但是通过后继结点V；去寻找它的前驱结点V1~Vx似乎没有那么直观。一个比较好的办法是，在拓扑排序访问到某个结点时，不是让它去找前驱结点来更新ve[i]，而是使用ve[i]去更新其所有后继结点的ve值。通过这个方法，可以让拓扑排序访问到V；的时候，V1\~Vk一定都已经用来更新过ve[i]，此时的ve[i]便是正确值，就可以用它去更新V；的所有后继结点的ve值。</code></pre><p>//拓扑序列</p><p>stack<int>topOrder;</p><p>//拓扑排序，顺便求ve数组</p><p>bool topologicalSort()</p><p>{</p><pre><code>queue&lt;int&gt;q;for(int i=0;i&lt;n;i++)    if(inDegree[i]==0)        q.push(i);while(!q.empty()){    int u=q.front();    q.pop();    topOrder.push(u);//将u加入拓扑序列    for(int i=0;i&lt;G[u].size();i++)    {        int v=G[u][i].v;//u的i号后继结点编号为v        inDegree[v]--;        if(inpegree[v]==0)            q.push(v);        //用ve[u]来更新u的所有后继结点        if(ve[u]+G[u][i].w&gt; ve[v])            ve[v]=ve[u]+G[u][i].w;    }}if(toporder.size()== n)    return true;else    return false;</code></pre><p>}</p><pre><code>同理，如图10-64所示，从事件V出发通过相应的活动ar1~ark可以到达k个事件V1~Vk，活动的边权为length[r1]~length[rk]。假设已经算好了事件V1~Vk的最迟发生时间xl[j1]～vl[jk]，那么事件Vi的最迟发生时间就是vl[j1]-length[r1]~vl[jk]-length[rk]中的最小值。此处取最小值是因为必须保证Vj1~Vjk的最迟发生时间能被满足；可以通过下面这个公式辅助理解。![](https://img-blog.csdnimg.cn/20191122153835953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70)和ve数组类似，如果需要算出vl[i]的正确值，vl[j1]\~vl[jk]必须已经得到。这个要求与ve数组的刚好相反，也就是需要在访问某个结点时保证它的后继结点都已经访问完毕，而这可以通过使用逆拓扑序列来实现。幸运的是，不必再做一次逆拓扑排序来得到逆拓扑序列，而是可以通过颠倒拓扑序列来得到一组合法的逆拓扑序列。此时会发现，在上面实现拓扑排序的过程中使用了栈来存储拓扑序列，那么只需要按顺序出栈就是逆拓扑序列。而当访问逆拓扑序列中的每个事件Vi时，就可以遍历Vi的所有后继结点Vj1\~Vjk，使用vI[j1]\~vl[jk]来求出vl[i]。这部分的代码如下所示：</code></pre><p>fill(vl，v1+n，ve[n-1]);//v1数组初始化，初始值为终点的ve值</p><p>//直接使用toporder出栈即为逆拓扑序列，求解v1数组</p><p>while(！topOrder.empty())</p><p>{</p><pre><code>int u=topOrder.top();//栈顶元素为utopOrder.pop();for(int i=0;i&lt;G[u].size();i++){    int v=G[u][i].v;//u的后继结点v    //用u的所有后继结点v的v1值来更新v1[u]    if(vl[v]-G[u][i].w &lt; vl[u])        vl[u]=vl[v]-G[u][i].w;}</code></pre><p>}</p><pre><code>复制代码1 fill(vl，v1+n，ve[n-1]);//v1数组初始化，初始值为终点的ve值2 3 //直接使用toporder出栈即为逆拓扑序列，求解v1数组4 5 while(！topOrder.empty())6 7 {8 9     int u=topOr通过上面的步骤已经把求解关键活动的过程倒着推导了一遍，下面给出上面过程的步骤总结，即“先求点，再夹边”：* ①按拓扑序和逆拓扑序分别计算各顶点（事件）的最早发生时间和最迟发生时间：![](https://img-blog.csdnimg.cn/20191122153922180.png)​* ②用上面的结果计算各边（活动）的最早开始时间和最迟开始时间：![](https://img-blog.csdnimg.cn/2019112215395853.png)​* ③e[i-→] = l[i-→i]的活动即为关键活动。主体部分代码如下（适用汇点确定且唯一的情况，以n-1号顶点为汇点为例）：【主体代码】求取关键路径：</code></pre><p>//遍历邻接表的所有边，计算活动的最早开始时间e和最迟开始时间1</p><p>for(int u=0；u&lt;n；u++)</p><p>{</p><pre><code>for(int i=0；i&lt;G[u].size()；i++){    int v=G[u][i].v，w=G[u][i].w；    //活动的最早开始时间e和最迟开始时间1    int e=ve[u]，l=vl[v]-w；    //如果e==1，说明活动u-&gt;v是关键活动    if(e==1)    printf(&quot;%d-&gt;%d\n&quot;，u,v)；//输出关键活动}}return ve[n-1]；//返回关键路径长度</code></pre><p>}</p><pre><code>在上述代码中，没有将活动的最早开始时间e和最迟开始时间l存储下来，这是因为一般来说e和l只是用来判断当前活动是否是关键活动，没有必要单独存下来。如果确实想要将它存储下来，只需要在结构体Node中添加域e和1即可。如果事先不知道汇点编号，有没有办法比较快地获得关键路径长度呢？当然是有办法的，那就是取ve数组的最大值。原因在于，ve数组的含义是事件的最早开始时间，因此所有事件中ve最大的一定是最后一个（或多个）事件，也就是汇点。于是只需要在fill函数之前添加一小段语句，然后改变下vl函数初始值即可，代码如下：</code></pre><p>int maxLength = 0;</p><p>for(int i=0; i&lt;n; ++i)</p><p>{</p><pre><code>if(ve[i] &gt; maxLength)    maxLength = ve[i];</code></pre><p>}</p><p>fill(vl, vl + n, maxLength);</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关键路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——最小生成树</title>
      <link href="/2020/06/09/shu-ju-jie-gou-zui-xiao-sheng-cheng-shu/"/>
      <url>/2020/06/09/shu-ju-jie-gou-zui-xiao-sheng-cheng-shu/</url>
      
        <content type="html"><![CDATA[<!-- password: --><h1 id="最小生成树："><a href="#最小生成树：" class="headerlink" title="最小生成树："></a>最小生成树：</h1><p>最小生成树（Minimum Spanning Tree，MST）是在一个给定的无向图G（V，E）中求一棵树T，使得这棵树拥有图G中的所有顶点，且所有边都是来自图G中的边，并且满足整棵树的边权之和最小。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191122155454937-1989257498.png" alt=""></p><p>图10-43给出了一个图G及其最小生成树T，其中较粗的线即为最小生成树的边。可以看到，边AB、BC、BD包含了图G的所有顶点，且由它们生成的树的边权之和为6，是所有生成树中权值最小的（例如边AD、BD、CD生成的树，其边权之和为7，大于之前给出的树的边权之和）。</p><p>最小生成树有3个性质需要掌握：</p><blockquote><ul><li>①最小生成树是树，因此其边数等于顶点数减1，且树内一定不会有环。</li></ul></blockquote><blockquote><ul><li>②对给定的图G（V，E），其最小生成树可以不唯一，但其边权之和一定是唯一的。</li></ul></blockquote><blockquote><ul><li>③由于最小生成树是在无向图上生成的，因此其根结点可以是这棵树上的任意一个结点。于是，如果题目中涉及最小生成树本身的输出，为了让最小生成树唯一，一般都会直接给出根结点，读者只需以给出的结点作为根结点来求解最小生成树即可。</li></ul></blockquote><p>求解最小生成树一般有两种算法，即prim算法与kruskal算法。</p><p>这两个算法都是采用了贪心法的思想，只是贪心的策略不太一样。</p><h1 id="Prim算法与Kurskal算法比较"><a href="#Prim算法与Kurskal算法比较" class="headerlink" title="Prim算法与Kurskal算法比较"></a>Prim算法与Kurskal算法比较</h1><blockquote><ul><li>（1）从算法的思想可以看出，如果图G中的边数较小时，可以采用Kruskal算法，因为Kruskal 算法每次查找最短的边；边数较多可以用Prim算法，因为它是每次加一个结点。可见，Kruskal算法适用于稀疏图，而Prim算法适用于稠密图。</li></ul></blockquote><blockquote><ul><li>（2）从时间上讲，Prim算法的时间复杂度为O（n2），Kruskal 算法的时间复杂度为O（eloge）。</li></ul></blockquote><blockquote><ul><li>（3）从空间上讲，显然在Prim算法中，只需要很小的空间就可以完成算法，因为每一次都是从V-U集合出发进行扫描的，只扫描与当前结点集到U集合的最小边。但在Kruskal算法中，需要对所有的边进行排序，对于大型图而言，Kruskal算法需要占用比Prim算法大得多的空间。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——prim算法【最小生成树1】</title>
      <link href="/2020/06/09/shu-ju-jie-gou-prim-suan-fa-zui-xiao-sheng-cheng-shu-1/"/>
      <url>/2020/06/09/shu-ju-jie-gou-prim-suan-fa-zui-xiao-sheng-cheng-shu-1/</url>
      
        <content type="html"><![CDATA[<!-- password: --><p>适用范围：要求无向图</p><p>prim算法（读者可以将其读作“普里姆算法”）用来解决最小生成树问题，</p><p>其基本思想是：</p><ul><li><p>对图G（VE）设置集合S，存放已被访问的顶点，</p></li><li><p>然后每次从集合V-S中选择与集合S的最短距离最小的一个顶点（记为u），访问并加入集合S。</p></li><li><p>令顶点u为中介点，优化所有从u能到达的顶点v与集合S之间的最短距离。</p></li></ul><p>这样的操作执行n次（n为顶点个数），直到集合S已包含所有顶点。可以发现，prim算法的思想与最短路径中Dijkstra算法的思想几乎完全相同，只是在涉及最短距离时使用了集合S代替Dijkstra算法中的起点s。</p><pre><code>int prim(){//默认0号为初始点，函数返回最小生成树的边权之和    fi11(d，d+MAXV，Inf)；//fi11函数将整个d数组赋为INE (慎用memset )    d[0]=0；//只有0号顶点到集合s的距离为0，其余全为Inf    int ans=0；//存放最小生成树的边权之和    for (int i=0；i&lt;n；i++ )   {//循环n次        int u=-1，MIN=Inf；//u使d[u]最小，MIN存放该最小的d[u]        for (int j=0；j&lt;n；j++ )        {//找到未访问的顶点中d[]最小的            if (vis[j]==false &amp;&amp; d[j]&lt;MIN )            {                u=j；                MIN=d[j]；            }        }        //找不到小于Inf的d[u]，则剩下的顶点和集合s不连通        if (u==-1 )            return-1；        vis[u]=true；//标记u为已访问        ans += d[u]；//将与集合s距离最小的边加入最小生成树        for (int v=0；v&lt;n；v++ )        {//v未访问&amp;&amp;u能到达v&amp;&amp;以u为中介点可以使v离集合S更近            if (vis[v]==false &amp;&amp; G[u][v] ！= Inf &amp;&amp; G[u][v]&lt; d[v] )                d[v]=G[u][v]；//将G[u][v]赋值给d[v]        }    }    return ans；//返回最小生成树的边权之和}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prim, 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——kruskal算法【最小生成树2】</title>
      <link href="/2020/06/09/shu-ju-jie-gou-kruskal-suan-fa-zui-xiao-sheng-cheng-shu-2/"/>
      <url>/2020/06/09/shu-ju-jie-gou-kruskal-suan-fa-zui-xiao-sheng-cheng-shu-2/</url>
      
        <content type="html"><![CDATA[<!-- password: --><p>设G=（V，E）是无向连通带权图，V={1，2，…，n}；</p><p>设最小生成树T=（V，TE），该树的初始状态为只有n个顶点而无边的非连通图T=（V，{}），Kruskal算法将这n个顶点看成是n个孤立的连通分支。</p><p>它首先将所有的边按权值从小到大排序，然后只要T中选中的边数不到n-1，就做如下的贪心选择：</p><p>在边集E中选取权值最小的边（i，j），如果将边（i，j）加入集合TE中不产生回路（圈），则将边（i，j）加入边集TE中，即用边（i，j）将这两个连通分支合并连接成一个连通分支；</p><p>否则继续选择下一条最短边。把边（i，j）从集合E中删去。</p><p>继续上面的贪心选择，直到T中所有顶点都在同一个连通分支上为止。</p><p>此时，选取到的n-1条边恰好构成G的一棵最小生成树T。</p><p>那么，怎样判断加入某条边后图T会不会出现回路呢？</p><p>该算法对于手工计算十分方便，因为用肉眼可以很容易看到挑选哪些边能够避免构成回路（避圈法），但使用计算机程序来实现时，还需要一种机制来进行判断。</p><p>Kruskal算法用了一个非常聪明的方法，就是运用集合避圈：</p><p>如果所选择加入的边的起点和终点都在T的集合中，那么就可以断定一定会形成回路（圈）。其实就是我们前面提到的“避圈法”：边的两个结点不能属于同一集合。</p><blockquote><ul><li>步骤1：初始化。将图G的边集E中的所有边按权值从小到大排序，边集TE={}，把每个顶点都初始化为一个孤立的分支，即一个顶点对应一个集合。</li></ul></blockquote><blockquote><ul><li>步骤2：在E中寻找权值最小的边（i，j）。</li></ul></blockquote><blockquote><ul><li>步骤3：如果顶点i和位于两个不同连通分支，则将边（i，j）加入边集TE，并执行合并操作，将两个连通分支进行合并【即两个顶点设置成同一个集合号，一般向小集合号合并】。</li></ul></blockquote><blockquote><ul><li>步骤4：将边（i，j）从集合E中删去，即E=E-{（i，j）}。</li></ul></blockquote><blockquote><ul><li>步骤5：如果选取边数小于n-1，转步骤2；否则，算法结束，生成最小生成树了。</li></ul></blockquote><p>** 适用范围：要求无向图 ** </p><p>kruskal算法（读者可以将其读作“克鲁斯卡尔算法”同样是解决最小生成树问题的一个算法。和prim算法不同，kruskal算法采用了边贪心的策略，其思想极其简洁，理解难度比prim算法要低很多。</p><p>kruskal算法的基本思想为：在初始状态时隐去图中的所有边，这样图中每个顶点都自成一个连通块。</p><p>之后执行下面的步骤：</p><ul><li><p>①对所有边按边权从小到大进行排序。</p></li><li><p>②按边权从小到大测试所有边，如果当前测试边所连接的两个顶点不在同一个连通块中，则把这条测试边加入当前最小生成树中；否则，将边舍弃。</p></li><li><p>③执行步骤②，直到最小生成树中的边数等于总顶点数减1或是测试完所有边时结束。</p></li></ul><p>而当结束时如果最小生成树的边数小于总顶点数减1，说明该图不连通。</p><p>接下来以图10-51a为例，给出对该图执行kruskal算法的步骤。</p><p>当前图中边权最小的边为V。V，权值为1。由于Vo和V4在不同的连通块中，因此把边VoVa加入最小生成树中，此时最小生成树中有1条边，权值之和为1，如图10-51所示。</p><p>因此，kruskal算法的思想简单说来就是：</p><p>每次选择图中最小边权的边，如果边两端的顶点在不同的连通块中，就把这条边加入最小生成树中。</p><pre><code>//边集定义部分struct edge{    int u，v；//边的两个端点编号    int cost；//边权}E[MAXE]；//最多有MAXE条边bool cmp(edge a，edge b){    return a.cost &lt;b.cost；}//并查集部分int father[MAXV]；//并查集数组int findFather(int x){//并查集查询函数    int a=x；    while(x！=father[x])        x=father[x]；    //路径压缩    while(a！=father[a])    {        int z = a；        a = father[a]；        father[z]=x；    }    return x；}//kruskal部分，返回最小生成树的边权之和，参数n为顶点个数，m为图的边数int kruskal(int n，int m){//ans为所求边权之和，Num Edge为当前生成树的边数    int ans=0，Num Edge=0；    for(int i=0；i&lt;n；i++)//顶点范围是[0，n-1]        father[i]=i；//并查集初始化    sort(E，E+m，cmp)；//所有边按边权从小到大排序    for(int i=0；i&lt;m；i++)    {//枚举所有边        int faU=findFather(E[i].u)；//查询测试边两个端点所在集合的根结点        int faV=findFather(E[i].v)；        if(faU！=faV)        {//如果不在一个集合中            father[faU]=faV；//合并集合(即把测试边加入最小生成树中)            ans += E[i].cost；//边权之和增加测试边的边权            Num_Edge++；//当前生成树的边数加1            if(Num_Edge == n-1)                break；//边数等于顶点数减1时结束算法        }    }    if(Num_Edge！=n-1)        return -1；//无法连通时返回-1    else        return ans；//返回最小生成树的边权之和}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kruskal, 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——KMP算法:字符匹配</title>
      <link href="/2020/06/09/suan-fa-kmp-suan-fa-zi-fu-pi-pei/"/>
      <url>/2020/06/09/suan-fa-kmp-suan-fa-zi-fu-pi-pei/</url>
      
        <content type="html"><![CDATA[<!-- password: --><h1 id="暴力匹配："><a href="#暴力匹配：" class="headerlink" title="暴力匹配："></a>暴力匹配：</h1><p>假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？ </p><p>如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有： </p><p>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</p><p>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</p><p>理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下：</p><pre><code>int ViolentMatch(char* s, char* p){    int sLen = strlen(s);    int pLen = strlen(p);    int i = 0;    int j = 0;    while (i &lt; sLen &amp;&amp; j &lt; pLen)    {        if (s[i] == p[j])        {            //①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++            i++;            j++;        }        else        {            //②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0            i = i - j + 1;  //i回到前一次遍历对比的位置            j = 0;        }    }    //匹配成功，返回模式串p在文本串s中的位置，否则返回-1    if (j == pLen)        return i - j;    else        return -1;}</code></pre><p>举个例子，如果给定文本串S“BBC ABCDAB ABCDABCDABDE”，和模式串P“ABCDABD”，现在要拿模式串P去跟文本串S匹配，整个过程如下所示：</p><blockquote><ol><li>S[0]为B，P[0]为A，不匹配，执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[1]跟P[0]匹配，相当于文本串要往右移动一位（i=1，j=0） </li></ol></blockquote><blockquote><ol start="2"><li>S[1]跟P[0]还是不匹配，继续执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[2]跟P[0]匹配（i=2，j=0），从而文本串串不断的向右移动一位（不断的执行“令i = i - (j - 1)，j = 0”，i从2变到4，j一直为0） </li></ol></blockquote><blockquote><ol start="3"><li>直到S[4]跟P[0]匹配成功（i=4，j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，可得S[i]为S[5]，P[j]为P[1]，即接下来S[5]跟P[1]匹配（i=5，j=1）  </li></ol></blockquote><blockquote><ol start="4"><li>S[5]跟P[1]匹配成功，继续执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，得到S[6]跟P[2]匹配（i=6，j=2），如此进行下去 </li></ol></blockquote><blockquote><ol start="5"><li>直到S[10]为空格字符，P[6]为字符D（i=10，j=6），因为不匹配，重新执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，相当于S[5]跟P[0]匹配（i=5，j=0）  </li></ol></blockquote><blockquote><ol start="6"><li>至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了S[9]、P[5]，但因为S[10]跟P[6]不匹配，所以文本串回溯到S[5]，模式串回溯到P[0]，从而让S[5]跟P[0]匹配。 </li></ol></blockquote><p>而S[5]肯定跟P[0]失配。为什么呢？因为在之前第4步匹配中，我们已经得知S[5] = P[1] = B，而P[0] = A，即P[1] != P[0]，故S[5]必定不等于P[0]，所以回溯过去必然会导致失配。那有没有一种算法，让i 不往回退，只需要移动j 即可呢？ </p><p>答案是肯定的。这种算法就是本文的主旨KMP算法，它利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。</p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212317023-1101605783.png" alt=""></p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><ul><li>定义</li></ul><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。 </p><p>下面先直接给出KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明☺）： </p><p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p><p>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]）， 都令i++，j++，继续匹配下一个字符；</p><p>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述）， 即移动的实际位数为：j - next[j]，且此值大于等于1。 </p><p>很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。</p><p>例如如果next [j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。</p><p>此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。</p><p>** 再强调一遍，next[i]就是子串s[0…i]的最长相等前后缀的前缀最后一位的下标。 **</p><p>** next数组的含义就是当j+1位失配时，j应该回退到的位置。 **</p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212432574-1006267186.png" alt=""></p><ul><li>由此可以总结出KMP算法的一般思路：</li></ul><blockquote><ul><li>①初始化j=-1，表示pattern当前已被匹配的最后位。</li></ul></blockquote><blockquote><ul><li>②让i遍历文本串text，对每个i，执行③④来试图匹配text[i]和pattern[i+1]。</li></ul></blockquote><blockquote><ul><li>③不断令j=next[i]，直到j回退为-1，或是text[i]=pattern[i+1]成立。</li></ul></blockquote><blockquote><ul><li>④如果text[i]=pattern[i+1]，则令j++。如果j达到m-1，说明pattern是text的子串，返回true。</li></ul></blockquote><ul><li>KMP算法的代码如下：<pre><code>//next的数组的原理就是复制一次原数组，然后和原数组向后差一位进行匹配void getNext(vector&lt;int&gt;&amp;next){  int j = 0;  int k = -1;//k是关键，k=0就是求前缀数组，k=-1就是将前缀数组向后移一位  int len = pattern.length();  next[0] = -1;  while (j &lt; len-1)  {      if (k == -1 || pattern[j] == pattern[k])//将复制数组与原数组匹配      {          ++k;          ++j;          next[j] = k;      }      else          k = next[k];//又从复制数组的头开始匹配，-1的位置  }}int KMP(){  int i = 0, j = 0;  int slen = text.length(), plen = pattern.length();  vector&lt;int&gt;next(pattern.length());  getNext(next);  while (i &lt; slen &amp;&amp; j &lt; plen)  {      if (j == -1 || text[i] == pattern[j])//j==-1表示第一个字母都没有匹配上      {          ++i;          ++j;      }      else          j = next[j];//一旦没匹配，就跳next中的步数  }  if (j == plen)//匹配成功      return i - j;  else      return -1;}</code></pre></li></ul><h2 id="详细步骤讲解："><a href="#详细步骤讲解：" class="headerlink" title="详细步骤讲解："></a>详细步骤讲解：</h2><ol><li>①寻找前缀后缀最长公共元素长度</li></ol><p>对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：<br>!()[<a href="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212544600-803968379.png]" target="_blank" rel="noopener">https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212544600-803968379.png]</a></p><p>比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k + 1 = 2）。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212544600-803968379.png" alt=""></p><ol start="2"><li>②求next数组<br>next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212538710-1902602709.png" alt=""></li></ol><p>比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）。</p><ol start="3"><li>③根据next数组进行匹配<br>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀pj-k pj-k+1, …, pj-1 跟文本串si-k si-k+1, …, si-1匹配成功，但pj 跟si匹配失败时，因为next[j] = k，相当于在不包含pj的模式串中有最大长度为k 的相同前缀后缀，即p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令j = next[j]，从而让模式串右移j - next[j] 位，使得模式串的前缀p0 p1, …, pk-1对应着文本串 si-k si-k+1, …, si-1，而后让pk 跟si 继续匹配。如下图所示：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212607443-50359875.png" alt=""></li></ol><p>综上，KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 j - next[j] 位。</p><p>接下来，分别具体解释上述3个步骤。 </p><h2 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h2><ol><li>寻找最长前缀后缀 </li></ol><p>如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212632985-1520852601.png" alt=""></p><p>也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212643038-407128118.png" alt=""></p><ol start="2"><li>基于《最大长度表》匹配</li></ol><p>最长前缀和最长后缀的匹配长度：<br>即PreIndex = 0,  LastIndex = N;</p><p>前缀指针向后移动，后缀指针向前移动，前缀指针不能到最后的一个字符，后缀指针不能到第一个字符，然后查找他们最长【从左至右的顺序】的相同长度。</p><p>上图所示：str = “abcabcd”<br>一般最长前缀和最长后缀值为： index[0] = -1, index[1] == 0, 因为0位无前字符，1位也无不满足后缀指针不等于第一个字符。</p><p>其他的需要计算：<br>d的标记为3：即以0位置的a为前缀指针，d前面的字母c为后缀指针，找到的相同最长字符为”abc”  == 3</p><p>因为模式串中首尾可能会有重复的字符，故可得出下述结论：<br>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p><p>下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。</p><p>如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：</p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212752075-1606534188.png" alt=""></p><ul><li><p>1).因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212837465-34254220.png" alt=""></p></li><li><p>2). 继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212846470-1422279734.png" alt=""></p></li><li><p>3). 模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 =2 位。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212854776-147524862.png" alt=""></p></li><li><p>4). A与空格失配，向右移动1 位。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212903151-244050017.png" alt=""></p></li><li><p>5). 继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 = 4 位。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212910289-948231451.png" alt=""></p></li><li><p>6). 经历第5步后，发现匹配成功，过程结束。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212916627-1500097556.png" alt=""></p></li></ul><p>通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。</p><ol start="3"><li>根据《最大长度表》求next 数组</li></ol><p>由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212933754-1746143212.png" alt=""></p><p>而且，根据这个表可以得出下述结论：</p><blockquote><p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p></blockquote><p>上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。 </p><p>给定字符串“ABCDABD”，可求得它的next 数组如下：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127212955003-427379178.png" alt=""></p><p>把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。</p><p>换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213004240-1194731365.png" alt=""></p><p>根据最大长度表求出了next 数组后，从而有失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</p><p>而后，你会发现，无论是基于《最大长度表》的匹配，还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为：</p><p>根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值</p><p>而根据《next 数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的next 值</p><p>其中，从0开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），</p><p>而失配字符对应的next 值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。</p><p>所以，你可以把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是可以的，区别不过是怎么用的问题。</p><ol start="4"><li>通过代码递推计算next 数组</li></ol><p>接下来，咱们来写代码求下next 数组。</p><p>基于之前的理解，可知计算next 数组的方法可以采用递推：</p><ul><li>1). 如果对于值k，已有p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k。</li></ul><p>此意味着什么呢？究其本质，next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀。有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j] 位。</p><ul><li>2). 下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？</li></ul><p>对于P的前j+1个序列字符：</p><p>若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1；</p><p>若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀”p0 p1, …, pk-1 pk”跟后缀“pj-k pj-k+1, …, pj-1 pj”相等，那么是否可能存在另一个值t+1 &lt; k+1，使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, …, k, …, j]）进行P串前缀跟P串后缀的匹配。</p><p>如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213116707-1536479101.png" alt=""></p><p>但如果pk != pj 呢？说明“p0 pk-1 pk”  ≠ “pj-k pj-1 pj”。换言之，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213159715-62831620.png" alt=""></p><p>结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk’-1 pk’ = pj-k’ pj-1 pj，则最大相同的前缀后缀长度为k’ + 1，从而next [j + 1] = k’ + 1 = next [k’ ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。</p><p>那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？这又归根到next数组的含义。我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。此过程相当于模式串的自我匹配，所以不断的递归k = next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。如下图所示：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213215099-1610682320.png" alt=""></p><p>找到p[k]对应的next[k]，根据对称性，只需再判断p[next[k]]与p[j]是否相等即可，于是令k = next[k],这里恰好就使用了递归的思路。其实我觉得不要一开始就陷入递归的方法中，换一种思路，直接从考虑对称性入手，可直接得出k = next[k]，而这正好是递归罢了。</p><p>所以，因最终在前缀ABC中没有找到D，故E的next 值为0：</p><p>模式串的后缀：ABDE</p><p>模式串的前缀：ABC</p><p>前缀右移两位：     ABC</p><p>那能否举一个能在前缀中找到字符D的例子呢？OK，咱们便来看一个能在前缀中找到字符D的例子，如下图所示：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213243820-1979109095.png" alt=""></p><p>给定模式串DABCDABDE，我们很顺利的求得字符D之前的“DABCDAB”的各个子串的最长相同前缀后缀的长度分别为0 0 0 0 1 2 3，但当遍历到字符D，要求包括D在内的“DABCDABD”最长相同前缀后缀时，我们发现pj处的字符D跟pk处的字符C不一样，换言之，前缀DABC的最后一个字符C 跟后缀DABD的最后一个字符D不相同，所以不存在长度为4的相同前缀后缀。</p><p>怎么办呢？既然没有长度为4的相同前缀后缀，咱们可以寻找长度短点的相同前缀后缀，最终，因在p0处发现也有个字符D，p0 = pj，所以p[j]对应的长度值为1，相当于E对应的next 值为1（即字符E之前的字符串“DABCDABD”中有长度为1的相同前缀和后缀）。</p><p>综上，可以通过递推求得next 数组，代码如下所示：</p><pre><code>//next的数组的原理就是复制一次原数组，然后和原数组向后差一位进行匹配void getNext(vector&lt;int&gt;&amp;next){    int j = 0;    int k = -1;//k是关键，k=0就是求前缀数组，k=-1就是将前缀数组向后移一位    int len = pattern.length();    next[0] = -1;    while (j &lt; len-1)    {        if (k == -1 || pattern[j] == pattern[k])//将复制数组与原数组匹配        {            ++k;            ++j;            next[j] = k;        }        else            k = next[k];//又从复制数组的头开始匹配，-1的位置    }}</code></pre><h1 id="扩展：BM算法"><a href="#扩展：BM算法" class="headerlink" title="扩展：BM算法"></a>扩展：BM算法</h1><p>KMP的匹配是从模式串的开头开始匹配的，而1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了一种新的字符串匹配算法：Boyer-Moore算法，简称BM算法。该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高。</p><p>BM算法定义了两个规则：</p><ul><li>坏字符规则：</li></ul><blockquote><p>当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为-1。</p></blockquote><ul><li>好后缀规则：</li></ul><blockquote><p>当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p></blockquote><p>下面举例说明BM算法。例如，给定文本串“HERE IS A SIMPLE EXAMPLE”，和模式串“EXAMPLE”，现要查找模式串是否在文本串中，如果存在，返回模式串在文本串中的位置。</p><ol><li><p>首先，”文本串”与”模式串”头部对齐，从尾部开始比较。”S”与”E”不匹配。这时，”S”就被称为”坏字符”（bad character），即不匹配的字符，它对应着模式串的第6位。且”S”不包含在模式串”EXAMPLE”之中（相当于最右出现位置是-1），这意味着可以把模式串后移6-(-1)=7位，从而直接移到”S”的后一位。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213411338-916688068.png" alt=""></p></li><li><p>依然从尾部开始比较，发现”P”与”E”不匹配，所以”P”是”坏字符”。但是，”P”包含在模式串 “EXAMPLE”之中。因为“P”这个“坏字符”对应着模式串的第6位（从0开始编号），且在模式串中的最右出现位置为4，所以，将模式串后移6-4=2位，两个”P”对齐。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213424562-493568045.png" alt=""></p></li><li><p>依次比较，得到 “MPLE”匹配，称为”好后缀”（good suffix），即所有尾部匹配的字符串。注意，”MPLE”、”PLE”、”LE”、”E”都是好后缀。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213436187-1376005758.png" alt=""></p></li><li><p>发现“I”与“A”不匹配：“I”是坏字符。如果是根据坏字符规则，此时模式串应该后移2-(-1)=3位。问题是，有没有更优的移法？<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213446841-192806358.png" alt=""></p></li></ol><p>5、更优的移法是利用好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串中上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p><p>所有的“好后缀”（MPLE、PLE、LE、E）之中，只有“E”在“EXAMPLE”的头部出现，所以后移6-0=6位。</p><p>可以看出，“坏字符规则”只能移3位，“好后缀规则”可以移6位。每次后移这两个规则之中的较大值。这两个规则的移动位数，只与模式串有关，与原文本串无关。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213457225-193867223.png" alt=""></p><ol start="6"><li>继续从尾部开始比较，“P”与“E”不匹配，因此“P”是“坏字符”，根据“坏字符规则”，后移 6 - 4 = 2位。因为是最后一位就失配，尚未获得好后缀。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213533438-360358258.png" alt=""></li></ol><p>由上可知，BM算法不仅效率高，而且构思巧妙，容易理解。</p><pre><code>//bad character数组，128   ASCll码为数组大小vector&lt;int&gt; preBmBc(string ps) {    vector&lt;int&gt; BC(128, ps.size());    for (size_t i = 0; i &lt; ps.size(); i++)        BC[ps[i]] = ps.size() - i - 1;//记住每个字母的最右端的位置，重复字母中，后端会把前端覆盖掉的    //记住，这位置的反着的，即ps.size()-i;return BC;}void BM(string text, string pattern){    vector&lt;int&gt; matched;//匹配的好字符    vector&lt;int&gt; BC = preBmBc(pattern);//创建bad character数组int tlen = text.size();    int plen = pattern.size();int tindex = 0;//text索引    while (tindex + plen &lt;= tlen) {        int badmove = 0;//坏字符位置        int goodmove = 0;//好字符位置        for (size_t j = plen; j &gt;= 0; j--)        {            if (text[tindex + j - 1] != pattern[j - 1]) {//匹配失败                badmove = BC[text[tindex + j - 1]]; //bad character移动步数,不存在则是将整个模式字符后移                break;            }           if (j == 0) {//匹配到                return;            }        }        tindex += badmove;    }}</code></pre><h1 id="扩展：Sunday算法"><a href="#扩展：Sunday算法" class="headerlink" title="扩展：Sunday算法"></a>扩展：Sunday算法</h1><p>上文中，我们已经介绍了KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比BM算法更快的查找算法即Sunday算法。</p><p>Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似：</p><p>只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。</p><p>如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；</p><p>否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。</p><p>下面举个例子说明下Sunday算法。假定现在要在文本串”substring searching algorithm”中查找模式串”search”。</p><ol><li><p>刚开始时，把模式串与文本串左边对齐：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213627855-1819294926.png" alt=""></p></li><li><p>结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127213636947-1994610482.png" alt=""></p></li><li><p>结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191127215416721-1703260399.png" alt=""></p></li><li><p>匹配成功。<br>回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。完。</p></li></ol><pre><code>int Sunday(string text, string pattern){    int i = 0;    int j = 0;    while (i &lt; text.length() &amp;&amp; j &lt; pattern.length())    {        if (text[i] == pattern[j])        {            i++;            j++;        }        else        {            int k = pattern.length() - 1;while (k &gt;= 0)            {                if (text[i + pattern.length() + 1] == pattern[k])//查询后面的哪个字母在pattern是否存在                {                    break;                }                else                {                    k--;                }            }            i += (pattern.length() - (k + 1) + 1);            j = 0;        }    }    if (j == pattern.length())//匹配成功        return i;    else        return -1;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构, 字符匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库——windows连接远程Oracle数据库</title>
      <link href="/2020/06/07/shu-ju-ku-windows-lian-jie-yuan-cheng-oracle-shu-ju-ku/"/>
      <url>/2020/06/07/shu-ju-ku-windows-lian-jie-yuan-cheng-oracle-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<!-- password: --><h1 id="一、在windows安装Oracle客户端："><a href="#一、在windows安装Oracle客户端：" class="headerlink" title="一、在windows安装Oracle客户端："></a>一、在windows安装Oracle客户端：</h1><p>下载地址：<a href="https://www.oracle.com/database/technologies/112010-win64soft.html" target="_blank" rel="noopener">https://www.oracle.com/database/technologies/112010-win64soft.html</a><br>** 选择第二项管理员安装**</p><ul><li><p>问题1：版本错误</p></li><li><p><em>解决：*</em><br>修改安装文件：\client\stage\cvu<br>编辑该目录下的两个xml文件：oracle.client_InstantClient.xml和cvu_prereq.xml<br>按规律添加以下内容：</p><pre><code>&lt;OPERATING_SYSTEM RELEASE=&quot;6.2&quot;&gt;   &lt;VERSION VALUE=&quot;3&quot;/&gt;   &lt;ARCHITECTURE VALUE=&quot;64-bit&quot;/&gt;   &lt;NAME VALUE=&quot;Windows 10&quot;/&gt;   &lt;ENV_VAR_LIST&gt;       &lt;ENV_VAR NAME=&quot;PATH&quot; MAX_LENGTH=&quot;5119&quot; /&gt;   &lt;/ENV_VAR_LIST&gt;&lt;/OPERATING_SYSTEM&gt;</code></pre></li><li><p>问题二：安装目录重复<br>重新选择安装目录！</p></li></ul><h1 id="二、安装PL-SQL-Developer"><a href="#二、安装PL-SQL-Developer" class="headerlink" title="二、安装PL/SQL Developer"></a>二、安装PL/SQL Developer</h1><p>下载地址：<a href="https://www.allroundautomations.com/try-it-free/" target="_blank" rel="noopener">https://www.allroundautomations.com/try-it-free/</a></p><h1 id="三、登录连接Orcle"><a href="#三、登录连接Orcle" class="headerlink" title="三、登录连接Orcle"></a>三、登录连接Orcle</h1><ul><li>问题一：没有监听<br>修改服务端Oracle的文件：<br>一定得备份！！！</li><li><em>解决办法简述：*</em></li></ul><ul><li>1.修改/home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/listener.ora中的localhost改为192.168.8.13【服务器IP】；   </li><li>2.修改/home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/tnsnames.ora中的localhost改为192.168.8.13【服务器IP】；    </li><li>3.修改后，重启oracle，监听，并注册，主win10上的plsql就可以远程连接虚拟机上的数据库了。</li></ul><p><strong>具体操作步骤如下：</strong></p><ul><li>1、修改数据库服务器中listener.ora文件内容<br>原始内容:<pre><code># listener.ora Network Configuration File:/home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/listener.ora# Generated by Oracle configuration tools.LISTENER =(DESCRIPTION_LIST =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))    (ADDRESS = (PROTOCOL = TCP)(HOST = localhost.localdomain)(PORT = 1521))  ))ADR_BASE_LISTENER = /home/tools/oracle11g</code></pre>修改后的内容如下：<pre><code># listener.ora Network Configuration File: /home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER =  (SID_LIST =      (SID_DESC =          (GLOBAL_DBNAME = orcl)          (ORACLE_HOME = /home/tools/oracle11g/product/11.2.0/dbhome_1/)          (SID_NAME = orcl)      )  )</code></pre></li></ul><p>LISTENER =<br>  (DESCRIPTION_LIST =<br>    (DESCRIPTION =<br>      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))<br>      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.8.13)(PORT = 1521))<br>    )<br>  )</p><p>ADR_BASE_LISTENER = /home/tools/oracle11g</p><pre><code>- 2、修改数据库服务器中tnsnames.ora文件内容原始内容:</code></pre><h1 id="tnsnames-ora-Network-Configuration-File-home-tools-oracle11g-product-11-2-0-dbhome-1-network-admin-tnsnames-ora"><a href="#tnsnames-ora-Network-Configuration-File-home-tools-oracle11g-product-11-2-0-dbhome-1-network-admin-tnsnames-ora" class="headerlink" title="tnsnames.ora Network Configuration File: /home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/tnsnames.ora"></a>tnsnames.ora Network Configuration File: /home/tools/oracle11g/product/11.2.0/dbhome_1/network/admin/tnsnames.ora</h1><h1 id="Generated-by-Oracle-configuration-tools"><a href="#Generated-by-Oracle-configuration-tools" class="headerlink" title="Generated by Oracle configuration tools."></a>Generated by Oracle configuration tools.</h1><p>ORCL =<br>  (DESCRIPTION =<br>    (ADDRESS = (PROTOCOL = TCP)(HOST = localhost.localdomain)(PORT = 1521))<br>    (CONNECT_DATA =<br>      (SERVER = DEDICATED)<br>      (SERVICE_NAME = orcl)<br>    )<br>  )</p><pre><code>修改后的内容：</code></pre><h1 id="tnsnames-ora-Network-Configuration-File-u01-app-oracle-product-11-2-0-dbhome-1-network-admin-tnsnames-ora"><a href="#tnsnames-ora-Network-Configuration-File-u01-app-oracle-product-11-2-0-dbhome-1-network-admin-tnsnames-ora" class="headerlink" title="tnsnames.ora Network Configuration File: /u01/app/oracle/product/11.2.0/dbhome_1/network/admin/tnsnames.ora"></a>tnsnames.ora Network Configuration File: /u01/app/oracle/product/11.2.0/dbhome_1/network/admin/tnsnames.ora</h1><h1 id="Generated-by-Oracle-configuration-tools-1"><a href="#Generated-by-Oracle-configuration-tools-1" class="headerlink" title="Generated by Oracle configuration tools."></a>Generated by Oracle configuration tools.</h1><p>LISTENER_ORCL =<br>  (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.183.129)(PORT = 1521))</p><p>orcl =<br>  (DESCRIPTION =<br>    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.183.129)(PORT = 1521))<br>    (CONNECT_DATA =<br>      (SERVER = DEDICATED)<br>      (SERVICE_NAME = orcl)<br>    )<br>  )</p><pre><code>* 添加服务器管理员权限运行Net Mananger按步骤添加：![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNzEzNTcxMjM4Ny0zMzA1MDI2OTMucG5n?x-oss-process=image/format,png)然后按内容添加：![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNzEzNTczNTY1Ni0xMzkyNjU0MjQ3LnBuZw?x-oss-process=image/format,png)* 修改windows客户端文件使用管理员权限修改：D:\Oracle11g_Client\product\11.2.0\client_1\network\admin修改内容为：【核对一下，一般不用修改】</code></pre><h1 id="tnsnames-ora-Network-Configuration-File-D-Oracle11g-Client-product-11-2-0-client-1-NETWORK-ADMIN-tnsnames-ora"><a href="#tnsnames-ora-Network-Configuration-File-D-Oracle11g-Client-product-11-2-0-client-1-NETWORK-ADMIN-tnsnames-ora" class="headerlink" title="tnsnames.ora Network Configuration File: D:\Oracle11g_Client\product\11.2.0\client_1\NETWORK\ADMIN\tnsnames.ora"></a>tnsnames.ora Network Configuration File: D:\Oracle11g_Client\product\11.2.0\client_1\NETWORK\ADMIN\tnsnames.ora</h1><h1 id="Generated-by-Oracle-configuration-tools-2"><a href="#Generated-by-Oracle-configuration-tools-2" class="headerlink" title="Generated by Oracle configuration tools."></a>Generated by Oracle configuration tools.</h1><p>ORCL =<br>  (DESCRIPTION =<br>    (ADDRESS_LIST =<br>      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.183.129)(PORT = 1521))<br>    )<br>    (CONNECT_DATA =<br>      (SERVICE_NAME = orcl)<br>    )<br>  )</p><pre><code># 三、在数据库服务器中启动监听并更新注册 #* 最后重启一下监听与数据库并更新注册</code></pre><p>$ lsnrctl stop        #先关闭监听服务<br>$ lsnrctl start        #开启监听服务<br>$ sqlplus / as sysdba      #登入<br>SQL&gt; shutdown immediate    #立即关闭数据库服务<br>SQL&gt; startup        #开启数据库服务<br>命令：SQL&gt; alter system register;  #注册<br>System altered.<br>SQL&gt;<br>SQL&gt; quit #登出<br>输出：<br>Disconnected from Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production<br>With the Partitioning, OLAP, Data Mining and Real Application Testing options</p><pre><code># 四、登录plsql![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNzE0MDAzNjc4MC0xMTM1MzkyMTYucG5n?x-oss-process=image/format,png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle, 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库——Ubuntu 16.04安装Oracle 11gR教程</title>
      <link href="/2020/06/06/shu-ju-ku-ubuntu-16.04-an-zhuang-oracle-11gr-jiao-cheng/"/>
      <url>/2020/06/06/shu-ju-ku-ubuntu-16.04-an-zhuang-oracle-11gr-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<!-- password: --><p>转自博客：<a href="https://www.cnblogs.com/sunshine5683/archive/2018/11/13/9953672.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunshine5683/archive/2018/11/13/9953672.html</a></p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Ubuntu版本：ubuntu-16.04.3-desktop-amd64<br>Oracle版本：linux.x64_11gR2_database</p><h1 id="二、安装JDK"><a href="#二、安装JDK" class="headerlink" title="二、安装JDK"></a>二、安装JDK</h1><pre><code>sudo apt-get updatesudo apt-get install openjdk-8-jdk</code></pre><p>编辑profile</p><pre><code>cd /etcsudo vim profile</code></pre><p>在文件中加入以下内容</p><pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><p>更新</p><pre><code>Source /etc/profile</code></pre><p>测试下jdk是否安装成功</p><pre><code>java -version</code></pre><h1 id="三、安装依赖"><a href="#三、安装依赖" class="headerlink" title="三、安装依赖"></a>三、安装依赖</h1><pre><code>sudo apt-get -y install lesstif2sudo apt-get -y install lesstif2-dev（这两个包是32位包，需要换源安装：sucd /etc/apt/sources.list.decho &quot;deb http://old-releases.ubuntu.com/ubuntu/ raring main restricted universe multiverse&quot; &gt; ia32-libs-raring.listapt updateapt-get -y install lesstif2 lesstif2-dev）</code></pre><p>把源换回来  </p><pre><code>rm -rf ia32-libs-raring.listapt update</code></pre><p>退出root账户</p><pre><code>exit</code></pre><p>继续安装剩下的依赖</p><pre><code>sudo asudo apt-get install automake sudo apt-get install autotools-devsudo apt-get install binutilssudo apt-get install bzip2sudo apt-get install elfutilssudo apt-get install expatsudo apt-get install gawksudo apt-get install gccsudo apt-get install gcc-multilibsudo apt-get install g++-multilibsudo apt-get install ia32-libssudo apt-get install kshsudo apt-get install lesssudo apt-get install lesstif2sudo apt-get install lesstif2-devsudo apt-get install lib32z1sudo apt-get install libaio1sudo apt-get install libaio-devsudo apt-get install libc6-devsudo apt-get install libc6-dev-i386sudo apt-get install libc6-i386 sudo apt-get install libelf-devsudo apt-get install libltdl-devsudo apt-get install libmotif4sudo apt-get install libodbcinstq4-1 libodbcinstq4-1:i386sudo apt-get install libpth-devsudo apt-get install libpthread-stubs0sudo apt-get install libpthread-stubs0-devsudo apt-get install libstdc++5sudo apt-get install lsb-cxxsudo apt-get install makesudo apt-get install openssh-serversudo apt-get install pdkshsudo apt-get install rlwrapsudo apt-get install rpmsudo apt-get install sysstatsudo apt-get install unixodbcsudo apt-get install unixodbc-devsudo apt-get install unzipsudo apt-get install x11-utilssudo apt-get install zlibc</code></pre><p>或者：</p><pre><code>sudo apt-get -y install automake autotools-dev binutils bzip2 elfutils expat gawk gcc gcc-multilib g++-multilib lib32ncurses5 lib32z1 ksh less lib32z1 libaio1 libaio-dev libc6-dev libc6-dev-i386 libc6-i386 libelf-dev libltdl-dev libxm4 libodbcinstq4-1 libodbcinstq4-1:i386 libpth-dev libpthread-stubs0-dev libstdc++5 make openssh-server rlwrap rpm sysstat unixodbc unixodbc-dev unzip x11-utils zlibc</code></pre><p>安装这个需要点时间（这是一个吐血的历程，原本是一个一个安装，还要查看安装结果。本人将这一堆依赖处理成了一个语句，这些包亲测没问题）</p><h1 id="四、配置环境"><a href="#四、配置环境" class="headerlink" title="四、配置环境"></a>四、配置环境</h1><p>用下面的命令查询系统的参数</p><pre><code>/sbin/sysctl -a | grep sem/sbin/sysctl -a | grep file-max/sbin/sysctl -a | grep aio-max/sbin/sysctl -a | grep ip_local_port_range/sbin/sysctl -a | grep rmem_default/sbin/sysctl -a | grep rmem_max/sbin/sysctl -a | grep wmem_default/sbin/sysctl -a | grep wmem_max/sbin/sysctl -a | grep shmall/sbin/sysctl -a | grep shmmax/sbin/sysctl -a | grep shmmni</code></pre><p>将查询出来的参数填入下面对应的地方<br>在/etc/sysctl.conf中追加的文件内容为：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDUwMzc0My0xOTcyNDQzOTkucG5n?x-oss-process=image/format,png" alt=""></p><p>更新内核参数</p><pre><code>cd /etcsudo sysctl –p</code></pre><p>添加用户的内核限制（我的用户名是zzw）</p><pre><code>cd security/sudo vim limits.conf</code></pre><p>将以下内容加到文件后面</p><pre><code>zzw soft nproc 2047zzw hard nproc 16384zzw soft nofile 1024zzw hard nofile 65536zzw soft stack 10240</code></pre><p>首先检查/etc/pam.d/login<br>增加一行（有了就不用增加了）：</p><pre><code>session required pam_limits.so </code></pre><p>同样检查/etc/pam.d/su，没有这行就自己加上：</p><pre><code>session required pam_limits.so</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDYxNDcyNi05ODI3MjYxMDAucG5n?x-oss-process=image/format,png" alt=""></p><p>创建文件夹</p><pre><code>mkdir /home/rogear/toolsmkdir /home/rogear/tools/oracle11g</code></pre><p>配置oracle的环境变量</p><pre><code>sudo vim /etc/profile</code></pre><p>将下面内容加到文件后面</p><pre><code>export ORACLE_BASE=/home/rogear/tools/oracle11gexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1export ORACLE_SID=orclexport ORACLE_UNQNAME=orclexport NLS_LANG=.AL32UTF8export PATH=${PATH}:${ORACLE_HOME}/bin/:$ORACLE_HOME/lib64</code></pre><p>更新参数</p><pre><code>source /etc/profile</code></pre><p>欺骗oracle的安装设置</p><pre><code>sudo mkdir /usr/lib64sudo ln -s /etc /etc/rc.dsudo ln -s /lib/x86_64-linux-gnu/libgcc_s.so.1 /lib64/sudo ln -s /usr/bin/awk /bin/awksudo ln -s /usr/bin/basename /bin/basenamesudo ln -s /usr/bin/rpm /bin/rpmsudo ln -s /usr/lib/x86_64-linux-gnu/libc_nonshared.a /usr/lib64/sudo ln -s /usr/lib/x86_64-linux-gnu/libpthread_nonshared.a /usr/lib64/sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /lib64/sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /usr/lib64/</code></pre><p>切换root账户</p><pre><code>suecho &#39;Red Hat Linux release 5&#39; &gt; /etc/RedHat-releaseexit</code></pre><h1 id="五、正式安装"><a href="#五、正式安装" class="headerlink" title="五、正式安装"></a>五、正式安装</h1><p>前期条件准备好了，接下来正式开始安装oracle。将oracle的安装包下载到oracle11g文件夹下，包是官网下的，这里不提供下载地址<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDY0MTczNy02NTk2NTY1ODAucG5n?x-oss-process=image/format,png" alt=""></p><p>解压压缩包</p><pre><code>unzip linux.x64_11gR2_database_1of2.zipunzip linux.x64_11gR2_database_2of2.zipcd database/./runInstaller</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcwNDA4NC04NjQwMzg5NDMucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcwODE5NC03OTIxOTgwNzMucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcxMjcxMS0xNTI1MTM4NjQ4LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcxNjcxMi0xMTE3MjU5NzY2LnBuZw?x-oss-process=image/format,png" alt=""></p><p><strong>注意前三项的安装路径选择！！！</strong><br>如果提示容量不足，则删除原来错误的地址文件，重新启动！<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcyMTE2My0xNTMzMTM5MzEwLnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDcyNTEyOC0xMzcyNTAzNTc4LnBuZw?x-oss-process=image/format,png" alt=""></p><p>上面这个说密码不符合规范，不用管，直接过<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDczMDI0NS0xOTgzODYwNzY2LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDczNDQyNS0zMzA1ODYxNjAucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDczODgwMi02MDk4ODU0NDkucG5n?x-oss-process=image/format,png" alt=""></p><p>这个地方有个东西需要跑一下，新开一个teminal找到那个东西跑一下<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDc0NjM1OC0xNzg1MTY2NDQ4LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDc1MDAzMC0xNTkyNDQ4ODczLnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDc1MzIzOS02OTY4MDE3OTAucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDc1NzcxNi0xMzMzMjA2ODE5LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDgwMjI4Ni02OTMzMjc0MjUucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDgwNjEzNy03Mzg3Mjg3NTkucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDgxMDUyMC0yMDkwNzU5MzkyLnBuZw?x-oss-process=image/format,png" alt=""></p><p>新开一个teminal（ctrl+alt+t）</p><pre><code>cd /home/rogear/tools/oracle11g/product/11.2.0/dbhome_1/sysman/lib/gedit ins_emagent.mk</code></pre><p>用查询功能（ctrl+f）找到下面这个东西（$(SYSMANBIN)emd），然后改一下<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDgzMTk4My0xODIxMDE0OTk4LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDgzNTQ2Mi0xMzQ1NDk1MTY5LnBuZw?x-oss-process=image/format,png" alt=""></p><p>保存后退出，然后点击Retry通过。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDg0Mjc1MS0xMzY3NjU2MjExLnBuZw?x-oss-process=image/format,png" alt=""></p><p>新开teminal，输入下面4个命令</p><pre><code>sudo sed -i &#39;s/^\(TNSLSNR_LINKLINE.*\$(TNSLSNR_OFILES)\) \(\$(LINKTTLIBS)\)/\1 -Wl,--no-as-needed \2/g&#39; /home/zzw/tools/oracle11g/product/11.2.0/dbhome_1/network/lib/env_network.mksudo sed -i &#39;s/^\(ORACLE_LINKLINE.*\$(ORACLE_LINKER)\) \(\$(PL_FLAGS)\)/\1 -Wl,--no-as-needed \2/g&#39; /home/zzw/tools/oracle11g/product/11.2.0/dbhome_1/rdbms/lib/env_rdbms.mksudo sed -i &#39;s/^\(\$LD \$LD_RUNTIME\) \(\$LD_OPT\)/\1 -Wl,--no-as-needed \2/g&#39; /home/zzw/tools/oracle11g/product/11.2.0/dbhome_1/bin/genorasdkshsudo sed -i &#39;s/^\(\s*\)\(\$(OCRLIBS_DEFAULT)\)/\1 -Wl,--no-as-needed \2/g&#39; /home/zzw/tools/oracle11g/product/11.2.0/dbhome_1/srvm/lib/ins_srvm.mk</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDg1NTg5OS0xMTcwOTMzMTE3LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkwMDYzMi00NTMwMDQ3OC5wbmc?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkwNDEzNC0xMDg2NzE2OTQ3LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkwODQ1Mi02NjgyMDM2MjEucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkxMTI4NC05MDQwODY2ODcucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkxNDAzMS0xMDY3MDA3NDA5LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDkxNjgyOC02NzczMjI5ODMucG5n?x-oss-process=image/format,png" alt=""></p><p>到这里oracle就安装完了，接下来就可以测试了</p><h1 id="六、测试"><a href="#六、测试" class="headerlink" title="六、测试"></a>六、测试</h1><p>启动oracle<br>检查参数</p><pre><code>echo $ORACLE_BASEecho $ORACLE_HOMEecho $PATH</code></pre><p>如果不对的话需要设置下<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMDk1Nzg2My0zNjQ0Njk0MTUucG5n?x-oss-process=image/format,png" alt=""></p><p>启动监听</p><pre><code>lsnrctl start</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTAxNzcxMS0xODMxNzUxMTIwLnBuZw?x-oss-process=image/format,png" alt=""></p><p>启动服务</p><pre><code>sqlplus /nologconn / as sysdbastartup</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTAzNjA5OS0xOTAxODI5MDEzLnBuZw?x-oss-process=image/format,png" alt=""></p><p>做个小测试<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTA0NDIwMS0zOTM0Mjc2NzcucG5n?x-oss-process=image/format,png" alt=""></p><p>到这里说明oracle可以用了</p><p>关闭oracle<br>shutdown<br>(不带参数的shutdown很长时间都没反应，我用的shutdown immediate，还可以用其它参数，如下： shutdown normal：不允许新的连接、等��会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。  shutdown transactional：不允许新的连接、不等待会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。  shutdown immediate：不允许新的连接、不等待会话结束、不等待事务结束、做一个检查点并关闭数据文件。没有结束的事务是自动rollback的。启动时不需要实例恢复。  shutdown abort：不允许新的连接、不等待会话结束、不等待事务结束、不做检查点且没有关闭数据文件。启动时自动进行实例恢复。<br>quit退出<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEwNTIxOS04NzY0NzkzMzkucG5n?x-oss-process=image/format,png" alt=""></p><p>关闭监听<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEwODU5My0xNTg3NjI0NDkzLnBuZw?x-oss-process=image/format,png" alt=""></p><h1 id="七、外部连接数据库"><a href="#七、外部连接数据库" class="headerlink" title="七、外部连接数据库"></a>七、外部连接数据库</h1><p>先按照上面的方法启动oracle<br>查看虚拟机的ip地址<br>ifconfig<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEyNDM4OC0xNTk4ODczNzUyLnBuZw?x-oss-process=image/format,png" alt=""></p><p>在宿主机用cmd测试能否ping通<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEyOTg5Ny0yMDMxODMyMzYucG5n?x-oss-process=image/format,png" alt=""></p><p>用plsql连接<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEzNDIwMi0xMjI3NzQ4NjY1LnBuZw?x-oss-process=image/format,png" alt=""></p><p>报错：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTEzODQwMC01Mjk1NDc1MjYucG5n?x-oss-process=image/format,png" alt=""></p><p>到ORACLE_HOME 下去修改listener.ora和tnsnames.ora<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTE0NDE1Ny0xNjk1MTkyOTYwLnBuZw?x-oss-process=image/format,png" alt=""></p><p>（先做好备份）<br>将localhost改为虚拟机的ip地址</p><pre><code>vim listener.ora</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTE1MjMwOS0xNzg0NzMzMDQ5LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTE1ODI3My02MjM5MTk5Ny5wbmc?x-oss-process=image/format,png" alt=""></p><p>vim tnsnames.ora<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIxMTQxMS02OTUzODA0ODYucG5n?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIxNjY2Mi0xNjc4OTQ4OTQ0LnBuZw?x-oss-process=image/format,png" alt=""></p><p>重启oracle服务和监听<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIyMTI3OC05MjAxNTU2NTEucG5n?x-oss-process=image/format,png" alt=""></p><p>启动监听<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIyNDk0OS04MTEzMzI1MjgucG5n?x-oss-process=image/format,png" alt=""></p><p>启动服务<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIyODczNi0xNTgzMTYxNTY1LnBuZw?x-oss-process=image/format,png" alt=""></p><p>给scott解锁<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIzMjg3MS0xMzY4OTY0ODk4LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTIzNjczNy0xOTIyNDUyNTcucG5n?x-oss-process=image/format,png" alt=""></p><p>进入该scott秘密啊的界面<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTI0NTAzOC01NDA1NDI2NTQucG5n?x-oss-process=image/format,png" alt=""></p><p>建议还是用tiger作为密码，不然以后自己忘了就有点傻了<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTI1MDc3MS0xNzAxNTkwMTk0LnBuZw?x-oss-process=image/format,png" alt=""></p><p>system账户我也是解锁和重新设置密码以后才登陆成功的<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTI1NzM1My0xMzMyMjQxNDA1LnBuZw?x-oss-process=image/format,png" alt=""><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTQ2MzA2My8yMDIwMDYvMTQ2MzA2My0yMDIwMDYwNjIyMTMwMzM1OC0xNTg4OTUxNzkzLnBuZw?x-oss-process=image/format,png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle, 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《图解HTTP》（四）</title>
      <link href="/2020/04/15/du-shu-bi-ji-tu-jie-http-si/"/>
      <url>/2020/04/15/du-shu-bi-ji-tu-jie-http-si/</url>
      
        <content type="html"><![CDATA[<h2 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h2><h3 id="为何认证："><a href="#为何认证：" class="headerlink" title="为何认证："></a>为何认证：</h3><pre><code>计算机本身无法判断坐在显示器前的使用者的身份、进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务器，就得让对方的客户端自报家门。可是，就算正在访问服务器的对方声称自己是ueno，身份是否属实这点却也无从谈起。为确认ueno本人是否真的具有访问系统的权限，就需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”。   </code></pre><ul><li><p>核对的信息通常是指以下这些。 </p><ul><li>密码：只有本人才会知道的字符串信息。   </li><li>动态令牌：仅限本人持有的设备内显示的一次性密码。   </li><li>数字证书：仅限本人（终端）持有的信息。</li><li>生物认证：指纹和虹膜等本人的生理信息。       </li><li>IC卡等：仅限本人持有的信息。  </li></ul></li><li><p>HTTP使用的认证方式<br>  HTTP/1.1使用的认证方式如下所示。  </p><ul><li>BASIC 认证（基本认证）  </li><li>DIGEST认证（摘要认证）  </li><li>SSL客户端认证  </li><li>FormBase认证（基于表单认证）<br>此外，还有Windows统一认证（Keberos认证、NTLM认证）。  </li></ul></li></ul><h3 id="BASIC认证："><a href="#BASIC认证：" class="headerlink" title="BASIC认证："></a>BASIC认证：</h3><pre><code>BASIC认证（基本认证）是从HTTP/1.0就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是Web服务器与通信客户端之间进行的认证方式。</code></pre><p>认证步骤：</p><ol><li><p>步骤1：<br> 当请求的资源需要BASIC认证时，服务器会随状态码401 Authorization Required，返回带     WWW-Authenticate首部字段的响应。该字段内包含认证的方式（BASIC）及Request-URI 安全域字符串（realm）。</p></li><li><p>步骤2：<br> 接收到状态码401的客户端为了通过BASIC认证，需要将用户ID及密码发送给服务器。发送的字符串内容是由用户ID和密码构成，两者中间以冒号(:)连接后，再经过Base64编码处理。把这串字符串写入首部字段Authorization后，发送请求。<br> 当用户代理为浏览器时，用户仅需输入用户ID和密码即可，之后，浏览器会自动完成到Base64编码的转换工作。</p></li><li><p>步骤3：<br> 接收到包含首部字段Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含Request-URI资源的响应。</p><p> BASIC认证虽然采用Base64编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户ID和密码，在HTTP等非加密通信的线路上进行BASIC认证的过程中，如果被人窃听，被盗的可能性极高。<br> 另外，除此之外想再进行一次BASIC认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一BASIC认证使用上不够便捷灵活，且达不到多数Web网站期望的安全性等级，因此它并不常用。     </p></li></ol><h3 id="DIGEST认证"><a href="#DIGEST认证" class="headerlink" title="DIGEST认证"></a>DIGEST认证</h3><pre><code>为弥补BASIC认证存在的弱点，从HTTP/1.1起就有了DIGEST认证。DIGEST认证同样使用质询/响应的方式（challenge/response），但不会像BASIC认证那样直接发送明文密码。      所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。        </code></pre><p>认证步骤：  </p><ol><li><p>步骤1：<br> 请求需认证的资源时，服务器会随着状态码401 Authorization Required，返回带WWW-Authenticate首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）。首部字段wWW-Authenticate内必须包含realm和nonce这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。<br> nonce是一种每次随返回的401响应生成的任意随机字符串。该字符串通常推荐由Base64编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现。      </p></li><li><p>步骤2：<br> 接收到401状态码的客户端，返回的响应中包含DIGEST认证必须的首部字段Authorization信息。首部字段Authorization内必须包含username、 realm、 nonce、 uri和response的字段信息。其中，realm和nonce就是之前从服务器接收到的响应中的字段。username是realm限定范围内可进行认证的用户名。uri （digest-uri） 即Request-URI的值，但考虑到经代理转发后Request-URI的值可能被修改，因此事先会复制一份副本保存在uri内。response也可叫做Request-Digest，存放经过MD5运算后的密码字符串，形成响应码。响应中其他的实体请参见第6章的请求首部字段Authorization。</p></li><li><p>步骤3：<br> 接收到包含首部字段Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则返回包含Request-URI资源的响应。并且这时会在首部字段Authentication-Info写入一些认证成功的相关信息。DIGEST认证提供了高于BASIC认证的安全等级，但是和HTTPS的客户端认证相比仍旧很弱。DIGEST认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。DIGEST认证和BASIC认证一样，使用上不那么便捷灵活，且仍达不到多数Web网站对高度安全等级的追求标准。因此它的适用范围也有所受限。    </p></li></ol><h3 id="SSL客户端认证"><a href="#SSL客户端认证" class="headerlink" title="SSL客户端认证"></a>SSL客户端认证</h3><pre><code>从使用用户ID和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果用户ID和密码被盗，就很有可能被第三者冒充。利用SSL客户端认证则可以避免该情况的发生。       SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。为达到SSL客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。     </code></pre><ol><li>步骤1：<br> 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。 </li><li>步骤2：<br> 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate 报文方式发送给服务器。 </li><li>步骤3：<br> 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信。  </li></ol><h3 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h3><pre><code>基于表单的认证方法并不是在HTTP协议中定义的。客户端会向服务器上的Web应用程序发送登录信息（Credential），按登录信息的验证结果认证。根据Web应用程序的实际安装，提供的用户界面及认证方式也各不相同。     </code></pre><ul><li><p>认证多半为基于表单认证<br>  由于使用上的便利性及安全性问题，HTTP协议标准提供的BASIC认证和DIGEST认证几乎不怎么使用。另外，SL客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。</p></li><li><p>Session 管理及Cookie应用<br>  基于表单认证的标准规范尚未有定论，一般会使用Cookie来管理Session（会话）。基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。但鉴于HTTP是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用Cookie来管理Session,以弥补HTTP协议中不存在的状态管理功能。</p></li></ul><ol><li>步骤1：<br> 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。</li><li>步骤2：<br> 服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。<br> 向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID（如PHPSESSID=028a8c…）。你可以把Session ID想象成一种用以区分不同用户的等位号。然而，如果Session ID被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止Session ID被盗，或被猜出。为了做到这点，Session ID应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。<br> 另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上htponly属性。</li><li>步骤3：<br>客户端接收到从服务器端发来的SessionID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以SessionID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。   </li></ol><h2 id="第九章-基于HTTP的功能追加协议"><a href="#第九章-基于HTTP的功能追加协议" class="headerlink" title="第九章 基于HTTP的功能追加协议"></a>第九章 基于HTTP的功能追加协议</h2><h3 id="消除HTTP瓶颈的SPDY"><a href="#消除HTTP瓶颈的SPDY" class="headerlink" title="消除HTTP瓶颈的SPDY"></a>消除HTTP瓶颈的SPDY</h3><pre><code>Google在2010年发布了SPDY（取自SPeeDY，发音同speedy），其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）。</code></pre><ul><li><p>HTTP的瓶颈<br>  在Facebook和Twitter等SNS网站上，几乎能够实时观察到海量用户公开发布的内容，这也是一种乐趣。当几百、几千万的用户发布内容时，Web网站为了保存这些新增内容，在很短的时间内就会发生大量的内容更新。为了尽可能实时地显示这些更新的内容，服务器上一有内容更新，就需要直接把那些内容反馈到客户端的界面上。虽然看起来挺简单的，但HTTP却无法妥善地处理好这项任务。<br>  使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。若想在现有web实现所需的功能，以下这些HTTP标准就会成为瓶颈。      </p><ul><li>一条连接上只可发送一个请求。  </li><li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。     </li><li>请求/响应首部未经压缩就发送。首部信息越多延迟越大。   </li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。       </li><li>可任意选择数据压缩格式。非强制压缩发送。   </li></ul></li><li><p>SPDY的设计与功能<br>  SPDY没有完全改写HITP协议，而是在TCP/ IP的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。<br>  SPDY以会话层的形式加人，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。<br>  <img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415151718425-740453936.png" alt=""></p></li></ul><p>使用SPDY后，HTTP协议额外获得以下功能：  </p><ul><li><p>多路复用流<br>通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。</p></li><li><p>赋予请求优先级<br>SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</p></li><li><p>压缩HTTP首部<br>压缩HTTP请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。</p></li><li><p>推送功能<br>支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p></li><li><p>服务器提示功能<br>服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</p></li></ul><h3 id="使用浏览器进行全双工通信的WebSocket"><a href="#使用浏览器进行全双工通信的WebSocket" class="headerlink" title="使用浏览器进行全双工通信的WebSocket"></a>使用浏览器进行全双工通信的WebSocket</h3><p>利用Ajax和Comet技术进行通信可以提升web的浏览速度。但问题在于通信若使用HTTP协议，就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及API。   </p><ul><li><p>*WebSocket的设计与功能<br>WebSocket，即web浏览器与web服务器之间全双工通信标准。其中，WebSocket协议由IETF定为标准，WebSocketAPI由W3C定为标准。仍在开发中的技术主要是为了解决Ajax和Comet里XMLHttpRequest附带的缺陷所引起的问题。</p></li><li><p>WebSocket协议<br>一旦web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p></li></ul><p>下面我们列举一下WebSocket协议的主要特点。</p><ul><li><p>推送功能<br>支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p></li><li><p>减少通信量<br>只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。</p></li></ul><p>为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次“握手”（Handshaking）的步骤。</p><h3 id="期盼已久的HTTP-2-0"><a href="#期盼已久的HTTP-2-0" class="headerlink" title="期盼已久的HTTP/2.0"></a>期盼已久的HTTP/2.0</h3><p>目前主流的HTTP/1.1标准，自1999年发布的RFC2616之后再未进行过改订。SPDY和WebSocket等技术纷纷出现，很难断言HTTP/1.1仍是适用于当下的Web的协议。</p><p>负责互联网技术标准的IETF（Internet Engineering Task Force，互联网工程任务组）创立httpbis工作组，其目标是推进下一代HTTP——HTTP/2.0在2014年11月实现标准化。</p><ul><li><p>HTTP/2.0的特点<br>HTTP/2.0的目标是改善用户在使用Web时的速度体验。由于基本上都会先通过HTTP/1.1与TCP连接，现在我们以下面的这些协议为基础，探讨一下它们的实现方法。</p><ul><li>SPDY</li><li>HTTP Speed+Mobility</li><li>Network-Friendly HTTP Upgrade</li></ul></li></ul><p>http2.0技术讨论：<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415151940900-59375749.png" alt=""></p><h2 id="第十章-构建Web内容的技术"><a href="#第十章-构建Web内容的技术" class="headerlink" title="第十章 构建Web内容的技术"></a>第十章 构建Web内容的技术</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML（HyperText Markup Language，超文本标记语言）是为了发送Web上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在HTML文档内的这种特殊字符串叫做HTML标签（Tag）。  </p><h3 id="设计应用CSS"><a href="#设计应用CSS" class="headerlink" title="设计应用CSS"></a>设计应用CSS</h3><p>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现HTML内的各种元素，属于样式表标准之一。即使是相同的HTML文档，通过改变应用的CSS，用浏览器看到的页面外观也会随之改变。CSS的理念就是让文档的结构和设计分离，达到解耦的目的。</p><h3 id="动态HTML"><a href="#动态HTML" class="headerlink" title="动态HTML"></a>动态HTML</h3><p>所谓动态HTML（Dynamic HTML），是指使用客户端脚本语言将静态的HTML内容变成动态的技术的总称。鼠标单击点开的新闻、Google Maps等可滚动的地图就用到了动态HTML。</p><p>动态HTML技术是通过调用客户端脚本语言JavaScript，实现对HTML的Web页面的动态改造。利用DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的HTML元素。</p><h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><p>Web应用是指通过Web功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和e-learning等。互联网（Internet）或企业内网（Intranet）上遍布各式各样的Web应用。</p><p>原本应用HTTP协议的Web的机制就是对客户端发来的请求，返回事前准备好的内容。可随着Web越来越普及，仅靠这样的做法已不足以应对所有的需求，更需要引入由程序创建HTML内容的做法。类似这种由程序创建的内容称为动态内容，而事先准备好的内容称为静态内容。Web应用则作用于动态内容之上。</p><h3 id="数据发布的格式及语言"><a href="#数据发布的格式及语言" class="headerlink" title="数据发布的格式及语言"></a>数据发布的格式及语言</h3><p>XML（extensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用XML，使互联网数据共享变得更容易。<br>XML和HTML都是从标准通用标记语言SGML（Standard Generalized Markup Language）简化而成。与HTML相比，它对数据的记录方式做了特殊处理。</p><h2 id="第十一章-Web的攻击技术"><a href="#第十一章-Web的攻击技术" class="headerlink" title="第十一章 Web的攻击技术"></a>第十一章 Web的攻击技术</h2><h3 id="针对Web的攻击技术"><a href="#针对Web的攻击技术" class="headerlink" title="针对Web的攻击技术"></a>针对Web的攻击技术</h3><p>简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等资源才是攻击且标。目前，来自互联网的攻击大多是冲着Web站点来的，它们大多把Web应用作为攻击目标。</p><ul><li><p>*以服务器为目标的主动攻击<br>主动攻击（active attack）是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击。</p></li><li><p>以服务器为目标的被动攻击<br>被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标Web应用访问发起攻击。<br>被动攻击通常的攻击模式如下所示。</p></li></ul><ul><li>步骤1：攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的HTTP请求。  </li><li>步骤2：当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。   </li><li>步骤3：中招后的用户浏览器会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击代码。  </li><li>步骤4：执行完攻击代码，存在安全漏洞的Web应用会成为攻击者的跳板，可能导致用户所持的Cookie等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。   </li></ul><p>被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</p><h3 id="因输出值转义不完全引发的安全漏洞"><a href="#因输出值转义不完全引发的安全漏洞" class="headerlink" title="因输出值转义不完全引发的安全漏洞"></a>因输出值转义不完全引发的安全漏洞</h3><p>实施Web应用的安全对策可大致分为以下两部分。  </p><ul><li>客户端的验证  </li><li>Web应用端（服务器端）的验证   <ul><li>输入值验证   </li><li>输出值转义   </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《图解HTTP》（三）</title>
      <link href="/2020/04/15/du-shu-bi-ji-tu-jie-http-san/"/>
      <url>/2020/04/15/du-shu-bi-ji-tu-jie-http-san/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h2><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143112867-1087293884.png" alt=""></p><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143120863-947712630.png" alt=""></p><h3 id="HTTP首部字段类型"><a href="#HTTP首部字段类型" class="headerlink" title="HTTP首部字段类型"></a>HTTP首部字段类型</h3><ul><li>通用首部字段（General Header Fields）<br>  请求报文和响应报文两方都会使用的首部。   </li><li>请求首部字段（Request Header Fields）<br>  从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。   </li><li>响应首部字段（Response Header Fields）<br>  从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。   </li><li>实体首部字段（Entity Header Fields）<br>  针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。   </li></ul><h3 id="HTTP-1-1通用首部字段"><a href="#HTTP-1-1通用首部字段" class="headerlink" title="HTTP/1.1通用首部字段"></a>HTTP/1.1通用首部字段</h3><ul><li><p>Cache-Control<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143305662-1773928462.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143334645-713960820.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143343440-114223268.png" alt=""></p></li><li><p>public表示其他用户也可利用缓存   </p></li><li><p>private表示响应只以特定的用户作为对象 </p></li></ul><h3 id="no-cache指令："><a href="#no-cache指令：" class="headerlink" title="no-cache指令："></a>no-cache指令：</h3><pre><code>使用no-cache指令的目的是为了防止从缓存中返回过期的资源。客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</code></pre><h3 id="HTTP1-1警告码："><a href="#HTTP1-1警告码：" class="headerlink" title="HTTP1.1警告码："></a>HTTP1.1警告码：</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143438442-1432162543.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143443501-283778518.png" alt=""></p><h3 id="请求首部字段："><a href="#请求首部字段：" class="headerlink" title="请求首部字段："></a>请求首部字段：</h3><pre><code>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</code></pre><ul><li><p>文本文件<br>  text/htm1，text/plain，text/css…<br>  application/xhtml+xml,application/xml…   </p></li><li><p>图片文件<br>  image/jpeg,image/gif,image/png…   </p></li><li><p>视频文件<br>  video/mpeg，video/quicktime….    </p></li><li><p>应用程序使用的二进制文件<br>  application/octet-stream,application/zip…   </p></li><li><p>gzip<br>  由文件压缩程序gzip（GNUzip）生成的编码格式（RFC1952），采用Lempel-Ziv算法（LZ77）及32位循环冗余校验（Cyclic Redundancy Check，通称CRC）。  </p></li><li><p>compress<br>  由UNIX文件压缩程序compress生成的编码格式，采用Lempel-Ziv-Welch算法（LZW）。    </p></li><li><p>deflate<br>  组合使用zlib格式（RFC1950）及由deflate压缩算法（RFC1951）生成的编码格式。         </p></li><li><p>identity<br>  不执行压缩或不会变化的默认编码格式    </p><p>  采用权重q值来表示相对优先级、这点与首部字段Accept相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。 </p></li></ul><h3 id="响应首部字段："><a href="#响应首部字段：" class="headerlink" title="响应首部字段："></a>响应首部字段：</h3><pre><code>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。     </code></pre><h3 id="实体首部字段："><a href="#实体首部字段：" class="headerlink" title="实体首部字段："></a>实体首部字段：</h3><pre><code>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</code></pre><h3 id="为Cookies服务的首部字段："><a href="#为Cookies服务的首部字段：" class="headerlink" title="为Cookies服务的首部字段："></a>为Cookies服务的首部字段：</h3><pre><code>管理服务器与客户端之间状态的Cookie，虽然没有被编入标准化HTTP/1.1的RFC2616中，但在Web网站方面得到了广泛的应用。   Cookie的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该      Web网站时，可通过通信方式取回之前发放的Cookie。调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露。   至2013年5月，Cookie的规格标准文档有以下4种。     </code></pre><ul><li>由网景公司颁布的规格标准<br>  网景通信公司设计并开发了Cookie，并制定相关的规格标准。1994年前后，Cookie正式应用在网景浏览器中。目前最为普及的Cookie方式也是以此为基准的。  </li><li>RFC2109<br>  某企业尝试以独立技术对Cookie规格进行标准化统筹。原本的意图是想和网景公司制定的标准交互应用，可惜发生了微妙的差异。现在该标准已淡出了人们的视线。           </li><li>RFC2965<br>  为终结Internet Explorer 浏览器与Netscape Navigator的标准差异而导致的浏览器战争，RFC2965内定义了新的HTTP首部Set-Cookie2和Cookie2。可事实上，它们几乎没怎么投入使用。       </li><li>RFC6265<br>  将网景公司制定的标准作为业界事实标准（De facto standard），重新定义Cookie标准后的产物。</li></ul><h3 id="其他首部字段："><a href="#其他首部字段：" class="headerlink" title="其他首部字段："></a>其他首部字段：</h3><p>X-Frame-Options:<br>    DENY：属于HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题。主要为了防止点击劫持攻击。 </p><ul><li>DENY：拒绝     </li><li>SAMEORIGIN：仅同源域名下的页面匹配时许可。      </li></ul><p>X-XSS-Protection：<br>    属于响应首部，用于控制浏览器XSS防护机制的开关。  </p><ul><li>0：将XSS过滤设置成无效状态    </li><li>1：将XSS过滤设置成有效状态     </li></ul><p>DNT：<br>    请求首部，Do Not Track，拒绝个人信息被收集，是表示拒绝被精确广告追踪的一种方法。<br>    0：同意<br>    1：拒绝    </p><p>P3P（在线隐私偏好平台）：<br>    响应首部，可以让Web网站上的个人隐私编程一种仅供程序可理解的形式，以达到保护用户隐私的作用。    </p><ul><li>创建P3P隐私  </li><li>保存在/w3c/p3p.xml   </li><li>从P3P隐私中新建Compact policies后，输出到HTTP响应中。     </li></ul><h2 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h2><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><p>HTTP主要有这些不足，例举如下。    </p><ul><li><p>通信使用明文（不加密），内容可能会被窃听  </p></li><li><p>不验证通信方的身份，因此有可能遭遇伪装   </p></li><li><p>无法证明报文的完整性，所以有可能已遭篡改      </p></li><li><p>TCP/IP是可能被窃听的网络<br>  如果要问为什么通信时不加密是一个缺点，这是因为，按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。<br>  所谓互联网，是由能连通到全世界的网络组成的。无论世界哪个角落的服务器在和客户端通信时，在此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节中会遭到恶意窥视行为。 </p></li><li><p>通信的加密<br>  一种方式就是将通信加密。HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容。<br>  用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL。     </p></li><li><p>内容的加密<br>  还有一种将参与通信的内容本身加密的方式。由于HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。在这种情况下，客户端需要对HTTP报文进行加密处理后再发送请求。<br>  由于该方式不同于SSL或TES将整个通信线路加密处理，所以内容仍有被篡改的风险。稍后我们会加以说明。        </p></li><li><p>任何人都可以发起请求<br>  HTTP协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。     </p><ul><li>无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器。  </li><li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。   </li><li>无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。  </li><li>无法判定请求是来自何方、出自谁手。  </li><li>即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击）。     </li></ul></li></ul><h3 id="SSL中的数字证书："><a href="#SSL中的数字证书：" class="headerlink" title="SSL中的数字证书："></a>SSL中的数字证书：</h3><pre><code>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外、伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。另外，客户端持有证书即可完成个人身份的确认，也可用于对Web网站的认证环节。    由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。   换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。      </code></pre><h3 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS = HTTP + 加密 + 认证 + 完整性保护"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h3><ul><li><p>HTTPS是身披SSL(TLS)外壳的HTTP<br>  通常HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415144719450-1082315715.png" alt=""></p><p>  SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术。</p></li><li><p>使用两把密钥的公开密钥加密<br>  公开密钥加密方式很好地解决了共享密钥加密的困难。<br>  公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。<br>  另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。</p></li><li><p>HTTPS采用混合加密机制<br>  HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势，将多种方法组合起来用于通信。<br>  在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p></li><li><p>HTTPS中的数字证书：<br>  为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。<br>  数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。    </p><ul><li>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。    </li><li>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。   </li><li>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。<br>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。<br>数字证书认证机构的私有密钥  </li></ul><ul><li>服务器把自己的公开密钥登录至数字证书认证机构   </li><li>数字证书认证机构用自己的私有密钥向服务器的公开密码署数字签名并颁发公钥证书   </li><li>数字证书认证机构的公开密钥已事先植入到浏览器里了。客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性。   </li><li>使用服务器的公开密钥对报文加密后发送   </li><li>服务器用私有密钥对报文解密 </li></ul></li><li><p>可证明组织真实性的EV SSL证书<br>  证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是EVSSL证书（Extended Validation SSL Certificate）。<br>  EVSSL证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的Web网站能够获得更高的认可度。<br>  持有EVSSL证书的Web网站的浏览器地址栏处的背景色是绿色的，从视觉上就能一眼辨别出。而且在地址栏的左侧显示了SSL证书中记录的组织名称以及颁发证书的认证机构的名称。  </p></li></ul><h3 id="HTTPS安全通信机制："><a href="#HTTPS安全通信机制：" class="headerlink" title="HTTPS安全通信机制："></a>HTTPS安全通信机制：</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415150519883-141471649.png" alt=""></p><ol><li>步骤1：客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li><li>步骤2：服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>步骤3：之后服务器发送Certificate报文。报文中包含公开密钥证书。</li><li>步骤4：最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。</li><li>步骤5：SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。</li><li>步骤6：接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。</li><li>步骤7：客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li><li>步骤8：服务器同样发送Change Cipher Spec报文。</li><li>步骤9：服务器同样发送Finished报文。</li><li>步骤10：服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。</li><li>步骤11：应用层协议通信，即发送HTTP响应。</li><li>步骤12：最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCPFIN报文来关闭与TCP的通信。</li></ol><h3 id="SSL和TLS："><a href="#SSL和TLS：" class="headerlink" title="SSL和TLS："></a>SSL和TLS：</h3><pre><code>HTTPS使用SSL（Secure Socket Layer）和TLS（Transport Layer Security）这两个协议。  SSL技术最初是由浏览器开发商网景通信公司率先倡导的，开发过SSL3.0之前的版本。目前主导权已转移到IETF（Internet Engineering Task Force，Internet工程任务组）的手中。IETF以SSL3.0为基准，后又制定了TLS1.0、TLS1.1和TLS1.2。  TSL是以SSL为原型开发的协议，有时会统一称该协议为SSL。当前主流的版本是SSL3.0和TLS1.0。由于SSL1.0协议在设计之初被发现出了问题，就没有实际投入使用。SSL2.0也被发现存在问题，所以很多浏览器直接废除了该协议版本。  </code></pre><h3 id="SSL速度慢吗"><a href="#SSL速度慢吗" class="headerlink" title="SSL速度慢吗"></a>SSL速度慢吗</h3><pre><code>HTTPS也存在一些问题，那就是当使用SSL时，它的处理速度会变慢。  由于HTTPS还需要做服务器、客户端双方加密及解密处理，因此会消耗CPU和内存等硬件资源。和HTTP通信相比，SSL通信部分消耗网络资源。而SSL通信部分，又因为要对通信进行处理，所以时间上又延长了。HTTPS比HTTP要慢2到100倍。   SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU及内存等资源，导致处理速度变慢。和使用HTTP相比，网络负载可能会变慢2到100倍。除去和TCP连接、发送HTTP请求+响应以外，还必须进行SSL通信，因此整体上处理通信量不可避免会增加。  另一点是SSL必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起HTTP会更多地消耗服务器和客户端的硬件资源，导致负载增强。  针对速度变慢这一问题，并没有根本性的解决方案，我们会使用SSL加速器这种（专用服务器）硬件来改善该问题。该硬件为SSL通信专用硬件，相对软件来讲，能够提高数倍SSL的计算速度。仅在SSL处理时发挥SSL加速器的功效，以分担负载。   </code></pre><p>解决方法：  </p><ul><li>不全都用HTTPS<br>  如果是非敏感信息则使用HTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS加密通信。</li><li>通信内容部分加密<br>  在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《图解HTTP》（二）</title>
      <link href="/2020/04/15/du-shu-bi-ji-tu-jie-http-er/"/>
      <url>/2020/04/15/du-shu-bi-ji-tu-jie-http-er/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-HTTP报文内的HTTP信息"><a href="#第三章-HTTP报文内的HTTP信息" class="headerlink" title="第三章 HTTP报文内的HTTP信息"></a>第三章 HTTP报文内的HTTP信息</h2><p>HTTP报文：<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415135639051-562443235.png" alt=""></p><p>请求报文和响应报文首部内容由以下几部分组成。           </p><ul><li>请求行：包含用于请求的方法、请求 URI 和 HTTP 版本        </li><li>状态行：包含表明响应结果的状态码、原因短语和 HTTP 版本        </li><li>首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部：通用首部、请求首部、响应首部和实体首部。    </li></ul><h3 id="编码提升传输效率："><a href="#编码提升传输效率：" class="headerlink" title="编码提升传输效率："></a>编码提升传输效率：</h3><ul><li>报文主体和实体主体的区别</li></ul><p>HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p><ul><li>压缩传输的内容编码</li></ul><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。<br>常用的内容编码有以下几种：gzip(GNU zip)、compress(UNIX 系统的标准压缩)、deflate(zlib) 和 identity(不进行压缩)</p><ul><li>分割发送的分块传输编码</li></ul><p>分块传输编码会将实体主体分为多个部分。使用分块传输编码的实体主体会由接收的客户端负责界面，恢复到编码前的实体主体。</p><h3 id="内容协商："><a href="#内容协商：" class="headerlink" title="内容协商："></a>内容协商：</h3><ul><li><p>服务器驱动协商（Server-driven Negotiation）<br>由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。</p></li><li><p>客户端驱动协商（Agent-driven Negotiation）<br>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。</p></li><li><p>透明协商（Transparent Negotiation）<br>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</p></li></ul><h2 id="第四章-返回结果的HTTP状态码"><a href="#第四章-返回结果的HTTP状态码" class="headerlink" title="第四章 返回结果的HTTP状态码"></a>第四章 返回结果的HTTP状态码</h2><h3 id="状态码返回告知："><a href="#状态码返回告知：" class="headerlink" title="状态码返回告知："></a>状态码返回告知：</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415135650140-517015800.png" alt=""></p><ul><li><p>2XX 成功<br>200 OK  客户端发送的请求在服务端正常处理<br>204 No Content  服务端成功处理请求，但没有资源返回<br>206 Partial Content 客户端进行了范围请求，而服务器成功执行    </p></li><li><p>3XX 重定向<br>301 Moved Permanently   永久性重定向<br>302 Found   临时性重定向<br>303 See Other   由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。<br>304 Not Modified    客户端请求的资源找到，但未符合条件的请求<br>307 Temporary Redirect  临时重定向，与302不同的是不会从POST变成GET<br>当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。<br>301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做。     </p></li><li><p>4XX 客户端错误<br>400 Bad Request 客户端请求报文出错<br>401 Unauthorized    客户端的请求需要HTTP认证<br>403 Forbidden   请求资源被拒绝访问<br>404 Not Found   访问的资源不存在     </p></li><li><p>5XX 服务器错误<br>500 Internal Server Error   服务器在执行请求时发生错误<br>503 Service Unavailable 服务器无法访问     </p></li></ul><h2 id="第五章-与HTTP协作"><a href="#第五章-与HTTP协作" class="headerlink" title="第五章 与HTTP协作"></a>第五章 与HTTP协作</h2><h3 id="用单台虚拟主机实现多个域名："><a href="#用单台虚拟主机实现多个域名：" class="headerlink" title="用单台虚拟主机实现多个域名："></a>用单台虚拟主机实现多个域名：</h3><p>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。即使在物理层面只有一台服务器，但只要利用虚拟主机的功能，则可以假想已具有多台服务器。</p><p>在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发生 HTTP 请求时，必须在 Host 首部内完整指定主机或域名的 URI。</p><h3 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h3><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p><p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p><ul><li><p>缓存代理<br>代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</p></li><li><p>透明代理<br>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。</p></li></ul><h3 id="网关："><a href="#网关：" class="headerlink" title="网关："></a>网关：</h3><p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。</p><p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p><h3 id="隧道："><a href="#隧道：" class="headerlink" title="隧道："></a>隧道：</h3><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</p><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</p><p>隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p><h3 id="保存资源的缓存："><a href="#保存资源的缓存：" class="headerlink" title="保存资源的缓存："></a>保存资源的缓存：</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p><p>缓存服务器是代理服务器的一种，并归类在缓存代理类型中。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本在代理服务器上。</p><ul><li>缓存的有效期限<br>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</li></ul><p>缓存的有效期限：即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题。<br>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器会再次从源服务器上获取”新”资源。</p><ul><li>客户端的缓存<br>缓存不仅可以存在于缓存服务器内，也可以存在客户端浏览器中。浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。</li></ul><p>另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《图解HTTP》（一）</title>
      <link href="/2020/04/15/du-shu-bi-ji-tu-jie-http-yi/"/>
      <url>/2020/04/15/du-shu-bi-ji-tu-jie-http-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-了解Web及网络基础"><a href="#第一章-了解Web及网络基础" class="headerlink" title="第一章 了解Web及网络基础"></a>第一章 了解Web及网络基础</h2><h3 id="http的诞生："><a href="#http的诞生：" class="headerlink" title="http的诞生："></a>http的诞生：</h3><ul><li>http0.9为1990年问世，由于没有正式标准建立，从而成为http1.0的前身，为http0.9</li><li>http1.0为1996年正式发布，为最初的标准协议。</li><li>http1.1为1997年正式发布，为目前最主流的协议版本。</li><li>http2.0正在制定中。。。</li></ul><h3 id="TCP-IP："><a href="#TCP-IP：" class="headerlink" title="TCP/IP："></a>TCP/IP：</h3><p>分为4层：应用层、传输层、网络层、数据链路层。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131038348-1877806121.png" alt=""></p><p>每一层必须打上上一层的首部。</p><h3 id="URI："><a href="#URI：" class="headerlink" title="URI："></a>URI：</h3><p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。<br>绝对URI格式：<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131511968-1204698359.png" alt=""></p><ol><li><p>使用http：<br>或https：等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号：。也可使用data：或javascript：这类指定数据或脚本程序的方案名。 </p></li><li><p>登录信息（认证）<br>指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</p></li><li><p>服务器地址<br>使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的Pv6地址名。</p></li><li><p>服务器端口<br>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。带层次的文件路径。指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p></li><li><p>带层次的文件路径<br>指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p></li><li><p>查询字符串<br>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</p></li><li><p>片段标识符<br>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项。</p></li></ol><h2 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h2><p>查看网页header部分：<br>F12后进入开发者模式，然后选中All,然后F5刷新网页，在name中随便打开一个，就可以打开其相关的Headers信息了。</p><p>HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。现在使用Cookie技术来达到一个处理状态的。</p><h3 id="GET：获取资源"><a href="#GET：获取资源" class="headerlink" title="GET：获取资源"></a>GET：获取资源</h3><p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGl（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131534612-2146907352.png" alt=""></p><h3 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h3><p>POST方法用来传输实体的主体。虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131551408-24285555.png" alt=""></p><h3 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h3><p>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST （REpresentational State Transfer，表征状态转移）标准的同类Web网站，就可能会开放使用PUT方法。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131618502-930083218.png" alt=""></p><h3 id="HEAD：获得报文首部"><a href="#HEAD：获得报文首部" class="headerlink" title="HEAD：获得报文首部"></a>HEAD：获得报文首部</h3><p>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131636235-887066925.png" alt=""></p><h3 id="DELETE：删除文件"><a href="#DELETE：删除文件" class="headerlink" title="DELETE：删除文件"></a>DELETE：删除文件</h3><p>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131648573-1336804768.png" alt=""></p><h3 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h3><p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131719681-671783301.png" alt=""></p><h3 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h3><p>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。<br>发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200OK的响应。<br>客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。<br>但是，TRACE方法本来就不怎么常用，再加上它容易引发XST<br>（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131835697-42751909.png" alt=""></p><h3 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h3><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<br>CONNECT方法的格式如下所示。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131912889-1239429781.png" alt=""></p><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131918318-1673449996.png" alt=""></p><h3 id="持久连接："><a href="#持久连接：" class="headerlink" title="持久连接："></a>持久连接：</h3><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一TCP连接。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131925966-392111315.png" alt=""></p><h4 id="持久连接：-1"><a href="#持久连接：-1" class="headerlink" title="持久连接："></a>持久连接：</h4><p>为解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive或HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。<br>在HTTP/1.1中，所有的连接默认都是持久连接，但在HTTP/1.0内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131945115-1106583189.png" alt=""></p><h4 id="管线化："><a href="#管线化：" class="headerlink" title="管线化："></a>管线化：</h4><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。<br>从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。<br>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131955435-1090784576.png" alt=""></p><h3 id="使用Cookie："><a href="#使用Cookie：" class="headerlink" title="使用Cookie："></a>使用Cookie：</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。<br>假设要求登录认证的Web页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。<br>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。<br>Cookie会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。<br>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode——009 Palindrome Number</title>
      <link href="/2020/01/03/leetcode-009-palindrome-number/"/>
      <url>/2020/01/03/leetcode-009-palindrome-number/</url>
      
        <content type="html"><![CDATA[<p><strong>Description</strong></p><h1 id="hdashf"><a href="#hdashf" class="headerlink" title="hdashf"></a>hdashf</h1><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><pre><code>Input: 121Output: true</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.Follow up:</code></pre><p>Coud you solve it without converting the integer to a string?</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//水题咯</span><span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//负数和尾数为0都不是回文数字</span>    <span class="token keyword">double</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        num <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> num <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> s<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode——008 String to Integer (atoi)</title>
      <link href="/2020/01/03/leetcode-008-string-to-integer-atoi/"/>
      <url>/2020/01/03/leetcode-008-string-to-integer-atoi/</url>
      
        <content type="html"><![CDATA[<p>** Description **</p><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;42&quot;Output: 42</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot;   -42&quot;Output: -42Explanation: The first non-whitespace character is &#39;-&#39;, which is the minus sign.             Then take as many numerical digits as possible, which gets 42.</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.</code></pre><p><strong>Example 4:</strong></p><pre><code>Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &#39;w&#39;, which is not a numerical              digit or a +/- sign. Therefore no valid conversion could be performed.</code></pre><p><strong>Example 5:</strong></p><pre><code>Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.             Thefore INT_MIN (−231) is returned.</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">Solution <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用来防止溢出的</span>        <span class="token keyword">bool</span> isBegan <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//是否开始了</span>        <span class="token keyword">int</span> isMinus <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是否是负数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isBegan <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//还没有开始</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isBegan <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">||</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第一次遇到负号</span>                isMinus <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是负数</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token comment" spellcheck="true">//不是数字</span>                <span class="token keyword">return</span> res <span class="token operator">*</span> isMinus<span class="token punctuation">;</span>            isBegan <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开始了</span>            <span class="token comment" spellcheck="true">//判断是否越界    </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>res <span class="token operator">*</span> isMinus<span class="token punctuation">)</span> <span class="token operator">&lt;</span> INT_MIN<span class="token punctuation">)</span><span class="token keyword">return</span> INT_MIN<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> isMinus <span class="token operator">></span> INT_MAX<span class="token punctuation">)</span><span class="token keyword">return</span> INT_MAX<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">*</span> isMinus<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode——007 Reverse Integer</title>
      <link href="/2020/01/03/leetcode-007-reverse-integer/"/>
      <url>/2020/01/03/leetcode-007-reverse-integer/</url>
      
        <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1:</strong></p><pre><code>Input: 123Output: 321</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: -123Output: -321</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: 120Output: 21Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</code></pre><p><strong>Solution:</strong></p><p>翻转一个带字符整数<br>最高数值为【-2^31 - 2^31-1】32位系统，由于int型的数值范围是 -2147483648～2147483647，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> rev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pop <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        x <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rev <span class="token operator">></span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rev <span class="token operator">==</span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">></span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rev <span class="token operator">&lt;</span> INT_MIN <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rev <span class="token operator">==</span> INT_MIN <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        rev <span class="token operator">=</span> rev <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> pop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> rev<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">></span> INT_MAX <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode——006 ZigZag Conversion</title>
      <link href="/2020/01/03/leetcode-006-zigzag-conversion/"/>
      <url>/2020/01/03/leetcode-006-zigzag-conversion/</url>
      
        <content type="html"><![CDATA[<p><strong>Description</strong></p><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><pre><code>P   A   H   NA P L S I I GY   I   R</code></pre><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><p>** Example 1: **</p><p>Input: s = “PAYPALISHIRING”, numRows = 3<br>Output: “PAHNAPLSIIGYIR”</p><p>** Example 2: **</p><p>Input: s = “PAYPALISHIRING”, numRows = 4<br>Output: “PINALSIGYAHRPI”<br>Explanation:</p><pre><code>P     I    NA   L S  I GY A   H RP     I</code></pre><p>** Solution: **</p><p>注意输入的字母排序是按照倒着的N排序的，然后让你根据这个倒置的N的图形进行按行排序输出<br>按照半个N，即:一个竖和一个行的循环将数据输入到每一行中<br>比如输入：0，1，2，3，4，5，6，7，8，9，10；4行<br>其形状为<br>0            6<br>1        5    7<br>2    4        8    10<br>3            9<br>按照半个N，即0，1，2，3 与4，5 为循环，然后确定半个N的大小为size = 2 * numRows - 2 = 6<br>半个N的下竖为, 存入行[i%size]，上斜存入[size - i % size];</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">convert</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> numRows <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span> s<span class="token punctuation">;</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token function">rows</span><span class="token punctuation">(</span>numRows<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> numRows <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//半个N的大小</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> id <span class="token operator">=</span> i <span class="token operator">%</span> size<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> numRows<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//竖下</span>                rows<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token comment" spellcheck="true">//斜上</span>                rows<span class="token punctuation">[</span>size <span class="token operator">-</span> id<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> str <span class="token operator">:</span> rows<span class="token punctuation">)</span>            res <span class="token operator">+</span><span class="token operator">=</span> str<span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode——005 Longest Palindromic Substring</title>
      <link href="/2020/01/03/leetcode-005-longest-palindromic-substring/"/>
      <url>/2020/01/03/leetcode-005-longest-palindromic-substring/</url>
      
        <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>** Example 1: **</p><pre><code>Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.</code></pre><p>** Example 2: **</p><pre><code>Input: &quot;cbbd&quot;Output: &quot;bb&quot;</code></pre><p>** Solution: **</p><p>使用中将对称思路<br>及从头开始遍历，对于每个字母进行左右向外扩散，判断是不是回文子串<br>注意，向外扩散有两种方式，第一种，就是以该字母为中心向外扩散，第二种就是该字母和其右端的字母开始进行向外扩散   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">help</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//奇数类型的中心向两边扩撒</span>            <span class="token function">help</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//偶数类型的中心向两边扩撒            </span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">help</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>res<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token operator">--</span>L<span class="token punctuation">;</span>            <span class="token operator">++</span>R<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>L <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R <span class="token operator">-</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode——003 Longest Substring Without Repeating Characters</title>
      <link href="/2020/01/02/leetcode-003-longest-substring-without-repeating-characters/"/>
      <url>/2020/01/02/leetcode-003-longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given a string, find the length of the longest substring without repeating characters.</p><p>** Example 1: **</p><pre><code>Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. </code></pre><p>** Example 2: **</p><pre><code>Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1.</code></pre><p>** Example 3: **</p><pre><code>Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3.              Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</code></pre><p>** Solution: **</p><p>使用unordered_map来记录重复字母出现的最右端位置，然后使用现在的位置减去重复字母位置，中间就是没有重复字母的子串了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> L <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用来记录字母出现的最右端位置</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                L <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i <span class="token operator">-</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode——002 Add Two Numbers</title>
      <link href="/2020/01/02/leetcode-002-add-two-numbers/"/>
      <url>/2020/01/02/leetcode-002-add-two-numbers/</url>
      
        <content type="html"><![CDATA[<p><strong>Description</strong></p><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>** Example: **</p><pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.</code></pre><p>** Solution: **</p><p>题目很简单，直接相加就行</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记住，这是带头节点的</span>        ListNode <span class="token operator">*</span>p <span class="token operator">=</span> result<span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> l1<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//进位</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">||</span> p2<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span>p1 <span class="token operator">?</span> p1<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>p2 <span class="token operator">?</span> p2<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token punctuation">;</span>            p<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            p1 <span class="token operator">=</span> p1 <span class="token operator">?</span> p1<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2 <span class="token operator">?</span> p2<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            p<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode——001 Two Sum</title>
      <link href="/2020/01/02/leetcode-001-two-sum/"/>
      <url>/2020/01/02/leetcode-001-two-sum/</url>
      
        <content type="html"><![CDATA[<p><strong>Description</strong></p><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>** Example: ** </p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><p>** Solution: **</p><p>可以使用最简单的暴力法</p><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    v1 <span class="token operator">=</span> nums<span class="token punctuation">;</span>    <span class="token keyword">int</span> num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p1 <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>        p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>        num1 <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v1<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            num2 <span class="token operator">=</span> v2<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            v2<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num1 <span class="token operator">+</span> num2<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>                v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>                f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件神器——视频下载神器</title>
      <link href="/2020/01/01/ruan-jian-shen-qi-shi-pin-xia-zai-shen-qi/"/>
      <url>/2020/01/01/ruan-jian-shen-qi-shi-pin-xia-zai-shen-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="youtube-dl："><a href="#youtube-dl：" class="headerlink" title="youtube-dl："></a>youtube-dl：</h2><p>Youtube-dl是谷歌github上的一个开源项目，它是一款轻量级的命令行下载实用工具，阿刚曾在乐软博客里文章《不仅仅是youtube，youtube-dl在线视频下载神器》一文章，详细介绍过Youtube-dl。 </p><p>作为一款命令行视频下载神器，Youtube-dl功能强大，可解析下载包括youtube、youku、腾讯视频、爱奇艺等国内外上百个视频网站，它甚至还支持XXX网站的视频解析与下载，比如阿刚经常用它下载XXX片子~~</p><p>youtube-dl支持Winodws ，linux和mac平台。安装配置简单，在Windows平台上，你只需下载youtube-dl.exe并为其创建系统变量，就可以通过CMD输入youtube-dl命令来下载视频了。</p><p>youtube-dl支持的命令众多，在Github项目主页上大家可以查阅命令，或者直接键入”Youtube-dl -h”查看帮助说明。</p><p><strong>常用命令</strong></p><pre><code>youtube-dl --list-extractors #查看支持网站列表youtube-dl -U #程序升级youtube-dl --get-format URL #获取视频格式youtube-dl -F URL #获取所有格式youtube-dl -o 输出路径</code></pre><p>如果你要下载视频，只需键入命令”youtube-dl +视频地址”</p><p>默认情况下，youtube-dl会自动选择下载最高画质。　　</p><p>【安装使用】：</p><p><strong>window：</strong></p><p>安装有pip3的环境后，直接输入 pip install you-get就可以使用</p><pre><code>youtube-dl  url </code></pre><p><strong>Liunx：</strong></p><p>解压后可以直接使用：</p><pre><code>youtube-dl url</code></pre><p>或者使用 sudo  apt install youtube-dl</p><p>。。。。。貌似不能用了</p><h2 id="you-get"><a href="#you-get" class="headerlink" title="you-get"></a>you-get</h2><p>youget下载</p><p>you-get是一款开源在线视频下载工具，与youtubedl相同，同样是一款轻量级多平台命令行工具，you-get支持众多视频网站，包含 41 家国内主流视频、音乐网站，如 优酷土豆、爱奇艺、腾讯视频、芒果TV 、网易云音乐等等。</p><p>you-get有三种安装方式，如果你电脑安装了Python，可以通过pip3 install </p><p>you-get命令一键安装。Windows平台还可通过Chocolatey来一键安装。当然还有最简单直接的exe文件（需创建变量）</p><p>you-get支持的命令非常丰富，使用最简单的命令you-get +视频网址，即可解析下载视频~~</p><p>默认情况下，you-get自动解析下载最佳画质的视频。同样在下载完成后，you-get会自动调用ffmpeg合并视频。　　</p><p>【安装使用】：</p><p><strong>window：</strong></p><p>安装有pip3的环境后，直接输入 pip install you-get就可以使用</p><p>you-get url</p><p><strong>Liunx：</strong></p><p>解压后可以直接使用：</p><p>you-get url</p><p>或者使用 sudo  apt install you-get</p><p>。。。。实测还能使用</p><h2 id="ykdl："><a href="#ykdl：" class="headerlink" title="ykdl："></a>ykdl：</h2><p>由于视频网站规则不断变换，无论是神器youtube-dl，you-get，经常莫名其妙无法解析视频，尤其是you-get，优酷某些特殊视频，在解析时经常出现”客户端无权播放-201”</p><p>这种情况下，我们可以试试ykdl。</p><p>ykdl——顾名思义，一款专注于国内优酷视频的命令行下载工具。阿刚这些天试用下来，在优酷视频解析下载方面ykdl的表现更为强大，至少在写这篇文章时，某些优酷视频，youtube-dl和you-get要么只能解析下载前几分钟，要么直接无法解析。</p><p>常用命令</p><pre><code>　　-h, --help　　　　　　　　　　 显示帮助信息　　-l, --playlist　　　　　　　　 下载播放列表　　-i, --info　　　　　　　　　　　　显示视频信息　　-J, --json　　　　　　　　　　 以json格式显示视频信息.　　-F --FORMAT,　　　　　　 视频格式　　-o --OUTPUT_DIR,　　　　设置视频下载的保存路径　　-O --OUTPUT_NAME, 设置视频输出的名称　　-p --PLAYER,　　　　　　　　直接调用mpv播放器播放视频　　ykdl的命令并不太多，但足够我们使用，最简单的命令　　ykdl+视频网址，可一键解析下载视频。　　</code></pre><p>【安装使用】：</p><p><strong>window：</strong></p><p>安装有pip3的环境后，直接输入 pip install ykdl就可以使用</p><p>ykdl url </p><p><strong>Liunx：</strong></p><p>解压后可以直接使用：</p><p>ydkl url</p><p>或者使用 sudo  apt install ykdl 下载再使用</p><p>。。。。貌似失效了</p><h2 id="annie"><a href="#annie" class="headerlink" title="annie:"></a>annie:</h2><p>下载　　</p><p>annie是GitHub上一个开源项目，是一款专注于在线视频下载的轻量级命令行工具。annie支持解析下载包括youtube、优酷、爱奇艺、腾讯视频、抖音等国内外17个在线视频网站。</p><p>annie支持的命令相当多，下面阿刚简单的介绍几个常用的命令。</p><p>直接下载一个视频：</p><p>如果你想下载多个链接视频，那么就在后面加上多个链接　</p><pre><code>annie https://www.bilibili.com/video/av45654043</code></pre><p>列举视频所有清晰度，但不下载：</p><pre><code>annie -i https://www.bilibili.com/video/av45654043</code></pre><p>根据列举出来的清晰度，下载指定清晰度的视频：</p><ul><li>比如列表显示的1080P视频<pre><code>annie -f 80 https://www.bilibili.com/video/av45654043</code></pre></li></ul><p>一般视频都默认下载到当前目录，如果你想下载到其它目录，需要在下载时候，加一个-o参数，后面带上文件夹路径即可。</p><ul><li>比如下载到桌面C:\Users\Rats\Desktop文件夹，Linux路径写法为/root/Rats<pre><code>annie -o C:\Users\Rats\Desktop -f 80 https://www.bilibili.com/video/av45654043</code></pre></li></ul><p>如果是下载bilibili电视剧，可以在后面加一个-p参数，然后可以将所有集数一起下载。</p><ul><li><p>列出该集数的电视剧所有集数清晰度等信息</p><pre><code>annie -i -p https://www.bilibili.com/bangumi/play/ep133269</code></pre></li><li><p>下载1到20集1080P视频</p><pre><code>annie -f 80 -p -start 1 -end 20 https://www.bilibili.com/bangumi/play/ep133269</code></pre></li></ul><p>目前播放列表暂时只支持B站和youtube。</p><p>你也可以将你需要下载的链接存放到bz.txt文件里，然后使用命令一起下载：</p><ul><li><p>列出所有链接信息</p><pre><code>annie -F /root/bz.txt -i</code></pre></li><li><p>下载1080p视频</p><pre><code>annie -f 80 -F /root/bz.txt</code></pre></li></ul><p>如果你下载的视频，比如需要会员啥的，就需要Cookies了，这里补充下优酷会员下载视频方法。</p><p>首先登录优酷账号，然后获取Cookies，只需要P_pck_rm参数即可，再新建一个文本cookie.txt，格式如下：</p><ul><li>后面为该值参数<pre><code>P_pck_rm=moerats</code></pre></li></ul><p>接下来在命令中加上-c cookie.txt参数解析地址并下载视频：</p><ul><li><p>获取视频格式列表</p><pre><code>annie -i -c cookie.txt https://v.youku.com/v_show/id_*.html</code></pre></li><li><p>根据自己需求下载指定清晰度视频</p><pre><code>annie -f mp4hd3v2-guoyu -c cookie.txt https://v.youku.com/v_show/id_*.html</code></pre></li></ul><p>【安装使用】：</p><p><strong>window：</strong></p><p>下载解压后，将文件根目录添加到用户的环境变量中</p><p>annie  rul</p><p><strong>Liunx：</strong></p><p>下载后解压后可以直接使用</p><p>。。。。实测，功能巨强！！！！</p><h2 id="Video-Download-Manager"><a href="#Video-Download-Manager" class="headerlink" title="Video Download Manager"></a>Video Download Manager</h2><p>如果你实在不喜欢命令行工具，那么这款使用youtube-dl+you-get为核心的工具一定可以满足你的需求。</p><p>你无需理会那些让人抓狂的命令，只需复制粘贴视频地址即可解析下载。</p><p>【安装使用】：</p><p>直接百度下载安装就行</p><p>。。。。不爱用</p><p>如何下载VIP视频</p><p>以上的使用都一样：</p><p>通过加载cookies获取播放权限，实现视频解析和下载。也就是说，首先你必须要有个VIP账户。</p><ul><li><p>step1:</p><p>  获取Cookies</p><p>  首先登陆会员账号，快捷键F12，打开开发者工具。选择”Network”，F5快捷键重新加载页面，选择视频播放页面，将Headers里的Cookies信息全部复制，保存为txt文件，比如Cookies.txt</p></li><li><p>step2:</p><p>  加载Cookies</p><p>  通过annie -c命令加载已保存的Cookies.txt文件。即可成功解析B站大会员视频，如图中</p><p>  （B站登陆账户最高可观看1080P视频，大会员可看1080P+视频）</p></li></ul><hr><p>指定下载储存的文件位置：</p><p>[命令] -o   [位置]   [视频地址url]<br>***s</p>]]></content>
      
      
      <categories>
          
          <category> 软件神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《More Effective C++》</title>
      <link href="/2020/01/01/du-shu-bi-ji-more-effective-c/"/>
      <url>/2020/01/01/du-shu-bi-ji-more-effective-c/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础议题-Basics"><a href="#一、基础议题-Basics" class="headerlink" title="一、基础议题(Basics)"></a>一、基础议题(Basics)</h2><h3 id="1、仔细区别-pointers【指针】-和-references"><a href="#1、仔细区别-pointers【指针】-和-references" class="headerlink" title="1、仔细区别 pointers【指针】 和 references"></a>1、仔细区别 pointers【指针】 和 references</h3><p>二者之间的区别是：在任何情况下都不能用指向空值的引用，而指针则可以；指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变</p><p>在以下情况下使用指针：一是存在不指向任何对象的可能性；二是需要能够在不同的时刻指向不同的对象</p><p>在以下情况使用引用：总是指向一个对象且一旦指向一个对象之后就不会改变指向；重载某个操作符时，使用指针会造成语义误解</p><h3 id="2、最好使用-C-转型操作符"><a href="#2、最好使用-C-转型操作符" class="headerlink" title="2、最好使用 C++ 转型操作符"></a>2、最好使用 C++ 转型操作符</h3><p>为解决 C 旧式转型的缺点（允许将任何类型转为任何类型，且难以辨识），C++ 导入 4 个新的转型操作符（cast operators）：</p><p>static_cast , const_cast , dynamic_cast , reinterpret_cast：分别是常规类型转换，去常量转换，继承转换，函数指针转换</p><p>static_cast：功能上基本上与C风格的类型转换一样强大，含义也一样但是不能把struct转换成int类型或者把double类型转换成指针类型另外，它不<br>能从表达式中去除const属性。用来针对一个继承体系做向下的安全转换，目标类型必须为指针或者引用。基类中要有虚函数，否则会编译出错；static_cast则没有这个限制。原因是：存在虚函数，说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。必须保证源类型跟目标类型本来就是一致的，否则返回 null 指针。这个函数使用的是RTTI机制，所以编译器必须打开这个选项才能编译。</p><p>const_cast：用于类型转换掉表达式的const或volatileness属性但是不能用它来完成修改这两个属性之外的事情</p><p>dynamic_cast：用于安全地沿着类的继承关系向下类型转换失败的转换将返回空指针或者抛出异常</p><p>reinterpret_cast：这个操作符被用于的类型转换的转换结果时实现时定义因此，使用它的代码很难移植最普通的用途就是在函数指针之间进行转换</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//想要使用 dynamic_cast ，基类中必须有虚函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//i == 3</span><span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pj <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//int *pj = (int*)(&amp;j);     //等同于上面</span>    <span class="token operator">*</span>pj <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//虽然 *pj的地址和 j 的地址是一样的，但是值却不一样。</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>pj<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//20</span>    cout<span class="token operator">&lt;&lt;</span>j<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//10</span>B <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>D<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FunPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>FunPtr<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fun<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//尽量避免使用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、绝对不要以多态方式处理数组"><a href="#3、绝对不要以多态方式处理数组" class="headerlink" title="3、绝对不要以多态方式处理数组"></a>3、绝对不要以多态方式处理数组</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"base print()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"derived print()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果没有此句，执行将正确，因为基类对象和子类对象长度相同  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> B array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B barray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span>barray<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D darray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span>darray<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>array[i] 其实是一个指针算术表达式的简写，它代表的其实是 *(array+i)，array是一个指向数组起始处的指针。在 for 里遍历 array 时，必须要知道每个元素之间相差多少内存，而编译器则根据传入参数来计算得知为 sizeof(B)，而如果传入的是派生类数组对象，它依然认为是 sizeof(B)，除非正好派生类大小正好与基类相同，否则运行时会出现错误。但是如果我们设计软件的时候，不要让具体类继承具体类的话，就不太可能犯这种错误。（理由是，一个类的父类一般都会是一个抽象类，抽象类不存在数组） </p><h3 id="4、避免无用的-default-constructors"><a href="#4、避免无用的-default-constructors" class="headerlink" title="4、避免无用的 default constructors"></a>4、避免无用的 default constructors</h3><p>没有缺省构造函数造成的问题：通常不可能建立对象数组，对于使用非堆数组，可以在定义时提供必要的参数。另一种方法是使用指针数组，但是必须删除数组里的每个指针指向的对象，而且还增加了内存分配量。</p><p>提供无意义的缺省构造函数会影响类的工作效率，成员函数必须测试所有的部分是否都被正确的初始化。</p><h2 id="二、操作符-Operators"><a href="#二、操作符-Operators" class="headerlink" title="二、操作符(Operators)"></a>二、操作符(Operators)</h2><h3 id="5、对定制的“类型转换函数”保持警觉"><a href="#5、对定制的“类型转换函数”保持警觉" class="headerlink" title="5、对定制的“类型转换函数”保持警觉"></a>5、对定制的“类型转换函数”保持警觉</h3><p>定义类似功能的函数，而抛弃隐式类型转换，使得类型转换必须显示调用。例如 String类没有定义对Char*的隐式转换，而是用c_str函数来实施这个转换。拥有单个参数（或除第一个参数外都有默认值的多参数）构造函数的类，很容易被隐式类型转换，最好加上 explicit 防止隐式类型转换。</p><h3 id="6、区别-increment-decrement-操作符的前置和后置形式"><a href="#6、区别-increment-decrement-操作符的前置和后置形式" class="headerlink" title="6、区别 increment/decrement 操作符的前置和后置形式"></a>6、区别 increment/decrement 操作符的前置和后置形式</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>id <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//返回值为 const ，以避免 a++++这种形式</span>        <span class="token comment" spellcheck="true">//因为第二个 operator++ 所改变的对象是第一个 operator++ 返回的对象</span>        <span class="token comment" spellcheck="true">//最终结果其实也只是累加了一次，a++++ 也还是相当于 a++，这是违反直觉的</span>        <span class="token keyword">const</span> A <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            A a <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>id <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">++</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//++++a;   也是允许的，但 a++++ 不允许。</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">++</span><span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后置operator++(int) 的叠加是不允许的，原因有两个：一是与内建类型行为不一致（内建类型支持前置叠加)；二是其效果跟调用一次 operator++(int) 效果一样，这是违反直觉的。另外，后置式操作符使用 operator++(int)，参数的唯一目的只是为了区别前置式和后置式而已，当函数被调用时，编译器传递一个0作为int参数的值传递给该函数。<br>处置用户定制类型时，尽可能使用前置式，因为后置式会产生一个临时对象。</p><h3 id="7、千万不要重载-amp-amp-和-操作符"><a href="#7、千万不要重载-amp-amp-和-操作符" class="headerlink" title="7、千万不要重载 &amp;&amp;, || 和 , 操作符"></a>7、千万不要重载 &amp;&amp;, || 和 , 操作符</h3><pre><code>int *pi = NULL;if(pi != 0 &amp;&amp; cout&lt;&lt;*pi&lt;&lt;endl) { }</code></pre><p>上面的代码不会报错，虽然 pi 是空指针，但 &amp;&amp; 符号采用”骤死式”评估方式，如果 pi == 0 的话，不会执行后面的语句。</p><p>不要重载这些操作符，是因为我们无法控制表达式的求解优先级，不能真正模仿这些运算符。操作符重载的目的是使程序更容易阅读，书写和理解，而不是来迷惑其他人。如果没有一个好理由重载操作符，就不要重载。而对于&amp;&amp;，||和“，”，很难找到一个好理由。 </p><h3 id="8、了解各种不同意义的-new-和-delete"><a href="#8、了解各种不同意义的-new-和-delete" class="headerlink" title="8、了解各种不同意义的 new 和 delete"></a>8、了解各种不同意义的 new 和 delete</h3><p>new 操作符的执行过程：</p><ol><li>调用operator new分配内存 ；//这一步可以使用 operator new 或 placement new 重载。</li><li>调用构造函数生成类对象；</li><li>返回相应指针。</li></ol><p>函数 operator new 通常声明如下： </p><p>void * operator new(size_t size);　　//第一个参数必须为 size_t，表示需要分配多少内存。</p><p>返回值为void型指针，表示这个指针指向的内存中的数据的类型要由用户来指定。比如内存分配函数malloc函数返回的指针就是void *型，用户在使用这个指针的时候，要进行强制类型转换，如（int *)malloc(1024)。任何类型的指针都可以直接赋给 void * 变量，而不必强制转换。如果函数的参数可以为任意类型的指针，则可以声明为 void * 了。 </p><p>void 有两个地方可以使用，第一是函数返回值，第二是作为无参函数的参数。（因为在C语言中，可以给无参函数传任意类型的参数，而且C语言中，没有指定函数返回值时，默认返回为 int 值）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"size: "</span><span class="token operator">&lt;&lt;</span>size<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span>std<span class="token operator">::</span>string str<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"size: "</span><span class="token operator">&lt;&lt;</span>size <span class="token operator">&lt;&lt;</span><span class="token string">"\nname: "</span> <span class="token operator">&lt;&lt;</span> str<span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    User<span class="token operator">*</span> user1 <span class="token operator">=</span> <span class="token keyword">new</span> User<span class="token punctuation">;</span>    User<span class="token operator">*</span> user2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token string">"JIM"</span><span class="token punctuation">)</span>User<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>    pi <span class="token operator">=</span> p<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>pi<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、异常-Exceptions"><a href="#三、异常-Exceptions" class="headerlink" title="三、异常(Exceptions)"></a>三、异常(Exceptions)</h2><h3 id="9、利用-destructors-避免泄漏资源"><a href="#9、利用-destructors-避免泄漏资源" class="headerlink" title="9、利用 destructors 避免泄漏资源"></a>9、利用 destructors 避免泄漏资源</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">void</span> <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>pi<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">try</span>    <span class="token punctuation">{</span>        <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果此处抛出异常而未处理，则无法执行 delete 语句，造成内存泄漏。</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>        <span class="token keyword">throw</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">delete</span> pi<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 一个函数在堆里申请内存到释放内存的过程中，如果发生异常，如果自己不处理而只交给调用程序处理，则可能由于未调用 delete 导致内存泄漏。上面的方法可以解决这一问题，不过这样的代码使人看起来心烦且难于维护，而且必须写双份的 delete 语句。函数返回时局部对象总是释放（调用其析构函数），无论函数是如何退出的。（仅有的一种例外是当调用 longjmp 时，而 longjmp 这个缺点也是C++最初支持异常处理的原因）</p><p>所以这里使用智能指针或类似于智能指针的对象是比较好的办法：</p><ul><li>auto_ptr; — 基本被弃用.</li><li>shared_ptr; — 共享指针, 引用计数为零就销毁对象空间.</li><li>weak_ptr; — weak_ptr是用来解决shared_ptr相互引用时的死锁问题. 弱引用不会增加引用计数.</li><li>unique_ptr; — unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权.<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">void</span> <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ap</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用 auto_ptr 包装一下</span>  std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>pi<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>上面的代码看起来简洁多了，因为 auto_ptr 会在离开作用域时调用其析构函数，析构函数中会做 delete 动作。  </p><h3 id="10、在-constructors-内阻止资源泄漏"><a href="#10、在-constructors-内阻止资源泄漏" class="headerlink" title="10、在 constructors 内阻止资源泄漏"></a>10、在 constructors 内阻止资源泄漏</h3><p>这一条讲得其实是捕获构造函数里的异常的重要性。</p><p><strong>堆栈辗转开解（stack-unwinding）：</strong>如果一个函数中出现异常，在函数内即通过 try..catch 捕捉的话，可以继续往下执行；如果不捕捉就会抛出（或通过 throw 显式抛出）到外层函数，则当前函数会终止运行，释放当前函数内的局部对象（局部对象的析构函数就自然被调用了），外层函数如果也没有捕捉到的话，会再次抛出到更外层的函数，该外层函数也会退出，释放其局部对象……如此一直循环下去，直到找到匹配的 catch 子句，如果找到 main 函数中仍找不到，则退出程序。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> userid_<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> username_ <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string address_ <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token function">userid</span><span class="token punctuation">(</span>userid_<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">username</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            username <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>username_<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//构造函数里抛出异常的话，由于对象没有构造完成，不会执行析构函数</span>            address <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>address_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//此例中不会执行,会导致内存泄漏</span>        <span class="token punctuation">{</span>            <span class="token keyword">delete</span> username<span class="token punctuation">;</span>            <span class="token keyword">delete</span> address<span class="token punctuation">;</span>            std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~B()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> userid<span class="token punctuation">;</span>        std<span class="token operator">::</span>string<span class="token operator">*</span> username<span class="token punctuation">;</span>        std<span class="token operator">::</span>string<span class="token operator">*</span> address<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> C++拒绝为没有完成构造函数的对象调用析构函数，原因是避免开销，因为只有在每个对象里加一些字节来记录构造函数执行了多少步，它会使对象变大，且减慢析构函数的运行速度。</p><p>一般建议不要在构造函数里做过多的资源分配，而应该把这些操作放在一个类似于 init 的成员函数中去完成。这样当 init 成员函数抛出异常时，如果对象是在栈上，析构函数仍会被调用(异常会自动销毁局部对象，调用局部对象的析构函数，见下面)，如果是在堆上，需要在捕获异常之后 delete 对象来调用析构函数。</p><h3 id="11、禁止异常流出-destructors-之外"><a href="#11、禁止异常流出-destructors-之外" class="headerlink" title="11、禁止异常流出 destructors 之外"></a>11、禁止异常流出 destructors 之外</h3><p>这一条讲得其实是捕获析构函数里的异常的重要性。第一是防止程序调用 terminate 终止（这里有个名词叫：堆栈辗转开解 stack-unwinding）；第二是析构函数内如果发生异常，则异常后面的代码将不执行，无法确保我们完成我们想做的清理工作。</p><p>之前我们知道，析构函数被调用，会发生在对象被删除时，如栈对象超出作用域或堆对象被显式 delete (还有继承体系中，virtual 基类析构函数会在子类对象析构时调用)。除此之外，在异常传递的堆栈辗转开解（stack-unwinding）过程中，异常处理系统也会删除局部对象，从而调用局部对象的析构函数，而此时如果该析构函数也抛出异常，C++程序是无法同时处理两个异常的，就会调用 terminate()终止程序(会立即终止，连局部对象也不释放)。另外，如果异常被抛出，析构函数可能未执行完毕，导致一些清理工作不能完成。</p><p>所以不建议在析构函数中抛出异常，如果异常不可避免，则应在析构函数内捕获，而不应当抛出。 场景再现如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> T<span class="token punctuation">{</span>    <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"T()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">"init() throw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~T() begin"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">"~T() throw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~T() end"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pi<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        T t<span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下面也会引发 terminate</span>    <span class="token comment" spellcheck="true">/*    try    {        int *p2 = new int[1000000000000L];    }catch(std::bad_alloc&amp;)    {        std::cout&lt;&lt;"bad_alloc"&lt;&lt;std::endl;    }    */</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">terminate_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"my terminate_handler()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">set_terminate</span><span class="token punctuation">(</span>terminate_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12、了解-“抛出一个-exception-”-与-“传递一个参数”-或-“调用一个虚函数”之间的差异"><a href="#12、了解-“抛出一个-exception-”-与-“传递一个参数”-或-“调用一个虚函数”之间的差异" class="headerlink" title="12、了解 “抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异"></a>12、了解 “抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异</h3><p>抛出异常对象，到 catch 中，有点类似函数调用，但是它有几点特殊性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>        <span class="token keyword">throw</span> pi<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pi指向的对象是静态的，所以才能抛出指针</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果抛出的是 int 对象的异常，是不能用 double 类型接收的，这一点跟普通函数传参不一样。异常处理中，支持的类型转换只有两种，一种是上面例子中演示的从”有型指针”转为”无型指针”，所以用 const void* 可以捕捉任何指针类型的 exception。另一种是继承体系中的类转换，可见下一条款的例子。<br>另外，它跟虚拟函数有什么不同呢？异常处理可以出现多个 catch 子句，而匹配方式是按先后顺序来匹配的（所以如 exception 异常一定要写在 runtime_error异常的后面，如果反过来的话，runtime_error异常语句永远不会执行），而虚函数则是根据虚函数表来的。</p><h3 id="13、以-by-reference-方式捕捉-exceptions"><a href="#13、以-by-reference-方式捕捉-exceptions" class="headerlink" title="13、以 by reference 方式捕捉 exceptions"></a>13、以 by reference 方式捕捉 exceptions</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>id <span class="token operator">=</span> b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里是静态对象</span>    <span class="token keyword">throw</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//只有该对象是静态对象或全局对象时，才能以指针形式抛出</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">try</span><span class="token punctuation">{</span>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>B<span class="token operator">*</span> b<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//这里以指针形式接收</span> <span class="token punctuation">{</span>     std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>b<span class="token operator">-</span><span class="token operator">></span>id<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出3</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用指针方式来捕捉异常，上面的例子效率很高，没有产生临时对象。但是这种方式只能运用于全局或静态的对象（如果是 new 出来的堆中的对象也可以，但是该何时释放呢？）身上，否则的话由于对象离开作用域被销毁，catch中的指针指向不复存在的对象。接下来看看对象方式和指针方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"print():B"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"D copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"print():D"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    D d<span class="token punctuation">;</span>    <span class="token keyword">throw</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>B b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//注意这里</span>    <span class="token punctuation">{</span>        b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子会输出：</p><p>可是如果把 catch(B b) 改成 catch(B&amp; b) 的话，则会输出：</p><p>该条款的目的就是告诉我们，请尽量使用引用方式来捕捉异常，它可以避免 new 对象的删除问题，也可以正确处理继承关系的多态问题，还可以减少异常对象的复制次数。 </p><h3 id="14、明智运用-exception-specifications"><a href="#14、明智运用-exception-specifications" class="headerlink" title="14、明智运用 exception specifications"></a>14、明智运用 exception specifications</h3><p>C++提供了一种异常规范，即在函数后面指定要抛出的异常类型，可以指定多个：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//必须这样声明，而不能是 void fun(void);</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//说明可能抛出 int 和 double 异常</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>d<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="15、了解异常处理的成本"><a href="#15、了解异常处理的成本" class="headerlink" title="15、了解异常处理的成本"></a>15、了解异常处理的成本</h3><p>大致的意思是，异常的开销还是比较大的，只有在确实需要用它的地方才去用。</p><h2 id="四、效率-Efficiency"><a href="#四、效率-Efficiency" class="headerlink" title="四、效率(Efficiency)"></a>四、效率(Efficiency)</h2><h3 id="16、谨记-80-20-法则"><a href="#16、谨记-80-20-法则" class="headerlink" title="16、谨记 80-20 法则"></a>16、谨记 80-20 法则</h3><p>大致的意思是说，程序中80%的性能压力可能会集中在20%左右的代码处。那怎么找出这20%的代码来进行优化呢？可以通过Profiler分析程序等工具来测试，而不要凭感觉或经验来判断。</p><h3 id="17、考虑使用-lazy-evaluation（缓式评估）"><a href="#17、考虑使用-lazy-evaluation（缓式评估）" class="headerlink" title="17、考虑使用 lazy evaluation（缓式评估）"></a>17、考虑使用 lazy evaluation（缓式评估）</h3><p>懒惰计算法的含义是拖延计算的时间，等到需要时才进行计算其作用为：能避免不需要的对象拷贝，通过使用operator[]区分出读写操作，避免不需要的数据库读取操作，避免不需要的数字操作但是，如果计算都是重要的，懒惰计算法可能会减慢速度并增加内存的使用</p><h3 id="18、分期摊还预期的计算成本"><a href="#18、分期摊还预期的计算成本" class="headerlink" title="18、分期摊还预期的计算成本"></a>18、分期摊还预期的计算成本</h3><ul><li><p>over-eager evaluation, 如果程序常常用到某个计算, 设计一份数据结构以便能够及有效率地处理需求</p></li><li><p>(caching)利用告诉缓存暂存使用频率高的内容.</p></li><li><p>caching是分期摊还预期计算成本的一种做法. 预先取出是另一种做法. ◦系统调用往往比进程内的函数调用慢.</p></li><li><p>较快的速度往往导致较大的内存, 空间交换时间.</p></li><li><p>较大对象比较不容易塞入虚内存分页(virtual memory page)或缓存分页(cache page). ◦对象变大可能会降低性能, 因为换页活动会增加,<br>缓存命中率(cache hit rate)会降低. </p></li></ul><h3 id="19、了解临时对象的来源"><a href="#19、了解临时对象的来源" class="headerlink" title="19、了解临时对象的来源"></a>19、了解临时对象的来源</h3><p>C++真正所谓的临时对象是不可见的——只要产生一个 non-heap object 而没有为它命名，就产生了一个临时对象。它一般产生于两个地方：</p><p>一是函数参数的隐式类型转换，</p><p>二是函数返回对象时。 </p><p>任何时候，只要你看到一个 reference-to-const参数，就极可能会有一个临时对象被产生出来绑定至该参数上；任何时候，只要你看到函数返回一个对象，就会产生临时对象（并于稍后销毁）。</p><h3 id="20、协助完成“返回值优化-RVO-”"><a href="#20、协助完成“返回值优化-RVO-”" class="headerlink" title="20、协助完成“返回值优化(RVO)”"></a>20、协助完成“返回值优化(RVO)”</h3><p>不要在一个函数里返回一个局部对象的地址，因为它离开函数体后就析构了。不过在GCC下可以正常运行，无论是否打开优化；而在VS2010中如果关闭优化，就会看到效果。</p><p>这个条款想说的是：const Test fun(){ return Test(); } 比 const Test fun(){Test test; return test; }  好，更能使编译器进行优化。<br>不过现在看来，在经过编译器优化之后，这两个好像已经没有什么区别了。</p><h3 id="21、利用重载技术避免隐式类型转换"><a href="#21、利用重载技术避免隐式类型转换" class="headerlink" title="21、利用重载技术避免隐式类型转换"></a>21、利用重载技术避免隐式类型转换</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b1<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>id <span class="token operator">+</span> b2<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//const B operator+(const B&amp; b1,int i)    //如果重载此方法，就不会产生临时对象了</span><span class="token comment" spellcheck="true">//{</span><span class="token comment" spellcheck="true">//  return B(b1.id + i);</span><span class="token comment" spellcheck="true">//}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    B b3 <span class="token operator">=</span> b1<span class="token operator">+</span> b2<span class="token punctuation">;</span>    B b4 <span class="token operator">=</span> b1 <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//会把 6 先转换成B对象，产生临时对象</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="22、考虑以操作符复合形式-op-取代其独身形式-op"><a href="#22、考虑以操作符复合形式-op-取代其独身形式-op" class="headerlink" title="22、考虑以操作符复合形式(op=)取代其独身形式(op)"></a>22、考虑以操作符复合形式(op=)取代其独身形式(op)</h3><p>使用 operator+= 的实现来实现 operator= ，其它如果 operator*=、operator-= 等类似。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        B<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            id <span class="token operator">+</span><span class="token operator">=</span>  b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>id<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b1<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不用声明为 B 的 friend 函数,而且只需要维护 operator+= 即可。</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>B<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token operator">=</span> b2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里要去掉b1的const属性，才能带入operator+= 中的 this 中</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b3</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>b1<span class="token operator">+</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10    这里进行 operator+ 操作，会改变 b1 的值，这个不应该吧</span>    b1<span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//10</span>    b3<span class="token operator">+</span><span class="token operator">=</span>b1<span class="token punctuation">;</span>    b3<span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//110</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="23、考虑使用其它程序库"><a href="#23、考虑使用其它程序库" class="headerlink" title="23、考虑使用其它程序库"></a>23、考虑使用其它程序库</h3><p>提供类似功能的程序库，可能在效率、扩充性、移植性和类型安全方面有着不同的表现。比如说 iostream 和 stdio 库，所以选用不同的库可能会大幅改善程序性能。</p><h3 id="24、了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification-的成本"><a href="#24、了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification-的成本" class="headerlink" title="24、了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本"></a>24、了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本</h3><p>在使用虚函数时，大部分编译器会使用所谓的 virtual tables 和 virtual table pointers ，通常简写为 vtbls 和 vptrs 。vtbl 通常是由 “函数指针” 架构而成的数组，每一个声明（或继承）虚函数的类都有一个 vtbl ，而其中的条目就是该 class 的各个虚函数实现体的指针。<br>虚函数的第一个成本：必须为每个拥有虚函数的类耗费一个 vtbl 空间，其大小视虚函数的个数（包括继承而来的）而定。不过，一个类只会有一个 vtbl 空间，所以一般占用空间不是很大。</p><p>不要将虚函数声明为 inline ，因为虚函数是运行时绑定的，而 inline 是编译时展开的，即使你对虚函数使用 inline ，编译器也通常会忽略。<br>虚函数的第二个成本：必须为每个拥有虚函数的类的对象，付出一个指针的代价，即 vptr ，它是一个隐藏的 data member，用来指向所属类的 vtbl。</p><p>调用一个虚函数的成本，基本上和通过一个函数指针调用函数相同，虚函数本身并不构成性能上的瓶颈。</p><p>虚函数的第三个成本：事实上等于放弃了 inline。（如果虚函数是通过对象被调用，倒是可以 inline，不过一般都是通过对象的指针或引用调用的）</p><ul><li><p>虚函数真正的运行时期成本发生在和inlining互动的时候. 虚函数不应该inline. ◦因为inline函数需要在编译器将函数本体拷贝, 而virtual意味着等待, 直到运行期才知道运行谁.</p></li><li><p>多重继承往往导致虚基类的需求(virtual base class), 会形成更复杂和特殊的虚表.</p></li><li><p>一个类只需一份RTTI信息(运行时类型识别), 当某种类型至少拥有一个虚函数, 才能保证检验该对象的动态类型. </p><ul><li><p>RTTI的设计理念根据类的虚表(vtbl)来实现的.</p></li><li><p>RTTI的空间成本只需在每个类的虚表(vtbl)内增加一个条目, 即一个类型信息(type_info)对象空间.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> B1 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B2 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B3 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> <span class="token keyword">virtual</span> B1<span class="token punctuation">,</span> <span class="token keyword">virtual</span> B2<span class="token punctuation">,</span> <span class="token keyword">virtual</span> B3 <span class="token punctuation">{</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B1<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//8</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B2<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//4</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//4</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//16</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//D 中只包含了三个 vptr ，D和B1共享了一个。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="五、技术-Techniques-Idioms-Patterns"><a href="#五、技术-Techniques-Idioms-Patterns" class="headerlink" title="五、技术(Techniques,Idioms,Patterns)"></a>五、技术(Techniques,Idioms,Patterns)</h2><h3 id="25、将-constructor-和-non-member-functions-虚化"><a href="#25、将-constructor-和-non-member-functions-虚化" class="headerlink" title="25、将 constructor 和 non-member functions 虚化"></a>25、将 constructor 和 non-member functions 虚化</h3><p>这里所谓的虚拟构造函数，并不是真的指在构造函数前面加上 virtual 修饰符，而是指能够根据传入不同的参数建立不同继承关系类型的对象。<br>被派生类重定义的虚函数可以与基类的虚函数具有不同的返回类型。所以所谓的虚拟复制构造函数，可以在基类里声明一个 virtual B* clone() const = 0 的纯虚函数，在子类中实现 virtual D* clone() const {return new D(*this);}</p><p>同样的，非成员函数虚化，这里也并不是指使用 virtual 来修饰非成员函数。比如下面这个输出 list 中多态对象的属性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">value</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">virtual</span> ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span><span class="token operator">:</span>        string value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D1</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">D1</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token string">"protect value"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//子类构造函数中，要先调用基类构造函数初始化基类</span>        ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>id<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//如果基类虚函数是 const 方法，则这里也必须使用 const 修饰</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D2</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">D2</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token string">"protect value"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//子类构造函数中，要先调用基类构造函数初始化基类</span>        ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>id<span class="token punctuation">;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span> lt<span class="token punctuation">;</span>    D1 <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D2 <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>    lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d2<span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>it <span class="token operator">!=</span> lt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//D1   D2</span>        it<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，即使给每一个继承类单独实现友元的 operator&lt;&lt; 方法，也不能实现动态绑定，只会调用基类的方法。那么，在基类里写 operator&lt;&lt; 用 virtual 修饰不就行了吗？遗憾的，虚函数不能是友元。</p><h3 id="26、限制某个-class-所能产生的对象数量"><a href="#26、限制某个-class-所能产生的对象数量" class="headerlink" title="26、限制某个 class 所能产生的对象数量"></a>26、限制某个 class 所能产生的对象数量</h3><p>只有一个对象：使用单一模式，将类的构造函数声明为private，再声明一个静态函数，该函数中有一个类的静态对象不将该静态对象放在类中原因是放在函数中时，执行函数时才建立对象，并且对象初始化时间确定的，即第一次执行该函数时另外，该函数不能声明为内联，如果内联可能造成程序的静态对象拷贝超过一个限制对象个数：建立一个基类，构造函数中计数加一，若超过最大值则抛出异常；析构函数中计数减一</p><p>编程点滴：</p><p>将模板类的定义和实现放在一个文件中，否则将造成引用未定义错误（血的教训）；</p><p>静态数据成员需要先声明再初始化；</p><p>用常量值作初始化的有序类型的const静态数据成员是一个常量表达式（可以作为数组定义的维数）；</p><p>构造函数中抛出异常，将导致静态数组成员重新初始化</p><h3 id="27、要求（或禁止）对象产生于-heap-中"><a href="#27、要求（或禁止）对象产生于-heap-中" class="headerlink" title="27、要求（或禁止）对象产生于 heap 中"></a>27、要求（或禁止）对象产生于 heap 中</h3><p>析构函数私有，有一个致命问题：妨碍了继承和组合（内含）。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span>    <span class="token comment" spellcheck="true">//禁止对象产生于 heap 中</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B1"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B2</span>    <span class="token comment" spellcheck="true">//要求对象产生于 heap 中</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//模拟的析构函数</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token operator">~</span><span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//B1* b1  = new B1; //Error!</span>    B1 b1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//B2 b2;    //Error</span>    B2<span class="token operator">*</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> B2<span class="token punctuation">;</span>    b2<span class="token operator">-</span><span class="token operator">></span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="28、Smart-Pointer（智能指针）"><a href="#28、Smart-Pointer（智能指针）" class="headerlink" title="28、Smart Pointer（智能指针）"></a>28、Smart Pointer（智能指针）</h3><ul><li><p>智能指针是一个看起来, 用起来, 感觉起来都像内建指针, 但是提供了更多机能的一种对象. </p><ul><li>资源管理;</li><li>自动的重复写码工作.</li></ul></li><li><p>以智能指针取代C++内建指针: </p><ul><li>构造和析构: 何时被产生以及何时被销毁.</li><li>赋值和复制(Assignment and Copying), 复制和赋值其所指对象, 执行所谓的深拷贝(deep copy).</li><li>解引用(Dereferencing): 智能指针有权决定所指之物发生了什么事情. </li><li>采用lazy fetching方法.</li></ul></li><li><p>远程过程调用(remote procedure calls, RPC).</p></li><li><p>只能指针的构造, 赋值和析构 </p><ul><li>只有当确定要将对象所有权传递给函数的某个参数时, 才应该以by value方式传递auto_ptrs.</li></ul></li><li><p>实现解引操作符(Dereferencing Operators): </p><ul><li>返回引用值.</li></ul></li><li><p>测试智能指针是否为null: </p><ul><li>提供一个隐式类型转换操作符来进行测试.</li></ul></li><li><p>将智能指针(smart pointers) 转换为内建指针(Dumb Pointers). </p><ul><li>不要提供对内建指针的隐式转换操作符, 除非不得已.</li></ul></li><li><p>智能指针(Smart Pointers)和继承有关的类型转换 </p><ul><li>每个只能指针有个隐式类型转换操作符, 用来转换至另一个只能指针类.</li><li>函数调用的自变量匹配规则;</li><li>隐式类型转换函数;</li><li>template函数的暗自实例化;</li><li>成员函数模板(member function templates)等技术.</li></ul></li><li><p>智能指针与const: </p><ul><li>const用来修饰被指之物, 或是指针本身, 或是两者都可以. 智能指针也具有同样的弹性.</li><li>对于智能指针只有一个地方可以放置const: 只能放置与指针身上, 不能置于所指的对象.</li><li>non-const转换至const是安全的, 从const转换至non-const则不安全.</li></ul></li><li><p>自己实现的智能指针不容易实现, 了解和维护.</p></li></ul><h3 id="29、Reference-counting（引用计数）"><a href="#29、Reference-counting（引用计数）" class="headerlink" title="29、Reference counting（引用计数）"></a>29、Reference counting（引用计数）</h3><p>使用引用计数后，对象自己拥有自己，当没有人再使用它时，它自己自动销毁自己因此，引用计数是个简单的垃圾回收体系</p><p>在基类中调用delete this将导致派生类的对象被销毁</p><p>写时拷贝：与其它对象共享一个值直到写操作时才拥有自己的拷贝它是Lazy原则的特例</p><p>精彩的类层次结构：<br>RCObject类提供计数操作；<br>StringValue包含指向数据的指针并继承RCObject的计数操作；<br>RCPtr是一个灵巧指针，封装了本属于String的一些计数操作</p><h3 id="30、Proxy-classes（替身类、代理类）"><a href="#30、Proxy-classes（替身类、代理类）" class="headerlink" title="30、Proxy classes（替身类、代理类）"></a>30、Proxy classes（替身类、代理类）</h3><ul><li><p>凡是用来代表(象征)其他对象的对象, 常被称为proxy object(替身对象), 替身对象的类称为代理类. </p><ul><li>二维数组是观念上并不存在的一维数组.</li></ul></li><li><p>读取动作是所谓的右值运用(rvalue usage); 写动作是所谓的左值运用(lvalue usages).</p></li><li><p>返回字符串中字符的proxy, 而不返回字符本身.</p></li><li><p>对于一个proxy, 只有3间事情可做: </p><ul><li>产生它;</li><li>以它作为赋值动作的目标(接收端).</li><li>以其他方式使用它.</li></ul></li><li><p>Proxy 类很适合用来区分operator[]的左值运用和右值运用.</p></li><li><p>对proxy取址所获得的指针类型和对真是对象取址所获得的指针类型不同.</p></li><li><p>用户将proxy传递给接受引用到非const对象的函数.</p></li><li><p>ploxies难以完全取代真正对象的最后一个原因在于隐式类型转换.</p></li><li><p>proxy 对象是一种临时对象, 需要被产生和被销毁.</p></li><li><p>类的身份从与真实对象合作转移到与替身对象(proxies)合作, 往往会造成类语义的改变, 因为proxy 对象所展现的行为常常和真正的行为有些隐微差异.</p></li></ul><h3 id="31、让函数根据一个以上的对象类型来决定如何虚化"><a href="#31、让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="31、让函数根据一个以上的对象类型来决定如何虚化"></a>31、让函数根据一个以上的对象类型来决定如何虚化</h3><ul><li><p>面向对象函数调用机制(mutil-method): 根据所希望的多个参数而虚化的函数; — C++暂时不支持.</p></li><li><p>消息派分(message dispatch): 虚函数调用动作.</p></li><li><p>虚函数+RTTI(运行时期类型辨识): </p><ul><li>虚函数可以实现single dispatch, 利用typeid操作符来获取一个类的类型参数值.</li></ul></li><li><p>虚函数被发明的主要原因: </p><ul><li>把生产及维护”以类型为行事基准的函数”的负荷, 从程序员转移给编译器.</li></ul></li><li><p>只用虚函数: </p><ul><li>将double dispatching以两个single dispatches(两个分离的虚函数调用)实现出来: <ul><li>一个用来决定第一对象的动态类型.</li><li>另一个用来决定第二对象的动态类型.</li></ul></li><li>编译器必须根据此函数所获得的自变量的静态类型(被声明时的类型), 才能解析出哪一组函数被调用.</li></ul></li></ul><h2 id="六、杂项讨论-Miscellany"><a href="#六、杂项讨论-Miscellany" class="headerlink" title="六、杂项讨论(Miscellany)"></a>六、杂项讨论(Miscellany)</h2><h3 id="32、在未来时态下发展程序"><a href="#32、在未来时态下发展程序" class="headerlink" title="32、在未来时态下发展程序"></a>32、在未来时态下发展程序</h3><p>要用语言提供的特性来强迫程序符合设计，而不要指望使用者去遵守约定。比如禁止继承，禁止复制，要求类的实例只能创建在堆中等等。处理每个类的赋值和拷贝构造函数，如果这些函数是难以实现的，则声明它们为私有。</p><p>所提供的类的操作和函数有自然的语法和直观的语义，和内建类型（如 int）的行为保持一致。</p><p>尽可能写可移植性的代码，只有在性能极其重要时不可移植的结构才是可取的。</p><p>多为未来的需求考虑，尽可能完善类的设计。</p><h3 id="33、将非尾端类设计为抽象类"><a href="#33、将非尾端类设计为抽象类" class="headerlink" title="33、将非尾端类设计为抽象类"></a>33、将非尾端类设计为抽象类</h3><p>如果有一个实体类公有继承自另一个实体类，应该将两个类的继承层次改为三个类的继承层次，通过创造一个新的抽象类并将其它两个实体类都从它继承因此，设计类层次的一般规则是：非尾端类应该是抽象类在处理外来的类库，可能不得不违反这个规则</p><p>编程点滴：抽象类的派生类不能是抽象类；实现纯虚函数一般不常见，但对纯虚析构函数，它必须实现</p><h3 id="34、如何在同一个程序中结合-C-和-C"><a href="#34、如何在同一个程序中结合-C-和-C" class="headerlink" title="34、如何在同一个程序中结合 C++ 和 C"></a>34、如何在同一个程序中结合 C++ 和 C</h3><ul><li><p>结合C++和C程序需要考虑的问题: </p><ul><li>名称重整(name mangling): <ul><li>名称重整(name mangling)是C++中的一种程序, 为每个函数编出独一无二的名称.</li><li>绝不要重整其他语言编写函数的名称.</li><li>压制名称重整(name mangling), 必须在C++中使用extern “C” { … }指令. — 进行C连接.</li><li>不同编译器以不同的方法进行重整名称.        </li></ul></li><li>static的初始化: <ul><li>在main之前执行的代码: static class对象, 全局对象, namespace内的对象, 文件范围(file scope)内的对象, 其构造函数都在main函数之前执行.</li></ul></li></ul></li><li><p>动态内存分配: </p><ul><li>C++中使用new和delete, C中使用malloc和free.</li></ul></li><li><p>数据结构的兼容性: </p><ul><li>structs可以安全地在C++和C之间往返.</li></ul></li><li><p>在同一程序中混用C++和C, 应该记住以下几个简单规则: </p><ul><li>确定C++和C编译器产出兼容的目标文件(object file).</li><li>将双方都使用的函数声明为extern “C”.</li><li>如果可能, 尽量在C++中撰写main.</li><li>总是以delete删除new返回的内存, 总是以free释放malloc返回的内存.</li><li>将两个语言间的数据结构传递限制于C所能了解的形式; C++structs如果内涵非虚函数, 倒是不受此限制.</li></ul></li></ul><h3 id="35、让自己习惯于标准-C-语言"><a href="#35、让自己习惯于标准-C-语言" class="headerlink" title="35、让自己习惯于标准 C++ 语言"></a>35、让自己习惯于标准 C++ 语言</h3><ul><li><p>新的语言特性: </p><ul><li>RTTI, 命名空间(namespace), bool, 关键字mutable, 关键字explicit, enums作为重载函数的自变量所引发的类型晋升转换, 在类中为const static成员变量设定初值.</li></ul></li><li><p>STL(standard template library) — C++标准程序库中最大的组成部分. </p><ul><li>迭代器(iterators)是一种行为类似指针的对象, 针对STL 容器而定义.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《Effective C++》</title>
      <link href="/2020/01/01/du-shu-bi-ji-effective-c/"/>
      <url>/2020/01/01/du-shu-bi-ji-effective-c/</url>
      
        <content type="html"><![CDATA[<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h3><ul><li>C语言</li><li>面对对象</li><li>C++模板</li><li>STL容器</li></ul><h3 id="尽量以const，enum，inline替换-define"><a href="#尽量以const，enum，inline替换-define" class="headerlink" title="尽量以const，enum，inline替换#define"></a>尽量以const，enum，inline替换#define</h3><ol><li>const的好处： <ol><li>define直接常量替换，出现编译错误不易定位(不知道常量是哪个变量)</li><li>define没有作用域，const有作用域提供了封装性</li></ol></li><li>enum的好处： <ol><li>提供了封装性</li><li>编译器肯定不会分配额外内存空间(其实const也不会)</li></ol></li><li>inline的好处： <ol><li>define宏函数容易造成误用(下面有个例子)</li></ol></li></ol><p>//define误用举例</p><pre><code>#define MAX(a, b) a &gt; b ? a : bint a = 5, b = 0;MAX(++a, b) //a++调用2次MAX(++a, b+10) //a++调用一次</code></pre><p>然而，了解宏的机制以后，我们也可以用宏实现特殊的技巧。例如：C++反射，TEST</p><h3 id="宏实现工厂模式"><a href="#宏实现工厂模式" class="headerlink" title="宏实现工厂模式"></a>宏实现工厂模式</h3><ol><li>需要一个全局的map用于存储类的信息以及创建实例的函数</li><li>需要调用全局对象的构造函数用于注册</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>register_fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CCFactory</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">NewInstance</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> map_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>class_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>it <span class="token operator">==</span> map_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span>      <span class="token keyword">return</span> it<span class="token operator">-</span><span class="token operator">></span><span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Register</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">,</span> register_fun func<span class="token punctuation">)</span><span class="token punctuation">{</span>    map_<span class="token punctuation">[</span>class_name<span class="token punctuation">]</span> <span class="token operator">=</span> func<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">static</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> register_fun<span class="token operator">></span> map_<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> register_fun<span class="token operator">></span> CCFactory<span class="token operator">::</span>map_<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Register</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Register</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">,</span> register_fun func<span class="token punctuation">)</span><span class="token punctuation">{</span>    CCFactory<span class="token operator">::</span><span class="token function">Register</span><span class="token punctuation">(</span>class_name<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> REGISTER_CLASS(class_name); \  const Register class_name_register(#class_name, []()->void *{return new class_name;});</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h3><ol><li>const定义接口，防止误用</li><li>const成员函数，代表这个成员函数承诺不会改变对象值 <ol><li>const成员只能调用const成员函数(加-fpermissive编译选项就可以了)</li><li>非const成员可以调用所有成员函数</li></ol></li></ol><p>尽量使用const来修饰函数名和参数变量名</p><p>尽量使用const来修饰类名<br><code>void function(classA  test);  //classA为自定义的类型</code></p><p>这样使用值传参的缺点：</p><ul><li>会导致自定义类型的构造函数和析构函数多次被调用，当自定义类型的构造函数和析构函数比较费时的时候，效率比较底下。</li><li>在传递派生类时容易产生对象被切割的问题。</li></ul><p>建议：<br><code>void function(const classA &amp;s);</code></p><p>优点：</p><ul><li>可以回避自定义类型的构造和析构函数的调用，不会影响效率。</li><li>不会产生对象切割问题，因为引用的底层其实就是指针，在内存中只有一份实例。</li></ul><p>原则：</p><ul><li>如果可以的话，尽量传递 const 的引用作为函数的参数。</li><li>不要将这个条款应用在内置类型上，对于内置类型(int double)，pass-by-value更适合。</li></ul><h3 id="确定对象使用前已被初始化"><a href="#确定对象使用前已被初始化" class="headerlink" title="确定对象使用前已被初始化"></a>确定对象使用前已被初始化</h3><ol><li>内置类型需要定义时初始化</li><li>最好使用初始化序列(序列顺序与声明顺序相同)，而不是在构造函数中赋值</li><li>跨编译单元定义全局对象不能确保初始化顺序 </li></ol><p>将static对象放入一个函数<br>Fuck&amp; fuck(){<br>    static Fuck f;<br>    return f;<br>}</p><h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="了解C-默默编调用了哪些函数"><a href="#了解C-默默编调用了哪些函数" class="headerlink" title="了解C++默默编调用了哪些函数"></a>了解C++默默编调用了哪些函数</h3><p>如果类中没有定义，程序却调用了，编译器会产生一些函数</p><ul><li><p>一个 default 构造函数</p></li><li><p>一个 copy 构造函数</p></li><li><p>一个 copy assignment 操作符</p></li><li><p>一个析构函数(non virtual)</p></li><li><p>如果自己构造了带参数的构造函数，编译器不会产生default构造函数</p></li><li><p>base class如果把拷贝构造函数或者赋值操作符设置为private，不会产生这两个函数</p></li><li><p>含有引用成员变量或者const成员变量不产生赋值操作符</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Fuck</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>  std<span class="token operator">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用定义后不能修改绑定对象</span>  <span class="token keyword">const</span> std<span class="token operator">::</span>string con_str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//const对象定义后不能修改</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>将默认生成的函数声明为private，或者C++ 11新特性”=delete”</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Uncopyable</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Uncopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h3><ol><li>给多态基类应该主动声明virtual析构函数</li><li>非多态基类，没有virtual函数，不要声明virtual析构函数</li></ol><h3 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h3><p>构造函数可以抛出异常，析构函数不能抛出异常。</p><p>因为析构函数有两个地方可能被调用。一是用户调用，这时抛出异常完全没问题。二是前面有异常抛出，正在清理堆栈，调用析构函数。这时如果再抛出异常，两个异常同时存在，异常处理机制只能terminate().</p><p>构造函数抛出异常，会有内存泄漏吗？</p><p>不会</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第二步，调用构造函数构造对象</span>    <span class="token keyword">new</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>T<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// placement new: 只调用T的构造函数</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 释放第一步分配的内存</span>    <span class="token keyword">throw</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 重抛异常，通知应用程序</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绝不在构造和析构过程中调用virtual函数"><a href="#绝不在构造和析构过程中调用virtual函数" class="headerlink" title="绝不在构造和析构过程中调用virtual函数"></a>绝不在构造和析构过程中调用virtual函数</h3><p>构造和析构过程中，虚表指针指向的虚表在变化。调用的是对应虚表指针指向的函数。</p><h3 id="令operator-返回一个reference-to-this"><a href="#令operator-返回一个reference-to-this" class="headerlink" title="令operator= 返回一个reference to *this"></a>令operator= 返回一个reference to *this</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x，y，z；x<span class="token operator">=</span>y<span class="token operator">=</span>z<span class="token operator">=</span><span class="token number">15</span>；同样有趣的是，赋值采用右结合律，x<span class="token operator">=</span>（y<span class="token operator">=</span>（z<span class="token operator">=</span><span class="token number">15</span>））；Widget<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span>（<span class="token keyword">const</span> Widget<span class="token operator">&amp;</span>rhs）<span class="token comment" spellcheck="true">//返回类型是个reference，</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token operator">*</span><span class="token keyword">this</span>；<span class="token operator">/</span>返回左侧对象<span class="token punctuation">}</span><span class="token operator">*</span> 在<span class="token keyword">operator</span><span class="token operator">=</span> 里处理自我赋值Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span>    ···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制对象时务忘其每一个成分"><a href="#复制对象时务忘其每一个成分" class="headerlink" title="复制对象时务忘其每一个成分"></a>复制对象时务忘其每一个成分</h3><ol><li>记得实现拷贝构造函数和赋值操作符的时候，调用base的相关函数</li><li>可以让拷贝构造函数和赋值操作符调用一个共同的函数，例如init</li></ol><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h3><ol><li>为了防止资源泄漏，请使用RAII对象，在构造函数里面获得资源，在析构函数里面释放资源</li><li>shared_ptr，unique_lock都是RAII对象</li></ol><h3 id="在资源管理类小心copy行为"><a href="#在资源管理类小心copy行为" class="headerlink" title="在资源管理类小心copy行为"></a>在资源管理类小心copy行为</h3><ul><li>常见的RAII对象copy行为 <ol><li>禁止copy</li><li>引用计数</li><li>深度复制</li><li>转移资源拥有权</li></ol></li></ul><h3 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h3><p>用户可能需要原始资源作为参数传入某个接口。有两种方式：</p><ul><li>提供显示调用接口</li><li>提供隐式转换接口(不推荐)</li></ul><h3 id="成对使用new和delete要采用相同的格式"><a href="#成对使用new和delete要采用相同的格式" class="headerlink" title="成对使用new和delete要采用相同的格式"></a>成对使用new和delete要采用相同的格式</h3><p>new和delete对应；new []和delete []对应</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//前面还分配了4个字节代表数组的个数</span><span class="token keyword">int</span> <span class="token operator">*</span>A <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前面分配了8个字节，分别代表对象的个数和Object的大小</span>Object <span class="token operator">*</span>O <span class="token operator">=</span> <span class="token keyword">new</span> Object<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="以独立的语句将newd对象置入智能指针"><a href="#以独立的语句将newd对象置入智能指针" class="headerlink" title="以独立的语句将newd对象置入智能指针"></a>以独立的语句将newd对象置入智能指针</h3><p>调用std::make_shared，而不要调用new，防止new Obeject和传入智能指针的过程产生异常<br>process(new Widget, priority);</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//其实这样也可以，独立的语句</span>shard_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">process</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="让接口容易被正确使用，不易被误用"><a href="#让接口容易被正确使用，不易被误用" class="headerlink" title="让接口容易被正确使用，不易被误用"></a>让接口容易被正确使用，不易被误用</h3><ol><li>好的接口很容易被正确使用，不容易被误用。努力达成这些性质(例如 explicit关键字)</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容</li><li>“防治误用”b包括建立新类型，限制类型上的操作，束缚对象值，以及消除用户的资源管理责任</li><li>shared_ptr支持定制deleter，需要灵活使用</li></ol><ul><li>宁以pass-by-refrence-to-const替换pass-by-value</li></ul><p>1.尽量以pass-by-reference-to-const替换pass-by-value，比较高效，并且可以避免切割问题<br>2.以上规则并不使用内置类型，以及STL迭代器，和函数对象。它们采用pass-by-value更合适(其实采用pass-by-reference-to-const也可以)<br>对象以by value的方式传递，其实际意义是由该对象的copy constructor决定的。这可能会使pass-by-value成为成本很高的动作。<br>以pass by reference，还可以避免所谓的“切割slicing问题”，又称为“upcasting问题”。详见《Thingking in C＋＋》P629<br>pass by reference是一件美妙的事情，但会导致某些复杂性。最知名的问题就是aliasing(别名问题)，见条款17。某些情况下必须pass by value。references的底层几乎都是指针完成，所以passing by reference通常意味着传递的是指针。如果有个小对象，例如一个int，那么pass by value可能比pass by reference的效率更高一些。  </p><ul><li>必须返回对象时，别妄想返回其reference</li></ul><p>1.不要返回pointer或者reference指向一个on stack对象(被析构)<br>2.不要返回pointer或者reference指向一个on heap对象(需要用户delete，我觉得必要的时候也不是不可以)<br>3.不要返回pointer或者reference指向local static对象，却需要多个这样的对象(static只能有一份)</p><ul><li>将成员变量申明为private</li></ul><p>1.切记将成员变量申明为private<br>2.protected并不比public更有封装性(用户可能继承你的base class)</p><h3 id="宁以non-member，non-friend替换member"><a href="#宁以non-member，non-friend替换member" class="headerlink" title="宁以non-member，non-friend替换member"></a>宁以non-member，non-friend替换member</h3><p>作者说多一个成员函数，就多一分破坏封装性，好像有点道理，但是我们都没有这样遵守。直接写member函数方便一些。</p><h3 id="若所有参数都需要类型转换，请为此采用non-member函数"><a href="#若所有参数都需要类型转换，请为此采用non-member函数" class="headerlink" title="若所有参数都需要类型转换，请为此采用non-member函数"></a>若所有参数都需要类型转换，请为此采用non-member函数</h3><p>如果调用member函数，就使得第一个参数的类失去一次类型转换的机会。</p><h3 id="考虑写一个不抛出异常的swap函数"><a href="#考虑写一个不抛出异常的swap函数" class="headerlink" title="考虑写一个不抛出异常的swap函数"></a>考虑写一个不抛出异常的swap函数</h3><ol><li><p>当std::swap效率不高(std::swap调用拷贝构造函数和赋值操作符，如果是深拷贝，效率不会高)，提供一个swap成员函数，并确定不会抛出异常。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token keyword">const</span> Obj<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//深拷贝}</span> Obj<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Obj<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>深拷贝<span class="token keyword">private</span><span class="token operator">:</span> OtherClass <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果提供一个member swap，也该提供一个non-member swap用来调用前者</p></li></ol><ol start="3"><li><p>调用swap时应该针对std::swap使用using声明式，然后调用swap不带任何”命名空间修饰”</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Obj<span class="token operator">&amp;</span> o1<span class="token punctuation">,</span> Obj<span class="token operator">&amp;</span> o2<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这样可以让编译器自己决定调用哪个swap，万一用户没有实现针对Obj的swap，还能调用std::swap</span> <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span> <span class="token function">swap</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>不要往std命名空间里面加东西</p></li></ol><h3 id="在constructor中尽量以initialization动作取代assignment动作"><a href="#在constructor中尽量以initialization动作取代assignment动作" class="headerlink" title="在constructor中尽量以initialization动作取代assignment动作"></a>在constructor中尽量以initialization动作取代assignment动作</h3><p>【尽量使用初始化列表来代替赋值】<br>const members和reference members只能被初始化，不能够被赋值（assigned）。这个时候，如果在构造函数中要对其初始化时必须用member initialization list。 另外，从效率方面考虑，也建议用以initialization动作取代assignment动作。<br>例外的情况：</p><ol><li>static class member不应该在构造函数中初始化。</li><li>如果有很多built-in type类型的class member要初始化，建议使用assignment，这和initialization在效率上没有什么区别，而且容易维护。</li><li>initialization list中的members初始化次序应该和其在class内的声明次序相同</li></ol><p>class members系以它们在class内的声明次序来初始化，和它们在member initialization list中出现的次序完全无关。基类的成员变量永远在继承类成员变量之前被初始化，所以如果运用了继承，你应该在member intialization lists起始处列出base class的初始设定值。</p><p>结论是：对象被初始化时，如果你希望确实掌握真正发生了什么事，请以class内的members声明次序，将各个memebers列于initialization list中。    </p><h3 id="区分member-functions，non-member-functions和friend-functions三者"><a href="#区分member-functions，non-member-functions和friend-functions三者" class="headerlink" title="区分member functions，non-member functions和friend functions三者"></a>区分member functions，non-member functions和friend functions三者</h3><p>member functions和non-member functions的区别是：member functions可以是虚函数，而non-member functions不可以。<br>在一个类中，只要能够避免friend函数，就应该尽量避免，“因为就像真实世界一样，朋友带来的麻烦常常多于其价值。”：）^_^</p><ol><li>虚拟函数必须是class members。</li><li>绝不要让operator&gt;&gt;和operator&lt;&lt;成为members。</li><li>如果non-member functions需要用到class的non-public members，让它成为class的friend functions。   </li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="尽可能延后变量定义式出现的时间"><a href="#尽可能延后变量定义式出现的时间" class="headerlink" title="尽可能延后变量定义式出现的时间"></a>尽可能延后变量定义式出现的时间</h3><p>C语言推荐在函数开始的时候定义所有变量(最开始的C语言编译器要求，现在并不需要)，C++推荐在使用对象前才定义对象</p><h3 id="尽量少做转型动作"><a href="#尽量少做转型动作" class="headerlink" title="尽量少做转型动作"></a>尽量少做转型动作</h3><ol><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。</li><li>如果转型是必要的，试着将它隐藏于某个函数后。客户可以随时调用该函数，而不需要将转型放入自己的代码。</li><li>使用C++风格的转型。</li></ol><h3 id="避免返回handles指向对象内部成分"><a href="#避免返回handles指向对象内部成分" class="headerlink" title="避免返回handles指向对象内部成分"></a>避免返回handles指向对象内部成分</h3><p>简单说，就是成员函数返回指针或者非const引用不要指向成员变量，这样会破坏封装性</p><h3 id="为“异常安全”而努力是值得的"><a href="#为“异常安全”而努力是值得的" class="headerlink" title="为“异常安全”而努力是值得的"></a>为“异常安全”而努力是值得的</h3><ul><li><p>“异常安全函数”承诺即使发生异常也不会有资源泄漏。在这个基础下，它有3个级别 </p><ol><li>基本保证：抛出异常，需要用户处理程序状态改变(自己写代码保证这个级别就行了把)</li><li>强烈保证：抛出异常，程序状态恢复到调用前</li><li>不抛异常：内置类型的操作就绝不会抛出异常</li></ol></li><li><p>“强烈保证”往往可以通过copy-and-swap实现，但是”强烈保证”并非对所有函数都具有实现意义</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//我反正从来没有这样写过</span><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>  Object <span class="token function">new_obj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  new_obj<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token function">swap</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> new_obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="透彻了解inline函数的里里外外"><a href="#透彻了解inline函数的里里外外" class="headerlink" title="透彻了解inline函数的里里外外"></a>透彻了解inline函数的里里外外</h3><p>这里插播一个C++处理定义的重要原则，一处定义原则：</p><ul><li><p>全局变量，静态数据成员，非内联函数和成员函数只能整个程序定义一次</p></li><li><p>类类型(class，struct,union)，内联函数可以每个翻译单元定义一次 </p><ol><li>template类的成员函数或者template函数，定义在头文件中，编译器可以帮忙去重</li><li>普通类的template函数，定义在头文件中，需要加inline</li></ol></li><li><p>inline应该限制在小的，频繁调用的函数上</p></li><li><p>inline只是给编译器的建议，编译器不一定执行</p></li></ul><h3 id="将文件的编译依存关系降到最低"><a href="#将文件的编译依存关系降到最低" class="headerlink" title="将文件的编译依存关系降到最低"></a>将文件的编译依存关系降到最低</h3><ol><li>支持”编译依存最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes(impl对象提供服务)和Interface classes。</li></ol><p>其实就是使用前置声明，下面有个需要注意的点</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Obj.h</span><span class="token keyword">class</span> <span class="token class-name">ObjImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>ObjImpl<span class="token operator">></span> pObjImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上面的写法会报错，因为编译器会再.h文件里面产生默认的析构函数，</span><span class="token comment" spellcheck="true">//析构函数要调用ObjImpl的析构函数，然后我们现在只有声明式，不能调用ObjImpl的实现。</span><span class="token comment" spellcheck="true">//下面的实现才是正确的</span><span class="token comment" spellcheck="true">//Obj.h</span><span class="token keyword">class</span> <span class="token class-name">ObjImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//声明</span>    <span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>ObjImpl<span class="token operator">></span> pObjImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Obj.cpp</span><span class="token comment" spellcheck="true">//现在可以看到ObjImpl的实现</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;ObjImpl></span></span>Obj<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于STL的对象不需要前置声明。</p><h2 id="继承与面对对象设计"><a href="#继承与面对对象设计" class="headerlink" title="继承与面对对象设计"></a>继承与面对对象设计</h2><h3 id="确定你的public继承塑模出is-a模型"><a href="#确定你的public继承塑模出is-a模型" class="headerlink" title="确定你的public继承塑模出is-a模型"></a>确定你的public继承塑模出is-a模型</h3><p>public继承意味着is-a。适用于base class身上的每一个函数也一定适用于derived class。</p><h3 id="避免遮掩继承而来的名称"><a href="#避免遮掩继承而来的名称" class="headerlink" title="避免遮掩继承而来的名称"></a>避免遮掩继承而来的名称</h3><p>子作用域会遮掩父作用域的名称。一般来讲，我们可以有以下几层作用域</p><ul><li>global作用域</li><li>namespace作用域 <ul><li>Base class作用域 <ul><li>Drive class作用域 <ul><li>成员函数 <ul><li>控制块作用域</li></ul></li></ul></li></ul></li><li>非成员函数作用域 <ul><li>控制块作用域</li></ul></li></ul></li></ul><p>注意：遮掩的是上一层作用域的名称，重载(不同参数)的函数也会直接遮掩</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//会遮掩f1()，子类并没有继承f1()</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Drive d<span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>可以通过<span class="token keyword">using</span>声明式或者<span class="token keyword">inline</span>转交解决这一问题<span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//using 声明式</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token operator">::</span>f1<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//inline转交</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Base<span class="token operator">::</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区分接口继承和实现继承"><a href="#区分接口继承和实现继承" class="headerlink" title="区分接口继承和实现继承"></a>区分接口继承和实现继承</h3><ol><li>纯虚函数：提供接口继承 <ol><li>Drived class必须实现纯虚函数</li><li>不能构造含有纯虚函数的类</li><li>纯虚函数可以有成员变量</li><li>可以给纯虚函数提供定义(wtf)</li></ol></li><li>虚函数：提供接口继承和默认的实现继承</li><li>非虚函数：提供了接口继承和强制的实现继承(最好不要在Drived class重新定义非虚函数)</li></ol><p>在编写自己的 class 时，你应该明白提供下面 3 种类型函数的理由</p><ul><li>pure virtual function</li><li>virtual function</li><li>no-virtual function</li></ul><p>何时提供 pure virtual function？</p><p>要求派生类只继承接口时，提供纯虚函数。【就像下单函数一样，其作用就是提供接口让你来重写】</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span>vitrual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>；何时提供 <span class="token keyword">virtual</span> function？要求派生类只继承接口和缺省实现时，提供虚函数。<span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span>vitrual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>何时提供 no-virtual function？</p><p>要求派生类只继承接口的强制实现时，提供非虚函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原则</strong></p><ul><li>纯虚函数指定接口继承。//这跟XTP中的订阅反馈函数的重载一样</li><li>虚函数指定接口和缺省实现继承。  //</li><li>非虚函数指定接口的强制实现继承。</li><li>接口继承和实现继承不同。</li></ul><h3 id="考虑virtual函数以外的选择"><a href="#考虑virtual函数以外的选择" class="headerlink" title="考虑virtual函数以外的选择"></a>考虑virtual函数以外的选择</h3><pre class="line-numbers language-cpp"><code class="language-cpp">non<span class="token operator">-</span><span class="token keyword">virtual</span> interface：提供非虚接口<span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优点：</strong></p><ul><li>可以在调用虚函数的前后，做一些准备工作(抽出一段重复代码)</li><li>提供良好的ABI兼容性</li></ul><h3 id="聊一聊ABI兼容性"><a href="#聊一聊ABI兼容性" class="headerlink" title="聊一聊ABI兼容性"></a>聊一聊ABI兼容性</h3><p>我们知道，程序库的优势之一是库版本升级，只要保证借口的一致性，用户不用修改任何代码。<br>一般一个设计完好的程序库都会提供一份C语言接口，为什么呢，我们来看看C++ ABI有哪些脆弱性。</p><ul><li>虚函数的调用方式，通常是 vptr/vtbl 加偏移量调用</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Object.h</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>···    <span class="token keyword">virtual</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第3个虚函数</span>···<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用户代码</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Object <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> Object<span class="token punctuation">;</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//编译器：vptr[3]()</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//如果加了虚函数，用户代码根据偏移量找到的是newfun函数</span><span class="token comment" spellcheck="true">//Object.h</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>···    <span class="token keyword">virtual</span> <span class="token function">newfun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第3个虚函数</span>    <span class="token keyword">virtual</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第4个虚函数</span>···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>name mangling 名字粉碎实现重载</li></ul><p>C++没有为name mangling制定标准。例如void fun(int)，有的编译器定为fun_int_，有的编译器指定为fun%int%。<br>因此，C++接口的库要求用户必须和自己使用同样的编译器(这个要求好过分)</p><ul><li>其实C语言接口也不完美</li></ul><p>例如struct和class。编译阶段，编译器将struct或class的对象对成员的访问通过偏移量来实现</p><h3 id="使用std-fun提供回调"><a href="#使用std-fun提供回调" class="headerlink" title="使用std::fun提供回调"></a>使用std::fun提供回调</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> doInterface<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="古典策略模式"><a href="#古典策略模式" class="headerlink" title="古典策略模式"></a>古典策略模式</h3><p>用另外一个继承体系替代</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        p<span class="token operator">-</span><span class="token operator">></span><span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    BaseInterface <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BaseInterface</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绝不重新定义继承而来的non-virtual函数"><a href="#绝不重新定义继承而来的non-virtual函数" class="headerlink" title="绝不重新定义继承而来的non-virtual函数"></a>绝不重新定义继承而来的non-virtual函数</h3><p>记住就行</p><h3 id="绝不重新定义继承而来的缺省参数值"><a href="#绝不重新定义继承而来的缺省参数值" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Drive "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                                                                 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                                                          Base <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> Drive<span class="token punctuation">;</span>                                                               b<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//   vptr[0](1)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Drive 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺省参数值是静态绑定</li><li>虚函数是动态绑定</li><li>遵守这条规定防止出错</li></ul><h3 id="通过复合塑模出has-a或者”根据某物实现出”"><a href="#通过复合塑模出has-a或者”根据某物实现出”" class="headerlink" title="通过复合塑模出has-a或者”根据某物实现出”"></a>通过复合塑模出has-a或者”根据某物实现出”</h3><ol><li>复合的意义和public完全不一样</li><li>根据某物实现出和is-a的区别：</li></ol><p>这个也是什么时候使用继承，什么时候使用复合。复合代表使用了这个对象的某些方法，但是却不想它的接口入侵。</p><h3 id="明智而审慎地使用private继承"><a href="#明智而审慎地使用private继承" class="headerlink" title="明智而审慎地使用private继承"></a>明智而审慎地使用private继承</h3><ol><li>private继承是”根据某物实现出“</li><li>唯一一个使用private继承的理由就是，可以使用空白基类优化技术，节约内存空间</li></ol><h3 id="C-对空类的处理"><a href="#C-对空类的处理" class="headerlink" title="C++对空类的处理"></a>C++对空类的处理</h3><p>C++ 设计者在设计这门语言要求所有的对象必须要有不同的地址(C语言没有这个要求)。C++编译器的实现方式是给让空类占据一个字节。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//8个字节</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    Base b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4个字节</span>classObject <span class="token operator">:</span> <span class="token keyword">private</span> Base<span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="明智而审慎地使用多重继承"><a href="#明智而审慎地使用多重继承" class="headerlink" title="明智而审慎地使用多重继承"></a>明智而审慎地使用多重继承</h3><p>首先我们来了解一下多重继承的内存布局。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//包含A对象</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B对象</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,C对象</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,A,B,C,D对象</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span><span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C<span class="token punctuation">{</span><span class="token punctuation">}</span>由于菱形继承，基类被构造了两次。其实，C<span class="token operator">++</span>也提供了针对菱形继承的解决方案的<span class="token comment" spellcheck="true">//包含A对象</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B对象</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,C对象</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B,C,D对象</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span><span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C<span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用虚继承，B,C对象里面会产生一个指针指向唯一一份A对象。这样付出的代价是必须再运行期根据这个指针的偏移量寻找A对象。</p><p>多重继承唯一的那么一点点用就是一个Base class提供public继承，另一个Base class提供private继承。(还是没什么用啊，干嘛不适用复合)</p><h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="了解隐式接口和编译期多态"><a href="#了解隐式接口和编译期多态" class="headerlink" title="了解隐式接口和编译期多态"></a>了解隐式接口和编译期多态</h3><ol><li>接口：强制用户实现某些函数</li><li>多态：相同的函数名，却有不同的实现</li><li>继承和模板都支持接口和多态</li><li>对继承而言，接口是显式的，以函数为中心，多态发生在运行期；</li><li>对模板而言，接口是隐式的，多态表现在template具象化和函数重载<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//这里接口要求T必须实现operator ></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T <span class="token function">max</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="了解typename的双重意义"><a href="#了解typename的双重意义" class="headerlink" title="了解typename的双重意义"></a>了解typename的双重意义</h3><ol><li>声明template参数时，前缀关键字class和typename可以互换</li><li>使用typename表明嵌套类型(防止产生歧义)</li></ol><p><strong>第一层：</strong>作为类模板的参数时，与 class 功能相同。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyTYpe</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个定义完全相同。</p><p><strong>第二层：</strong> typename 可以让模板里面定义嵌套从属名称的类型变成有效的类型，因为 C++ 的解析器在模板中遇到嵌套从属类型时，默认认为它是无效的类型。</p><p>例如：无效的嵌套从属类型</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>        T<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要认为指定它为有效的嵌套从属类型</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">typename</span> T<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况 当你想在 template 中指定一个有效的嵌套从属类型名称，只需要在嵌套从属类型前面加上 typename 关键字即可。<br><strong>例外</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">*</span> 不得在 base <span class="token keyword">class</span> <span class="token class-name">list</span> 中使用 <span class="token keyword">typename</span><span class="token comment" spellcheck="true">/* 错误用法 */</span><span class="token keyword">class</span> <span class="token class-name">Deriver</span> <span class="token operator">:</span> <span class="token keyword">public</span> <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>MyType<span class="token punctuation">;</span><span class="token operator">*</span> 不得在 member initialization list 中使用 <span class="token keyword">typename</span><span class="token keyword">class</span> <span class="token class-name">Deriver</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>MyType<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment" spellcheck="true">/* 错误用法 */</span>  <span class="token keyword">explicit</span> <span class="token function">Deriver</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">MyType</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原则</strong></p><ul><li><p>class 和 typename 在声明模板参数时作用相同。</p></li><li><p>使用 typename 标识嵌套从属类型，但是不得在 base class list 和 member initialization list 中使用。</p></li></ul><h3 id="学习处理模板化基类内的名称"><a href="#学习处理模板化基类内的名称" class="headerlink" title="学习处理模板化基类内的名称"></a>学习处理模板化基类内的名称</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>                                                                        <span class="token keyword">public</span><span class="token operator">:</span>                                                                              <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>                                                             <span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>                                                    <span class="token keyword">public</span><span class="token operator">:</span>                                                                            <span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span><span class="token punctuation">{</span>                                                            <span class="token comment" spellcheck="true">//error 编译器不知道基类有print函数</span>    <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解决方案</span><span class="token comment" spellcheck="true">//this->print();</span><span class="token comment" spellcheck="true">//using Base&lt;T>::print</span><span class="token comment" spellcheck="true">//base&lt;T>::print直接调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将参数无关代码抽离template"><a href="#将参数无关代码抽离template" class="headerlink" title="将参数无关代码抽离template"></a>将参数无关代码抽离template</h3><ol><li>非类型模板参数造成的代码膨胀：以函数参数或者成员变量替换</li><li>类型模板参数造成的代码膨胀：特化它们，让含义相近的类型模板参数使用同一份底层代码。例如int，long, const int</li></ol><h3 id="运用成员函数模版接收所有兼容类型"><a href="#运用成员函数模版接收所有兼容类型" class="headerlink" title="运用成员函数模版接收所有兼容类型"></a>运用成员函数模版接收所有兼容类型</h3><p>我们来考虑一下智能指针的拷贝构造函数和赋值操作符怎么实现。它需要子类的智能指针能够隐式转型为父类智能指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//拷贝构造函数，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//赋值操作符，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//声明正常的拷贝构造函数</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span>；    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    T <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用成员函数模版生成“可接受所有兼容类型”的函数</li><li>即使有了“泛化拷贝构造函数”和“泛化的赋值操作符”，仍然需要声明正常的拷贝构造函数和赋值操作符</li><li>在一个类模版内，template名称可被用来作为作为“template和其参数”的简略表达式</li></ul><h3 id="所有参数需要类型转换的时候请为模版定义非成员函数"><a href="#所有参数需要类型转换的时候请为模版定义非成员函数" class="headerlink" title="所有参数需要类型转换的时候请为模版定义非成员函数"></a>所有参数需要类型转换的时候请为模版定义非成员函数</h3><ol><li>当我们编写一个模版类，某个相关函数都需要类型转换，需要把这个函数定义为非成员函数</li><li>但是模版的类型推到遇见了问题，需要把这个函数声明为友元函数帮助推导</li><li>模版函数只有声明编译器不会帮忙具现化，所以我们需要实现的是友元模版函数<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">{</span> … <span class="token keyword">friend</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">Rational</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">GetNumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">.</span><span class="token function">GetNumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         a<span class="token punctuation">.</span><span class="token function">GetDenominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">.</span><span class="token function">GetDenominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> …<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="请使用traits-classes表现类型信息"><a href="#请使用traits-classes表现类型信息" class="headerlink" title="请使用traits classes表现类型信息"></a>请使用traits classes表现类型信息</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">ccSizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> type_traits<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>size<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>traits采用类模版和特化的方式，为不同的类型提供了相同的类型抽象(都由size)</li><li>为某些类型提供编译期测试，例如is_fundamental(是否为内置类型)</li></ul><h2 id="模版元编程"><a href="#模版元编程" class="headerlink" title="模版元编程"></a>模版元编程</h2><p>本质上就是函数式编程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//上楼梯，每次上一步或者两步，有多少种</span><span class="token keyword">int</span> <span class="token function">climb</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//元编程，采用类模版</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>n <span class="token operator">+</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-2</span><span class="token operator">></span><span class="token operator">::</span>n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>C++元编程可以将计算转移到编译期，执行速度迅速(缺陷？)</li></ul><h2 id="函数调用的栈结构："><a href="#函数调用的栈结构：" class="headerlink" title="函数调用的栈结构："></a>函数调用的栈结构：</h2><p>当编译器为函数调用生成代码时，首先将参数从右至左压栈，然后是函数返回的地址（Return Address）压栈，同时在函数内部，生成代码来将堆栈指针移动（向上或向下，这要视机器而定），为函数的本地变量提供存储空间。当函数调用完毕，栈指针将移动到函数（Return Address）的位置，这样函数的本地变量出栈。那么函数的返回值（尤其是一个自定义的类型）存放在什么地方？答案是将函数的返回值作为一个参数压栈，直接将返回值的信息拷贝至该参数中。这个答案没有解决所有的问题，但它效率很高。</p><p>下面是一个函数调用的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> f（<span class="token keyword">int</span> x，<span class="token keyword">char</span> c）；<span class="token keyword">int</span> g＝f（a，b）；看一下它对应的汇编代码：push b；push a；call f（）；add sp，<span class="token number">4</span>；mov g，<span class="token keyword">register</span> a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先是两个参数压栈，然后调用函数，完了将参数出栈，将返回值放在寄存器中（因为int是built-in type），传递给返回值g。这与上面讲的函数调用的过程稍有不同。插一句：前段时间碰到很多次stack overflow的错误，搞死我了。但是当我理解了函数调用背后的故事后，stack overflow的问题终于暂时解决了。</p><p>何为copy constructor？</p><p>当需要从一个已存在的对象创建另一个对象时，会调用copy constructor。当然，我们也可以阻止这样的行为。忠告中会讲到。<br>看下面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//copy constructor</span><span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//assignment operator</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">char</span> <span class="token operator">*</span>m_data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果缺少了copy constructor和assignment operator，当进行复制时会进行bitcopy，也就是按位进行拷贝。试想如果上面的类中没有copy constructor和assignment operator，调用如下语句时的问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">String a（“hello”）；<span class="token comment" spellcheck="true">//m_data指向字符串“hello”</span>String b（“World”）；<span class="token comment" spellcheck="true">//m_data指向字符串“world”</span>b＝a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样，经过bitcopy，a和b中的m_data都指向“hello”，“world”没人管了，Memory Leak！！！而且，当a或b中的一个调用了析构函数后，“hello”所在的内存将被释放，这样另一个中的指针指向了一片非法内存！！！</p><p>忠告：如果class的成员变量中含有任何指针，请为这个类写copy constructor和assignment operator。但是你如果确信你的class不会执行copy和assignment动作，这时候写copy constructor和assignment operator会觉得有点得不偿失，这时候将copy-construction（No definition）声明为private，将阻止使用值传递方式(pass an object of your class by value)。呵呵，我知道这个时候你的头在游泳了。</p><h2 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h2><h3 id="了解new-handler的行为"><a href="#了解new-handler的行为" class="headerlink" title="了解new-handler的行为"></a>了解new-handler的行为</h3><p>new和malloc对比：</p><ul><li>new构造对象，malloc不会</li><li>new分配不出内存会抛异常，malloc返回NULL</li><li>new分配不出内存可以调用用户设置的new-handler，malloc没有<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> std<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>new_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回旧的handler</span>  new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以为每个类设置专属new handler</li></ul><h3 id="了解new和delete合理的替换时机"><a href="#了解new和delete合理的替换时机" class="headerlink" title="了解new和delete合理的替换时机"></a>了解new和delete合理的替换时机</h3><p>C++中对象的构造和析构经历了都两个阶段</p><ul><li>operator new, operator delete：分配和释放内存</li><li>调用构造函数，调用析构函数</li></ul><p>替换new和delete的理由，就是需要收集分配内存的资源信息</p><h3 id="编写符合常规的new和delete"><a href="#编写符合常规的new和delete" class="headerlink" title="编写符合常规的new和delete"></a>编写符合常规的new和delete</h3><ol><li>operator new应该内含一个无穷循环尝试分配内存，如果无法满足，就调用new-handler。class版本要处理“比正确大小更大的(错误)申请”</li><li>operator deleter应该处理Null。classz专属版本还要处理“比正确大小更小的(错误)申请”</li></ol><h3 id="写了operator-new也要写相应的operator-delete"><a href="#写了operator-new也要写相应的operator-delete" class="headerlink" title="写了operator new也要写相应的operator delete"></a>写了operator new也要写相应的operator delete</h3><p>我们知道，new一个对象要经历两步。如果在调用构造函数失败，编译器会寻找一个“带相同额外参数”的operator delete，否则就不调用，造成资源泄漏</p><p>我觉得这个条款讲的不是太通俗，所以我决定来个“俗”点的：<br>重载new和delete时必须要做到的，这里的重载包括（参见《Thinking in C++》）：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Overloading global <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>Overloading <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span> fro a <span class="token keyword">class</span><span class="token punctuation">;</span>Overloading <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span> <span class="token keyword">for</span> arrays。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不过现在有了这练习上乘内功的口诀，就不怕走火入魔了。</p><p>口诀：</p><ol><li>正确的返回值</li><li>内存不足，调用错误处理函数</li><li>不索求任何内存时的调用</li><li>避免不经意遮掩了“正常”形式的new(见条款9)</li></ol><h3 id="问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？"><a href="#问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？" class="headerlink" title="问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？"></a>问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？</h3><p>解决：</p><ol><li><p>祭出inline函数，搞定！</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span><span class="token keyword">public</span>：<span class="token keyword">void</span> f（）；<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">,</span> new_handler p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//我们重载，为了区别，则多添加一个参数</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这是系统自己的</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为自己重载new添加的额外参数添加默认参数值，一样搞定！</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span><span class="token keyword">public</span>：<span class="token keyword">void</span> f（）；<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">,</span> new_handler p＝<span class="token number">0</span>）<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="绝不重新定义继承而来的缺省参数值-1"><a href="#绝不重新定义继承而来的缺省参数值-1" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Drive "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                                                                 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                                                          Base <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> Drive<span class="token punctuation">;</span>                                                               b<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//   vptr[0](1)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Drive 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺省参数值是静态绑定</li><li>虚函数是动态绑定</li><li>遵守这条规定防止出错</li></ul><h3 id="运用成员函数模版接收所有兼容类型-1"><a href="#运用成员函数模版接收所有兼容类型-1" class="headerlink" title="运用成员函数模版接收所有兼容类型"></a>运用成员函数模版接收所有兼容类型</h3><p>我们来考虑一下智能指针的拷贝构造函数和赋值操作符怎么实现。它需要子类的智能指针能够隐式转型为父类智能指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//拷贝构造函数，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//赋值操作符，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//声明正常的拷贝构造函数</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span>；    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    T <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用成员函数模版生成“可接受所有兼容类型”的函数</li><li>即使有了“泛化拷贝构造函数”和“泛化的赋值操作符”，仍然需要声明正常的拷贝构造函数和赋值操作符</li><li>在一个类模版内，template名称可被用来作为作为“template和其参数”的简略表达式</li></ul><h2 id="模版元编程-1"><a href="#模版元编程-1" class="headerlink" title="模版元编程"></a>模版元编程</h2><p>本质上就是函数式编程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//上楼梯，每次上一步或者两步，有多少种</span><span class="token keyword">int</span> <span class="token function">climb</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//元编程，采用类模版</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>n <span class="token operator">+</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-2</span><span class="token operator">></span><span class="token operator">::</span>n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++元编程可以将计算转移到编译期，执行速度迅速(缺陷？)</p><h2 id="STL使用小细节"><a href="#STL使用小细节" class="headerlink" title="STL使用小细节"></a>STL使用小细节</h2><h3 id="删除连续容器-vector-deque-string-的元素"><a href="#删除连续容器-vector-deque-string-的元素" class="headerlink" title="删除连续容器(vector,deque,string)的元素"></a>删除连续容器(vector,deque,string)的元素</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 当c是vector、string，删除value</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除</span><span class="token keyword">bool</span> <span class="token function">assertFun</span><span class="token punctuation">(</span>valuetype<span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove_if</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> assertFun<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 有时候我们不得不遍历去完成，并删除</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除list中某个元素"><a href="#删除list中某个元素" class="headerlink" title="删除list中某个元素"></a>删除list中某个元素</h3><pre class="line-numbers language-cpp"><code class="language-cpp">c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除    </span>c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>assertFun<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span> 删除关联容器<span class="token punctuation">(</span>set<span class="token punctuation">,</span>map<span class="token punctuation">)</span>中某个元素c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件神器——软件记录</title>
      <link href="/2020/01/01/ruan-jian-shen-qi-ruan-jian-ji-lu/"/>
      <url>/2020/01/01/ruan-jian-shen-qi-ruan-jian-ji-lu/</url>
      
        <content type="html"><![CDATA[<hr><p>用来记录我喜爱的软件应用，仅限window用户</p><hr><hr><p><strong>所有软件直接百度至官网或者xxx贴中下载，因为链接总会死，所以此处不给附上链接</strong></p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ol><li><p><a href="https://www.google.com/intl/zh-CN/chrome/" target="_blank" rel="noopener">Goole Chrome</a><br> 你们的最爱</p></li><li><p><a href="https://browser.360.cn/ee/" target="_blank" rel="noopener">360极速浏览器</a><br> 我的最爱</p></li></ol><h3 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h3><ol><li><p><a href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener">Visual Studio</a><br> 社区版免费，支持各类语言，C的爹</p></li><li><p><a href="https://ww2.mathworks.cn/products/matlab.html" target="_blank" rel="noopener">MATLAB</a><br> 数据分析</p></li><li><p><a href="https://www.anaconda.com" target="_blank" rel="noopener">Anaconda</a><br> 机器学习、爬虫</p></li><li><p><a href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">PyCharm</a><br> python的爹</p></li><li><p><a href="https://www.netsarang.com/zh/xshell/" target="_blank" rel="noopener">Xshell&amp;shell家族</a><br> linux服务器远程必备</p></li><li><p><a href="https://www.qt.io/download" target="_blank" rel="noopener">QT</a><br> 界面开发</p></li><li><p><a href="https://git-scm.com" target="_blank" rel="noopener">git</a><br> 仓库备份</p></li><li><p><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">VMware Workstation</a><br> 虚拟机</p></li><li><p><a href="https://cmake.org" target="_blank" rel="noopener">Cmake</a><br> C++项目不可少</p></li><li><p><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">sublime</a><br>代码编辑神器，我离不开了</p></li><li><p><a href="https://notepad-plus-plus.org/downloads/" target="_blank" rel="noopener">Notepad++</a><br>代码编辑器，界面风格巨丑</p></li><li><p><a href="https://www.ultraedit.com/#" target="_blank" rel="noopener">Ultra家族</a><br>代码对比，编辑，文件传输，泽家族都干</p></li></ol><h3 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h3><ol><li><p><a href="https://calibre-ebook.com" target="_blank" rel="noopener">calibre</a><br> 各类电子书的阅读神器</p></li><li><p><a href="https://www.office.com" target="_blank" rel="noopener">office</a><br> 呵呵🙂</p></li><li><p><a href="https://www.wps.cn" target="_blank" rel="noopener">WPS</a><br> 国产的？！真香😄</p></li><li><p><a href="https://products.office.com/zh-cn/visio/" target="_blank" rel="noopener">visio</a><br> 专业流程图，不要安装与office用一版本，会失败</p></li><li><p><a href="http://www.ctex.org/CTeXDownload" target="_blank" rel="noopener">LaTex</a><br> 就是LaTex，著名的论文排版神器</p></li></ol><h3 id="社交应用"><a href="#社交应用" class="headerlink" title="社交应用"></a>社交应用</h3><ol><li><p><a href="https://tim.qq.com/" target="_blank" rel="noopener">TIM</a><br> 替代QQ</p></li><li><p><a href="https://weixin.qq.com/" target="_blank" rel="noopener">微信</a><br> 你不用？！</p></li></ol><h3 id="下载神器"><a href="#下载神器" class="headerlink" title="下载神器"></a>下载神器</h3><ol><li><p><a href="https://pan.baidu.com" target="_blank" rel="noopener">百度网盘</a><br> 不是神器，渣渣，真香！</p></li><li><p><a href="https://www.xunlei.com" target="_blank" rel="noopener">迅雷</a><br> 无会员比死</p></li><li><p><a href="http://pandownload.com" target="_blank" rel="noopener">PanDownload</a><br> 希望崛起，貌似死了</p></li><li><p><a href="http://enfi.cloud" target="_blank" rel="noopener">ENFI下载器</a><br> 这是我唯一舍得花钱的网盘下载器</p></li><li><p><a href="https://www.apowersoft.cn/video-download-capture" target="_blank" rel="noopener">Apowersoft视频下载王</a><br> B站视频可下载</p></li></ol><h3 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h3><ol><li><p><a href="https://yasuo.360.cn" target="_blank" rel="noopener">360压缩</a><br> 速度不是盖的</p></li><li><p><a href="https://www.teamviewer.cn/cn/" target="_blank" rel="noopener">TeamView</a><br> 远程必备，安装时记得选择个人使用</p></li><li><p><a href="https://products.office.com/en-us/onenote/digital-note-taking-app" target="_blank" rel="noopener">OneNote</a><br> 个人认为最强大的笔记软件</p></li><li><p><a href="https://onedrive.live.com/about/en-US/" target="_blank" rel="noopener">OneDrive</a><br> 为了不让你的OneNote丢失，你必须后台一直开着它    </p></li><li><p><a href="https://daumpotplayer.com/download/" target="_blank" rel="noopener">PotPlayer</a><br> 视频播放神器，还有视频源哦</p></li></ol><h3 id="简直神器"><a href="#简直神器" class="headerlink" title="简直神器"></a>简直神器</h3><ol><li><p><a href="http://www.bingdian001.com" target="_blank" rel="noopener">fish</a><br> 百度文库的克星</p></li><li><p><a href="https://www.onlinedown.net/soft/1225142.htm" target="_blank" rel="noopener">DesktopNotes</a><br> 桌面便签必备</p></li><li><p><a href="https://justgetflux.com" target="_blank" rel="noopener">f.lux</a><br> 屏幕护眼</p></li><li><p><a href="https://tianruoocr.cn" target="_blank" rel="noopener">天若OCR</a><br> 截图文字识别神器</p></li><li><p><a href="https://zh.snipaste.com" target="_blank" rel="noopener">Snipaste</a><br> 一键截图，我的爱</p></li><li><p><a href="https://www.faststone.org/FSCaptureDetail.htm" target="_blank" rel="noopener">FSCapture</a><br> 长屏截图</p></li><li><p><a href="http://www.mathtype.cn" target="_blank" rel="noopener">Math Type</a><br> 公式编辑器</p></li><li><p><a href="https://www.pcworld.com/article/3202314/microsoft-onenote-add-ins-and-tools.html" target="_blank" rel="noopener">notegem2016</a><br> 配合OneNote笔记的一个神助攻</p></li><li><p><a href="https://download.cnet.com/TakeColor/3000-2192_4-10387506.html" target="_blank" rel="noopener">TakeColor</a><br> 颜色获取神器</p></li></ol><h3 id="软件下载网站"><a href="#软件下载网站" class="headerlink" title="软件下载网站"></a>软件下载网站</h3><ol><li><p><a href="https://apkpure.com/cn/search?q=APkpure&t=app" target="_blank" rel="noopener">apkpure</a><br> 需翻墙，良心的GoolePlay</p></li><li><p><a href="https://play.google.com/store?hl=zh-CN&tab=w81" target="_blank" rel="noopener">GoolePlay</a><br> 你知道的</p></li><li><p><a href="http://yx.bsh.me" target="_blank" rel="noopener">异星空间</a><br> 软件下载的好地址</p></li><li><p><a href="http://sj.qq.com/index.html" target="_blank" rel="noopener">应用宝</a><br> 腾讯的</p></li><li><p><a href="https://pc.qq.com" target="_blank" rel="noopener">腾讯软件中心</a><br> 腾讯的PC版</p></li><li><p><a href="http://www.carrotchou.blog" target="_blank" rel="noopener">胡萝卜周</a><br> 反正我粉了</p></li><li><p><a href="http://www.zdfans.com" target="_blank" rel="noopener">ZD423</a><br> 我是铁粉</p></li><li><p><a href="https://mirrors.tuna.tsinghua.edu.cn" target="_blank" rel="noopener">清华镜像</a><br> 很强的镜像网站</p></li><li><p><a href="https://www.coolapk.com" target="_blank" rel="noopener">酷安</a><br> 什么都别说，我手机安的就是酷安，所有软件都来自于它</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode——004-Median-of-Two-Sorted-Arrays</title>
      <link href="/2019/12/30/leetcode-004-median-of-two-sorted-arrays/"/>
      <url>/2019/12/30/leetcode-004-median-of-two-sorted-arrays/</url>
      
        <content type="html"><![CDATA[<p><strong>Description</strong></p><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p><strong>Example 1:</strong></p><pre><code>nums1 = [1, 3]   nums2 = [2]   </code></pre><pre><code>The median is 2.0   </code></pre><p><strong>Example 2:</strong></p><pre><code>nums1 = [1, 2]   nums2 = [3, 4]   </code></pre><pre><code>The median is (2 + 3)/2 = 2.5</code></pre><p><strong>solution</strong><br>当一看到这道题的算法复杂度的限制为O(log(m+1)),<br>就可以排除将两个数组排序后再寻找中位数。<br>感觉题目又在提示我们使用二分法，但感觉此处没法使用二分法。  </p><p>我的方法就是一边排序一遍判断是否是位，即使用k来对数组A，B进行排序，<br>当k==（A+B）/2【数组大小】时，即可直接返回中位数，唯一值得注意的就是数组大小为奇数还是偶数的问题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>sum <span class="token operator">+</span><span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> sum <span class="token operator">+</span><span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReturn</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReturn</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReturn</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> k<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">isReturn</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">&amp;</span>sum<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> mid <span class="token operator">&amp;&amp;</span> s <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            sum <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>借鉴</strong><br>借鉴一下<a href="https://github.com/grandyang/leetcode/issues/4" target="_blank" rel="noopener">大神</a>的思路,<br>使用递归求解，但大致思路和我一样。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">findKth</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums2<span class="token punctuation">[</span>j <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums1<span class="token punctuation">[</span>i <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> midVal1 <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums1<span class="token punctuation">[</span>i <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> midVal2 <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums2<span class="token punctuation">[</span>j <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>midVal1 <span class="token operator">&lt;</span> midVal2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> i <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">-</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">findKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> i<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> j <span class="token operator">+</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k <span class="token operator">-</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中位数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件神器——Chrome插件推荐</title>
      <link href="/2019/12/30/ruan-jian-shen-qi-chrome-cha-jian-tui-jian/"/>
      <url>/2019/12/30/ruan-jian-shen-qi-chrome-cha-jian-tui-jian/</url>
      
        <content type="html"><![CDATA[<hr><p>个人感觉极速360杠杆的，Chrome能的它也能，Chrome不能的它也能！！！</p><hr><hr><p>所有插件百度名字官网，或者到对应的浏览器扩展商城，或者Chrome应用商店下载；<br>下载解压后可以直接拖拽进浏览器即可。</p><hr><h3 id="插件神库"><a href="#插件神库" class="headerlink" title="插件神库"></a>插件神库</h3><p>找插件的必备之地</p><ol><li><p><a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">chrome网上应用商店</a><br> 墙的了就使,墙不了看下面</p></li><li><p><a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a><br> 油猴脚本插件的必选之地</p></li></ol><h3 id="万能插件"><a href="#万能插件" class="headerlink" title="万能插件"></a>万能插件</h3><ol><li><p><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">油猴Tampermonkey</a></p><p> 以下插件请到<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a>中下载</p><ul><li>CNKI中国知网PDF全文下载（特制版）<br>  知网论文下载必备</li><li>【全新升级】百度文库原文档免费下载<br>  百度文库下载必备</li><li>智能划词翻译<br>  网页翻译神器</li><li>网盘自动填写密码【威力加强版】<br>  度盘分享免密</li></ul></li></ol><h3 id="安全插件"><a href="#安全插件" class="headerlink" title="安全插件"></a>安全插件</h3><ol><li><p>360安全网银<br> 钓鱼网站必死</p></li><li><p>Adblock </p></li></ol><h3 id="广告拦截"><a href="#广告拦截" class="headerlink" title="广告拦截"></a>广告拦截</h3><ol><li><p>广告终结者<br> 个人感觉还可以</p></li><li><p><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb?hl=zh-CN" target="_blank" rel="noopener">Adblock plus</a><br> Google的广告拦截插件，可以拦截YouTube得到视频广告</p></li></ol><h3 id="下载神器"><a href="#下载神器" class="headerlink" title="下载神器"></a>下载神器</h3><ol><li>GitZip for github<br> github项目不再需要全部下载，直接双击相应文件名后的空白后，出现✔选中成功；<br> 选中完毕后，点击右下脚的大箭头即可下载</li></ol><h3 id="浏览器辅助"><a href="#浏览器辅助" class="headerlink" title="浏览器辅助"></a>浏览器辅助</h3><ol><li><p>smartUp手势<br> 这是chrome的短板，我弃之而去的理由</p></li><li><p>Stylish<br> 绚丽的goole主页</p></li></ol><h3 id="万能梯"><a href="#万能梯" class="headerlink" title="万能梯"></a>万能梯</h3><ol><li><p>Ghelper<br> 买了会员，你懂的，无限制，不买会员，goole随便玩</p></li><li><p>Hoxx VPN Proxy<br> 免费梯，速度还可以，推荐选择港地</p></li><li><p>skyZIP Proxy<br> 貌似死了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档——vim的配置</title>
      <link href="/2019/12/24/wen-dang-vim-de-pei-zhi/"/>
      <url>/2019/12/24/wen-dang-vim-de-pei-zhi/</url>
      
        <content type="html"><![CDATA[<pre><code>set sw=4set ts=4set etset smarttabset smartindentset lbrset fo+=mBset smset selection=inclusiveset wildmenuset mousemodel=popup&quot; 这里根据自己需要的插件来设置，以下是我的配置 &quot;&quot;&quot; YouCompleteMe:语句补全插件set runtimepath+=~/.vim/bundle/YouCompleteMeautocmd InsertLeave * if pumvisible() == 0|pclose|endif &quot;离开插入模式后自动关闭预览窗口&quot;let g:ycm_collect_identifiers_from_tags_files = 1           &quot; 开启 YCM基于标签引擎let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释与字符串中的内容也用于补全let g:syntastic_ignore_files=[&quot;.*\.py$&quot;]let g:ycm_seed_identifiers_with_syntax = 1                  &quot; 语法关键字补全let g:ycm_complete_in_comments = 1let g:ycm_confirm_extra_conf = 0                            &quot; 关闭加载.ycm_extra_conf.py提示let g:ycm_key_list_select_completion = [&#39;&lt;c-n&gt;&#39;, &#39;&lt;Down&gt;&#39;]  &quot; 映射按键,没有这个会拦截掉tab, 导致其他插件的tab不能用.let g:ycm_key_list_previous_completion = [&#39;&lt;c-p&gt;&#39;, &#39;&lt;Up&gt;&#39;]let g:ycm_complete_in_comments = 1                          &quot; 在注释输入中也能补全let g:ycm_complete_in_strings = 1                           &quot; 在字符串输入中也能补全let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释和字符串中的文字也会被收入补全let g:ycm_global_ycm_extra_conf=&#39;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#39;let g:ycm_show_diagnostics_ui = 0                           &quot; 禁用语法检查inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;CR&gt;&quot;             &quot; 回车即选中当前项nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;     &quot; 跳转到定义处let g:ycm_min_num_of_chars_for_completion=2                 &quot; 从第2个键入字符就开始罗列匹配项&quot;au FileType php setlocal dict+=~/.vim/dict/php_funclist.dictau FileType css setlocal dict+=~/.vim/dict/css.dictau FileType c setlocal dict+=~/.vim/dict/c.dictau FileType cpp setlocal dict+=~/.vim/dict/cpp.dictau FileType scale setlocal dict+=~/.vim/dict/scale.dictau FileType javascript setlocal dict+=~/.vim/dict/javascript.dictau FileType html setlocal dict+=~/.vim/dict/javascript.dictau FileType html setlocal dict+=~/.vim/dict/css.dict&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 显示相关  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;syntax onset cul &quot;高亮光标所在行set cucset shortmess=atI   &quot; 启动的时候不显示那个援助乌干达儿童的提示  set go=             &quot; 不要图形按钮  &quot;color desert     &quot; 设置背景主题  color ron     &quot; 设置背景主题  &quot;color torte     &quot; 设置背景主题  &quot;set guifont=Courier_New:h10:cANSI   &quot; 设置字体  &quot;autocmd InsertLeave * se nocul  &quot; 用浅色高亮当前行  autocmd InsertEnter * se cul    &quot; 用浅色高亮当前行  set ruler           &quot; 显示标尺  set showcmd         &quot; 输入的命令显示出来，看的清楚些  &quot;set whichwrap+=&lt;,&gt;,h,l   &quot; 允许backspace和光标键跨越行边界(不建议)  set scrolloff=3     &quot; 光标移动到buffer的顶部和底部时保持3行距离  set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)}   &quot;状态行显示的内容  set laststatus=2    &quot; 启动显示状态行(1),总是显示状态行(2)  &quot;set foldenable      &quot; 允许折叠  &quot;&quot;set foldmethod=manual   &quot; 手动折叠  set nocompatible  &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限  &quot; 显示中文帮助if version &gt;= 603    set helplang=cn    set encoding=utf-8endif&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop=4&quot; 统一缩进为4set softtabstop=4set shiftwidth=4&quot; 使用空格代替制表符set expandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history=1000&quot;搜索逐字符高亮set hlsearchset incsearch&quot;语言设置set langmenu=zh_CN.UTF-8set helplang=cn&quot; 总是显示状态行set cmdheight=2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+=!&quot; 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-&quot; 字符间插入的像素行数目&quot;markdown配置au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn}   set filetype=mkdau BufRead,BufNewFile *.{go}   set filetype=goau BufRead,BufNewFile *.{js}   set filetype=javascript&quot;rkdown to HTML  nmap md :!~/.vim/markdown.pl % &gt; %.html &lt;CR&gt;&lt;CR&gt;nmap fi :!firefox %.html &amp; &lt;CR&gt;&lt;CR&gt;nmap \ \ccvmap \ \cc&quot;将tab替换为空格nmap tt :%s/\t/    /g&lt;CR&gt;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新文件标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.rb,*.java,*.py exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle()     &quot;如果文件类型为.sh文件     if &amp;filetype == &#39;sh&#39;         call setline(1,&quot;\#!/bin/bash&quot;)         call append(line(&quot;.&quot;), &quot;&quot;)     elseif &amp;filetype == &#39;python&#39;        call setline(1,&quot;#!/usr/bin/env python&quot;)        call append(line(&quot;.&quot;),&quot;# coding=utf-8&quot;)        call append(line(&quot;.&quot;)+1, &quot;&quot;)     elseif &amp;filetype == &#39;ruby&#39;        call setline(1,&quot;#!/usr/bin/env ruby&quot;)        call append(line(&quot;.&quot;),&quot;# encoding: utf-8&quot;)        call append(line(&quot;.&quot;)+1, &quot;&quot;)        &quot;    elseif &amp;filetype == &#39;mkd&#39;        &quot;        call setline(1,&quot;&lt;head&gt;&lt;meta charset=\&quot;UTF-8\&quot;&gt;&lt;/head&gt;&quot;)    else         call setline(1, &quot;/*************************************************************************&quot;)         call append(line(&quot;.&quot;), &quot;    &gt; File Name: &quot;.expand(&quot;%&quot;))         call append(line(&quot;.&quot;)+1, &quot;    &gt; Author: zzw &quot;)         call append(line(&quot;.&quot;)+2, &quot;    &gt; Mail: 819342493@qq.com&quot;)         call append(line(&quot;.&quot;)+3, &quot;    &gt; Created Time: &quot;.strftime(&quot;%c&quot;))         call append(line(&quot;.&quot;)+4, &quot; ************************************************************************/&quot;)         call append(line(&quot;.&quot;)+5, &quot;&quot;)    endif    if expand(&quot;%:e&quot;) == &#39;cpp&#39;        call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;)        call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;)        call append(line(&quot;.&quot;)+8, &quot;&quot;)    endif    if &amp;filetype == &#39;c&#39;        call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;)        call append(line(&quot;.&quot;)+7, &quot;&quot;)    endif    if expand(&quot;%:e&quot;) == &#39;h&#39;        call append(line(&quot;.&quot;)+6, &quot;#ifndef _&quot;.toupper(expand(&quot;%:r&quot;)).&quot;_H&quot;)        call append(line(&quot;.&quot;)+7, &quot;#define _&quot;.toupper(expand(&quot;%:r&quot;)).&quot;_H&quot;)        call append(line(&quot;.&quot;)+8, &quot;#endif&quot;)    endif    if &amp;filetype == &#39;java&#39;        call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%:r&quot;))        call append(line(&quot;.&quot;)+7,&quot;&quot;)    endif    &quot;新建文件后，自动定位到文件末尾endfunc autocmd BufNewFile * normal G&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;键盘命令&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;:nmap &lt;silent&gt; &lt;F9&gt; &lt;ESC&gt;:Tlist&lt;RETURN&gt;&quot; shift tab pagesmap &lt;S-Left&gt; :tabp&lt;CR&gt;map &lt;S-Right&gt; :tabn&lt;CR&gt;map! &lt;C-Z&gt; &lt;Esc&gt;zzimap! &lt;C-O&gt; &lt;C-Y&gt;,map &lt;C-A&gt; ggVG$&quot;+ymap &lt;Esc&gt;&lt;Esc&gt; :w&lt;CR&gt;map &lt;F12&gt; gg=Gmap &lt;C-w&gt; &lt;C-w&gt;wimap &lt;C-k&gt; &lt;C-y&gt;,imap &lt;C-t&gt; &lt;C-q&gt;&lt;TAB&gt;imap &lt;C-j&gt; &lt;ESC&gt;&quot; 选中状态下 Ctrl+c 复制&quot;map &lt;C-v&gt; &quot;*paimap &lt;C-v&gt; &lt;Esc&gt;&quot;*paimap &lt;C-a&gt; &lt;Esc&gt;^imap &lt;C-e&gt; &lt;Esc&gt;$vmap &lt;C-c&gt; &quot;+yset mouse=v&quot;set clipboard=unnamed&quot;去空行  nnoremap &lt;F2&gt; :g/^\s*$/d&lt;CR&gt; &quot;比较文件  nnoremap &lt;C-F2&gt; :vert diffsplit &quot;nnoremap &lt;Leader&gt;fu :CtrlPFunky&lt;Cr&gt;&quot;nnoremap &lt;C-n&gt; :CtrlPFunky&lt;Cr&gt;&quot;列出当前目录文件  map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt; :NERDTreeToggle&lt;CR&gt;&quot;打开树状文件目录  map &lt;C-F3&gt; \be  :autocmd BufRead,BufNewFile *.dot map &lt;F5&gt; :w&lt;CR&gt;:!dot -Tjpg -o %&lt;.jpg % &amp;&amp; eog %&lt;.jpg  &lt;CR&gt;&lt;CR&gt; &amp;&amp; exec &quot;redr!&quot;&quot;C，C++ 按F5编译运行map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc()    exec &quot;w&quot;    if &amp;filetype == &#39;c&#39;        exec &quot;!g++ % -o %&lt;&quot;        exec &quot;!time ./%&lt;&quot;    elseif &amp;filetype == &#39;cpp&#39;        exec &quot;!g++ % -std=c++11 -o %&lt;&quot;        exec &quot;!time ./%&lt;&quot;    elseif &amp;filetype == &#39;java&#39;         exec &quot;!javac %&quot;         exec &quot;!time java %&lt;&quot;    elseif &amp;filetype == &#39;sh&#39;        :!time bash %    elseif &amp;filetype == &#39;python&#39;        exec &quot;!time python2.7 %&quot;    elseif &amp;filetype == &#39;html&#39;        exec &quot;!firefox % &amp;&quot;    elseif &amp;filetype == &#39;go&#39;        &quot;        exec &quot;!go build %&lt;&quot;        exec &quot;!time go run %&quot;    elseif &amp;filetype == &#39;mkd&#39;        exec &quot;!~/.vim/markdown.pl % &gt; %.html &amp;&quot;        exec &quot;!firefox %.html &amp;&quot;    endifendfunc&quot;C,C++的调试map &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb()    exec &quot;w&quot;    exec &quot;!g++ % -std=c++11 -g -o %&lt;&quot;    exec &quot;!gdb ./%&lt;&quot;endfunc&quot;代码格式优化化map &lt;F6&gt; :call FormartSrc()&lt;CR&gt;&lt;CR&gt;&quot;定义FormartSrc()func FormartSrc()    exec &quot;w&quot;    if &amp;filetype == &#39;c&#39;        exec &quot;!astyle --style=ansi -a --suffix=none %&quot;    elseif &amp;filetype == &#39;cpp&#39; || &amp;filetype == &#39;hpp&#39;        exec &quot;r !astyle --style=ansi --one-line=keep-statements -a --suffix=none %&gt; /dev/null 2&gt;&amp;1&quot;    elseif &amp;filetype == &#39;perl&#39;        exec &quot;!astyle --style=gnu --suffix=none %&quot;    elseif &amp;filetype == &#39;py&#39;||&amp;filetype == &#39;python&#39;        exec &quot;r !autopep8 -i --aggressive %&quot;    elseif &amp;filetype == &#39;java&#39;        exec &quot;!astyle --style=java --suffix=none %&quot;    elseif &amp;filetype == &#39;jsp&#39;        exec &quot;!astyle --style=gnu --suffix=none %&quot;    elseif &amp;filetype == &#39;xml&#39;        exec &quot;!astyle --style=gnu --suffix=none %&quot;    else        exec &quot;normal gg=G&quot;        return    endif    exec &quot;e! %&quot;endfunc&quot;结束定义FormartSrc&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;实用设置&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 设置当文件被改动时自动载入set autoread&quot; quickfix模式autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;&quot;代码补全 set completeopt=preview,menu &quot;允许插件  filetype plugin on&quot;共享剪贴板  set clipboard=unnamed &quot;从不备份  set nobackup&quot;make 运行:set makeprg=g++\ -Wall\ \ %&quot;自动保存set autowriteset ruler                   &quot; 打开状态栏标尺set cursorline              &quot; 突出显示当前行set magic                   &quot; 设置魔术set guioptions-=T           &quot; 隐藏工具栏set guioptions-=m           &quot; 隐藏菜单栏&quot;set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&amp;fileformat}\ %{&amp;encoding}\ %c:%l/%L%)\&quot; 设置在状态行显示的信息set foldcolumn=0set foldmethod=indent set foldlevel=3 set foldenable              &quot; 开始折叠&quot; 不要使用vi的键盘模式，而是vim自己的set nocompatible&quot; 语法高亮set syntax=on&quot; 去掉输入错误的提示声音set noeb&quot; 在处理未保存或只读文件的时候，弹出确认set confirm&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop=4&quot; 统一缩进为4set softtabstop=4set shiftwidth=4&quot; 不要用空格代替制表符set noexpandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history=1000&quot;禁止生成临时文件set nobackupset noswapfile&quot;搜索忽略大小写set ignorecase&quot;搜索逐字符高亮set hlsearchset incsearch&quot;行内替换set gdefault&quot;编码设置set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936&quot;语言设置set langmenu=zh_CN.UTF-8set helplang=cn&quot; 我的状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)}set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]&quot; 总是显示状态行set laststatus=2&quot; 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+=!&quot; 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-&quot; 字符间插入的像素行数目set linespace=0&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 使回格键（backspace）正常处理indent, eol, start等set backspace=2&quot; 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0&quot; 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\ ,stl:\ ,stlnc:\&quot; 高亮显示匹配的括号set showmatch&quot; 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1&quot; 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3&quot; 为C程序提供自动缩进set smartindent&quot; 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile *  setfiletype txt&quot;自动补全:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;=ClosePair(&#39;)&#39;)&lt;CR&gt;&quot;:inoremap { {&lt;CR&gt;}&lt;ESC&gt;O&quot;:inoremap } &lt;c-r&gt;=ClosePair(&#39;}&#39;)&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;=ClosePair(&#39;]&#39;)&lt;CR&gt;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i:inoremap &#39; &#39;&#39;&lt;ESC&gt;ifunction! ClosePair(char)    if getline(&#39;.&#39;)[col(&#39;.&#39;) - 1] == a:char        return &quot;\&lt;Right&gt;&quot;    else        return a:char    endifendfunctionfiletype plugin indent on &quot;打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; CTags的设定  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;let Tlist_Sort_Type = &quot;name&quot;    &quot; 按照名称排序  let Tlist_Use_Right_Window = 1  &quot; 在右侧显示窗口  let Tlist_Compart_Format = 1    &quot; 压缩方式  let Tlist_Exist_OnlyWindow = 1  &quot; 如果只有一个buffer，kill窗口也kill掉buffer  &quot;&quot;let Tlist_File_Fold_Auto_Close = 0  &quot; 不要关闭其他文件的tags  &quot;&quot;let Tlist_Enable_Fold_Column = 0    &quot; 不要显示折叠树  &quot;let Tlist_Show_One_File=1            &quot;不同时显示多个文件的tag，只显示当前文件的&quot;设置tags  set tags=tags;  set autochdir &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;其他东东&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;默认打开Taglist let Tlist_Auto_Open=0 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; Tag list (ctags) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; let Tlist_Ctags_Cmd = &#39;/usr/local/bin/ctags&#39; let Tlist_Show_One_File = 1 &quot;不同时显示多个文件的tag，只显示当前文件的 let Tlist_File_Fold_Auto_Close = 1let Tlist_Exit_OnlyWindow = 1 &quot;如果taglist窗口是最后一个窗口，则退出vim let Tlist_Use_Right_Window = 1 &quot;在右侧窗口中显示taglist窗口&quot; minibufexpl插件的一般设置let g:miniBufExplMapWindowNavVim = 1let g:miniBufExplMapWindowNavArrows = 1let g:miniBufExplMapCTabSwitchBufs = 1let g:miniBufExplModSelTarget = 1  nmap tl :Tlist&lt;cr&gt;&quot;python补全let g:pydiction_location = &#39;~/.vim/after/complete-dict&#39;let g:pydiction_menu_height = 20let Tlist_Ctags_Cmd=&#39;/usr/local/bin/ctags&#39;let g:miniBufExplMapWindowNavVim = 1let g:miniBufExplMapWindowNavArrows = 1let g:miniBufExplMapCTabSwitchBufs = 1let g:miniBufExplModSelTarget = 1set iskeyword+=.set termencoding=utf-8set encoding=utf8set fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030autocmd FileType python set omnifunc=pythoncomplete#Complete&quot;set nocompatible               &quot; be iMproved&quot;filetype off                   &quot; required!let g:html_indent_inctags = &quot;html,body,head,tbody&quot;let g:html_indent_script1 = &quot;inc&quot;let g:html_indent_style1 = &quot;inc&quot;filetype plugin indent on     &quot; required!&quot;&quot;ctrlp设置&quot;set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.pyc,*.png,*.jpg,*.gif     &quot; MacOSX/Linuxset wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe,*.pyc,*.png,*.jpg,*.gif  &quot; Windowslet g:ctrlp_custom_ignore = &#39;\v[\/]\.(git|hg|svn)$&#39;let g:ctrlp_custom_ignore = &#39;\v\.(exe|so|dll)$&#39;let g:ctrlp_extensions = [&#39;funky&#39;]let NERDTreeIgnore=[&#39;\.pyc&#39;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《STL源码剖析》（第七、八章：仿函数与接配器）</title>
      <link href="/2019/12/24/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-qi-ba-zhang-fang-han-shu-yu-jie-pei-qi/"/>
      <url>/2019/12/24/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-qi-ba-zhang-fang-han-shu-yu-jie-pei-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章：仿函数"><a href="#第七章：仿函数" class="headerlink" title="第七章：仿函数"></a>第七章：仿函数</h1><h2 id="7-1、仿函数（函数对象）概观"><a href="#7-1、仿函数（函数对象）概观" class="headerlink" title="7.1、仿函数（函数对象）概观"></a>7.1、仿函数（函数对象）概观</h2><p>STL仿函数的分类，若以操作数（operand）的个数划分，可分为一元和二元仿函数，若以功能划分，可分为算术运算（Arithmetic）、关系运算（Rational）、逻辑运算（Logical）三大类。任何应用程序欲使用STL内建的仿函数，都必须含人&lt; functiona1 &gt;头文件，SGI则将它们实际定义于&lt; st1_function.h &gt;文件中。以下分别描述。<br>重载 () 所以函数的对象 使用（）像函数调用是类 而不是普通的函数<br><strong>内部记录状态：</strong><br>作为类型 与模板进行配合使用  </p><ol><li>函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可内联编译，性能好。用函数指针几乎不可能</li><li>模版函数对象使函数对象具有通用性，这也是它的优势之一</li></ol><h2 id="7-2、可配接（adaptable）的关键"><a href="#7-2、可配接（adaptable）的关键" class="headerlink" title="7.2、可配接（adaptable）的关键"></a>7.2、可配接（adaptable）的关键</h2><ul><li><p>unary_function<br>unary_function用来呈现一元函数的参数型别和回返值型别。其定义非常简单：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000914459-1414387869.png" alt=""></p></li><li><p>binary_function<br>binary_function 用来呈现二元函数的第一参数型别、第二参数型别，以及回返值型别。其定义非常简单：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000925773-1298919017.png" alt=""></p></li></ul><h2 id="7-3、算术类（Arithmetic）仿函数"><a href="#7-3、算术类（Arithmetic）仿函数" class="headerlink" title="7.3、算术类（Arithmetic）仿函数"></a>7.3、算术类（Arithmetic）仿函数</h2><p>STL内建的“算术类仿函数”，支持加法、减法、乘法、除法、模数（余数，modulus）和否定（negation）运算。除了“否定”运算为一元运算，其它都是二元运算。</p><ul><li>加法：plus<T></li><li>减法：minus<T></li><li>乘法：multiplies<T></li><li>除法：divides<T></li><li>模取（modulus）：modulus<T></li><li>否定（negation）：negate<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000940335-1676139172.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000955791-618196543.png" alt=""></p><h2 id="7-4、关系运算类（Relational）仿函数"><a href="#7-4、关系运算类（Relational）仿函数" class="headerlink" title="7.4、关系运算类（Relational）仿函数"></a>7.4、关系运算类（Relational）仿函数</h2><p>STL内建的“关系运算类仿函数”支持了等于、不等于、大于、大于等于、小于、小于等于六种运算。每一个都是二元运算。</p><ul><li>等于（equality）：equal_to<T></li><li>不等于（inequality）：not_equal_tocT&gt;</li><li>大于（greater than）：greater<T></li><li>大于或等于（greater than or equal）：greater_-equal<T></li><li>小于（less than）：1ess<T></li><li>小于或等于（less than or equal）：1ess_equal<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001007466-1276806188.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001020777-765884354.png" alt=""></p><h2 id="7-5、逻辑运算类（Logical）仿函数"><a href="#7-5、逻辑运算类（Logical）仿函数" class="headerlink" title="7.5、逻辑运算类（Logical）仿函数"></a>7.5、逻辑运算类（Logical）仿函数</h2><p>STL内建的“逻辑运算类仿函数”支持了逻辑运算中的 And、or、Not三种运算，其中And和or为二元运算，Not为一元运算。</p><ul><li>逻辑运算And：1ogical_and<T></li><li>逻辑运算or：1ogical_or<T></li><li>逻辑运算Not:logical_not<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001032087-1471946754.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001043598-1146445021.png" alt=""></p><h2 id="7-6、证同（identity）、选择（select）、投射（project）"><a href="#7-6、证同（identity）、选择（select）、投射（project）" class="headerlink" title="7.6、证同（identity）、选择（select）、投射（project）"></a>7.6、证同（identity）、选择（select）、投射（project）</h2><ul><li><p>identity<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001057404-685324224.png" alt=""></p></li><li><p>select<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001110220-114459234.png" alt=""></p></li><li><p>project<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001119469-1357538208.png" alt=""></p></li></ul><h2 id="7-7、自建函数function"><a href="#7-7、自建函数function" class="headerlink" title="7.7、自建函数function"></a>7.7、自建函数function</h2><ul><li><p>包装普通函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">g_Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> g_Minus<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>包装模板函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>T <span class="token function">g_Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> g_Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>包装lambda表达式</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> g_Minus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>int main()<br>{<br>    function&lt;int(int, int)&gt; f = g_Minus;<br>    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1<br>    return 1;<br>}</p><pre><code>* 包装函数对象**非模板类型：**```cppstruct Minus{    int operator() (int i, int j)    {        return i - j;    }};int main(){    function&lt;int(int, int)&gt; f = Minus();    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1    return 1;}</code></pre><p><strong>模板类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> Minus<span class="token punctuation">{</span>    T <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>包装类静态成员函数</li><li><em>非模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>模板类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>    <span class="token keyword">static</span> T <span class="token function">Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>包装类对象成员函数</li><li><em>非模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">int</span> <span class="token function">Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Math m<span class="token punctuation">;</span>   function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token operator">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><em>模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>   T <span class="token function">Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>int main()<br>{<br>    Math m;<br>    function&lt;int(int, int)&gt; f = bind(&amp;Math::Minus<int>, &amp;m, placeholders::_1, placeholders::_2);<br>    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1<br>    return 1;<br>}</p><pre><code># 第x章：匿名函数（lambda）* 格式： [](){};</code></pre><p>[ ](int val){ cout &lt;&lt; val “”; }<br>//匿名函数  lambda表达式  <a href=""></a>{};<br>for_each(v.begin(), v.end(), [](int val) { cout &lt;&lt; val &lt;&lt; “ “; });</p><pre><code>* 捕获：需要捕获的参数放置在[ ]中！！！```[a](int b){return a+b;}```[ ]中为需要捕获的参数，一般存在与函数体中！！！* 传参放置在（）中：```cpppint a = 45;int sum = [a](int b){return a+b;};cout &lt;&lt; sum (14)&lt;&lt; endl;</code></pre><p>注意：<br>捕获参数a需自己定义，调用函数不需写明！<br>而传参需要调用函数传入进去！！！<br>( )中一般使用的是容器中的元素。   </p><pre class="line-numbers language-cpp"><code class="language-cpp">eg<span class="token operator">:</span>string ss<span class="token punctuation">;</span><span class="token keyword">float</span> f<span class="token punctuation">;</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span>m<span class="token punctuation">;</span>vecot<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span>v<span class="token punctuation">;</span><span class="token keyword">auto</span> pt<span class="token operator">=</span><span class="token function">find_if</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ss<span class="token punctuation">]</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span>ps<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> ps<span class="token punctuation">.</span>second<span class="token operator">==</span>ss<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pt<span class="token operator">=</span><span class="token function">find_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">float</span> fa<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> fa <span class="token operator">==</span> f<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>lambda表达式语法定义</li></ul><p>lambda表达式的语法定义如下：<br><code>[capture] （parameters） mutable -&gt;return-type {statement};</code></p><ol><li><p>[capture]: 捕捉列表。捕捉列表总是出现在lambda函数的开始处。实质上，[]是lambda引出符（即独特的标志符）<br>　　编译器根据该引出符判断接下来的代码是否是lambda函数<br>　　捕捉列表能够捕捉上下文中的变量以供lambda函数使用<br>　　捕捉列表由一个或多个捕捉项组成，并以逗号分隔，捕捉列表一般有以下几种形式：   </p><ul><li><p>[]：默认不捕获任何变量；</p></li><li><p>[=]：默认以值捕获所有变量；</p></li><li><p>[&amp;]：默认以引用捕获所有变量；</p></li><li><p>[x]：仅以值捕获x，其它变量不捕获；</p></li><li><p>[&amp;x]：仅以引用捕获x，其它变量不捕获；</p></li><li><p>[=, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；</p></li><li><p>[&amp;, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；</p></li><li><p>[this]：通过引用捕获当前对象（其实是复制指针）；</p></li><li><p>[*this]：通过传值方式捕获当前对象；</p><p>　　- &lt;1&gt; [var] 表示值传递方式捕捉变量var</p><ul><li>&lt;2&gt; [=] 表示值传递方式捕捉所有父作用域的变量（包括this指针） 【即该作用域中说所有的变量】</li><li>&lt;3&gt; [&amp;var] 表示引用传递捕捉变量var</li><li>&lt;4&gt; [&amp;] 表示引用传递捕捉所有父作用域的变量（包括this指针）<pre><code>  讲解一下使用&amp;的作用</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">5678</span><span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> f<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>k<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">return</span> i<span class="token operator">+</span>j<span class="token operator">+</span>k<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>k<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  输出为：1234，记住，当生命lambda声明时，参数已经捕获完毕，即i为值传递，不可改变，j,k为引用传递，可以改变，故最终传入的参数为：  i=1234, j=2, k=3;</code></pre>　　- &lt;5&gt; [this] 表示值传递方式捕捉当前的this指针,    当要使用类成员时，不能使用[=]进行捕获，需使用[this]来捕获      <ul><li>&lt;6&gt; [=，&amp;a，&amp;b] 表示以引用传递的方式捕捉变量 a 和 b，而以值传递方式捕捉其他所有的变量  </li><li>&lt;7&gt; [&amp;，a，this] 表示以值传递的方式捕捉 a 和 this，而以引用传递方式捕捉其他所有变量   <pre><code>备注：父作用域是指包含lambda函数的语句块{ }    </code></pre>  另外，需要注意的是，捕捉列表不允许变量重复传递。下面的例子就是典型的重复，会导致编译错误：<br>  [=， a] 这里 = 已经以值传递方式捕捉了所有的变量，那么再捕捉 a 属于重复<br>  [&amp;，&amp;this] 这里 &amp; 已经以引用传递方式捕捉了所有变量，那么再捕捉 this 属于重复   </li></ul></li></ul></li></ul></li><li><p>parameters）:参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号（）一起省略</p></li><li><p>mutable : mutable修饰符。默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性（后面有详解）在使用该修饰符时，参数列表不可省略（即使参数为空）</p></li><li><p>-&gt;return-type : 返回类型。用追踪返回类型形式声明函数的返回类型。　出于方便，不需要返回值的时候也可以连同符号-&gt;一起省略　　此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导</p></li><li><p>{statement} : 函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量,在lambda函数的定义中，参数列表和返回类型都是可选的部分，而捕捉列表和函数体都可能为空<br>那么，在极端情况下，C++11中最为简单的lambda函数只需要声明为：　[] {};</p><ul><li><p>当使用多个捕获时：<br>  当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。<br>  当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了&amp;），则显式捕获命名变量必须采用值方式，因此不能在其名字前使用&amp;。类似的，如果隐式捕获采用的是值方式（使用了=），则显式捕获命名变量必须采用引用方式，即，在名字前使用&amp;。<br>  默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表：<br>  <code>auto f=[v1]()mutable{return ++vl;};</code></p></li><li><p>声明返回类型：<br>默认返回为void类型，当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型；<br><code>[](int i)-&gt;int{if (i&lt;0)return-i;else return i;}</code></p></li></ul></li></ol><h1 id="第八章：配接器（adapters）"><a href="#第八章：配接器（adapters）" class="headerlink" title="第八章：配接器（adapters）"></a>第八章：配接器（adapters）</h1><h2 id="8-1、配接器之概观与分类"><a href="#8-1、配接器之概观与分类" class="headerlink" title="8.1、配接器之概观与分类"></a>8.1、配接器之概观与分类</h2><ul><li><p>应用于容器，container adapters</p></li><li><p>应用于迭代器，iterator adapters<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001308017-749591728.png" alt=""></p></li><li><p>应用于仿函数，functor adapters<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001318958-461090507.png" alt=""></p></li></ul><h2 id="8-2、container-adapters"><a href="#8-2、container-adapters" class="headerlink" title="8.2、container adapters"></a>8.2、container adapters</h2><ul><li><p>stack<br>stack的底层由deque构成。从以下接口可清楚看出stack与deque的关系：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{</span><span class="token keyword">protected</span>：Sequence c；<span class="token comment" spellcheck="true">//底层容器</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>queue<br>queue的底层由deque构成。从以下接口可清楚看出queue与deque的关系：   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">=</span>deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">queue</span><span class="token punctuation">{</span><span class="token keyword">protected</span>：Sequence c；<span class="token comment" spellcheck="true">//底层容器</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="8-3、iterator-adapters"><a href="#8-3、iterator-adapters" class="headerlink" title="8.3、iterator adapters"></a>8.3、iterator adapters</h2><ul><li><p>insert iterators</p></li><li><p>reverse iterators<br>所谓 reverse iterator，就是将迭代器的移动行为倒转。如果STL算法接受的不是一般正常的迭代器，而是这种逆向迭代器，它就会以从尾到头的方向来处理序列中的元素。例如：<br>//将所有元素逆向拷贝到ite所指位置上<br>//rbegin（）和rend（）与reverse_iterator有关copy（id.rbegin（），id.rend（），ite）；看似单纯，实现时却大有文章。  </p></li><li><p>stream iterators<br>所谓 stream iterators，可以将迭代器绑定到一个stream（数据流）对象身上。<br>绑定到istream对象（例如std:：cin）者，称为istream iterator，拥有输人能力；<br>绑定到ostream对象（例如std:：cout）者，称为ostream_iterator，拥有输出能力。   </p></li></ul><h2 id="8-4、function-adapters"><a href="#8-4、function-adapters" class="headerlink" title="8.4、function adapters"></a>8.4、function adapters</h2><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001339871-20879902.png" alt=""></p><ul><li>对返回值进行逻辑否定：not1，not2</li><li>对参数进行绑定：bindls t，bind2nd</li><li>用于函数合成：compose1，compose2 </li><li>用于函数指针：ptr_fun</li></ul><p>定义一个函数指针类型。<br>比如你有三个函数：   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"你好!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">bye</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"再见！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"好的！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>typdef void (*funcptr)(void);</code><br><code>typede[函数返回类型][*函数指针名][函数参数类型]</code><br>这样就构造了一个通用的函数<br>你用的时候可以这样：  </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>funcptr words<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&amp;</span>hello<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bye<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ok<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将函数指针存入</span>funcptr fun <span class="token operator">=</span> words<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>就会显示“你好！”；<span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>就会显示“再见！”；<span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>就会显示“好的！”<span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sayHelloPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> sayHello<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//其中，括号是必不可少的</span>    <span class="token punctuation">(</span><span class="token operator">*</span>sayHelloPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于成员函数指针：memfun，mem fun_ref</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《STL源码剖析》（第五、六章：关联容器与算法）</title>
      <link href="/2019/12/24/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-wu-liu-zhang-guan-lian-rong-qi-yu-suan-fa/"/>
      <url>/2019/12/24/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-wu-liu-zhang-guan-lian-rong-qi-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章、关联容器"><a href="#第五章、关联容器" class="headerlink" title="第五章、关联容器"></a>第五章、关联容器</h1><h2 id="5-0、关联容器"><a href="#5-0、关联容器" class="headerlink" title="5.0、关联容器"></a>5.0、关联容器</h2><ul><li><p>标准的STL关联式容器分为set（集合）和map（映射表）两大类，以及这两大类的衍生体multiset（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。</p></li><li><p>SGISTL还提供了一个不在标准规格之列的关联式容器：hash_table（散列表），以及以此hash_table为底层机制而完成的hash_set（散列集合）、hash_map（散列映射表）、hash_multiset（散列多键集合）、hash_multimap（散列多键映射表）。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235640834-174846146.png" alt=""></p></li><li><p>所谓关联式容器，观念上类似关联式数据库：每笔数据（每个元素）都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器内部结构（可能是RB-tree，也可能是hash-table）便依照其键值大小，以某种特定规则将这个元素放置于适当位置。关联式容器没有所谓头尾（只有最大元素和最小元素），所以不会有所谓 push_back()、push_front()、pop_back()、pop_front()、begin()【即无法通过*.begin()取出数据】、endt()这样的操作行为。</p></li></ul><h2 id="5-1、树的导览"><a href="#5-1、树的导览" class="headerlink" title="5.1、树的导览"></a>5.1、树的导览</h2><p>即讲解数据结构中的二叉树、二叉搜索树、平衡二叉树。。。</p><h2 id="5-2、RB-tree（红黑树）"><a href="#5-2、RB-tree（红黑树）" class="headerlink" title="5.2、RB-tree（红黑树）"></a>5.2、RB-tree（红黑树）</h2><h3 id="红黑树定义及其特性"><a href="#红黑树定义及其特性" class="headerlink" title="红黑树定义及其特性"></a>红黑树定义及其特性</h3><ol><li>每个节点或是黑色或是红色 </li><li>根节点是黑色 </li><li>每个叶节点是黑色（叶节点为空节点） </li><li>如果一个节点是红色，则它的两个子节点必须是黑色 </li><li>从任意的一个节点到该节点的所有叶节点的路径包含相同数目的黑色节点</li><li>红黑树是一种平衡二叉树，当不是完全的平衡二叉树，红黑树只要求最多三次旋转来尽可能达到平衡<br> 【也就是说没有规定左子树与右子树的高度差必须&lt;=1!!!!!!】</li></ol><ul><li>迭代器</li><li><em>operator++*</em><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235713829-442804034.png" alt=""></li></ul><p><strong>operator–</strong><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235737458-1520435092.png" alt=""></p><p><strong>自身迭代器</strong><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235806708-1498398018.png" alt=""></p><p>关于红黑树的具体数据结构，请看<a href="http://zzw1024.top/2019/12/22/hong-hei-shu/" target="_blank" rel="noopener"><strong>博文</strong></a></p><h2 id="5-3、-set"><a href="#5-3、-set" class="headerlink" title="5.3、 set"></a>5.3、 set</h2><ul><li>set底层是由红黑树构造的 </li><li>set key值不能重复</li><li>set中的key值不允许改变</li><li>STL特别提供了一组set/multiset相关算法，包括交集set_intersection、联集set_union、差集 set_difference、对称差集set_symmetric_difference。</li></ul><h2 id="5-4、map"><a href="#5-4、map" class="headerlink" title="5.4、map"></a>5.4、map</h2><ul><li>map不可以通过迭代器修改键值，但可以修改实值</li><li>map拥有list的某些性质：即增删改查其迭代器不会失效</li><li>map几乎是在调用RBTree的接口函数</li><li>map底层仍然是红黑树构造的</li></ul><h2 id="5-5、multiset"><a href="#5-5、multiset" class="headerlink" title="5.5、multiset"></a>5.5、multiset</h2><ul><li>与set一样，只不过是允许键值存在重复</li></ul><h2 id="5-6、multimap"><a href="#5-6、multimap" class="headerlink" title="5.6、multimap"></a>5.6、multimap</h2><p>与map一样，但允许键值重复</p><h2 id="5-7-、hashtable"><a href="#5-7-、hashtable" class="headerlink" title="5.7 、hashtable"></a>5.7 、hashtable</h2><ul><li>详细讲解请见<a href="http://zzw1024.top/2019/12/23/hash-biao-xiang-jie/" target="_blank" rel="noopener"><strong>博文</strong></a>      </li><li>hashtable没有向后的迭代器operator–()</li></ul><h2 id="5-8、hash-set"><a href="#5-8、hash-set" class="headerlink" title="5.8、hash_set"></a>5.8、hash_set</h2><p>hash_set拥有set的功能，底层使用的是hashtable，且不排序</p><h2 id="5-9、hash-map"><a href="#5-9、hash-map" class="headerlink" title="5.9、hash_map"></a>5.9、hash_map</h2><p>hash_map拥有map的功能，但底层是由hashtable组成的，且无排序功能</p><h2 id="5-10、hash-multiset"><a href="#5-10、hash-multiset" class="headerlink" title="5.10、hash_multiset"></a>5.10、hash_multiset</h2><ul><li>与multiset功能完全相同，其底层换成了hashtable</li><li>与hash_set的区别就是可以键值重复</li></ul><h2 id="5-11、-hash-multimap"><a href="#5-11、-hash-multimap" class="headerlink" title="5.11、 hash_multimap"></a>5.11、 hash_multimap</h2><p>hash_multimap与multimap的功能完全类似，但底层是以hashmap基本</p><h1 id="第六章-算法algorithms"><a href="#第六章-算法algorithms" class="headerlink" title="第六章 算法algorithms"></a>第六章 算法algorithms</h1><h2 id="6-1、概述"><a href="#6-1、概述" class="headerlink" title="6.1、概述"></a>6.1、概述</h2><ul><li><p>算法的五大特征如下：</p><ul><li>有穷性（Finiteness）。算法的有穷性是指算法必须能在执行有限个步骤之后终止；</li><li>确切性(Definiteness)。算法的每一步骤必须有确切的定义；</li><li>输入项(Input)。一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；</li><li>输出项(Output)。一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；</li><li>可行性(Effectiveness)。算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）。</li></ul></li><li><p>时间复杂度<br>时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为O(n)），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于常数时间内的操作（对应时间复杂度O(1)）。</p></li></ul><p>在化简某算法时间复杂度表达式时需遵循以下规则：<br>对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如O(n^2)+O(n)可化简为O(n^2)，O(n)+O(1)可化简为O(n)<br>可省去样本量前的常量系数，如O(2n)可化简为O(n)，O(8)可化简为O(1),对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如O(logm)+O(n^2)不能化简为O(n^2)或O(logm)。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为O(logm)，因为表达式增量是由样本量决定的。</p><ul><li><p>额外空间复杂度<br>算法额外空间复杂度指的是对于输入样本，经过算法操作需要的额外空间。比如使用冒泡排序对一个数组排序，期间只需要一个临时变量temp，那么该算法的额外空间复杂度为O(1)。又如归并排序，在排序过程中需要创建一个与样本数组相同大小的辅助数组，尽管在排序过后该数组被销毁，但该算法的额外空间复杂度为O(n)。</p></li><li><p>算法：<br>算法主要是由头文件<algorithm> <functional> <numeric>组成。<br><algorithm>是所有 STL 头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等…<br><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.<br><functional> 定义了一些模板类,用以声明函数对象。          </p></li><li><p>STL算法概况</p></li><li><p><em>质变指定是算法的稳定性*</em><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235934523-639435368.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235940226-890758197.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000001776-1055970874.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000010021-477313739.png" alt=""></p></li><li><p>质变的算法——会改变操作对象之值<br>所有的STL算法都作用在由迭代器[first，last）所标示出来的区间上。所谓“质变算法”，是指运算过程中会更改区间内（迭代器所指）的元素内容。诸如拷贝（copy）、互换（swap）、替换（replace）、填写（fill）、删除（remove）、排列组合（permutation）、分割（partition）、随机重排（random shuffling）、排序（sort）等算法，都属此类。</p></li><li><p>不质变的算法——不改变操作对象之值<br>所有的STL算法都作用在由迭代器[first，last）所标示出来的区间上。所谓“非质变算法”，是指运算过程中不会更改区间内（迭代器所指）的元素内容。<br>诸如查找（find）、匹配（search）、计数（count）、巡访（for_each）、比较（equal，mismatch）、寻找极值（max，min）等算法，都属此类。但是如果你在for_each（巡访每个元素）算法身上应用一个会改变元素内容的仿函数（functor）。   </p></li></ul><h2 id="6-2、算法的泛化过程"><a href="#6-2、算法的泛化过程" class="headerlink" title="6.2、算法的泛化过程"></a>6.2、算法的泛化过程</h2><ul><li>算法函数传参最好是传引用参数，这样可以避免由于对象的庞大而付出大的代价</li><li>这样的find（）很好，几乎适用于任何容器——只要该容器允许指针指入，而指针们又都支持以下四种find（）函数中出现的操作行为：<ul><li>inequality（判断不相等）操作符</li><li>dereferencelm（提领，取值）操作符</li><li>prefix increment（前置式递增）操作符</li><li>copy（复制）行为（以便产a’x生函数的返回值）</li></ul></li></ul><h2 id="6-3、数值算法"><a href="#6-3、数值算法" class="headerlink" title="6.3、数值算法"></a>6.3、数值算法<stl numeric.h></h2><ul><li><p>头文件<numeric><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000202562-1209119902.png" alt="">    </p></li><li><p>accumlate<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000222791-1493346367.png" alt=""></p></li></ul><p>算法accumulate用来计算init和[first，last）内所有元素的总和。注意，你一定得提供一个初始值init，这么做的原因之一是当[first，last）为空区间时仍能获得一个明确定义的值。如果希望计算[first，1ast）中所有数值的总和，应该将init设为0.</p><ul><li>adjacent_difference<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000240388-361851450.png" alt=""></li></ul><p>算法adjacent_difference用来计算[first，last）中相邻元素的差额。也就是说，它将<em>first 赋值给</em>result，并针对[first+1，last）内的每个迭代器i，将<em>i-</em>（i-1）之值赋值给*（result+（i-first））。<br>注意，你可以采用就地（in place）运算方式，也就是令result等于first。</p><ul><li><p>inner_product<br>算法inner_product能够计算[first1，last1）和[first2，first2+<br>（1ast1-first1））的一般内积（generalized inner product）。注意，你一定得提供初值init。这么做的原因之一是当[first，last）为空时，仍可获得一个明确定义的结果。如果你想计算两个vectors的一般内积，应该将init设为0.</p></li><li><p>partical_sum<br>算法partial_sum用来计算局部总和。它会将<em>first赋值给</em>result，将<em>first和</em>（first+1）的和赋值给*（result+1），依此类推。注意，result可以等于first，这使我们得以完成就地（in place）计算。在这种情况下它是一个质变算法（mutating algorithm）。</p></li></ul><p>运算中的总和首先初始为*first，然后赋值给<em>result。对于<br>[first+1，last）中每个迭代器i，从头至尾依序执行sum=sum+</em>i（第一版本）或sum=binary_op（sum，<em>i）（第二版本），然后再将sum赋值给</em>（result+（i-first））。此式所用之二元仿函数不必满足交换律（commutative）和结合律（associative）。所有运算行为的顺序都有明确设定。<br>本算法返回输出区间的最尾端位置：result+（last-first）。</p><ul><li><p>power<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000323728-288517597.png" alt=""></p></li><li><p>itoa<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000336197-1995376542.png" alt=""></p></li></ul><h2 id="6-4、基本算法"><a href="#6-4、基本算法" class="headerlink" title="6.4、基本算法"></a>6.4、基本算法<stl algobase.h></h2><ul><li><p>for_each</p></li><li><p>equal</p></li><li><p>fill</p></li><li><p>fill_n</p></li><li><p>iter_swap</p></li><li><p>lexicographical_compare</p><ul><li>以“字典排列方式”对两个序列[first1，last1）和tfirst2，1ast2）进行比较。比较操作针对两序列中的对应位置上的元素进行，并持续直到<ul><li>（1）某一组对应元素彼此不相等；</li><li>（2）同时到达1ast1和last2（当两序列的大小相同）；</li><li>（3）到达1ast1或last2（当两序列的大小不同）。</li></ul></li></ul></li><li><p>当这个函数在对应位置上发现第一组不相等的元素时，有下列几种可能：</p><ul><li>如果第一序列的元素较小，返回true.否则返回false。</li><li>如果到达last1而尚未到达last2，返回true。</li><li>如果到达last2而尚未到达last1，返回false。</li><li>如果同时到达last1和last2（换句话说所有元素都匹配），返回false；</li></ul></li><li><p>max</p></li><li><p>min</p></li><li><p>mism atch</p></li></ul><p>用来平行比较两个序列，指出两者之间的第一个不匹配点。返回一对迭代器，分别指向两序列中的不匹配点，如下图。如果两序列的所有对应元素都匹配，返回的便是两序列各自的last迭代器。缺省情况下是以equality操作符来比较元素；但第二版本允许用户指定比较操作。如果第二序列的元素个数比第一序列多，多出来的元素忽略不计。如果第二序列的元素个数比第一序列少，会发生未可预期的行为。</p><ul><li>swap</li><li>copy<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000358486-2111604671.png" alt=""></li></ul><h2 id="6-5、set相关算法"><a href="#6-5、set相关算法" class="headerlink" title="6.5、set相关算法"></a>6.5、set相关算法</h2><p>STL一共提供了四种与set（集合）相关的算法，分别是并集（union）、交集（intersection）、差集（difference）、对称差集（symmetric difference）。</p><h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><p>算法set_union可构造s1、s2之并集。也就是说，它能构造出集合s1Us2，此集合内含s1或s2内的每一个元素。s1、s2及其并集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此，如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现max（m，n）次，其中n个来自s1，其余来自s2。</p><p>set_union 是一种稳定（stable）操作，意思是输入区间内的每个元素的相对顺序都不会改变。set-union有两个版本，差别在于如何定义某个元素小于另一个元素。</p><h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><p>算法 set_intersection可构造s1、s2之交集。也就是说，它能构造出集合s1 n s2，此集合内含同时出现于s1和s2内的每一个元素。s1、s2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现min（m，n）次，并且全部来自s1。</p><p>set_intersection 是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和s1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。</p><h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><p>算法 set_difference可构造s1、s2之差集。也就是说，它能构造出集合s1-s2，此集合内含“出现于s1但不出现于s2”的每一个元素。s1、s2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现max（n-m，0）次，并且全部来自S1。</p><h3 id="set-difference-1"><a href="#set-difference-1" class="headerlink" title="set_difference"></a>set_difference</h3><p>是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和S1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p><h3 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h3><p>算法setsymmetric_difference 可构造s1、s2之对称差集。也就是说，它能构造出集合（S1-S2）U（S2-S1），此集合内含“出现于s1但不出现于s2”<br>以及“出现于s2但不出现于s1”的每一个元素。S1、S2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现ln-ml次。如果n&gt;m，输出区间内的最后n-m个元素将由s1复制而来，如果n&lt; m则输出区间内的最后m-n个元素将由s2复制而来。在STL set容器内，m≤1且n&lt;=1。</p><p>setsymmetric_difference 是一种稳定（stable）操作，意思是输入区间内的元素相对顺序不会被改变。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operators进行比较，第二版本采用仿函数comp。</p><h2 id="6-6、heap算法"><a href="#6-6、heap算法" class="headerlink" title="6.6、heap算法"></a>6.6、heap算法</h2><h2 id="6-7、其它算法"><a href="#6-7、其它算法" class="headerlink" title="6.7、其它算法"></a>6.7、其它算法</h2><p>深入源代码之前，先观察每一个算法的表现，是个比较好的学习方式。以下程序示范本节每一个算法的用法。程序中有时使用STL内建的仿函数（functors，如less，greater，equeal_to）和配接器（adapters，如bind2nd），有时使用自定义的仿函数（如display，even_by_two）。</p><ul><li><p>adjacent find<br>找出第一组满足条件的相邻元素。这里所谓的条件，在版本一中是指“两元素相等”，在版本二中允许用户指定一个二元运算，两个操作数分别是相邻的第一元素和第二元素。</p></li><li><p>count<br>运用equality操作符，将[first，last）区间内的每一个元素拿来和指定值value比较，并返回与value相等的元素个数。</p></li><li><p>count_if<br>将指定操作（一个仿函数）pred实施于[first，1ast）区间内的每一个元素身上，并将“造成pred之计算结果为true”的所有元素的个数返回。</p></li><li><p>find</p></li><li><p>find it</p></li><li><p>find_end</p></li><li><p>find_first of</p></li><li><p>for_each</p></li><li><p>generate</p></li><li><p>generate_n</p></li><li><p>includes（应用于有序区间）</p></li><li><p>max element</p></li><li><p>merge（应用于有序区间）</p></li><li><p>min_element</p></li><li><p>partition</p></li></ul><p>partition 会将区间[first，last）中的元素重新排列。所有被一元条件运算pred判定为true的元素，都会被放在区间的前段，被判定为false的元素，都会被放在区间的后段。这个算法并不保证保留元素的原始相对位置。如果需要保留原始相对位置，应使用stable_partition。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000454758-820817564.png" alt=""></p><ul><li><p>remove移除（但不删除）<br>移除[first，1ast）之中所有与value相等的元素。这一算法并不真正从容器中删除那些元素（换句话说容器大小并未改变），而是将每一个不与value相等（也就是我们并不打算移除）的元素轮番赋值给first之后的空间。返回值Fonwarditerator 标示出重新整理后的最后元素的下一位置。<br>例如序列<br>{0，1，0，2，0，3，0，4]，如果我们执行remove（），希望移除所有0值元素，执行结果将是{1，23，4，0，3.0.4]。每一个与0不相等的元素，1，2，3，4，分别被拷贝到第一、二、三、四个位置上。第四个位置以后不动，换句话说是第四个位置之后是这一算法留下的残余数据。返回值Forwardlterator 指向第五个位置。如果要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase（）member function。注意，array 不适合使用remove（）和remove_if（），因为array无法缩小尺寸，导致残余数据永远存在。对array而言，较受欢迎的算法是remove_copy（）和</p></li><li><p>remove_copy</p></li><li><p>remove_if</p></li><li><p>remove_copy.if</p></li><li><p>replace</p></li><li><p>replace_copy</p></li><li><p>replace if</p></li><li><p>replace_copy._if</p></li><li><p>reverse</p></li><li><p>reverse_copy</p></li><li><p>rotate<br>将[first，middle）内的元素和[middle，last）内的元素互换。middle所指的元素会成为容器的第一个元素。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000526836-1762719892.png" alt=""></p></li><li><p>rotate_copy</p></li><li><p>search</p></li><li><p>search_n</p></li></ul><p>在序列[first，last）所涵盖的区间中，查找“连续count个符合条件之元素”所形成的子序列，并返回一个迭代器指向该子序列起始处。如果找不到这样的子序列，就返回迭代器last。上述所谓的“某条件”，在search_n版本一指的是相等条件“equality”，在search_n版本二指的是用户指定的某个二元运算（以仿函数呈现）。</p><p>例如，面对序列{10，8，8，7，2，8，7，2，2，8，7，0}，查找“连续两个8”所形成的子序列起点，可以这么写：<br>iter1 = search_n（iv.begin（），iv.end（），2，8）；</p><p>查找“连续三个小于8的元素”所形成的子序列起点，可以这么写：<br>iter2 = search_n（iv.begin（），iv.end（），3，8，1ess&lt; int &gt;（）；</p><ul><li><p>swap_ranges</p></li><li><p>transform</p></li><li><p>unique</p></li><li><p>unique_copy</p></li><li><p>lower_bound（应用于有序区间）<br>这是二分查找（binary search）的一种版本，试图在已排序的（first，last）中寻找元素value。如果[first，last）具有与value相等的元素（s），便返回一个迭代器，指向其中第一个元素。如果没有这样的元素存在，便返回“假设这样的元素存在时应该出现的位置”。也就是说，它会返回一个迭代器，指向第一个“不小于value”的元素。如果value大于[first，last）内的任何一个元素，则返回last。以稍许不同的观点来看1ower_bound，其返回值是“在不破坏排序状态的原则下，可插入value的第一个位置”。 </p></li><li><p>upper_bound（应用于有序区间）<br>算法upper_bound是二分查找（binary search）法的一个版本。它试图在已排序的[first，last）中寻找value。更明确地说，它会返回“在不破坏顺序的情况下，可插入value的最后一个合适位置”。</p></li><li><p>binary_search（应用于有序区间）<br>算法binary_search 是一种二分查找法，试图在已排序的[first，last）中寻找元素value。如果[first，last）内有等同于value的元素，便返回true，否则返回false。</p></li></ul><p>返回单纯的bool或许不能满足你，前面所介绍的lower_bound和upper_bound能够提供额外的信息。事实上binary_search便是利用lower_bound先找出“假设value存在的话，应该出现的位置”，然后再对比该位置上的值是否为我们所要查找的目标，并返回对比结果。</p><ul><li>next_permutation<br>STL提供了两个用来计算排列组合关系的算法，分别是nextpermucation和 prev_permutation。首先我们必须了解什么是“下一个”排列组合，什么是“前一个”排列组合。</li></ul><p>考虑三个字符所组成的序列（a，b，c）。这个序列有六个可能的排列组合：abc，acb，bac，bca，cab，cba。这些排列组合根据less-than操作符做字典顺序（lexicographical）的排序。也就是说，abc名列第一，因为每一个元素都小于其后的元素。</p><p>next_permutation（）会取得[first，last）所标示之序列的下一个排列组合。如果没有下一个排列组合，便返回false；否则返回true。</p><ul><li><p>prev_permutation<br>所谓“前一个”排列组合，其意义已在上一节阐述。实际做法简述如下，其中所用的符号如图6-8所示。首先，从最尾端开始往前寻找两个相邻元素，令第一元素为<em>i，第二元素为</em>ii，且满足*i&gt;*ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个小于*i的元素，令为*j，将i，j元素对调，再将ii之后的所有元素颠倒排列。此即所求之“前一个”排列组合。</p></li><li></li><li><p>random_shufle<br>这个算法将[first，last）的元素次序随机重排。也就是说，在N！种可能的元素排列顺序中随机选出一种，此处N为last-first。</p></li></ul><p>N个元素的序列，其排列方式有N！种，random_shuffle会产生一个均匀分布，因此任何一个排列被选中的机率为1/N！。这很重要，因为有不少算法在其第一阶段过程中必须获得序列的随机重排，但如果其结果未能形成“在N！个可能排列上均匀分布（uniform distribution）”，便很容易造成算法的错误。</p><ul><li><p>partial_sort/partial_sort<br>本算法接受一个middle 迭代器（位于序列[first，last）之内），然后重新安排[first，last），使序列中的middle-first个最小元素以递增顺序排序，置于（first，middle）内。其余1ast-middle个元素安置于[middle，last）中，不保证有任何特定顺序。</p></li><li><p>sort<br>STL的sort 算法，数据量大时采用Quick Sort，分段递归排序。<br>一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷（overhead），就改用Insertion Sort。<br>如果递归层次过深，还会改用Heap Sort。</p></li><li><p>equal_range（应用于有序区间）<br>算法equal_range是二分查找法的一个版本，试图在已排序的[first，last）中寻找value。它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即1ower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound）。因此，[i，j）内的每个元素都等同于value，而且[i，j）是(first，last)之中符合此一性质的最大子区间。<br>于是，算法lower_bound返回区间A的第一个迭代器，算法upper_bound返回区间A的最后元素的下一位置，算法equalrange则是以pair的形式将两者都返回。</p></li><li><p>inplace_merge（应用于有序区间）<br>如果两个连接在一起的序列[first，middle）和[middle，last）都已排序，那么inplacemerge可将它们结合成单一一个序列，并仍保有序性（sorted）。</p></li></ul><p>如果原先两个序列是递增排序，执行结果也会是递增排序，如果原先两个序列是递减排序，执行结果也会是递减排序。</p><p>和merge一样，inplace_merge也是一种稳定（stable）操作。每个作为数据来源的子序列中的元素相对次序都不会变动；如果两个子序列有等同的元素，第一序列的元素会被排在第二序列元素之前。</p><ul><li>nth_element<br>这个算法会重新排列[first，last），使迭代器nth所指的元素，与“整个<br>[first，1ast）完整排序后，同一位置的元素”同值。此外并保证（nth，last）内没有任何一个元素小于（更精确地说是不大于）[first，nth）内的元素，但对于[first，nth）和[nth，last）两个子区间内的元素次序则无任何保证一—这一点也是它与partial_sort很大的不同处。以此观之，nth_element比较近似partition 而非 sort 或 partial_sort。</li></ul><p>例如，假设有序列{22，30，30，17，33，40，17，23，22，12，20}，以下操作：<br>nth_element(iv.begin()，iv.begin()+5，iv.end())；便是将小于*(iv.begin()+5)(本例为40)的元素置于该元素之左，其余置于该元素之右，并且不保证维持原有的相对位置。获得的结果为{20，12，22，17，17，<br>22，23，30，30，33，40]。执行完毕后的5th个位置上的元素值22，与整个序列完整排序后{12，17，17，20，22，22，23，30，30，33，40]的5th个位置上的元素值相同。</p><ul><li>6.7.13 merge sort<br>以上的排序算法详见<a href="http://zzw1024.top/2019/12/23/shi-da-jing-dian-pai-xu-suan-fa/" target="_blank" rel="noopener"><strong>博文</strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——十大经典排序算法</title>
      <link href="/2019/12/23/shu-ju-jie-gou-shi-da-jing-dian-pai-xu-suan-fa/"/>
      <url>/2019/12/23/shu-ju-jie-gou-shi-da-jing-dian-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="影响排序性能的要素："><a href="#影响排序性能的要素：" class="headerlink" title="影响排序性能的要素："></a>影响排序性能的要素：</h2><p>时间性能<br>辅助空间<br>算法的复杂度</p><h2 id="简单排序【n-2】"><a href="#简单排序【n-2】" class="headerlink" title="简单排序【n^2】"></a>简单排序【n^2】</h2><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><p>第一趟：<br>从第一个记录开始，通过n-1次关键字比较，从n个记录中选出最小的并和第一个记录交换；<br>第二趟：<br>从第二个记录开始，通过n-2次关键字比较，从n -1个记录中选出最小的并和第二个记录交换；<br>复杂度稳稳的是0(n2)，几乎被抛弃      </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">SimpleSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> minV <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minV <span class="token operator">></span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                minV <span class="token operator">=</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），故名“冒泡排序”。每一次排序都将最大的数排到最后【最前】            </p><p><strong>算法稳定性</strong><br>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>  T temp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i  <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j  <span class="token operator">&lt;</span> len <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//之所以是-i，是因为每一次j的循环都将最大的数冒出到最后，所以后面的i个数是已经完成了排序的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j  <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                temp  <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j  <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j  <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>改进：</strong><br>使用一个标记，一旦某次j循环遍历中没有进行数据交换，那么数据是提前有序了，使用flag进行标记提前结束循环。  </p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序（Selection sort）是一种简单直观的排序算法。<br>它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。【好像就是前面的简单排序】          </p><p><strong>稳定性:</strong><br>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。          </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                index <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!=</span> i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            v<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。   </p><p>插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p><p><strong>插入排序的基本思想是：</strong><br>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：   </p><ul><li>从第一个元素开始，该元素可以认为已经被排序；   </li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；   </li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；  </li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；   </li><li>将新元素插入到该位置后；     </li></ul><h4 id="直接插入排序："><a href="#直接插入排序：" class="headerlink" title="直接插入排序："></a>直接插入排序：</h4><p>直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。<br><strong>直接插入排序的算法思路：</strong>   </p><ol><li>设置监视哨temp，将待插入记录的值赋值给temp；</li><li>设置开始查找的位置j = i-1,从判断比较的i位置的前一个数开始比较；</li><li>在数组中进行搜索，搜索中将第j个记录后移，直至temp≥r[j].key为止；</li><li>将temp插入r[j+1]的位置上。   </li></ol><p>直接插入排序算法:   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//临时哨兵</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        temp <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从i的前一位开始从后向前比较</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                v<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向后移</span>            <span class="token keyword">else</span>                <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//找到位置了</span>        v<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意，j前移动了</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="折半插入排序（二分插入排序）"><a href="#折半插入排序（二分插入排序）" class="headerlink" title="折半插入排序（二分插入排序）"></a>折半插入排序（二分插入排序）</h4><p>算法的基本过程：    </p><ol><li>计算 0 ~ i-1 的中间点，用 i 索引处的元素与中间值进行比较，如果 i 索引处的元素大，说明要插入的这个元素应该在中间值和刚加入i索引之间，反之，就是在刚开始的位置到中间值的位置，这样很简单的完成了折半；   </li><li>在相应的半个范围里面找插入的位置时，不断的用（1）步骤缩小范围，不停的折半，范围依次缩小为 1/2 1/4 1/8 …….快速的确定出第 i 个元素要插在什么地方；      </li><li>确定位置之后，将整个序列后移，并将元素插入到相应位置。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232332714-1361581688.png" alt=""><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iterator></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> biIter<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">insertion_sort</span> <span class="token punctuation">(</span>biIter begin<span class="token punctuation">,</span> biIter end<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>biIter<span class="token operator">></span><span class="token operator">::</span>value_type value_type<span class="token punctuation">;</span> biIter bond <span class="token operator">=</span> begin<span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>bond<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> bond <span class="token operator">!=</span> end<span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>bond<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     value_type key <span class="token operator">=</span> <span class="token operator">*</span>bond<span class="token punctuation">;</span>     biIter ins <span class="token operator">=</span> bond<span class="token punctuation">;</span>     biIter pre <span class="token operator">=</span> ins<span class="token punctuation">;</span>     std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>ins <span class="token operator">!=</span> begin <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>pre <span class="token operator">></span> key<span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token operator">*</span>ins <span class="token operator">=</span> <span class="token operator">*</span>pre<span class="token punctuation">;</span>         std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>ins<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token operator">*</span>ins <span class="token operator">=</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。<br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。      </p><p>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；<br>然后，取第二个增量<code>d2 &lt; d1</code>重复上述的分组和排序，直至所取的增量 =1<br><code>(&lt;…&lt;d2&lt;d1)</code>，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法一般的初次取序列的一半为增量，以后每次减半，直到增量为1。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232357154-1789458743.png" alt=""></p><p><strong>稳定性:</strong><br>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。每次插入排序都是把跨度为gap的所有数组成一个数组进行插入排序，一定记得位置别弄错</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//gap为组的跨度，初始取长度的一半，此后每一次都折半取</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//对于每个跨度为gap的数据进行插入排序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> gap<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//每次i与跨度为gap的j一起比较</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> gap<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">+</span><span class="token operator">=</span>gap<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//j对应的是i的跨度为gap的数值</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//后比前小，应该向前插入</span>                <span class="token punctuation">{</span>                    <span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">-</span> gap<span class="token punctuation">,</span> temp <span class="token operator">=</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//temp哨兵</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        v<span class="token punctuation">[</span>k <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//后移</span>                        k <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    v<span class="token punctuation">[</span>k <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//k-gap了，故需加上gap</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；   即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。   </p><p><strong>算法稳定性:</strong><br>在归并排序中，相等的元素的顺序不会改变，所以它是稳定的算法。</p><p>归并操作的工作原理如下：[数组1小，数组1的数字上，否则数组2的数上]    </p><ul><li>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列     </li><li>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置    </li><li>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232503712-79710875.png" alt=""></li></ul><p>两个数组进行归并</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//两个数组进行归并</span><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> iL<span class="token punctuation">,</span> <span class="token keyword">int</span> iR<span class="token punctuation">,</span> <span class="token keyword">int</span> jL<span class="token punctuation">,</span> <span class="token keyword">int</span> jR<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//此处的L，R分别为两个小数组的边界</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">temp</span><span class="token punctuation">(</span>jR <span class="token operator">-</span> iL <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开辟大小为两个数组的大小空间</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> iL<span class="token punctuation">,</span> j <span class="token operator">=</span> jL<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> iR <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> jR<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//此处的等号保证了算法的稳定性，使得相同数值前后位置不变</span>            temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> iR<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//数组1未完</span>        temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> jR<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//数组2未完</span>        temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> iL<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> jR<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">,</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将排好序的数据赋值给原数组</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自底向上：非递归版【小数组到大数组】</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//step为小数组的大小，此处step的代表为两个小数组的大小，故定是2的倍数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> step <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> step <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//1&amp;1组，2&amp;2组，4&amp;4组。。。。</span>    <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//一定是从1与1的数组开始！！！不然就没法保证排序了</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> step<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//sort(v + i, v + min(i + step, n));//直接使用自带的sort函数进行排序</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> step <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//中间节点</span>                <span class="token function">Merge</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">+</span> step <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> step <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>i <span class="token operator">+</span> step <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从i开始，在跨度为step中分为两个小数组进行归并</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自顶向下：递归版【大数组到小数组】</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//一定不能等于</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> L <span class="token operator">+</span> <span class="token punctuation">(</span>R <span class="token operator">-</span> L<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//求中点</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对左边进行递归切分成小数组</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对右边进行递归切分成小数组</span>        <span class="token function">Merge</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将左右两边进行归并</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序（Quicksort）是对冒泡排序的一种改进。快速排序由C. A. R. Hoare在1960年提出。<br><strong>它的基本思想是：</strong><br>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。    </p><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。          </p><p><strong>一趟快速排序的算法是：</strong>  </p><ul><li>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</li><li>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</li><li>3）从j开始向前搜索，即由后开始向前搜索(j–)，直到找到第一个小于key的值A[j]，将A[j]和A[i]的值交换；</li><li>4）从i开始向后搜索，即由前开始向后搜索(i++)，直到找到第一个大于key的A[i]，将A[i]和A[j]的值交换；</li><li>5）重复第3、4步，直到i==j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232745511-1716928742.png" alt=""></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//对区间进行划分</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//int p = round(1.0*rand() / RAND_MAX * (R - L) + L);//选取随机位置的数为基准值</span>    <span class="token comment" spellcheck="true">//swap(v[L], v[p]);//将基准值换到最左边</span>    <span class="token keyword">int</span> key <span class="token operator">=</span> v<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一般默认使用最左端的值为基准值</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token operator">></span>key<span class="token punctuation">)</span><span class="token operator">--</span>R<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从右向左，直到找到比key小的数</span>        v<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将小的数移到左边</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key<span class="token punctuation">)</span><span class="token operator">++</span>L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从左向右，直到找到比key大数</span>        v<span class="token punctuation">[</span>R<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将大的数移到右边</span>    <span class="token punctuation">}</span>    v<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//key在中间的位置</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回中点坐标</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;</span> R<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对左子区间进行快速排序</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对右子区间进行快速排序</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三平均分区法"><a href="#三平均分区法" class="headerlink" title="三平均分区法"></a>三平均分区法</h3><p>关于这一改进的最简单的描述大概是这样的：与一般的快速排序方法不同，它并不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。这一改进对于原来的快速排序算法来说，主要有两点优势：     </p><ol><li>首先，它使得最坏情况发生的几率减小了。</li><li>其次，未改进的快速排序算法为了防止比较时数组越界，在最后要设置一个哨点。  </li></ol><h3 id="根据分区大小调整算法"><a href="#根据分区大小调整算法" class="headerlink" title="根据分区大小调整算法"></a>根据分区大小调整算法</h3><p>这一方面的改进是针对快速排序算法的弱点进行的。快速排序对于小规模的数据集性能不是很好。可能有人认为可以忽略这个缺点不计，因为大多数排序都只要考虑大规模的适应性就行了。但是快速排序算法使用了分治技术，最终来说大的数据集都要分为小的数据集来进行处理。由此可以得到的改进就是，当数据集较小时，不必继续递归调用快速排序算法，而改为调用其他的对于小规模数据集处理能力较强的排序算法来完成。   </p><h3 id="不同的分区方案考虑"><a href="#不同的分区方案考虑" class="headerlink" title="不同的分区方案考虑"></a>不同的分区方案考虑</h3><p>对于快速排序算法来说，实际上大量的时间都消耗在了分区上面，因此一个好的分区实现是非常重要的。尤其是当要分区的所有的元素值都相等时，一般的快速排序算法就陷入了最坏的一种情况，也即反复的交换相同的元素并返回最差的中轴值。无论是任何数据集，只要它们中包含了很多相同的元素的话，这都是一个严重的问题，因为许多“底层”的分区都会变得完全一样。         </p><p>对于这种情况的一种改进办法就是将分区分为三块而不是原来的两块：一块是小于中轴值的所有元素，一块是等于中轴值的所有元素，另一块是大于中轴值的所有元素。   </p><p>另一种简单的改进方法是，当分区完成后，如果发现最左和最右两个元素值相等的话就避免递归调用而<br>采用其他的排序算法来完成。  </p><h3 id="并行的快速排序"><a href="#并行的快速排序" class="headerlink" title="并行的快速排序"></a>并行的快速排序</h3><p>由于快速排序算法是采用分治技术来进行实现的，这就使得它很容易能够在多台处理机上并行处理。<br>在大多数情况下，创建一个线程所需要的时间要远远大于两个元素比较和交换的时间，因此，快速排序的并行算法不可能为每个分区都创建一个新的线程。一般来说，会在实现代码中设定一个阀值，如果分区的元素数目多于该阀值的话，就创建一个新的线程来处理这个分区的排序，否则的话就进行递归调用来排序。    </p><h3 id="随机化快排"><a href="#随机化快排" class="headerlink" title="随机化快排"></a>随机化快排</h3><p>快速排序的最坏情况基于每次划分对主元的选择。基本的快速排序选取第一个元素作为主元。这样在数组已经有序的情况下，每次划分将得到最坏的结果。一种比较常见的优化方法是随机化算法，即随机选取一个元素作为主元。这种情况下虽然最坏情况仍然是O(n^2)，但最坏情况不再依赖于输入数据，而是由于随机函数取值不佳。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n)。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn)的期望时间复杂度。一位前辈做出了一个精辟的总结：“随机化快速排序可以满足一个人一辈子的人品需求。”<br>随机化快速排序的唯一缺点在于，一旦输入数据中有很多的相同数据，随机化的效果将直接减弱。对于极限情况，即对于n个相同的数排序，随机化快速排序的时间复杂度将毫无疑问的降低到O(n^2)。解决方法是用一种方法进行扫描，使没有交换的情况下主元保留在原位置。      </p><h3 id="平衡快排"><a href="#平衡快排" class="headerlink" title="平衡快排"></a>平衡快排</h3><p>每次尽可能地选择一个能够代表中值的元素作为关键数据，然后遵循普通快排的原则进行比较、替换和递归。通常来说，选择这个数据的方法是取开头、结尾、中间3个数据，通过比较选出其中的中值。取这3个值的好处是在实际问题中，出现近似顺序数据或逆序数据的概率较大，此时中间数据必然成为中值，而也是事实上的近似中值。万一遇到正好中间大两边小（或反之）的数据，取的值都接近最值，那么由于至少能将两部分分开，实际效率也会有2倍左右的增加，而且利于将数据略微打乱，破坏退化的结构。     </p><h3 id="外部快排"><a href="#外部快排" class="headerlink" title="外部快排"></a>外部快排</h3><p>与普通快排不同的是，关键数据是一段buffer，首先将之前和之后的M/2个元素读入buffer并对该buffer中的这些元素进行排序，然后从被排序数组的开头（或者结尾）读入下一个元素，假如这个元素小于buffer中最小的元素，把它写到最开头的空位上；假如这个元素大于buffer中最大的元素，则写到最后的空位上；否则把buffer中最大或者最小的元素写入数组，并把这个元素放在buffer里。保持最大值低于这些关键数据，最小值高于这些关键数据，从而避免对已经有序的中间的数据进行重排。完成后，数组的中间空位必然空出，把这个buffer写入数组中间空位。然后递归地对外部更小的部分，循环地对其他部分进行排序。       </p><h3 id="三路基数快排"><a href="#三路基数快排" class="headerlink" title="三路基数快排"></a>三路基数快排</h3><p>（Three-way Radix Quicksort，也称作Multikey Quicksort、Multi-key Quicksort）：结合了基数排序（radix sort，如一般的字符串比较排序就是基数排序）和快排的特点，是字符串排序中比较高效的算法。该算法被排序数组的元素具有一个特点，即multikey，如一个字符串，每个字母可以看作是一个key。算法每次在被排序数组中任意选择一个元素作为关键数据，首先仅考虑这个元素的第一个key（字母），然后把其他元素通过key的比较分成小于、等于、大于关键数据的三个部分。然后递归地基于这一个key位置对“小于”和“大于”部分进行排序，基于下一个key对“等于”部分进行排序。    </p><h2 id="堆排序【整个过程都是倒着来的】"><a href="#堆排序【整个过程都是倒着来的】" class="headerlink" title="堆排序【整个过程都是倒着来的】"></a>堆排序【整个过程都是倒着来的】</h2><p>堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于等于（或者大于等于）它的父节点。<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；<br>或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。          </p><p><strong>堆具有完全二叉树的概念：</strong><br>即：树的叶子节点必须从左向右依次补充！中间不能有空叶子！<br>用数组来表示一棵完全二叉树：       </p><pre class="line-numbers language-cpp"><code class="language-cpp">arry<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//不越界的情况下！ 【下角标从0开始】</span>i的左节点：<span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i的右节点：<span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>i的父节点：（i<span class="token number">-1</span>）<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>堆排序算法思想：</strong><br>将向量中存储的数据看成一棵完全二叉树，利用完全二叉树中双亲节点和孩子节点之间的内在关系选择关键字最小的记录。</p><ul><li>将待排序的序列构造成一个大顶堆【或小顶堆】，称为建堆的过程。</li><li>此时，整个序列的最大值【最小值】就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），即交换v[0],  v[n-1]</li><li>然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。</li><li>如此反复执行，直到交换v[0], v[1]。便能得到一个有序序列了。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232826228-214612324.png" alt=""></li></ul><h3 id="将一个数组中的数字按大根堆的顺序排列："><a href="#将一个数组中的数字按大根堆的顺序排列：" class="headerlink" title="将一个数组中的数字按大根堆的顺序排列："></a>将一个数组中的数字按大根堆的顺序排列：</h3><ol><li>换父节点：<br>遍历数组，比较array[i]与其父节点array[（i-1）/2 ]的大小，若大于父节点，则与父节点交换，并且同样向回比，比较父节点与祖父节点的大小，知道头部。。。。</li><li>换子节点：<br>在准备将数字加入树之前，与自己未来的孩子比较。<br>即，当array[i]准备入树时，找到自己的两个孩子，array[2<em>i+1],array[2</em>i+2],与孩子中最大的值进行比较，若自己小于孩子中的最大值，则交换!然后孩子继续与自己的孩子比较！</li></ol><h3 id="大根堆排序："><a href="#大根堆排序：" class="headerlink" title="大根堆排序："></a>大根堆排序：</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//向下调整</span><span class="token keyword">void</span> <span class="token function">downAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> L <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//i为父节点，j为左子节点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> R<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> R <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//若有右节点，且右节点大，那么就选右节点,即选取最大的子节点与父节点对比</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//选取了右节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//孩子节点都比父节点小，满足条件，无需调整</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//不满足的话，那么我就将最大孩子节点j与父节点i对调,</span>        <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i <span class="token operator">=</span> j<span class="token punctuation">;</span>        j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续向下遍历</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//建堆</span><span class="token keyword">void</span> <span class="token function">createHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>        <span class="token function">downAdjust</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">createHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//建堆</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从最后开始交换，直到只剩下最后一个数字</span>    <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//每次都将最大值放到最后</span>        <span class="token function">downAdjust</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将前0-i个数字重新构成大根堆</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小根堆排序："><a href="#小根堆排序：" class="headerlink" title="小根堆排序："></a>小根堆排序：</h3><p>与大根堆排序是一样的【但排序结果为从大到小排序】<br>只需要在downAdjust()中将父节点与子节点的大小比较改变一下   </p><h3 id="删除堆顶元素："><a href="#删除堆顶元素：" class="headerlink" title="删除堆顶元素："></a>删除堆顶元素：</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//删除堆顶元素</span><span class="token keyword">void</span> <span class="token function">deleteTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//也就是堆顶使用最后一个数值来替代</span>    <span class="token function">downAdjust</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//然后对前n-1个数进行排序</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加元素："><a href="#添加元素：" class="headerlink" title="添加元素："></a>添加元素：</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//向上调整</span><span class="token keyword">void</span>  <span class="token function">upAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span>  i <span class="token operator">=</span> R<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//i为欲调整结点，j为其父亲</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> L<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//父节点小了，那么就将孩子节点调上来</span>        <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> j<span class="token punctuation">;</span>            j <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续向上遍历</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token comment" spellcheck="true">//无需调整</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span>  x<span class="token punctuation">)</span><span class="token punctuation">{</span>    v<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将新加入的值放置在数组的最后，切记保证数组空间充足</span>    <span class="token function">upAdjust</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向上调整新加入的结点n</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。<br>它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。 当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n<em>log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n</em>log(n)), 如归并排序，堆排序）   </p><p>计数排序对输入的数据有附加的限制条件：</p><ol><li>输入的线性表的元素属于有限偏序集S；</li><li>设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。<br>在这两个条件下，计数排序的复杂性为O(n)。     </li></ol><p>找出待排序的数组中最大和最小的元素；<br>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；[计数]<br>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。[放出去一个，那么就计数减少一个]    </p><p>计数排序算法是一个稳定的排序算法。   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">CountSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> minN <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> maxN <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//找出最大值与最小值</span>    <span class="token punctuation">{</span>        minN <span class="token operator">=</span> minN <span class="token operator">&lt;</span> a <span class="token operator">?</span> minN <span class="token operator">:</span> a<span class="token punctuation">;</span>        maxN <span class="token operator">=</span> maxN <span class="token operator">></span> a <span class="token operator">?</span> maxN <span class="token operator">:</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">nums</span><span class="token punctuation">(</span>maxN <span class="token operator">-</span> minN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//以空间换取时间，用来计算每个数的数量</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span>        <span class="token operator">++</span>nums<span class="token punctuation">[</span>a <span class="token operator">-</span> minN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将数赋给原数组</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span>            v<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> minN<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。<br>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。   </p><p><strong>桶排序 (Bucket sort)的工作的原理：</strong><br>假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序  </p><p><strong>数据结构设计：</strong><br>链表可以采用很多种方式实现，通常的方法是动态申请内存建立结点，但是针对这个算法，桶里面的链表结果每次扫描后都不同，就有很多链表的分离和重建。如果使用动态分配内存，则由于指针的使用，安全性低。<br>所以，使用了数组来模拟链表（当然牺牲了部分的空间，但是操作却是简单了很多，稳定性也大大提高了）。共十个桶，所以建立一个二维数组，行向量的下标0—9代表了10个桶，每个行形成的一维数组则是桶的空间。     </p><p>平均情况下桶排序以线性时间运行。像基数排序一样，桶排序也对输入作了某种假设，因而运行得很快。具体来说，基数排序假设输入是由一个小范围内的整数构成，而桶排序则假设输入由一个随机过程产生，该过程将元素一致地分布在区间[0，1)上。 桶排序的思想就是把区间[0，1)划分成n个相同大小的子区间，或称桶，然后将n个输入数分布到各个桶中去。因为输入数均匀分布在[0，1)上，所以一般不会有很多数落在一个桶中的情况。为得到结果，先对各个桶中的数进行排序，然后按次序把各桶中的元素列出来即可。   </p><p>在桶排序算法的代码中，假设输入是含n个元素的数组A，且每个元素满足0≤ A[i]&lt;1。<br>另外还需要一个辅助数组B[O..n-1]来存放链表实现的桶，并假设可以用某种机制来维护这些表。   </p><p><strong>算法思想：</strong><br>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；<br>遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；<br>从不是空的桶里把排好序的数据拼接起来。<br>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129232944991-274909653.png" alt=""></p><p>对N个关键字进行桶排序的时间复杂度分为两个部分：<br>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。<br>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为<code>∑ O(Ni*logNi)</code> 。  </p><p>其中Ni 为第i个桶的数据量。<br>很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到<code>O(N*logN)了)</code>。</p><p>因此，我们需要尽量做到下面两点：<br>(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。<br>(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。    当然，做到这一点很不容易，数据量巨大的情况下，f(k)   函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。  </p><p>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：<br><code>O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)</code><br>当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。<br>总结：桶排序的平均时间复杂度为线性的O(N+C)，其中<code>C=N*(logN-logM)</code>。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。当然桶排序的空间复杂度为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">BucketSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> minN <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> maxN <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//找出最大值与最小值</span>    <span class="token punctuation">{</span>        minN <span class="token operator">=</span> minN <span class="token operator">&lt;</span> a <span class="token operator">?</span> minN <span class="token operator">:</span> a<span class="token punctuation">;</span>        maxN <span class="token operator">=</span> maxN <span class="token operator">></span> a <span class="token operator">?</span> maxN <span class="token operator">:</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token function">bucket</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxN<span class="token operator">-</span>minN<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除数是按照数据范围进行调整的</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将数据放入对应的桶中</span>        bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>a <span class="token operator">-</span> minN<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucket<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token function">sort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分别对每个桶进行排序，可以使用任意的排序算法，个人感觉没必要使用复杂的排序算法</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> bucket<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将数据赋予原数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> b <span class="token operator">:</span> a<span class="token punctuation">)</span>            v<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序（radix sort）属于“分配式排序”（distribution sort），基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。   </p><p><strong>过程：</strong><br>取得数组中的最大数，并取得位数；<br>arr为原始数组，从最低位开始取每个位组成radix数组；<br>对radix进行计数排序（利用计数排序适用于小范围数的特点）；    </p><p>源数据：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233027963-1766286128.png" alt=""><br>第一次排序：【按个位数】<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233032416-1559345928.png" alt=""><br>还原：【底下的先出来】<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233042559-1408220568.png" alt=""><br>再排：【按十位数】<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233047290-1231896371.png" alt=""><br>再次还原：【底下的先出来】<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233052548-1962580255.png" alt=""></p><p><strong>最高位优先</strong>(Most Significant Digit first)法，简称MSD法：<br>先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。   </p><p><strong>最低位优先</strong>(Least Significant Digit first)法，简称LSD法：     先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//基数排序</span><span class="token keyword">void</span> <span class="token function">RadixSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> maxBit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最大的位数</span>    <span class="token keyword">int</span> bit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先从个位开始</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里我就偷懒直接使用string来转换</span>        maxBit <span class="token operator">=</span> maxBit <span class="token operator">></span> len <span class="token operator">?</span> maxBit <span class="token operator">:</span> len<span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxBit<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最大的数有多少位就进行多少次排序</span>    <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存放位数上数值相同的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span>            count<span class="token punctuation">[</span><span class="token punctuation">(</span>a <span class="token operator">%</span> <span class="token punctuation">(</span>bit <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">/</span> bit<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//按照第bit位上进行排序</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> count<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> b <span class="token operator">:</span> a<span class="token punctuation">)</span>                v<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将数据放回</span>        bit <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向前一位</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序算法总结："><a href="#排序算法总结：" class="headerlink" title="排序算法总结："></a>排序算法总结：</h2><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233123515-993860531.png" alt=""></p><ul><li>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233133750-173981905.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233155386-551809284.png" alt=""></li></ul><p>名词及数据解释：  </p><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li><li>log为log2</li><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ul><p>从算法的简单性来看，我们将7种算法分为两类：</p><ul><li>简单算法：冒泡、简单选择、直接插入。</li><li>改进算法：希尔、堆、归并、快速。</li><li>比较排序：快速排序、归并排序、堆排序、冒泡排序。</li></ul><p>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。<br>非比较排序：计数排序、基数排序、桶排序</p><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li></ul><p>所谓的稳定性：<br>就是维持相同数字在排序过程中的相对位置。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233225976-15046075.png" alt=""><br>是稳定的，以为111的相对位置未被打乱。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201911/1463063-20191129233229777-1913348815.png" alt=""><br>不是稳定的，因为555的相对位置打乱了。</p><p><strong>意义：</strong><br>在比较数据的属性时，比如年龄、身高、体重,若按身高排序，然后再按年龄排序，在稳定性下，相同年龄的两人会安上次身高的排序放置！！！</p><p><strong>怎么选用排序算法</strong></p><ul><li>在排序数据&lt;60时，会选择插入排序，当数据量很大时，先选择归并等算法，当数据分支小于60时，立马使用插入排序。</li><li>从空间复杂度来考虑：首选堆排序，其次是快速排序，最后是归并排序。</li><li>若从稳定性来考虑，应选取归并排序，因为堆排序和快速排序都是不稳定的。</li><li>若从平均情况下的排序速度考虑，应该选择快速排序。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——hash表详解</title>
      <link href="/2019/12/23/shu-ju-jie-gou-hash-biao-xiang-jie/"/>
      <url>/2019/12/23/shu-ju-jie-gou-hash-biao-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表结构讲解："><a href="#哈希表结构讲解：" class="headerlink" title="哈希表结构讲解："></a>哈希表结构讲解：</h2><p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>记录的存储位置 = <strong>function(关键字)</strong><br>这里的对应关系function称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。   </p><p>哈希表hashtable(key，value)  就是把Key通过一个固定的算法函数function既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，<strong>取余</strong>结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。） 而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标 <strong>(仍通过映射哈希函数function)</strong> ，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。 </p><h2 id="Hash的应用："><a href="#Hash的应用：" class="headerlink" title="Hash的应用："></a>Hash的应用：</h2><ol><li><p>Hash主要用于信息安全领域中==加密算法==，它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做Hash值. 也可以说，Hash就是找到一种数据内容和数据存放地址之间的映射关系。</p></li><li><p>查找：<br>哈希表，又称为散列，是一种更加快捷的查找技术。我们之前的查找，都是这样一种思路：集合中拿出来一个元素，看看是否与我们要找的相等，如果不等，缩小范围，继续查找。而哈希表是完全另外一种思路：当我知道key值以后，我就可以直接计算出这个元素在集合中的位置，根本不需要一次又一次的查找！</p></li></ol><p>举一个例子，假如我的数组A中，第i个元素里面装的key就是i，那么数字3肯定是在第3个位置，数字10肯定是在第10个位置。哈希表就是利用利用这种基本的思想，建立一个从key到位置的函数，然后进行直接计算查找。</p><ol start="3"><li>Hash表在海量数据处理中有着广泛应用。</li></ol><h2 id="Hash的特点："><a href="#Hash的特点：" class="headerlink" title="Hash的特点："></a>Hash的特点：</h2><p>Hash Table的查询速度非常的快，几乎是==O(1) 的时间复杂度==。<br>hash就是找到一种数据内容和数据存放地址之间的映射关系。   </p><h3 id="散列法：元素特征转变为数组下标的方法。"><a href="#散列法：元素特征转变为数组下标的方法。" class="headerlink" title="散列法：元素特征转变为数组下标的方法。"></a>散列法：元素特征转变为数组下标的方法。</h3><p>我想大家都在想一个很严重的问题：“如果两个字符串在哈希表中对应的位置相同怎么办？”,毕竟一个数组容量是有限的，这种可能性很大。解决该问题的方法很多，我首先想到的就是用“链表”。我遇到的很多算法都可以转化成链表来解决，只要在<strong>哈希表的每个入口挂一个链表</strong>，保存所有对应的字符串就OK了。</p><h3 id="散列表的查找步骤-："><a href="#散列表的查找步骤-：" class="headerlink" title="散列表的查找步骤 ："></a>散列表的查找步骤 ：</h3><p>当存储记录时，通过散列函数计算出记录的散列地址<br>当查找记录时，我们通过同样的是散列函数计算记录的散列地址，并按此散列地址访问该记录   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//////////////////*********怎样判断一个数是否存在hash表中///////</span>即使用hash映射函数进行查找，当查找某个位置为空或者查找整个hash表完毕即表示该数不存在hash表中<span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token punctuation">(</span>x <span class="token operator">+</span> j <span class="token operator">*</span> j<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">]</span> <span class="token operator">==</span> x <span class="token operator">||</span> v<span class="token punctuation">[</span><span class="token punctuation">(</span>x <span class="token operator">+</span> j <span class="token operator">*</span> j<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//==0表示不存在，我就死在这点上了</span>     <span class="token keyword">break</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关键字——散列函数（哈希函数）——散列地址"><a href="#关键字——散列函数（哈希函数）——散列地址" class="headerlink" title="关键字——散列函数（哈希函数）——散列地址"></a>关键字——散列函数（哈希函数）——散列地址</h3><p><strong>优点</strong>：一对一的查找效率很高；</p><p><strong>缺点</strong>：一个关键字可能对应多个散列地址；需要查找一个范围时，效果不好。</p><p><strong>散列冲突</strong>：不同的关键字经过散列函数的计算得到了相同的散列地址。</p><p>==好的散列函数=计算简单+分布均匀（计算得到的散列地址分布均匀）m==</p><p>哈希表是种数据结构，它可以提供快速的插入操作和查找操作。 </p><h2 id="Hash优缺点："><a href="#Hash优缺点：" class="headerlink" title="Hash优缺点："></a>Hash优缺点：</h2><p><strong>优点：</strong><br>不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即O(1）的时间级。实际上，这只需要几条机器指令。</p><p>哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。</p><p>如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。</p><p><strong>缺点：</strong><br>它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。 </p><h2 id="常见的散列法："><a href="#常见的散列法：" class="headerlink" title="常见的散列法："></a>常见的散列法：</h2><p>元素特征转变为数组下标的方法就是散列法。散列法当然不止一种，下面列出三种比较常用的：</p><h3 id="1、除法【求余】散列法"><a href="#1、除法【求余】散列法" class="headerlink" title="1、除法【求余】散列法"></a>1、除法【求余】散列法</h3><p>最直观的一种，公式：<br><strong>index = value % 16</strong><br>学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。<br>一般哈希表的大小为素数，因为素数不存在因子，所以大大减少了位置冲突的概率</p><h3 id="2、MAD法"><a href="#2、MAD法" class="headerlink" title="2、MAD法"></a>2、MAD法</h3><p>除余法存在的不足<br>除余法虽能一定程度保证词条均匀分布，但从关键码空间到散列地址空间依然残留有一定的连续性，如 相邻关键码对应散列地址也相邻。<br>因此便有mad法，若常数ab选取得当，可以很好地克服除余法的这种连续性。除余法也可以看作Mad法a=1和b=0的特例，只是两个常数并未发挥实质作用。<br><img src="https://img-blog.csdnimg.cn/20191121225601879.jpg" alt=""><br>表达式:<br><strong>hash(key) = (a*key+b) % M</strong>， 其中M仍为素数,a&gt;0,b&gt;0，且a % M != 0</p><h3 id="3、数字分析法（selecting-digits）"><a href="#3、数字分析法（selecting-digits）" class="headerlink" title="3、数字分析法（selecting digits）"></a>3、数字分析法（selecting digits）</h3><p>注：<br>以下各方法为保证落在合法的散列地址空间上，最后通常还需对表长M取余。<br>思路:<br>从关键码key特定进制的展开中抽取特定的若干位，构成整型地址。<br>表达式:<br>例：选取key十进制展开中的奇数位<br><strong>hash(123456789) = 13579</strong>   </p><h3 id="4、平方取中法（mid-square）"><a href="#4、平方取中法（mid-square）" class="headerlink" title="4、平方取中法（mid-square）"></a>4、平方取中法（mid-square）</h3><p>思路:<br>从关键码key的平方的十进制或二进制展开中取居中的若干位，构成一个整型地址。<br>表达式:<br>例：取平方并用十进制展开中的居中3位作为散列地址<br><strong>123^2 = 15129，hash(123) = 512</strong>                  </p><h3 id="5、折叠法（folding）"><a href="#5、折叠法（folding）" class="headerlink" title="5、折叠法（folding）"></a>5、折叠法（folding）</h3><p>思路:<br>将关键码的十进制或二进制展开分割成等宽的若干段，取其总和作为散列地址。<br>表达式:<br>例：以十进制三个数位为分割单位<br><strong>hash(123456789) = 123+456+789 = 1368</strong>                       </p><h3 id="6、异或法（xor）"><a href="#6、异或法（xor）" class="headerlink" title="6、异或法（xor）"></a>6、异或法（xor）</h3><p>思路:<br>将关键码的二进制展开分割成等宽的若干段，经异或运算得到散列地址。<br>表达式:<br>例：以二进制三个数位为分割单位<br><strong>hash(411) = hash(110011011b) = 110^011^011 = 110b = 6</strong> </p><h3 id="7、平方散列法"><a href="#7、平方散列法" class="headerlink" title="7、平方散列法"></a>7、平方散列法</h3><p>求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：<br><strong>index = (value * value) &gt;&gt; 28</strong><br>（右移，除以2^28。记法：左移变大，是乘。右移变小，是除。）<br>如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的index都是0——非常失败。也许你还有个问题，value如果很大，value * value不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取index。</p><h3 id="8、斐波那契（Fibonacci）散列法"><a href="#8、斐波那契（Fibonacci）散列法" class="headerlink" title="8、斐波那契（Fibonacci）散列法"></a>8、斐波那契（Fibonacci）散列法</h3><p>平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。        </p><ol><li>对于16位整数而言，这个乘数是40503 </li><li>对于32位整数而言，这个乘数是2654435769 </li><li>对于64位整数而言，这个乘数是11400714819323198485</li></ol><p>这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,377, 610， 987, 1597, 2584, 4181, 6765, 10946，…。另外，斐波那契数列的值和太阳系八大行星的轨道半径的比例出奇吻合。</p><p>对我们常见的32位整数而言，公式：<br><strong>index = (value * 2654435769) &gt;&gt; 28</strong></p><p>如果用这种斐波那契散列法的话，那上面的图就变成这样了：<br><img src="https://img-blog.csdnimg.cn/20191121225628874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>注：用斐波那契散列法调整之后会比原来的取摸散列法好很多。      </p><p>适用范围:<br>快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。          </p><p>基本原理及要点:<br>hash函数选择，针对字符串，整数，排列，具体相应的hash方法。<br>碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。     </p><h2 id="散列冲突的解决方案："><a href="#散列冲突的解决方案：" class="headerlink" title="散列冲突的解决方案："></a>散列冲突的解决方案：</h2><ol><li><p>建立一个缓冲区，把凡是拼音重复的人放到缓冲区中。当我通过名字查找人时，发现找的不对，就在缓冲区里找。</p></li><li><p>进行再探测。就是在其他地方查找。探测的方法也可以有很多种。</p><ul><li><p>在找到查找位置的index的index-1，index+1位置查找，index-2，index+2查找，依次类推。这种方法称为线性再探测。</p><ul><li><p>在查找位置index周围随机的查找。称为随机在探测。</p></li><li><p>再哈希。就是当冲突时，采用另外一种映射方式来查找。</p></li></ul><p>这个程序中是通过取模来模拟查找到重复元素的过程。对待重复元素的方法就是再哈希：对当前key的位置+7。最后，可以通过全局变量来判断需要查找多少次。我这里通过依次查找26个英文字母的小写计算的出了总的查找次数。显然，当总的查找次数/查找的总元素数越接近1时，哈希表更接近于一一映射的函数，查找的效率更高。 </p></li></ul></li></ol><h2 id="哈希冲突解决办法："><a href="#哈希冲突解决办法：" class="headerlink" title="哈希冲突解决办法："></a>哈希冲突解决办法：</h2><p>冲突必然的!<br>因为用短位(散列地址空间)表示长位数据(关键码空间)，肯定会出现冲突。比如 常见的 MD5码，一共就128bit，但却要表示无限的数据的散列码，因此必然会出现不同数据具有相同MD5码的情况。<br>如果遇到冲突，哈希表一般是怎么解决的呢？具体方法有很多，百度也会有一堆，最常用的就是开发定址法和链地址法。</p><p>冲突排解策略分为以下两种类型：           </p><ol><li><p><strong>开放定址(open addressing) / 闭散列(closed hashing)：</strong><br> 散列地址空间对所有词条开放（即 桶单元允许装hash(key)不对应的词条）；词条存储地址(散列地址)仅限于散列表所覆盖的范围之内。<br> 如：线性试探、查找链法等。<br> 注：因闭散列不得使用附加空间的原因，装填因子通常&lt;=0.5     </p></li><li><p><strong>封闭定址(closed addressing) / 开散列(open hashing)：</strong><br> 散列地址空间只对对应的词条开放；词条存储地址不局限于散列表范围之内。<br> 如：多槽位法、独立链法、公共溢出区等</p></li></ol><h3 id="1、多槽位法（multiple-slots）"><a href="#1、多槽位法（multiple-slots）" class="headerlink" title="1、多槽位法（multiple slots）"></a>1、多槽位法（multiple slots）</h3><p>思路:<br><img src="https://img-blog.csdnimg.cn/20191121225802634.jpg" alt=""><br>每个桶本身再细分为若干槽位，用于存放彼此冲突的词条。每个桶槽位的词典结构为向量，因此整体物理存储结构类似于二维数组。             如：put操作，首先通过hash(key)定位到对应的桶单元，并在该桶内部槽位中进一步查找key，若没找到，则创建新词条插入到该桶的空闲槽位中。<br>缺点:      </p><ul><li>绝大多数的槽位都处于空闲状态，造成空间浪费。若桶被细分为k个槽位，则装填因子将直接降低为原来的1/k.</li><li>很难实现确定应该细分为多少个槽位，才能保证够用。</li></ul><h3 id="2、-独立链法-separate-chaining-拉链法"><a href="#2、-独立链法-separate-chaining-拉链法" class="headerlink" title="2、 独立链法(separate chaining) / 拉链法"></a>2、 独立链法(separate chaining) / 拉链法</h3><p>思路:<br><img src="https://img-blog.csdnimg.cn/20191121225828805.jpg" alt=""><br>与多槽位思想类似，但每个桶的子词典是使用链表实现，令彼此冲突的词条互相串接。<br><strong>优点：</strong><br>能灵活动态地调整子词典的规模，有效地使用空间。<br><strong>缺点:</strong><br>空间未必连续分布，会导致系统缓存失效。<br><img src="https://img-blog.csdnimg.cn/20191121225854306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="3、公共溢出区"><a href="#3、公共溢出区" class="headerlink" title="3、公共溢出区"></a>3、公共溢出区</h3><p>原理:<br><img src="https://img-blog.csdnimg.cn/20191121225934334.jpg" alt=""><br>在原散列表之外另设一个词典结构$D_{overflow}$，插入词条一旦发生冲突，则转存到该词典中。$D_{overflow}$相当于存放冲突词条的公共缓冲池。</p><h3 id="4-线性探查法-【Linear-Probing】"><a href="#4-线性探查法-【Linear-Probing】" class="headerlink" title="4.线性探查法 【Linear Probing】"></a>4.线性探查法 【Linear Probing】</h3><p>当得到key的hash值H(key)，但是表中下标为H(key)的位置已经被某个其他元素使用了，那么就检查下一个位置H(key) + 1 是否被占，如果没有，就使用这个位置；否则就继续检查下一个位置（也就是将hash值H(key)不断加1）。如果检查过程中超过了表长，那么就回到表的首位继续循环，直到找到一个可以使用的位置，或者是发现表中所有位置都已被使用。显然，这个做法容易导致扎堆，即表中连续若干个位置都被使用，这在一定程度上会降低效率。 </p><h3 id="5-采用平方探查法【Quadratic-Probing】"><a href="#5-采用平方探查法【Quadratic-Probing】" class="headerlink" title="5.采用平方探查法【Quadratic Probing】"></a>5.采用平方探查法【Quadratic Probing】</h3><p>通过将给定元素值对表长的余数作为在哈希表中的插入位置，如果出现冲突，采用平方探查法解决。平方探查法的具体过程是，假设给定元素值为a，表长为M，插入位置为a%M，假设a%M位置已有元素，即发生冲突，则查找<br>(a+1^2)%M，(a-1^2)%M，   (a+2^2)%M，(a-2^2)%M，⋯⋯，   (a+k^2)%M，(a-k^2)%M直至查找到一个可进行插入的位置，否则当查找到(a+k^2)%M，(a-k^2)%M仍然不能插入则该元素插入失败。其中 k&lt;=M/2 【有的是k&lt;M】  </p><p>此方法中，hashtable的大小为素数</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="具体查找逻辑"><a href="#具体查找逻辑" class="headerlink" title="具体查找逻辑"></a>具体查找逻辑</h3><p>查找链(probing chain)：对于待查找的key，从hash(key)桶单元开始，直接空桶结束的顺序序列。       </p><ol><li>经hash(key)算得的当前桶单元，若关键码相等，则成功返回。      </li><li>当前桶单元非空，但关键码不等，则转入下一桶单元继续试探。         </li><li>当前桶为空，则返回查找失败。             </li></ol><p><strong>注：</strong><br>相互冲突的关键码比属于同一查找链（即中途不包含空桶），但同一查找链的关键码未必相互冲突。多组各自冲突的关键码所对应的查找链，有可能相互交织和重叠。<br><strong>优点：</strong><br>具体由良好的数据局部性，试探地桶单元在物理空间上依次连贯，系统缓存能发挥作用。</p><h3 id="懒惰删除："><a href="#懒惰删除：" class="headerlink" title="懒惰删除："></a>懒惰删除：</h3><p>定义：<br>从词典删除词条时，暂时并不实际将桶置空，而是额外维护一个删除标记Bitmap，标记该桶已删除。<br>为什么需要懒惰删除？<br>因为查找链中任何一环的缺失，都会导致后续词条的“丢失”，即无法找到已存在词条；同时因为开销问题，不可能每次删除操作都对查找链进行维护重建（在扩容时，才重建链）。<br>因此懒惰删除机制既能保证查找链的完整，也不需要太多开销。<br>加入懒惰删除后，操作逻辑的变化：         </p><ol><li>在删除等操作查询指定词条时，判断失败的条件变为：为空且不带懒惰删除标记。           </li><li>在插入操作时，找空桶过程中，判断桶为空条件为：带有懒惰标记或当前桶为空。        </li></ol><h3 id="d-left-hashing："><a href="#d-left-hashing：" class="headerlink" title="d-left hashing："></a>d-left hashing：</h3><p>其中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。<br>2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同 时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个 位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key 存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。 </p><h3 id="问题实例（海量数据处理）"><a href="#问题实例（海量数据处理）" class="headerlink" title="问题实例（海量数据处理）"></a>问题实例（海量数据处理）</h3><p>我们知道hash 表在海量数据处理中有着广泛的应用，下面，请看另一道百度面试题：<br>题目：海量日志数据，提取出某日访问百度次数最多的那个IP。<br>方案：IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。           </p><h2 id="hash-map的使用："><a href="#hash-map的使用：" class="headerlink" title="hash_map的使用："></a>hash_map的使用：</h2><p>hash函数系统自带的类型函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">></span> <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token operator">></span><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">short</span><span class="token operator">></span><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">></span> <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span> <span class="token keyword">struct</span> hash<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通的hash使用：  </p><pre class="line-numbers language-cpp"><code class="language-cpp">hash_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>map1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自定义hash函数的使用：</p><pre class="line-numbers language-cpp"><code class="language-cpp">hash_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token punctuation">,</span> hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> equal_to<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> mymap<span class="token punctuation">;</span> hash函数的自定义与默认函数：<span class="token keyword">struct</span> str_hash<span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//自写hash函数    </span>     size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token keyword">const</span>       <span class="token punctuation">{</span>           <span class="token keyword">unsigned</span> <span class="token keyword">long</span> __h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                     __h <span class="token operator">=</span> <span class="token number">107</span><span class="token operator">*</span>__h <span class="token operator">+</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token function">size_t</span><span class="token punctuation">(</span>__h<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// struct str_hash</span><span class="token comment" spellcheck="true">// {    //自带的string hash函数   </span><span class="token comment" spellcheck="true">//          size_t operator()(const string&amp; str) const    </span><span class="token comment" spellcheck="true">//          {  </span><span class="token comment" spellcheck="true">//                   return __stl_hash_string(str.c_str());  </span><span class="token comment" spellcheck="true">//          }    </span><span class="token comment" spellcheck="true">// };</span><span class="token comment" spellcheck="true">//  struct hash&lt;int> </span><span class="token comment" spellcheck="true">//  {        //自带的int hash函数   </span><span class="token comment" spellcheck="true">//     size_t operator()(int __x) const { return __x; }</span><span class="token comment" spellcheck="true">// }; </span><span class="token keyword">struct</span> str_equal  <span class="token comment" spellcheck="true">//即压入数据时，去重的比较函数</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//string 判断相等函数  </span>     <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token keyword">const</span>       <span class="token punctuation">{</span>                 <span class="token keyword">return</span> s1<span class="token operator">==</span>s2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span> 注意hash函数只指的是第一个元素类型 hash_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span>str_hash<span class="token punctuation">,</span>str_equal<span class="token operator">></span> map2<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="hash-map的案例——布隆过滤器"><a href="#hash-map的案例——布隆过滤器" class="headerlink" title="hash_map的案例——布隆过滤器"></a>hash_map的案例——布隆过滤器</h2><p>不安全网页的黑名单包含100亿个黑名单网页，每个网页的URL最多占用64B。现在想要实现一种网页过滤系统，可以根据网页的URL判断该网页是否在黑名单上，请设计该系统。<br>要求如下：            </p><ul><li>该系统允许有万分之一以下的判断失误率。         </li><li>使用的额外空间不要超过30GB。            </li><li>如果将这100亿个URL通过数据库或哈希表保存起来，就可以对每条URL进行查询，但是每个URL有64B，数量是100亿个，所以至少需要640GB的空间，不满足要求2。         </li></ul><p>如果面试者遇到网页黑名单系统、垃圾邮件过滤系统，爬虫的网页判重系统等题目，又看到系统容忍一定程度的失误率，但是对空间要求比较严格，那么很可能是面试官希望面试者具备布隆过滤器的知识。一个布隆过滤器精确地代表一个集合，并可以精确判断一个元素是否在集合中。注意，只是精确代表和精确判断，到底有多精确呢？则完全在于你具体的设计，但想做到完全正确是不可能的。布隆过滤器的优势就在于使用很少的空间就可以将准确率做到很高的程度。该结构由Burton Howard Bloom于1970年提出。  </p><p>那么什么是布隆过滤器呢？</p><p>假设有一个长度为m的bit类型的数组，即数组的每个位置只占一个bit，如果我们所知，每一个bit只有0和1两种状态，如图所示：<br><img src="https://img-blog.csdnimg.cn/20191121230117995.jpg" alt=""></p><p>再假设一共有k个哈希函数，这些函数的输出域S都大于或等于m，并且这些哈希函数都足够优秀且彼此之间相互独立（将一个哈希函数的计算结果乘以6除以7得出的新哈希函数和原函数就是相互独立的）。那么对同一个输入对象（假设是一个字符串，记为URL），经过k个哈希函数算出来的结果也是独立的。可能相同，也可能不同，但彼此独立。对算出来的每一个结果都对m取余（%m），然后在bit array 上把相应位置设置为1（我们形象的称为涂黑）。如图所示<br><img src="https://img-blog.csdnimg.cn/20191121230129649.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>我们把bit类型的数组记为bitMap。至此，一个输入对象对bitMap的影响过程就结束了，也就是bitMap的一些位置会被涂黑。接下来按照该方法，处理所有的输入对象（黑名单中的100亿个URL）。每个对象都可能把bitMap中的一些白位置涂黑，也可能遇到已经涂黑的位置，遇到已经涂黑的位置让其继续为黑即可。处理完所有的输入对象后，可能bitMap中已经有相当多的位置被涂黑。至此，一个布隆过滤器生成完毕，这个布隆过滤器代表之前所有输入对象组成的集合。 </p><p>那么在检查阶段时，如何检查一个对象是否是之前的某一个输入对象呢（判断一个URL是否是黑名单中的URL）？假设一个对象为a，想检查它是否是之前的输入对象，就把a通过k个哈希函数算出k个值，然后把k个值都取余（%m），就得到在[0,m-1]范围伤的k个值。接下来在bitMap上看这些位置是不是都为黑。如果有一个不为黑，说明a一定不再这个集合里。如果都为黑，说明a在这个集合里，但可能误判。<br>再解释具体一点，如果a的确是输入对象 ，那么在生成布隆过滤器时，bitMap中相应的k个位置一定已经涂黑了，所以在检查阶段，a一定不会被漏过，这个不会产生误判。会产生误判的是，a明明不是输入对象，但如果在生成布隆过滤器的阶段因为输入对象过多，而bitMap过小，则会导致bitMap绝大多数的位置都已经变黑。那么在检查a时，可能a对应的k个位置都是黑的，从而错误地认为a是输入对象（即是黑名单中的URL）。通俗地说，布隆过滤器的失误类型是“宁可错杀三千，绝不放过一个”。</p><p>布隆过滤器到底该怎么生成呢？只需记住下列三个公式即可：<br>对于输入的数据量n（这里是100亿）和失误率p（这里是万分之一），布隆过滤器的大小<br>m：m = - (n*lnp)/(ln2*ln2)，计算结果向上取整（这道题m=19.19n，向上取整为20n，即需要2000亿个bit，也就是25GB）<br>需要的哈希函数的个数k：k = ln2 * m/n = 0.7 * m/n（这道题k = 0.7 * 20n/n = 14）<br>由于前两步都进行了向上取整，那么由前两步确定的布隆过滤器的真正失误率p：p = (1 - e^(-nk/m))^k </p><h2 id="一致性哈希算法的基本原理"><a href="#一致性哈希算法的基本原理" class="headerlink" title="一致性哈希算法的基本原理"></a>一致性哈希算法的基本原理</h2><p><strong>题目</strong></p><p>工程师常使用服务器集群来设计和实现数据缓存，以下是常见的策略：<br>无论是添加、查询还是珊瑚数据，都先将数据的id通过哈希函数换成一个哈希值，记为key<br>如果目前机器有N台，则计算key%N的值，这个值就是该数据所属的机器编号，无论是添加、删除还是查询操作，都只在这台机器上进行。<br>请分析这种缓存策略可能带来的问题，并提出改进的方案。      </p><p><strong>解析</strong>    </p><p>题目中描述的缓存从策略的潜在问题是，如果增加或删除机器时（N变化）代价会很高，所有的数据都不得不根据id重新计算一遍哈希值，并将哈希值对新的机器数进行取模啊哦做。然后进行大规模的数据迁移。<br>为了解决这些问题，下面介绍一下一致性哈希算法，这时一种很好的数据缓存设计方案。我们假设数据的id通过哈希函数转换成的哈希值范围是2^32，也就是0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形，那么一个数据id在计算出哈希值之后认为对应到环中的一个位置上，如图所示<br><img src="https://img-blog.csdnimg.cn/20191121230147583.jpg" alt=""></p><p>接下来想象有三台机器也处在这样一个环中，这三台机器在环中的位置根据机器id（主机名或者主机IP，是主机唯一的就行）设计算出的哈希值对2^32取模对应到环上。那么一条数据如何确定归属哪台机器呢？我们可以在该数据对应环上的位置顺时针寻找离该位置最近的机器，将数据归属于该机器上:<br><img src="https://img-blog.csdnimg.cn/2019112123020021.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=" "></p><p>这样的话，如果删除machine2节点，则只需将machine2上的数据迁移到machine3上即可，而不必大动干戈迁移所有数据。当添加节点的时候，也只需将新增节点到逆时针方向新增节点前一个节点这之间的数据迁移给新增节点即可。 </p><p>但这时还是存在如下两个问题：</p><p>机器较少时，通过机器id哈希将机器对应到环上之后，几个机器可能没有均分环<br><img src="https://img-blog.csdnimg.cn/20191121230241965.jpg" alt=""><br>那么这样会导致负载不均。</p><p>增加机器时，可能会打破现有的平衡：<br><img src="https://img-blog.csdnimg.cn/2019112123025041.jpg" alt=""> </p><p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一台机器通过不同的哈希函数计算出多个哈希值，对多个位置都放置一个服务节点，称为虚拟节点。</p><p>具体做法：比如对于machine1的IP192.168.25.132（或机器名），计算出192.168.25.132-1、192.168.25.132-2、192.168.25.132-3、192.168.25.132-4的哈希值，然后对应到环上，其他的机器也是如此，这样的话节点数就变多了，根据哈希函数的性质，平衡性自然会变好：<br><img src="https://img-blog.csdnimg.cn/20191121230259813.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzNzQ5NQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>此时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，比如上图的查找表。当某一条数据计算出归属于m2-1时再根据查找表的跳转，数据将最终归属于实际的m1节点。</p><p>基于一致性哈希的原理有很多种具体的实现，包括Chord算法、KAD算法等，有兴趣的话可以进一步学习。</p><h2 id="RandomPool"><a href="#RandomPool" class="headerlink" title="RandomPool"></a>RandomPool</h2><p>设计一种结构，在该结构中有如下三个功能：        </p><ul><li>inserrt(key)：将某个key加入到该结构中，做到不重复加入。          </li><li>delete(key)：将原本在结构中的某个key移除。    </li><li>getRandom()：等概率随机返回结构中的任何一个key。<br>要求：insert、delete和getRandom方法的时间复杂度都是O(1)<br>思路：使用两个哈希表和一个变量size，一个表存放某key的标号，另一个表根据根据标号取某个key。size用来记录结构中的数据量。加入key时，将size作为该key的标号加入到两表中；删除key时，将标号最大的key替换它并将size–；随机取key时，将size范围内的随机数作为标号取key。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">RandomPool</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span>T <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">getPrint</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">getPrint</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>hash_map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>KeyMap<span class="token punctuation">;</span>hash_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span>IndexMap<span class="token punctuation">;</span><span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RandomPool<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>KeyMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> KeyMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>KeyMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size<span class="token punctuation">;</span>IndexMap<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"add succeed!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"add filed!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RandomPool<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">del</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">auto</span> ptr <span class="token operator">=</span> KeyMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> KeyMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete filed! there is not exsite the key!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//交换查找到元素与最后一个元素</span>T temp <span class="token operator">=</span> IndexMap<span class="token punctuation">[</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最后一个元素的关键词,同时将hash表中的元素删除了</span><span class="token keyword">int</span> index <span class="token operator">=</span> KeyMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//要删除元素的位置</span>KeyMap<span class="token punctuation">[</span>temp<span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">;</span>IndexMap<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将最后一个元素替换要删除元素的位置</span><span class="token comment" spellcheck="true">//正式删除</span>KeyMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>IndexMap<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>IndexMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>T RandomPool<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the map is empty!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">99</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">99</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//随机生成一个位置</span><span class="token keyword">return</span> IndexMap<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RandomPool<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">getPrint</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>KeyMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> KeyMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the key is not exsite!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> KeyMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RandomPool<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">getPrint</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>IndexMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">==</span> IndexMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"the key is not exsite!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> IndexMap<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>code <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"lang-java"</span><span class="token operator">></span>import java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RandomPool</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">public</span> HashMap<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Integer<span class="token operator">></span> keySignMap<span class="token punctuation">;</span><span class="token keyword">public</span> HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Object<span class="token operator">></span> signKeyMap<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">RandomPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keySignMap <span class="token operator">=</span> <span class="token keyword">new</span> HashMap<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>signKeyMap <span class="token operator">=</span> <span class="token keyword">new</span> HashMap<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//不重复添加</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>keySignMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    keySignMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    signKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>keySignMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object lastKey <span class="token operator">=</span> signKeyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">--</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> deleteSign <span class="token operator">=</span> keySignMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        keySignMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>lastKey<span class="token punctuation">,</span> deleteSign<span class="token punctuation">)</span><span class="token punctuation">;</span>        signKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>deleteSign<span class="token punctuation">,</span> lastKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        keySignMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        signKeyMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastKey<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> Object <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> signKeyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="认识一致性哈希"><a href="#认识一致性哈希" class="headerlink" title="认识一致性哈希"></a>认识一致性哈希</h2><p>使用二分法，找到hash值大于等于该值的hash值的服务器即为管理该值的服务器<br>一致性哈希的应用：<br>当我们要添加或减少服务器时，一般操作是将已存的值重新计算hash值，然后取mod，来决定管理该数据的服务器，代价太高，时间太长</p><p>于是使用一个环来减少操作：<br>将hash范围组成一个环，如图所示，然后将服务器按其hash值按顺序数组中，<br>然后每输入一个数据，根据其hash值，使用二分法将其放入刚刚&gt;=该数hash值的服务器。<br>当添加服务器时，【假如添加一个服务器mx在m1-m2之间】只需要将原m1-m2中一部分小于mx的数据改为有mx来管理。<br>如何确保服务器负载均衡【因为服务器的hash值不均匀】？<br>使用一致hash<br>将每个服务器产生N个虚拟服务器，如1000个，则有3个服务器就有3000个虚拟服务器，然后让3000个虚拟去负载整个hash范围，那么这三个服务器的虚拟服务器所管理的数据就几乎均分分布在整个hash域中<br>那么就认为这3个服务器的负载均衡。<br>添加与删除原理也是如此。              </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——红黑树</title>
      <link href="/2019/12/22/shu-ju-jie-gou-hong-hei-shu/"/>
      <url>/2019/12/22/shu-ju-jie-gou-hong-hei-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>红黑树的起源，自然是二叉查找树了，这种树结构从根节点开始，左子节点小于它，右子节点大于它。每个节点都符合这个特性，所以易于查找，是一种很好的数据结构。但是它有一个问题，就是容易偏向某一侧，这样就像一个链表结构了，失去了树结构的优点，查找时间会变坏。</p><p>所以我们都希望树结构都是矮矮胖胖的，像这样：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232256511-1770822469.png" alt=""></p><p>而不是像这样：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232306279-1089139086.png" alt=""></p><p>在这种需求下，平衡树（AVL）的概念就应运而生了。<br>红黑树就是一种平衡树，它可以保证二叉树基本符合矮矮胖胖的结构，但是理解红黑树之前，必须先了解另一种树，叫2-3树，红黑树背后的逻辑就是它。</p><p>好吧来看2-3树吧。<br>2-3树是二叉查找树的变种，树中的2和3代表两种节点，以下表示为2-节点和3-节点。<br>2-节点即普通节点：包含一个元素，两条子链接。<br>3-节点则是扩充版，包含2个元素和三条链接：两个元素A、B，左边的链接指向小于A的节点，中间的链接指向介于A、B值之间的节点，右边的链接指向大于B的节点。<br>2-节点：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232349973-1733377438.png" alt=""><br>3-节点：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232431538-1959600684.png" alt=""></p><p>在这两种节点的配合下，2-3树可以保证在插入值过程中，任意叶子节点到根节点的距离都是相同的。完全实现了矮胖矮胖的目标。怎么配合的呢，下面来看2-3树的构造过程。<br>所谓构造，就是从零开始一个节点一个节点的插入。<br>在二叉查找树中，插入过程从根节点开始比较，小于节点值往右继续与左子节点比，大于则继续与右子节点比，直到某节点左或右子节点为空，把值插入进去。这样无法避免偏向问题。在2-3树中，插入的过程是这样的。<br>如果将值插入一个2-节点，则将2-节点扩充为一个3-节点。<br>如果将值插入一个3-节点，分为以下几种情况。</p><p>(1).3-节点没有父节点，即整棵树就只有它一个三节点。此时，将3-节点扩充为一个4-节点，即包含三个元素的节点，然后将其分解，变成一棵二叉树。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232507203-1019263925.png" alt=""><br>此时二叉树依然保持平衡。   </p><p>(2).3-节点有一个2-节点的父节点，此时的操作是，3-节点扩充为4-节点，然后分解4-节点，然后将分解后的新树的父节点融入到2-节点的父节点中去。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232523136-1704921855.png" alt=""></p><p>(3).3-节点有一个3-节点的父节点，此时操作是：3-节点扩充为4-节点，然后分解4-节点，新树父节点向上融合，上面的3-节点继续扩充，融合，分解，新树继续向上融合，直到父节点为2-节点为止，如果向上到根节点都是3-节点，将根节点扩充为4-节点，然后分解为新树，至此，整个树增加一层，仍然保持平衡。   </p><p>第三种情况稍微复杂点，为了便于直观理解，现在我们从零开始构建2-3树，囊括上面所有的情况，看完所以步骤后，你也可以自己画一画。</p><p>我们将{7,8,9,10,11,12}中的数值依次插入2-3树，画出它的过程：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232557632-860740846.png" alt=""></p><p>所以，2-3树的设计完全可以保证二叉树保持矮矮胖胖的状态，保持其性能良好。但是，将这种直白的表述写成代码实现起来并不方便，因为要处理的情况太多。这样需要维护两种不同类型的节点，将链接和其他信息从一个节点复制到另一个节点，将节点从一种类型转换为另一种类型等等。</p><p>因此，红黑树出现了，红黑树的背后逻辑就是2-3树的逻辑，但是由于用红黑作为标记这个小技巧，最后实现的代码量并不大。(但是，要直接理解这些代码是如何工作的以及背后的道理，就比较困难了。所以你一定要理解它的演化过程，才能真正的理解红黑树)</p><p>我们来看看红黑树和2-3树的关联，首先，最台面上的问题，红和黑的含义。红黑树中，所有的节点都是标准的2-节点，为了体现出3-节点，这里将3-节点的两个元素用左斜红色的链接连接起来，即连接了两个2-节点来表示一个3-节点。这里红色节点标记就代表指向其的链接是红链接，黑色标记的节点就是普通的节点。</p><p>所以才会有那样一条定义，叫“从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点”，因为红色节点是可以与其父节点合并为一个3-节点的，红黑树实现的其实是一个完美的黑色平衡，如果你将红黑树中所有的红色链接放平，那么它所有的叶子节点到根节点的距离都是相同的。所以它并不是一个严格的平衡二叉树，但是它的综合性能已经很优秀了。</p><p>借一张别人的图来看：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232626189-455918211.png" alt=""></p><p>红链接放平：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232643426-1761684491.png" alt=""></p><p>所以，红黑树的另一种定义是满足下列条件的二叉查找树：</p><ol><li>链接均为左链接。</li><li>没有任何一个结点同时和两条红链接相连。(这样会出现4-节点)</li><li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li></ol><h1 id="红黑树（一）——基本概念"><a href="#红黑树（一）——基本概念" class="headerlink" title="红黑树（一）——基本概念"></a>红黑树（一）——基本概念</h1><h2 id="1-红黑树基本特性"><a href="#1-红黑树基本特性" class="headerlink" title="1. 红黑树基本特性"></a>1. 红黑树基本特性</h2><h3 id="1-1-红黑树定义"><a href="#1-1-红黑树定义" class="headerlink" title="1.1 红黑树定义"></a>1.1 红黑树定义</h3><p>红黑树是一种特殊的二叉树，且必须要满足以下几个特性：  </p><ol><li>每个节点或是黑色或是红色 </li><li>根节点是黑色 </li><li>每个叶节点是黑色（叶节点为空节点） </li><li>如果一个节点是红色，则它的两个子节点必须是黑色 </li><li>从任意的一个节点到该节点的所有叶节点的路径包含相同数目的黑色节点</li><li>红黑树是一种平衡二叉树，当不是完全的平衡二叉树，红黑树只要求最多三次旋转来尽可能达到平衡    【也就是说没有规定左子树与右子树的高度差必须&lt;=1!!!!!!】</li></ol><h3 id="1-2-红黑树时间复杂度"><a href="#1-2-红黑树时间复杂度" class="headerlink" title="1.2 红黑树时间复杂度"></a>1.2 红黑树时间复杂度</h3><p>定理：红黑树的时间复杂度为0（log2n）。<br>定义：   </p><ol><li>h（v）为以节点v为根节点的子树的高度。   </li><li>bh（v）为从节点v到其子树叶节点路径中黑色节点的数量。  </li></ol><p>根据特性5可知，bh（v）是唯一值。<br>又根据特性4可知，从一个节点到其叶节点路径上的黑色节点数目≥路径上的红色节点数目。也就是说h（x）≤2bh（x）</p><p>引理：以v为根节点的红黑树，至少有2bh（v）-1 个内部节点。<br>使用数学归纳法证明引理：</p><ol><li>当树的高度h=0时，内部节点个数为0，bh（v）=0，则2bh（v）-1=0，显然满足内部节点个数≥2bh（v）-1.</li><li>当h&gt;0，且当h-1时，包含的内部节点数至少为2bh（v）-1-1，<br>那么对于根节点x，其左子树的内部节点个数至少为2bh（v）-1-1，其右子节点的内部节点个数至少为2bh（v）-1-1，则高度为h，内部节点个数至少为（2bh（v）-1-1）+（2hb（v）-1-1）+1=2bh（v）-1。引理得证。</li></ol><p>根据引理可以得出，一个节点数为n的红黑树，bh（v）≤log2（n+1）。又因为h（x）≤2bh（x），可得，h≤2log2（n+1）。<br><strong>（结论1）</strong>红黑树是一种特殊的二又树，对于有n个节点的二又树而言，当其为满二又树时，树的高度最小。</p><p>满二又树的节点数量与高度的关系为n=2h-1。<br>那么可以得出，h≥log2（n+1）。<br><strong>（结论2）</strong>由结论1和结论2可知，log2（n+1）≤h≤2log2（n+1）。<br>所以，红黑树的时间复杂度为：0（log2n）   </p><h3 id="1-3-节点结构定义"><a href="#1-3-节点结构定义" class="headerlink" title="1.3  节点结构定义"></a>1.3  节点结构定义</h3><p>红黑树的节点结构与一般的二叉树类似，但是多了一个标记颜色的变量。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> RBTColor<span class="token punctuation">{</span>RED<span class="token punctuation">,</span> BLACK<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">RBTNode</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    RBTColor color<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 颜色</span>    T key<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 关键字(键值)</span>    RBTNode <span class="token operator">*</span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左孩子</span>    RBTNode <span class="token operator">*</span>right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右孩子</span>    RBTNode <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 父结点</span>    <span class="token function">RBTNode</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> RBTColor c<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>p<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>l<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token function">key</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">color</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">left</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">right</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-红黑树旋转操作"><a href="#2-红黑树旋转操作" class="headerlink" title="2. 红黑树旋转操作"></a>2. 红黑树旋转操作</h2><p>红黑树的旋转操作目的是在插入或删除节点后，尽可能的保持红黑树的特性。旋转操作分为左旋和右旋。</p><h3 id="2-1-左旋操作"><a href="#2-1-左旋操作" class="headerlink" title="2.1 左旋操作"></a>2.1 左旋操作</h3><p>左旋操作效果如图所示。左旋操作会使当前节点与其右子节点位置互换。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222232959347-1985378619.png" alt=""></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">leftRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 设置x的右孩子为y</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>y <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的左孩子” 设为 “x的右孩子”；</span><span class="token comment" spellcheck="true">// 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    y<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的父亲” 设为 “y的父亲”</span>y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    root <span class="token operator">=</span> y<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “x的父亲” 是空节点，则将y设为根节点</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> x<span class="token punctuation">)</span>        x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span>    <span class="token keyword">else</span>        x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将 “x” 设为 “y的左孩子”</span>y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将 “x的父节点” 设为 “y”</span>x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-右旋操作"><a href="#2-2-右旋操作" class="headerlink" title="2.2 右旋操作"></a>2.2 右旋操作</h3><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233024036-941160549.png" alt=""><br>右旋操作效果如图所示。右旋操作会使当前节点与其左子节点位置互换。 </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">rightRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 设置x是当前节点的左孩子。</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的右孩子” 设为 “y的左孩子”；</span><span class="token comment" spellcheck="true">// 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”</span>y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    x<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的父亲” 设为 “x的父亲”</span>x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    root <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “y的父亲” 是空节点，则将x设为根节点</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>        y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”</span>    <span class="token keyword">else</span>        y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将 “y” 设为 “x的右孩子”</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将 “y的父节点” 设为 “x”</span>y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本篇文章主要介绍了红黑树的基本概念，包括红黑树的定义、时间复杂度及其证明、节点定义和旋转操作。 </p><h1 id="红黑树（二）——数据操作"><a href="#红黑树（二）——数据操作" class="headerlink" title="红黑树（二）——数据操作"></a>红黑树（二）——数据操作</h1><h2 id="1-查找"><a href="#1-查找" class="headerlink" title="1. 查找"></a>1. 查找</h2><p>红黑树的查找方式很简单，是一个递归过程。如果查找的元素小于当前节点，那么查找其左子树；如果查找的元素大于当前元素，则查找其右子树。查找的时间复杂度为O(log2n)。</p><h2 id="2-插入"><a href="#2-插入" class="headerlink" title="2. 插入"></a>2. 插入</h2><p>（图例：C表示当前节点，P表示父节点，U表示叔节点，G表示祖父节点）</p><p>插入操作首先需要通过查找操作找到合适的插入点，然后插入新节点。如果在插入节点后，发生了违背红黑树特性的情况时，需要对红黑树进行旋转染色等操作，使其重新满足特性。</p><h3 id="2-1-插入新节点"><a href="#2-1-插入新节点" class="headerlink" title="2.1 插入新节点"></a>2.1 插入新节点</h3><p><strong>第一步:</strong><br>将红黑树当作一颗二叉查找树，将节点插入。<br>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。</p><p><strong>第二步：</strong><br>将插入的节点着色为”红色”。<br>为什么着色成红色，而不是黑色呢？为什么呢？我们需要重新温习一下红黑树的特性：</p><ul><li>(1) 每个节点或者是黑色，或者是红色。</li><li>(2) 根节点是黑色。</li><li>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</li><li>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。</li><li>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ul><p>将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。</p><p><strong>第三步:</strong><br>通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。<br>第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>对于”特性(4)”，是有可能违背的！<br>那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* * 将结点插入到红黑树中** 参数说明：*     root 红黑树的根结点*     node 插入的结点        */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span><span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    y <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;</span> x<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>        x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token keyword">else</span>        x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span><span class="token punctuation">}</span>    node<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;</span> y<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>        y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">else</span>        y<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span>    root <span class="token operator">=</span> node<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 2. 设置节点的颜色为红色</span>node<span class="token operator">-</span><span class="token operator">></span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3. 将它重新修正为一颗二叉查找树</span><span class="token function">insertFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-调整子树"><a href="#2-2-调整子树" class="headerlink" title="2.2 调整子树"></a>2.2 调整子树</h3><p>那么，在违反了特性4的时候，新节点的父节点为红色节点。根据特性2可知，父节点不是根节点，则新节点必有祖父节点。<br>又根据特性3可推论出红色节点必有两个黑色子节点（空节点为黑色）。<br>此时会出现两种情况：叔节点为红色、叔节点为黑色。   </p><p>####（1）父节点与叔节点都为红色的情况<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233221783-1425102515.png" alt=""></p><p>在这种情况下，需要将父节点和叔节点变为黑色，再将祖父节点变为红色。这样，图上所展示的子树就满足了红黑树的特性。如下图所示。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233244262-855036277.png" alt=""><br>但是这里又可能会产生新的违法特性情况，因为祖父节点变成了红色，那么它可能会造成违反特性4的情况。所以，这里就将祖父节点作为当前节点，进行新一轮的调整操作。</p><p>####（2）父节点为红色, 叔节点为黑色的情况<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233302841-610895399.png" alt=""></p><p>在这种情况下，对其调整的核心就是保持父节点分支符合特性4，而叔节点分支保持符合特性5。<br><strong>第一步，旋转。</strong><br>对祖父节点进行左旋或者右旋。如果父节点是祖父节点的右子节点，那么对祖父节点进行左旋；否则，对祖父节点进行右旋。 </p><p><strong>第二步，染色。</strong><br>将祖父节点染为红色，而父节点染为黑色。<br>进过这两步，上图的情况会转换为下图所示。  </p><p>可以看出，父节点这一分支进过调整后，当前节点与父节点的颜色不再是连续红色，满足特性4。而叔节点这一分支的黑色节点数目没有发生变化，满足特性5。<br>对原祖父节点的父节点来说，该子树没有发生违反特性的变化。该子树调整完成。</p><h3 id="2-3-检查根节点"><a href="#2-3-检查根节点" class="headerlink" title="2.3 检查根节点"></a>2.3 检查根节点</h3><p>当上述调整执行完后，还有最后一步，就是检查是否满足特性2。这一步只需要将根节点染成黑色就可以，无需再多加判断。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** 红黑树插入修正函数** 在向红黑树中插入节点之后(失去平衡)，再调用该函数；* 目的是将它重新塑造成一颗红黑树。** 参数说明：*     root 红黑树的根*     node 插入的结点        // 对应《算法导论》中的z*/</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insertFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token operator">*</span>gparent<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若“父节点存在，并且父节点的颜色是红色”</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    gparent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//若“父节点”是“祖父节点的左孩子”</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> gparent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>        <span class="token punctuation">{</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>uncle <span class="token operator">=</span> gparent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                 <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">==</span> node<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>            <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>            parent <span class="token operator">=</span> node<span class="token punctuation">;</span>            node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是左孩子。</span>        <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span><span class="token comment" spellcheck="true">//若“z的父节点”是“z的祖父节点的右孩子”</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>        <span class="token punctuation">{</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>uncle <span class="token operator">=</span> gparent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>               <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是左孩子</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>            <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>            parent <span class="token operator">=</span> node<span class="token punctuation">;</span>            node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是右孩子。</span>        <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 将根节点设为黑色</span><span class="token function">rb_set_black</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-删除"><a href="#3-删除" class="headerlink" title="3. 删除"></a>3. 删除</h2><p>（图例：D表示当前节点，P表示父节点，B表示兄弟节点，BR表示兄弟节点的右子节点，BL表示兄弟节点的左子节点）</p><p>删除操作要比插入操作略微复杂一些。因为删除的节点可能是出现在树的中间层的节点，此时删除该节点会遇到很复杂的情况。所以，在删除节点的时候，需要先对红黑树进行一些调整，使得删除节点对整个树的影响降到最低。</p><h3 id="第一步：将红黑树当作一颗二叉查找树，将节点删除。"><a href="#第一步：将红黑树当作一颗二叉查找树，将节点删除。" class="headerlink" title="第一步：将红黑树当作一颗二叉查找树，将节点删除。"></a>第一步：将红黑树当作一颗二叉查找树，将节点删除。</h3><p>这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：</p><ol><li>被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</li><li>被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</li><li>被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</li></ol><h3 id="第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。"><a href="#第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。" class="headerlink" title="第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。"></a>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</h3><p>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p><h3 id="3-1-替换删除节点"><a href="#3-1-替换删除节点" class="headerlink" title="3.1 替换删除节点"></a>3.1 替换删除节点</h3><p>首先根据BST删除节点的规则，使用当前节点左子树的最大值节点【最右】或者右子树的最小值节点【最左】代替其删除（这两个节点是其子树中数值上最贴近当前节点数值的节点）。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233453271-1165499223.png" alt=""><br>为了方便讲解，我们默认采用的是右子树的最小值节点代替。<br>那么现在需要考虑的情况就减少了，只可能会出现以下几种情况（因为需要满足红黑树特性）： </p><ol><li>无子节点，节点为红色 </li><li>无子节点，节点为黑色 </li><li>只有右子节点，右子节点为红色，节点本身为黑色<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233513067-1819268508.png" alt=""><br>情况1，只需要直接删除节点就可以。 </li></ol><p>情况2，删除节点后，违反了红黑树特性5，需要调整（不考虑待删除节点为根节点的情况） </p><p>情况3，用右子节点占据待删除节点，再将其染成黑色即可，不违反红黑树特性。   </p><p>在这三种情况中，情况1和情况3比较简单，不需要多余的调整。情况2则需要后续的调整步骤使其满足红黑树特性。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/* * 删除结点(node)，并返回被删除的结点** 参数说明：*     root 红黑树的根结点*     node 删除的结点*/</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>child<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>RBTColor color<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 被删除节点的"左右孩子都不为空"的情况。</span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 被删节点的后继节点。(称为"取代节点")</span>    <span class="token comment" spellcheck="true">// 用它来取代"被删节点"的位置，然后再将"被删节点"去掉。</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>replace <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 获取后继节点</span>    replace <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>replace<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        replace <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// "node节点"不是根节点(只有根节点不存在父节点)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>            <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> replace<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> replace<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// "node节点"是根节点，更新根节点。</span>        root <span class="token operator">=</span> replace<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// child是"取代节点"的右孩子，也是需要"调整的节点"。</span>    <span class="token comment" spellcheck="true">// "取代节点"肯定不存在左孩子！因为它是一个后继节点。</span>    child <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>    color <span class="token operator">=</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// "被删除节点"是"它的后继节点的父节点"</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// child不为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span>            <span class="token function">rb_set_parent</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>        replace<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token function">rb_set_parent</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> replace<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    replace<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    replace<span class="token operator">-</span><span class="token operator">></span>color <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>color<span class="token punctuation">;</span>    replace<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    node<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>        <span class="token function">removeFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> node<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    child <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span><span class="token keyword">else</span>     child <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>parent <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>color <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>color<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span>    child<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// "node节点"不是根节点</span><span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>        parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token keyword">else</span>        parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span>    root <span class="token operator">=</span> child<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>    <span class="token function">removeFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-调整红黑树"><a href="#3-2-调整红黑树" class="headerlink" title="3.2 调整红黑树"></a>3.2 调整红黑树</h3><p>上述情况2的调整比较复杂。下面对各种情况进行讲解。<br>根据红黑树的特性5，待删除节点必然有兄弟节点。下面根据其兄弟节点所在分支的不同，来分情况讨论。<br>（以下是以关注节点为父节点的左子节点进行描述，如果遇到关注节点为父节点的右子节点的情况，则镜像处理） </p><h4 id="（1）兄弟节点为红色"><a href="#（1）兄弟节点为红色" class="headerlink" title="（1）兄弟节点为红色"></a>（1）兄弟节点为红色</h4><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233549386-1589251368.png" alt=""></p><p>先对父节点进行左旋操作，然后将父节点染成红色，兄弟节点染成黑色。此时就转换为了（4），之后按照（4）继进行调整。</p><p>（2）兄弟节点为黑色，远侄节点为红色<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233611890-1654034424.png" alt=""></p><p>这种情况下，不需要考虑父节点的颜色。<br><strong>第一步：</strong>对父节点P进行左旋操作<br><strong>第二步：</strong>将父节点P与兄弟节点B的颜色互换<br><strong>第三步：</strong>将兄弟节点的右子节点BR染成黑色<br>可以看到，经过这三步的调整后，直接删除节点D后满足红黑树的特性，调整完成。</p><p>####（3）兄弟节点为黑色，远侄节点为黑色，近侄节点为红色<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233722212-1190684847.png" alt=""><br>这种情况下，先对兄弟节点B进行右旋操作，然后BL节点染成黑色，B节点染成红色。此时的状况就和（2）一样了。之后就通过（2）的调整方式进行调整。</p><p>####（4）父节点为红色，兄弟节点为黑色，兄弟节点无子节点<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233738972-2030598122.png" alt=""><br>这种情况下，将父节点P染成黑色，再将兄弟节点染成红色。<br>经过这样的操作后，除去节点D后，以P为根节点的子树的黑节点深度没有发生。调整完成。</p><p>####（5）父节点为黑色，兄弟节点为黑色，兄弟节点无子节点<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222233753018-2072912921.png" alt=""><br>这种情况下，为了在删除节点D后使以P为根节点的子树能满足红黑树特性5，将兄弟节点B染成红色。但是这样操作后，以P为根节点的子树的黑色节点深度变小了。所以需要继续调整。<br>因为P节点子树的黑色深度发生了减少，可以把其当作待删除节点，那么此时就以P节点为关注节点进行进一步调整。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** 红黑树删除修正函数** 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；* 目的是将它重新塑造成一颗红黑树。** 参数说明：*     root 红黑树的根*     node 待修正的节点*/</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">removeFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>other<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>node <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> node <span class="token operator">!=</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_is_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> parent<span class="token punctuation">;</span>            parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>                other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>            <span class="token function">rb_set_color</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> root<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_is_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> parent<span class="token punctuation">;</span>            parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>                other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>                    <span class="token function">rb_set_color</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> root<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span>    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-检查根节点及删除节点"><a href="#3-3-检查根节点及删除节点" class="headerlink" title="3.3 检查根节点及删除节点"></a>3.3 检查根节点及删除节点</h3><p>经过上述的调整后，此时基本满足了红黑树的特性。但是存在根节点变成红色的情况。所以需要将根节点染成黑色的操作。<br>最后，执行删除操作，将待删除节点删掉。</p><p>###4. 总结<br>本篇文章讲解了红黑树的数据操作，包括除了左旋”、”右旋”、”添加”、”删除”、”遍历”、”查找”、”打印”、”最小值”、”最大值”、”创建”、”销毁”等接口。<br><strong>注意：</strong><br>红黑树中的private中的函数都是public中函数的内部实现函数，也就是说，为了确保红黑树的封装，几乎所有的操作都是在内部的私有属性函数中完成的，而public中的函数仅仅只是一个接口而已</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * C++ 语言: 红黑树 * * @author skywang * @date 2013/11/07 */</span>    <span class="token macro property">#<span class="token directive keyword">ifndef</span> _RED_BLACK_TREE_HPP_</span><span class="token macro property">#<span class="token directive keyword">define</span> _RED_BLACK_TREE_HPP_ </span>    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iomanip></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>    <span class="token keyword">enum</span> RBTColor<span class="token punctuation">{</span>RED<span class="token punctuation">,</span> BLACK<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">RBTNode</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        RBTColor color<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 颜色</span>        T key<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 关键字(键值)</span>        RBTNode <span class="token operator">*</span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左孩子</span>        RBTNode <span class="token operator">*</span>right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右孩子</span>        RBTNode <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 父结点</span>    <span class="token function">RBTNode</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> RBTColor c<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>p<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>l<span class="token punctuation">,</span> RBTNode <span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token operator">:</span>            <span class="token function">key</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">color</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">left</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">right</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">RBTree</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span><span class="token operator">:</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>mRoot<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根结点</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">~</span><span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 前序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 中序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 后序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (递归实现)查找"红黑树"中键值为key的节点</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">search</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// (非递归实现)查找"红黑树"中键值为key的节点</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">iterativeSearch</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 查找最小结点：返回最小结点的键值。</span>        T <span class="token function">minimum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 查找最大结点：返回最大结点的键值。</span>        T <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 找结点(x)的后继结点。即，查找"红黑树中数据值大于该结点"的"最小结点"。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">successor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 找结点(x)的前驱结点。即，查找"红黑树中数据值小于该结点"的"最大结点"。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">predecessor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将结点(key为节点键值)插入到红黑树中</span>        <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 删除结点(key为节点键值)</span>        <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 销毁红黑树</span>        <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印红黑树</span>        <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token comment" spellcheck="true">// 前序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 中序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 后序遍历"红黑树"</span>        <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (递归实现)查找"红黑树x"中键值为key的节点</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">search</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// (非递归实现)查找"红黑树x"中键值为key的节点</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">iterativeSearch</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 查找最小结点：返回tree为根结点的红黑树的最小结点。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">minimum</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 查找最大结点：返回tree为根结点的红黑树的最大结点。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token function">maximum</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左旋</span>        <span class="token keyword">void</span> <span class="token function">leftRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 右旋</span>        <span class="token keyword">void</span> <span class="token function">rightRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 插入函数</span>        <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 插入修正函数</span>        <span class="token keyword">void</span> <span class="token function">insertFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除函数</span>        <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除修正函数</span>        <span class="token keyword">void</span> <span class="token function">removeFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 销毁红黑树</span>        <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印红黑树</span>        <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">,</span> T key<span class="token punctuation">,</span> <span class="token keyword">int</span> direction<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">define</span> rb_parent(r)   ((r)->parent)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_color(r) ((r)->color)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_is_red(r)   ((r)->color==RED)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_is_black(r)  ((r)->color==BLACK)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_set_black(r)  do { (r)->color = BLACK; } while (0)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_set_red(r)  do { (r)->color = RED; } while (0)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_set_parent(r,p)  do { (r)->parent = (p); } while (0)</span><span class="token macro property">#<span class="token directive keyword">define</span> rb_set_color(r,c)  do { (r)->color = (c); } while (0)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*  * 构造函数 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">mRoot</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    mRoot <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 析构函数 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token operator">~</span><span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 前序遍历"红黑树" */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">preOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span> tree<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token punctuation">;</span>        <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 中序遍历"红黑树" */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">inOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">inOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span> tree<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token punctuation">;</span>        <span class="token function">inOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 后序遍历"红黑树" */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">postOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">postOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">postOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span> tree<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">postOrder</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * (递归实现)查找"红黑树x"中键值为key的节点 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">search</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token constant">NULL</span> <span class="token operator">||</span> x<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">==</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> x<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">search</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">search</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * (非递归实现)查找"红黑树x"中键值为key的节点 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">iterativeSearch</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">!=</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> x<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        <span class="token keyword">else</span>            x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">iterativeSearch</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">iterativeSearch</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 查找最小结点：返回tree为根结点的红黑树的最小结点。 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">minimum</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        tree <span class="token operator">=</span> tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token keyword">return</span> tree<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>T RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">minimum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> p<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*  * 查找最大结点：返回tree为根结点的红黑树的最大结点。 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">maximum</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        tree <span class="token operator">=</span> tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token keyword">return</span> tree<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>T RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">maximum</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> p<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 找结点(x)的后继结点。即，查找"红黑树中数据值大于该结点"的"最小结点"。 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">successor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">minimum</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果x没有右孩子。则x有以下两种可能：</span>    <span class="token comment" spellcheck="true">// (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。</span>    <span class="token comment" spellcheck="true">// (02) x是"一个右孩子"，则查找"x的最低的父结点，并且该父结点要具有左孩子"，找到的这个"最低的父结点"就是"x的后继结点"。</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> y <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        x <span class="token operator">=</span> y<span class="token punctuation">;</span>        y <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*  * 找结点(x)的前驱结点。即，查找"红黑树中数据值小于该结点"的"最大结点"。 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">predecessor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果x存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">maximum</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果x没有左孩子。则x有以下两种可能：</span>    <span class="token comment" spellcheck="true">// (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。</span>    <span class="token comment" spellcheck="true">// (01) x是"一个左孩子"，则查找"x的最低的父结点，并且该父结点要具有右孩子"，找到的这个"最低的父结点"就是"x的前驱结点"。</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> y <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        x <span class="token operator">=</span> y<span class="token punctuation">;</span>        y <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 对红黑树的节点(x)进行左旋转 * * 左旋示意图(对节点x进行左旋)： *      px                              px *     /                               / *    x                               y                 *   /  \      --(左旋)-->           / \                # *  lx   y                          x  ry      *     /   \                       /  \ *    ly   ry                     lx  ly   * * */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">leftRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置x的右孩子为y</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>y <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的左孩子” 设为 “x的右孩子”；</span>    <span class="token comment" spellcheck="true">// 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”</span>    x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        y<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的父亲” 设为 “y的父亲”</span>    y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        root <span class="token operator">=</span> y<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “x的父亲” 是空节点，则将y设为根节点</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> x<span class="token punctuation">)</span>            x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span>        <span class="token keyword">else</span>            x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将 “x” 设为 “y的左孩子”</span>    y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的父节点” 设为 “y”</span>    x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 对红黑树的节点(y)进行右旋转 * * 右旋示意图(对节点y进行左旋)： *            py                               py *           /                                / *          y                                x                   *         /  \      --(右旋)-->            /  \                     # *        x   ry                           lx   y   *       / \                                   / \                   # *      lx  rx                                rx  ry *  */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">rightRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置x是当前节点的左孩子。</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的右孩子” 设为 “y的左孩子”；</span>    <span class="token comment" spellcheck="true">// 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”</span>    y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        x<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的父亲” 设为 “x的父亲”</span>    x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        root <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “y的父亲” 是空节点，则将x设为根节点</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>            y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”</span>        <span class="token keyword">else</span>            y<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将 “y” 设为 “x的右孩子”</span>    x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的父节点” 设为 “x”</span>    y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 红黑树插入修正函数 * * 在向红黑树中插入节点之后(失去平衡)，再调用该函数； * 目的是将它重新塑造成一颗红黑树。 * * 参数说明： *     root 红黑树的根 *     node 插入的结点        // 对应《算法导论》中的z */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insertFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token operator">*</span>gparent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若“父节点存在，并且父节点的颜色是红色”</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        gparent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//若“父节点”是“祖父节点的左孩子”</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> gparent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>            <span class="token punctuation">{</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>uncle <span class="token operator">=</span> gparent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">==</span> node<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> node<span class="token punctuation">;</span>                node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是左孩子。</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">else</span><span class="token comment" spellcheck="true">//若“z的父节点”是“z的祖父节点的右孩子”</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>            <span class="token punctuation">{</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>uncle <span class="token operator">=</span> gparent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> <span class="token function">rb_is_red</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是左孩子</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> node<span class="token punctuation">;</span>                node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是右孩子。</span>            <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rb_set_red</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将根节点设为黑色</span>    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 将结点插入到红黑树中 * * 参数说明： *     root 红黑树的根结点 *     node 插入的结点        // 对应《算法导论》中的node */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>x <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        y <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;</span> x<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        <span class="token keyword">else</span>            x <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    node<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;</span> y<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>            y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token keyword">else</span>            y<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        root <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 设置节点的颜色为红色</span>    node<span class="token operator">-</span><span class="token operator">></span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3. 将它重新修正为一颗二叉查找树</span>    <span class="token function">insertFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 将结点(key为节点键值)插入到红黑树中 * * 参数说明： *     tree 红黑树的根结点 *     key 插入结点的键值 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>z<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果新建结点失败，则返回。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>z<span class="token operator">=</span><span class="token keyword">new</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>BLACK<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token function">insert</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 红黑树删除修正函数 * * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数； * 目的是将它重新塑造成一颗红黑树。 * * 参数说明： *     root 红黑树的根 *     node 待修正的节点 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">removeFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>other<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>node <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> node <span class="token operator">!=</span> root<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_is_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>                <span class="token function">rb_set_color</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> root<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_is_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>                <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>other<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">||</span> <span class="token function">rb_is_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                    <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rb_set_red</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    other <span class="token operator">=</span> parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>                <span class="token function">rb_set_color</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rb_set_black</span><span class="token punctuation">(</span>other<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> root<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token function">rb_set_black</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 删除结点(node)，并返回被删除的结点 * * 参数说明： *     root 红黑树的根结点 *     node 删除的结点 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>child<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>    RBTColor color<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 被删除节点的"左右孩子都不为空"的情况。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 被删节点的后继节点。(称为"取代节点")</span>        <span class="token comment" spellcheck="true">// 用它来取代"被删节点"的位置，然后再将"被删节点"去掉。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>replace <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取后继节点</span>        replace <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>replace<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            replace <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// "node节点"不是根节点(只有根节点不存在父节点)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>                <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> replace<span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token function">rb_parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> replace<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">else</span>             <span class="token comment" spellcheck="true">// "node节点"是根节点，更新根节点。</span>            root <span class="token operator">=</span> replace<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// child是"取代节点"的右孩子，也是需要"调整的节点"。</span>        <span class="token comment" spellcheck="true">// "取代节点"肯定不存在左孩子！因为它是一个后继节点。</span>        child <span class="token operator">=</span> replace<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        parent <span class="token operator">=</span> <span class="token function">rb_parent</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>        color <span class="token operator">=</span> <span class="token function">rb_color</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// "被删除节点"是"它的后继节点的父节点"</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> node<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// child不为空</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span>                <span class="token function">rb_set_parent</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>    replace<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token function">rb_set_parent</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> replace<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    replace<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>        replace<span class="token operator">-</span><span class="token operator">></span>color <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>color<span class="token punctuation">;</span>        replace<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        node<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>            <span class="token function">removeFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> node<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        child <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token keyword">else</span>         child <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    parent <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>    color <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>color<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span>        child<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// "node节点"不是根节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>            parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>        <span class="token keyword">else</span>            parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        root <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>        <span class="token function">removeFixUp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  * 删除红黑树中键值为key的节点 * * 参数说明： *     tree 红黑树的根结点 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span><span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">*</span>node<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 查找key对应的节点(node)，找到的话就删除该节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token function">remove</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 销毁红黑树 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">destroy</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">destroy</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">destroy</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> tree<span class="token punctuation">;</span>    tree<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">destroy</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* * 打印"二叉查找树" * * key        -- 节点的键值  * direction  --  0，表示该节点是根节点; *               -1，表示该节点是它的父结点的左孩子; *                1，表示该节点是它的父结点的右孩子。 */</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> tree<span class="token punctuation">,</span> T key<span class="token punctuation">,</span> <span class="token keyword">int</span> direction<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>direction<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// tree是根节点</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> tree<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;&lt;</span> <span class="token string">"(B) is root"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">else</span>                <span class="token comment" spellcheck="true">// tree是分支节点</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> tree<span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">&lt;&lt;</span>  <span class="token punctuation">(</span><span class="token function">rb_is_red</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token operator">?</span><span class="token string">"(R)"</span><span class="token operator">:</span><span class="token string">"(B)"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" is "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> key <span class="token operator">&lt;&lt;</span> <span class="token string">"'s "</span>  <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>direction<span class="token operator">==</span><span class="token number">1</span><span class="token operator">?</span><span class="token string">"right child"</span> <span class="token operator">:</span> <span class="token string">"left child"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> tree<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">print</span><span class="token punctuation">(</span>tree<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>tree<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> RBTree<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mRoot <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> mRoot<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《STL源码剖析》（第四章、序列容器）</title>
      <link href="/2019/12/22/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-si-zhang-xu-lie-rong-qi/"/>
      <url>/2019/12/22/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-si-zhang-xu-lie-rong-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="1、容器的概观与分类"><a href="#1、容器的概观与分类" class="headerlink" title="1、容器的概观与分类"></a>1、容器的概观与分类</h2><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111112044-1498089234.png" alt=""><br>所谓序列式容器，其中的元素都可序（ordered）【比如可以使用sort进行排序】，但未必有序（sorted）。C++语言本身提供了一个序列式容器array，STL另外再提供vector，list，deque，stack，queue，priority-queue 等等序列式容器。其中stack和queue由于只是将 deque 头换面而成，技术上被归类为一种配接器（adapter)。</p><h2 id="2、vector"><a href="#2、vector" class="headerlink" title="2、vector"></a>2、vector</h2><p>vector的数据安排以及操作方式，与array非常相似。两者的唯一差别在于空间的运用的灵活性。<br>array是静态空间，一旦配置了就不能改变；要换个大（或小）一点的房子，可以，一切琐细得由客户端自己来：首先配置一块新空间，然后将元素从旧址一一搬往新址，再把原来的空间释还给系统。<br>vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而一开始就要求一个大块头array了，我们可以安心使用vector，吃多少用多少。</p><h3 id="常用的源码："><a href="#常用的源码：" class="headerlink" title="常用的源码："></a>常用的源码：</h3><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111144693-777575451.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111148942-1191823589.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111153586-106686768.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111156636-189118959.png" alt=""></p><p><strong>注意：</strong></p><ul><li>size() &amp; captical：<br>表示已存储数据的大小，而capital则是内部开辟的空间的大小所以，在erase、pop_back、clear等删除操作，都不会使得其captial产生变化，只会变的就是size()</li></ul><h3 id="动态空间配置："><a href="#动态空间配置：" class="headerlink" title="动态空间配置："></a>动态空间配置：</h3><p>注意，所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。这是程序员易犯的一个错误，务需小心。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111220346-523302115.png" alt=""> </p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111228720-2046744508.png" alt=""></p><h3 id="insert-："><a href="#insert-：" class="headerlink" title="insert()："></a>insert()：</h3><p>insert()会根据需要插入元素的位置p以及p后面的元素个数与需要插入元素个数n进行比较，分两种情况进行插入<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111242126-1491471714.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111250514-499650255.png" alt=""></p><h3 id="emplace-back-VS-push-back-减少内存拷贝和移动"><a href="#emplace-back-VS-push-back-减少内存拷贝和移动" class="headerlink" title="emplace_back()  VS   push_back()减少内存拷贝和移动"></a>emplace_back()  VS   push_back()减少内存拷贝和移动</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> President<span class="token punctuation">{</span>    <span class="token function">President</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string <span class="token operator">&amp;&amp;</span> p_name<span class="token punctuation">,</span> std<span class="token operator">::</span>string <span class="token operator">&amp;&amp;</span> p_country<span class="token punctuation">,</span> <span class="token keyword">int</span> p_year<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p_name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">country</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p_country<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">year</span><span class="token punctuation">(</span>p_year<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I am being constructed.\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">President</span><span class="token punctuation">(</span>President<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">country</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>country<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">year</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>year<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I am being moved.\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    President<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> President<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>President<span class="token operator">></span> elections<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"emplace_back:\n"</span><span class="token punctuation">;</span>    elections<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"Nelson Mandela"</span><span class="token punctuation">,</span> <span class="token string">"South Africa"</span><span class="token punctuation">,</span> <span class="token number">1994</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>President<span class="token operator">></span> reElections<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\npush_back:\n"</span><span class="token punctuation">;</span>    reElections<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">President</span><span class="token punctuation">(</span><span class="token string">"Franklin Delano Roosevelt"</span><span class="token punctuation">,</span> <span class="token string">"the USA"</span><span class="token punctuation">,</span> <span class="token number">1936</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>emplace_back<span class="token operator">:</span>I am being constructed<span class="token punctuation">.</span>push_back<span class="token operator">:</span>I am being constructed<span class="token punctuation">.</span>I am being moved<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="merge-函数："><a href="#merge-函数：" class="headerlink" title="merge()函数："></a>merge()函数：</h3><pre><code>merge方式要注意三点：merge(vec1.begin(),vec1.end(),vec2.begin(),vec2.end(),vec3.begin());1. vec1,和vec2需要经过排序，merge只能合并排序后的集合，不然会报错。2. vec3需要指定好大小，不然会报错。3. merge的时候指定vec3的位置一定要从begin开始，如果指定了end，它会认为没有空间，当然，中间的位置我没有试，回头有空试一下。</code></pre><h2 id="3、list"><a href="#3、list" class="headerlink" title="3、list"></a>3、list</h2><p>相较于vector的连续线性空间，1ist就显得复杂许多，它的好处是每次插人或删除一个元素，就配置或释放一个元素空间。因此，list 对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插人或元素移除，list永远是常数时间。</p><p>由于STL1ist是一个双向链表（double linked-list），迭代器必须具备前移、后移的能力，所以1ist 提供的是Bidirectional lterators。</p><p>list 有一个重要性质：插入操作（insert）和接合操作（splice）都不会造成原有的list迭代器失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效。甚至1ist的元素删除操作（erase），也只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。<br>    <img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111347787-1579187860.png" alt=""> </p><ul><li>SGI list 是一个环状双向链表，它只需要一个指针就可以完整表现整个链表<br>  <img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111355799-334800690.png" alt=""></li></ul><h3 id="list链表的初始结构："><a href="#list链表的初始结构：" class="headerlink" title="list链表的初始结构："></a>list链表的初始结构：</h3><pre><code>    node-&gt;next = node;    node-&gt;prv = node;</code></pre><pre><code>![](https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111405617-453133763.png)</code></pre><h3 id="transfter-迁移函数"><a href="#transfter-迁移函数" class="headerlink" title=".transfter() //迁移函数"></a>.transfter() //迁移函数</h3><pre><code>```void transfer(iterator position, iterator first, iterator last);```将list2的first-last之间的元素插入到list1中的position中</code></pre><h3 id="splice-衔接函数"><a href="#splice-衔接函数" class="headerlink" title=".splice()  //衔接函数"></a>.splice()  //衔接函数</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;</span> other <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;&amp;</span> other <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;</span> other<span class="token punctuation">,</span> const_iterator it <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">,</span> const_iterator it <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;</span> other<span class="token punctuation">,</span> const_iterator first<span class="token punctuation">,</span> const_iterator last<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">,</span> const_iterator first<span class="token punctuation">,</span> const_iterator last <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从一个 list 转移元素给另一个。<br>不复制或移动元素，仅重指向链表结点的内部指针。若 get_allocator() != other.get_allocator() 则行为未定义。没有迭代器或引用被非法化,指向被移动元素的迭代器保持合法，但现在指代到 *this 中，而非到 other 中。</p><ol><li>从 other 转移所有元素到 *this 中。元素被插入到 pos 所指向的元素之前。操作后容器 other 变为空。若 other 与 *this 指代同一对象则行为未定义。</li><li>从 other 转移 it 所指向的元素到 *this 。元素被插入到 pos 所指向的元素之前。</li><li>从 other 转移范围 [first, last) 中的元素到 *this 。元素被插入到 pos 所指向的元素之前。若 pos 是范围 [first,last) 中的迭代器则行为未定义。<br>参数<br>pos            -    将插入内容到其前的元素<br>other        -    要自之转移内容的另一容器<br>it            -    要从 other 转移到 *this 的元素<br>first, last    -    要从 other 转移到 *this 的元素范围</li></ol><h3 id="merge"><a href="#merge" class="headerlink" title=".merge()"></a>.merge()</h3><pre class="line-numbers language-cpp"><code class="language-cpp">    c1<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//合并2个有序的链表并使之有序,从新放到c1里,释放c2。</span>    c1<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>c2<span class="token punctuation">,</span>comp<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//合并2个有序的链表并使之按照自定义规则排序之后从新放到c1中,释放c2。</span>    c1<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>beg<span class="token punctuation">,</span>c2<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//将c2连接在c1的beg位置,释放c2</span>    c1<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>beg<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c2<span class="token punctuation">.</span>beg<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//将c2的beg位置的元素连接到c1的beg位置，并且在c2中释放掉beg位置的元素</span>    c1<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>beg<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c2<span class="token punctuation">.</span>beg<span class="token punctuation">,</span>c2<span class="token punctuation">.</span>end<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//将c2的[beg,end)位置的元素连接到c1的beg位置并且释放c2的[beg,end)位置的元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并二个已排序链表为一个。链表应以升序排序。<br>不复制元素。操作后容器 other 变为空。若 other 与 *this 指代同一对象则函数不做任何事。若 get_allocator() != other.get_allocator() ，则行为未定义。没有引用和迭代器变得非法，除了被移动元素的迭代器现在指代到*this 中， 而非到 other 中，第一版本用 operator&lt; 比较元素，第二版本用给定的比较函数 comp 。<br>此操作是稳定的：对于二个链表中的等价元素，来自 *this 的元素始终前驱来自 other 的元素，而且 *this  和 other 的等价元素顺序不更改。<br>参数<br>    other    -    要交换的另一容器<br>    comp    -    比较函数对象（即满足比较 (Compare) 概念的对象），若第一参数小于（即先序于）第二参数则返回 ​true 。<br>    比较函数的签名应等价于如下：<br>     bool cmp(const Type1 &amp;a, const Type2 &amp;b);<br>    虽然签名不必有 const &amp; ，函数也不能修改传递给它的对象，而且必须接受（可为 const 的）类型 Type1 与 Type2的值，无关乎值类别（从而不允许 Type1 &amp; ，亦不允许 Type1 ，除非 Type1 的移动等价于复制 (C++11 起)）。<br>    类型 Type1 与 Type2 必须使得 list&lt;T,Allocator&gt;::const_iterator 类型的对象能在解引用后隐式转换到这两个类型。 ​</p><h2 id="4、deque"><a href="#4、deque" class="headerlink" title="4、deque"></a>4、deque</h2><p>deque和vector的最大差异:【vector与deque都可以随机读取】<br>一在于deque允许于常数时间内对起头端进行元素的插入或移除操作，<br>二在于deque没有所谓容量（capacity）观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</p><h3 id="中控器："><a href="#中控器：" class="headerlink" title="中控器："></a>中控器：</h3><p>deque是连续空间（至少逻辑上看来如此）。</p><p>deque系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。</p><p>deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。</p><p>deque采用一块所谓的map（注意，不是STL的map容器）作为主控。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。SGI STL允许我们指定缓冲区大小，默认值0表示将使用512bytes缓冲区。<br>当map的空间也不够后，会开辟另一个大的map空间<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111504070-550240525.png" alt=""></p><h3 id="迭代器："><a href="#迭代器：" class="headerlink" title="迭代器："></a>迭代器：</h3><p>deque是分段连续空间。维持其“整体连续”假象的任务，落在了迭代器的operator++和operator–两个运算子身上。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111510713-2032044283.png" alt=""></p><h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><p>deque 除了维护一个先前说过的指向map的指针外，也维护 start，finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素（的下一位置）。此外，它当然也必须记住目前的map大小。因为一旦map所提供的节点不足，就必须重新配置更大的一块map。</p><p>什么时候map需要重新整治？这个问题的判断由 reserve_map_at_back（）和 reserve_map_at_front（）进行，实际操作则由reallocate_map（）执行;</p><p>一个deque对象包含四个成员变量，_M_map指向主控器，_M_map_size表示中控器的大小，能够容纳多少个指针，_M_start表示deque的迭代器，所有元素的起始位置，_M_finish表示deque的迭代器，所有元素的终止位置。<br>odeque的insert()操作：首先判断插入的地方是头或者尾，如果都不是则在调用一个名为insert_aux的辅助函数。此辅助函数通过判断当前的插入位置更靠近头端或者尾端。<br>odeque的+=操作：首先判断是否在同一级缓冲区区域，如果不在，在确定应该夸几个缓冲区，然后到相应的缓冲区后，再移动。</p><h2 id="5、stack"><a href="#5、stack" class="headerlink" title="5、stack"></a>5、stack</h2><ul><li><p>sack定义完整列表<br>deque是双向开口的数据结构，若以deque为底部结构并封闭其头端开口，便轻而易举地形成了一个stack。因此，SGI STL便以deque作为缺省情况下的stack底部结构，stack的实现因而非常简单，源代码十分简短，</p></li><li><p>stack没有迭代器</p></li><li><p>以list作为stack的底层容器</p></li></ul><h2 id="6、queue"><a href="#6、queue" class="headerlink" title="6、queue"></a>6、queue</h2><ul><li><p>queue定义完整列表<br>odeque是双向开口的数据结构，若以deque为底部结构并封闭其底端的出口和前端的入口，便轻而易举地形成了一个queue。因此，SGISTL便以deque作为缺省情况下的queue底部结构，queue的实现因而非常简单。</p></li><li><p>queue没有迭代器</p></li><li><p>以list作为queue的底层容器</p></li><li><p>优先队列<br>opriority_queue&lt;Type, Container, Functional&gt;</p></li></ul><h2 id="7、-heap（隐式表述，implicit-representation）【堆排序】"><a href="#7、-heap（隐式表述，implicit-representation）【堆排序】" class="headerlink" title="7、 heap（隐式表述，implicit representation）【堆排序】"></a>7、 heap（隐式表述，implicit representation）【堆排序】</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>heap并不归属于STL容器组件，它是个幕后英雄，扮演priority queue<br>的助手。顾名思义，priority queue允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高（也就是数值最高）的元素开始取。binary max heap正是具有这样的特性，适合作为priority queue的底层机制。</p><p>如果使用list作为priority queue的底层机制，元素插入操作可享常数时间。但是要找到list中的极值，却需要对整个list进行线性扫描。我们也可以改变做法，让元素插人前先经过排序这一关，使得list的元素值总是由小到大（或由大到小），但这么一来，收之东隅却失之桑榆：虽然取得极值以及元素删除操作达到最高效率，可元素的插入却只有线性表现。</p><p>以binary search tree作为priority queue的底层机制。这么一来，元素的插入和极值的取得就有O(logN）的表现。<br>但杀鸡用牛刀，未免小题大做，一来binary search tree的输入需要足够的随机性，二来binary search tree并不容易实现。priority queue的复杂度，最好介于queue和binary search tree 之间，才算适得其所。binary heap便是这种条件下的适当候选人。</p><p>binary heap就是一种 complete binary tree（完全二叉树）2，也就是说，整棵binary tree除了最底层的叶节点（s）之外，是填满的，而最底层的叶节点（s）由左至右又不得有空隙。【即是一棵完全搜索二叉树】</p><h3 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h3><ul><li>push_heap<br>实现的是堆排序中的插入操作<pre class="line-numbers language-CPP"><code class="language-CPP">//向上调整void  upAdjust(int L, int R){  int  i = R, j = (i - 1) / 2;//i为欲调整结点，j为其父亲  while (j >= L)  {      if (v[j] < v[i])//父节点小了，那么就将孩子节点调上来      {          swap(v[i], v[j]);          i = j;          j = (i - 1) / 2;//继续向上遍历      }      else//无需调整          break;  }}void insert(int  x){  v[n] = x;//将新加入的值放置在数组的最后，切记保证数组空间充足  upAdjust(0, n);//向上调整新加入的结点n}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h3><p>实现的是堆排序的删除操作</p><pre class="line-numbers language-CPP"><code class="language-CPP">//向下调整void downAdjust(int L, int R){    int i = L, j = 2 * L + 1;//i为父节点，j为左子节点    while (j <= R)    {        if (j + 1 <= R && v[j + 1] > v[j])//若有右节点，且右节点大，那么就选右节点,即选取最大的子节点与父节点对比            ++j;//选取了右节点        if (v[j] <= v[i])//孩子节点都比父节点小，满足条件，无需调整            break;        //不满足的话，那么我就将最大孩子节点j与父节点i对调,        swap(v[i], v[j]);        i = j;        j = 2 * i + 1;//继续向下遍历    }}//删除堆顶元素void deleteTop(){    v[0] = v[n - 1];//也就是堆顶使用最后一个数值来替代    downAdjust(0, n - 2);//然后对前n-1个数进行排序}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h3><p>就是不断的pop出最大的元素<br>实现的就是堆排序</p><pre class="line-numbers language-CPP"><code class="language-CPP">for (int i = n - 1; i > 0; --i)//从最后开始交换，直到只剩下最后一个数字{    swap(v[i], v[0]);//每次都将最大值放到最后    downAdjust(0, i - 1);//将前0-i个数字重新构成大根堆}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h3><p>实现的是堆排序的构建</p><pre class="line-numbers language-CPP"><code class="language-CPP">//建堆void createHeap(){    for (int i = n / 2; i >= 0; --i)        downAdjust(i, n - 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>heap没有迭代器</strong></p><h2 id="8、-priority-queue"><a href="#8、-priority-queue" class="headerlink" title="8、 priority_queue"></a>8、 priority_queue</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>opriority_queue带有权值观念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列（通常权值以实值表示）。权值最高者，排在最前面。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>由于priority_queue 完全以底部容器为根据，再加上heap处理规则，所以其实现非常简单。缺省情况下是以vector为底部容器。具有这种“修改某物接口，形成另一种风貌”之性质者，称为adapter（配接器），因此，STL priority-queue往往不被归类为container（容器），而被归类为container adapter。</p><p><strong>没有迭代器</strong></p><h2 id="9、slist"><a href="#9、slist" class="headerlink" title="9、slist"></a>9、slist</h2><ul><li><p>概述<br>STL list是个双向链表（double linked list）。SGI STL另提供了一个单向链表（single linked list），名为slist。</p></li><li><p>slist和list的主要差别在于，前者的迭代器属于单向的Forward lerator，后者的迭代器属于双向的Bidirectional lterator。单向链表所耗用的空间更小，某些操作更快，不失为另一种选择。</p></li><li><p>注意，根据STL的习惯，插入操作会将新元素插入于指定位置之前，而非之后。然而作为一个单向链表，slist没有任何方便的办法可以回头定出前一个位置，因此它必须从头找起。换句话说，除了slist起点处附近的区域之外，在其它位置上采用insert或erase操作函数，都属不智之举。这便是slist相较于1ist之下的大缺点。为此，slist 特别提供了insert_after（）和erase_after（）供灵活运用。<br>迭代器</p></li></ul><h2 id="10、常见错误总结："><a href="#10、常见错误总结：" class="headerlink" title="10、常见错误总结："></a>10、常见错误总结：</h2><p>迭代器失效：</p><ul><li><p>由于vector在扩容时，是在一块新地址上开辟空间，然后将原数据复制过来，并把原来的内存空间给释放了，所以一旦vector发生扩容，那么指向原来迭代器将会失效。</p></li><li><p>由于list不是连续空间，所以删除和添加都在原的内存上添加或删除一个空间即可，所以指向原来的迭代器不会失效【除非该迭代器指向的位置被删除了】。</p></li><li><p>迭代器不仅可以后移，而且可以前进的，–ptr, ++ptr</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《STL源码剖析》（第一、二、三章）</title>
      <link href="/2019/12/22/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-yi-er-san-zhang/"/>
      <url>/2019/12/22/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-yi-er-san-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：概论："><a href="#第一章：概论：" class="headerlink" title="第一章：概论："></a>第一章：概论：</h1><p>换句话说，STL所实现的，是依据泛型思维架设起来的一个概念结构。这个以抽象概念（abstract concepts）为主体而非以实际类（classes）为主体的结构，形成了一个严谨的接口标准。在此接口之下，任何组件都有最大的独立性，并以所谓迭代器（iterator）胶合起来，或以所谓配接器（adapter）互相配接，或以所谓仿函数（functor）动态选择某种策略（policy或strategy）。</p><h2 id="STL提供六大组件"><a href="#STL提供六大组件" class="headerlink" title="STL提供六大组件"></a>STL提供六大组件</h2><ol><li><p>容器（containers）：<br>各种数据结构，如 vector，list，deque，set，map，用来存放数据，详见本书4，5两章。从实现的角度来看，STL容器是一种class template。就体积而言，这一部分很像冰山在海面下的比率。</p></li><li><p>算法（algorithms）：<br>各种常用算法如sort，search，copy，erase…详见第6章。从实现的角度来看，STL算法是一种function template。</p></li><li><p>迭代器（iterators）：    扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，详见第3章。共有五种类型，以及其它衍生变化。从实现的角度来看，迭代器是一种将 operator*，operator-&gt;，operatort+，operator–等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器——是的，只有容器设计者才知道如何遍历自己的元素。原生指针（native pointer）也是一种迭代器。</p></li><li><p>仿函数（functors）：行为类似函数，可作为算法的某种策略（policy），详见第7章。从实现的角度来看，仿函数是一种重载了operator（）的class或class template.一般函数指针可视为狭义的仿函数。</p></li><li><p>配接器（adapters）：<br>一种用来修饰容器（containers）或仿函数（functors）<br>或迭代器（iterators）接口的东西。例如，STL提供的queue和stack，虽然看似容器，其实只能算是一种容器配接器，因为它们的底部完全借助 deque，所有操作都由底层的deque供应。改变functor接口者，称为function adapter；改变container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。配接器的实现技术很难一言以蔽之，必须逐一分析，详见第8章。</p></li><li><p>配置器（allocators）：     负责空间配置与管理，详见第2章。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">alloc</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="C-11-STL中的容器"><a href="#C-11-STL中的容器" class="headerlink" title="C++11 STL中的容器"></a>C++11 STL中的容器</h2><h3 id="一、顺序容器："><a href="#一、顺序容器：" class="headerlink" title="一、顺序容器："></a>一、顺序容器：</h3><p>vector：可变大小数组；<br>deque：双端队列；<br>list：双向链表；<br>forward_list：单向链表；<br>array：固定大小数组；<br>string：与vector相似的容器，但专门用于保存字符。</p><h3 id="二、关联容器："><a href="#二、关联容器：" class="headerlink" title="二、关联容器："></a>二、关联容器：</h3><h4 id="按关键字有序保存元素：（底层实现为红黑树）"><a href="#按关键字有序保存元素：（底层实现为红黑树）" class="headerlink" title="按关键字有序保存元素：（底层实现为红黑树）"></a>按关键字有序保存元素：（底层实现为红黑树）</h4><p>map：关联数组；保存关键字-值对；<br>set：关键字即值，即只保存关键字的容器；<br>multimap：关键字可重复的map；<br>multiset：关键字可重复的set；</p><h4 id="无序集合："><a href="#无序集合：" class="headerlink" title="无序集合："></a>无序集合：</h4><p>不会按字典规则进行排序<br>unordered_map：用哈希函数组织的map；<br>unordered_set：用哈希函数组织的set；<br>unordered_multimap：哈希组织的map；关键字可以重复出现；<br>unordered_multiset：哈希组织的set；关键字可以重复出现。    </p><h3 id="三、其他项："><a href="#三、其他项：" class="headerlink" title="三、其他项："></a>三、其他项：</h3><ol><li><p>stack、queue、valarray、bitset<br>随机访问中，[ ]与 .at( )功能相同，但是[ ]越界了会直接导致程序崩溃，而 .at( )会抛出异常，故其更安全！</p></li><li><p>size、capacity与shrink_to_fit<br>size表示目前容器的实际大小、capacity表示容器的空间，一般 &gt;=size，因为容器初始化或者赋值时，系统会根据情况给予容器一个适当的空间，避免每次增加数据时又得重新新分配空间，索性一次给多点，但也不会很大,为了节省空间，你可以使用shrink_to_fit将容器空间capacity缩小为size</p></li></ol><h3 id="四、迭代器删除失效："><a href="#四、迭代器删除失效：" class="headerlink" title="四、迭代器删除失效："></a>四、迭代器删除失效：</h3><ol><li><p>vector，erase(pos)，直接把pos+1到finish的数据拷贝到以pos为起点的区间上，也就是vector的长度会逐渐变短，同时iter会逐渐往后移动，直到iter == cont.end()，由于容器中end()返回的迭代器是最后一个元素的下一个（这个地方没有任何值），现在考虑这个状态前一个状态，此时要删除的点是iter, tempIt = iter, ++iter会指向此时的end()，但是执行erase(tempIt)之后，end()向前移动了！！！问题来了，此时iter空了！！！不崩溃才怪。</p></li><li><p>list，erase(pos)，干的事情很简单，删除自己，前后的节点连接起来就完了，所以iter自增的过程不会指空，不会崩溃喽。</p></li><li><p>map，erase(pos)，干的事情太复杂，但是我们需要知道的信息其实很少。该容器底层实现是RBTree，删除操作分了很多种情形来讨论的，目的是为了维持红黑树性质。但是我们需要知道的就是每个节点类似于list节点，都是单独分配的空间，所以删除一个节点并不会对其他迭代器产生影响，对应到题目中，不会崩溃喽。</p></li><li><p>deque，erase(pos)，与vector的erase(pos)有些类似，基于结构的不同导致中间有些步骤不太一致。先说说deque的结构（这个结构本身比较复杂，拣重要说吧，具体看STL源码），它是一个双向开口的连续线性空间，实质是分段连续的，由中控器map维持其整体连续的假象。其实题中只要知道它是双向开口的就够了（可以在头部或尾部增加、删除）。在题中有erase(pos)，deque是这样处理的：如果pos之前的元素个数比较少，那么把start到pos-1的数据移到起始地址为start+1的区间内；否则把pos后面的数据移到起始地址为pos的区间内。在题中iter一直往后移动，总会出现后面数据比前面少的时候，这时候问题就和1一样了，必须崩溃！</p></li><li><p>关联容器(如map, set, multimap,multiset)，【不会失效】删除当前的iterator，只会使当前的iterator失效，只要在erase时，递增当前iterator即可。</p></li><li><p>对于序列式容器(如vector,deque)，【会失效】删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。不过erase方法可以返回下一个有效的iterator，cont.erase(iter++)可以修改为cont.erase(iter)</p></li><li><p>list使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator。</p></li></ol><h3 id="五、为不同的容器选择不同删除方式"><a href="#五、为不同的容器选择不同删除方式" class="headerlink" title="五、为不同的容器选择不同删除方式"></a>五、为不同的容器选择不同删除方式</h3><p>删除连续容器(vector,deque,string)的元素</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 当c是vector、string，删除value</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除</span><span class="token keyword">bool</span> <span class="token function">assertFun</span><span class="token punctuation">(</span>valuetype<span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove_if</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> assertFun<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 有时候我们不得不遍历去完成，并删除</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除list中某个元素</p><pre class="line-numbers language-cpp"><code class="language-cpp">c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除    </span>c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>assertFun<span class="token punctuation">)</span><span class="token punctuation">;</span>删除关联容器<span class="token punctuation">(</span>set<span class="token punctuation">,</span>map<span class="token punctuation">)</span>中某个元素c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="各大容器性能对比："><a href="#各大容器性能对比：" class="headerlink" title="各大容器性能对比："></a>各大容器性能对比：</h2><ol><li><p>vector<br>变长一维数组，连续存放的内存块，有保留内存，堆中分配内存；<br>支持[]操作，高效率的随机访问；<br>在最后增加元素时，一般不需要分配内存空间，速度快；在中间或开始操作元素时要进行内存拷贝效率低；<br>vector高效的原因在于配置了比其所容纳的元素更多的内存，内存重新配置会花很多时间；<br>vector的内存分配：<br>一般是按你当时存储数据的两倍开辟空间，当插入数据空间不够时，又会重新增加空间至当时数据空间的2倍，此动作降低了vector的工作效率！！！<br>注：需要高效的随即存取，而不在乎插入和删除使用vector。   </p></li><li><p>list<br>双向链表，内存空间上可能是不连续的，无保留内存，堆中分配内存；<br>不支持随机存取，开始和结尾元素的访问时间快,其它元素都O（n）；<br>在任何位置安插和删除元素速度都比较快，安插和删除操作不会使其他元素的各个pointer，reference，iterator失效；   </p></li></ol><p>注：大量的插入和删除，而不关系随即存取使用list。   </p><ol start="3"><li><p>deque<br>双端队列，在堆上分配内存，一个堆保存几个元素，而堆之间使用指针连接；<br>支持[]操作，在首端和末端插入和删除元素比较快，在中部插入和删除则比较慢，像是list和vector的结合；<br>注：关心插入和删除并关心随即存取折中使用deque。   </p></li><li><p>set&amp;multiset<br>有序集合，使用平衡二叉树存储，按照给定的排序规则（默认按less排序）对set中的数据进行排序；<br>set中不允许有重复元素，multiset中运行有重复元素；<br>两者不支持直接存取元素的操作；<br>因为是自动排序，查找元素速度比较快；<br>不能直接改变元素值，否则会打乱原本正确的顺序，必须先下删除旧元素，再插入新的元素。 </p></li><li><p>map&amp;multimap<br>字典库，一个值映射成另一个值，使用平衡二叉树存储，按照给定的排序规则对map中的key值进行排序；<br>map中的key值不允许重复，multimap中的key允许重复；<br>根据已知的key值查找元素比较快；<br>插入和删除操作比较慢。   </p></li><li><p>hash_map<br>hash_map使用hash表来排列配对，hash表是使用关键字来计算表位置。当这个表的大小合适，并且计算算法合适的情况下，hash表的算法复杂度为O(1)的，但是这是理想的情况下的，如果hash表的关键字计算与表位置存在冲突，那么最坏的复杂度为O(n)。<br>选用map还是hash_map， 关键是看关键字查询操作次数，以及你所需要保证的是查询总体时间还是单个查询的时间。如果是要很多次操作，要求其整体效率，那么使用hash_map，平均处理时间短。如果是少数次的操作，使用 hash_map可能造成不确定的O(N)，那么使用平均处理时间相对较慢、单次处理时间恒定的map，便更好些。</p></li></ol><h2 id="STL容器对比："><a href="#STL容器对比：" class="headerlink" title="STL容器对比："></a>STL容器对比：</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>名称</td><td>向量容器</td><td>双向队列容器</td><td>列表容器</td><td>集合</td><td>多重集合</td><td>映射</td><td>多重映射</td></tr><tr><td>内部数 据结构</td><td>连续存储的数组形式（一端开口的组）</td><td>连续或分段连续存储数组（两端 开口的数组）</td><td>双向环状链表</td><td>红黑树（平衡检索二叉树）</td><td>红黑树</td><td>红黑树</td><td>红黑树</td></tr><tr><td>特  点</td><td>获取元素效率很高，插入和删除的 效率很低</td><td>获取元素效率较高，插入和删除的效率较高</td><td>获取元素效率很低，插入和删除的效率很高</td><td>1.键（关键字）和值（数据）相等（就是模版只有一个参数，键和值合起来） 2.键唯一 3.元素默认按升序排列</td><td>1.键和值相等 2.键可以不唯一 3.元素默认按升序排列</td><td>1.键和值分开（模版有两个参数，前面是键后面是值） 2.键唯一 3.元素默认按键的升序排列</td><td>1.键和值分开 2.键可以不唯一 3.元素默认按键的升序排列</td></tr><tr><td>头文件</td><td>#include <vector></td><td>#include <deque></td><td>#include <list></td><td>#include <set></td><td>#include <set></td><td>#include <map></td><td>#include <map></td></tr><tr><td>操作元素的方式</td><td>下标运算符：[0]（可以用迭代器，但插入删除操作时会失效）</td><td>下标运算符或迭代器</td><td>只能用迭代器(不断用变量值来递推新值，相当于指针)，不支持使用下标运算符</td><td>迭代器</td><td>迭代器</td><td>迭代器</td><td>迭代器</td></tr><tr><td>插入删除操作迭代器是否失效</td><td>插入和删除元素都会使迭代器失效</td><td>插入任何元素都会使迭代器失效。删除头和尾元素，指向被删除节点迭代器失效，而删除中间元素会使所有迭代器失效</td><td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td><td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td><td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td><td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td><td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td></tr></tbody></table><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>典型内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>可随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对 key 而言：不是</td><td>否</td></tr><tr><td>元素搜寻速度</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对 key 而言：快</td><td>对 key 而言：快</td></tr><tr><td>元素安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="容器自定义比较方式："><a href="#容器自定义比较方式：" class="headerlink" title="容器自定义比较方式："></a>容器自定义比较方式：</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> fruit <span class="token punctuation">{</span>        string name<span class="token punctuation">;</span>         <span class="token keyword">int</span> price<span class="token punctuation">;</span>         <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>fruit fl<span class="token punctuation">,</span> fruit f2<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                <span class="token keyword">return</span> fl<span class="token punctuation">.</span> price<span class="token operator">></span>f2<span class="token punctuation">.</span> price<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="STL容器新颖使用"><a href="#STL容器新颖使用" class="headerlink" title="STL容器新颖使用"></a>STL容器新颖使用</h2><p>将数组中的值直接付给容器<br>int arry[size] = {0,1,2,3,4,5,6};<br>xxx<int>contain(arry, arry+size);//即将数组中的值直接初始化赋予了容器中</p><h1 id="简介SGI："><a href="#简介SGI：" class="headerlink" title="简介SGI："></a>简介SGI：</h1><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">:</span><span class="token keyword">class</span> <span class="token class-name">alloc</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">=</span>alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span><span class="token punctuation">{</span><span class="token keyword">public</span>：     <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>Alloc<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"swap()"</span><span class="token operator">&lt;&lt;</span> endl；    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>x<span class="token punctuation">,</span>y<span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">=</span>alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>     <span class="token keyword">typedef</span> value_type<span class="token operator">*</span> iterator<span class="token punctuation">;</span>     <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">,</span>I first<span class="token punctuation">,</span>I last<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"insert()"</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>x<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator ite<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>stack:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>clase A1loc<span class="token operator">=</span>alloc<span class="token punctuation">,</span>size_t BufSiz<span class="token operator">=</span><span class="token number">0</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">deque</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"deque"</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据前一个参数值T，设定下一个参数Sequence的默认值为deque&lt;T></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，claas Sequence<span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"stack"</span><span class="token operator">&lt;&lt;</span> end1<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Sequence c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>x<span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">=</span>alloc<span class="token punctuation">,</span>size_t BufSiz<span class="token operator">=</span><span class="token number">0</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">deque</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"deque"</span><span class="token operator">&lt;&lt;</span><span class="token string">''</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T，Sequence<span class="token operator">></span><span class="token operator">&amp;</span>x，<span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T，Sequence<span class="token operator">></span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T，Sequence<span class="token operator">></span><span class="token operator">&amp;</span>x，<span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T，Sequence<span class="token operator">></span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">=</span>deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//写成这样是可以的</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span> <span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//写成这样也是可以的</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//写成这样也是可以的</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token operator">></span>（<span class="token keyword">const</span> stack<span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//写成这样就不可以</span>    <span class="token comment" spellcheck="true">//friend bool operator==(const stack&amp;，const stack&amp;);</span>    <span class="token comment" spellcheck="true">//friend bool operator&lt;(const stack&amp;，const stack&amp;);</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"stack"</span><span class="token operator">&lt;&lt;</span>endl；<span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Sequence c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Sequence<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Sequence<span class="token operator">></span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> cout <span class="token operator">&lt;&lt;</span><span class="token string">"operator=="</span><span class="token operator">&lt;&lt;</span><span class="token string">'\t'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Sequence<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Sequence<span class="token operator">></span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> cout <span class="token operator">&lt;&lt;</span><span class="token string">"operator&lt;"</span><span class="token operator">&lt;&lt;</span><span class="token string">'\t'</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//deque stack</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>y<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//deque stack </span>    cout <span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//operator==1</span>    cout <span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span>y<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>end1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//operator&lt;1</span>    stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span>y1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//deque stack</span>    <span class="token comment" spellcheck="true">//cout c&lt;(x== y1)&lt;&lt; endl; //error: no match for...</span>    <span class="token comment" spellcheck="true">//cout &lt;&lt;(x&lt; y1)&lt;&lt; end1;//error: no match for...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>deque:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">inline</span> sizet <span class="token function">_deque_buf_size</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span>size_t sz<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> n<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">?</span>n<span class="token operator">:</span><span class="token punctuation">(</span>sz<span class="token operator">&lt;</span><span class="token number">512</span><span class="token operator">?</span><span class="token function">size_t</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token operator">/</span>sz<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">size_t</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token punctuation">,</span>size_t BufSiz<span class="token operator">></span><span class="token keyword">struct</span> _deque_iterator<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _deque_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token operator">&amp;</span><span class="token punctuation">,</span>T<span class="token operator">*</span><span class="token punctuation">,</span>BufSiz<span class="token operator">></span> iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> __deque_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> T<span class="token operator">*</span><span class="token punctuation">,</span>BufSiz<span class="token operator">></span>const_iterator<span class="token punctuation">;</span>     <span class="token keyword">static</span> size_t <span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> deque_ <span class="token function">buf_size</span><span class="token punctuation">(</span>Bufsiz<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">=</span>alloc<span class="token punctuation">,</span>size_t Buf8iz<span class="token operator">=</span><span class="token number">0</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> deque_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token operator">&amp;</span><span class="token punctuation">,</span>T<span class="token operator">*</span><span class="token punctuation">,</span>BufSiz<span class="token operator">></span> iterator<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator<span class="token operator">::</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>end1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//128</span>cout <span class="token operator">&lt;&lt;</span> deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>alloc<span class="token punctuation">,</span><span class="token number">64</span><span class="token operator">></span><span class="token operator">::</span>iterator<span class="token operator">::</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="第二章、空间配置："><a href="#第二章、空间配置：" class="headerlink" title="第二章、空间配置："></a>第二章、空间配置：</h1><ol><li>考虑到小型区块所可能造成的内存破碎问题，SGI设计了双层配置器，第一级配置器直接使用malloc和free，第二级配置器则视情况采用不用的策略(需求区块是否大于128bytes)。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102600276-1255786342.png" alt=" "></li></ol><p>第一级适配器以malloc()，free()，reaclloc()等C函数执行实际的内存配置、释放、重配置操作。第二级配置器多了一些机制，避免太多小额区块造成内存的碎片。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102607726-222688072.png" alt=" "></p><p>SGI第二级配置器的做法是，如果区块够大，超过128字节时，就移交第一级配置器处理。当区块小于128字节时，则以内存池(memory pool)管理，此法又称为次层配置(sub-allocation)：每次配置一大块内存，并维护对应的自由链表(free-list)。下次若再有相同大小的内存需求，就直接从free-lists中拔出。如果没有，则向系统要一大块内存，然后做切割，此时切割出来的小内存块，不带cookie。如果客户端释放小额区块，就由配置器回收。为方便管理，任何小额区块的内存需求量上调至8的倍数，并维护16个free-lists，各自管理大小分别为8,16,24…128字节。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102613857-2071157239.png" alt=" "></p><p>在G4.9中编译器使用的是不作任何优化的空间配置器，如果需要制定，则需要指明第二参数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> __gnu_cxx<span class="token operator">::</span>__pool_alloc<span class="token operator">&lt;</span>string<span class="token operator">>></span> vec<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果free-list中没有可用的区块，将区块大小上调至8的倍数边界，然后调用refill()，准备为free-list重新填充空间。refill()之后介绍。<br>空间的释放，大于128字节就调用第一级配置器，小于128字节就找出对应的free list，将区块回收。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102620400-1938054497.png" alt=" "></p><p>refill()重新填充空间，新的空间将取自内存池(经由chunk_alloc()完成)。内存池实际操练结果如下图：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102625685-1826453299.png" alt=" "></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102633369-309620775.png" alt=" "></p><ol start="2"><li>第一级配置器直接调用C函数执行实际的内存操作，并实现类似C++ new handler的机制。</li></ol><ol start="3"><li><p>当区块超过128bytes时，视之为足够大，便调用第一级配置器。当配置器小于128bytes时，视之为过小，便采用内存池的方式。每次配置一大块内存，并维护对应之自由链表，下次若再有相同大小的内存需求，就直接从free-list中拔出。如果客端释还小额区块，就由配置器回收到free-list中。为了方便管理，SGI第二季配置器会主动将任何小额区块的内存需求量上调至8的倍数（例如客端要求30bytes，就自动调整为32bytes），并维护16个free-list，大小分别是8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128bytes。</p></li><li><p>内存池  </p></li></ol><p>如果水量充足，就直接调出20个区块返回给free-list，如果不够20则返回不足实际个数。如果一个都拿不出，则调用malloc配置40个区块的空间，其中20个给free-list，剩下的20个留在内存池。如果malloc分配失败，则调用第一级配置器。因为第一级配置器有new-handler机制，获取能够整理出多余的空间。、</p><ol start="5"><li>内存基本处理工具<br>uninitialized_copy，uninitialized_fill,uninitialized_fill_n， 能够将内存配置与对象构造行为分离开来。并且会对POD（即标量型别或传统C struct） 对象采用最有效率的初值填写手法，而对non-POD型别采取最保险安全的做法。</li></ol><p>为了细化分工，STL allocator将两阶段操作区分开来。内存配置操作由alloc::allocate()负责，内存释放操作由alloc::deallocate()负责；对象构造操作由::construct负责，对象析构操作由::destroy()负责。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102648805-1757914145.png" alt=" "></p><h2 id="内存池："><a href="#内存池：" class="headerlink" title="内存池："></a>内存池：</h2><p>当申请空间不充足时，系统首先将剩余的空间尽量为你申请出来<br>一般新申请的空间大小为你所需求空间大小的2倍加上一个随机配置次数增加愈加增大的附加量<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102706624-214811463.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102718902-167431135.png" alt=""></p><h1 id="第三章、迭代器概念"><a href="#第三章、迭代器概念" class="headerlink" title="第三章、迭代器概念"></a>第三章、迭代器概念</h1><p>STL的中心思想在于：将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。</p><h2 id="迭代器相应型别："><a href="#迭代器相应型别：" class="headerlink" title="迭代器相应型别："></a>迭代器相应型别：</h2><h3 id="迭代器相应型别之一：value-type："><a href="#迭代器相应型别之一：value-type：" class="headerlink" title="迭代器相应型别之一：value type："></a>迭代器相应型别之一：value type：</h3><p>所谓 value type，是指迭代器所指对象的型别。任何一个打算与STL算法有完美搭配的class，都应该定义自己的vluetype内嵌型别， 做法就像上节所述。</p><h3 id="迭代器相应型别之二：difference-type："><a href="#迭代器相应型别之二：difference-type：" class="headerlink" title="迭代器相应型别之二：difference type："></a>迭代器相应型别之二：difference type：</h3><p>differencetype用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。<br>如果一个泛型算法提供计数功能，例如STL的count（），其传回值就必须使用迭代器的diference type：  </p><h3 id="迭代器相应型别之三：reference-type"><a href="#迭代器相应型别之三：reference-type" class="headerlink" title="迭代器相应型别之三：reference type"></a>迭代器相应型别之三：reference type</h3><p>从“迭代器所指之物的内容是否允许改变”的角度观之，迭代器分为两种：<br>不允许改变“所指对象之内容”者，称为constant iterators，例如 const int *pic；【视为不可改的右值】</p><p>允许改变“所指对象之内容”者，称为mutable iterators，例如int *pi。当我们对一个mutable iterators进行提领操作时，获得的不应该是一个右值（rvalue），应该是一个左值（lvalue），因为右值不允许赋值操作（assignment），左值才允许：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>pi<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span>（<span class="token number">5</span>）；<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pci<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span>（<span class="token number">9</span>）；<span class="token operator">*</span>pi<span class="token operator">=</span><span class="token number">7</span>；<span class="token comment" spellcheck="true">//对mutable iterator进行提领操作时，获得的应该是个左值，允许赋值</span><span class="token operator">*</span>pci<span class="token operator">=</span><span class="token number">1</span>；<span class="token comment" spellcheck="true">//这个操作不允许，因为pci是个constant iterator，</span>   <span class="token comment" spellcheck="true">//提领pci所得结果，是个右值，不允许被赋值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代器相应型别之四：pointer-type"><a href="#迭代器相应型别之四：pointer-type" class="headerlink" title="迭代器相应型别之四：pointer type"></a>迭代器相应型别之四：pointer type</h3><p>pointers和references在C++中有非常密切的关联。如果“传回一个左值，令它代表p所指之物”是可能的，那么“传回一个左值，令它代表p所指之物的地址”也一定可以。也就是说，我们能够传回一个pointer，指向迭代器所指之物。  </p><h3 id="迭代器相应型别之五：iterator-category"><a href="#迭代器相应型别之五：iterator-category" class="headerlink" title="迭代器相应型别之五：iterator_category"></a>迭代器相应型别之五：iterator_category</h3><p>最后一个（第五个）迭代器的相应型别会引发较大规模的写代码工程。在那之前，我必须先讨论迭代器的分类。  </p><h2 id="根据移动特性与施行操作，迭代器被分为五类："><a href="#根据移动特性与施行操作，迭代器被分为五类：" class="headerlink" title="根据移动特性与施行操作，迭代器被分为五类："></a>根据移动特性与施行操作，迭代器被分为五类：</h2><ul><li>Input lterator：这种迭代器所指的对象，不允许外界改变。只读（read only）。</li><li>Output terator：唯写（write only）。</li><li>Forward lterator：允许“写入型”算法（例如replace（））在此种迭代器所形成的区间上进行读写操作。</li><li>Bidirectiona lterator：可双向移动。某些算法需要逆向走访某个迭代器区间（例如逆向拷贝某范围内的元素），可以使用Biairectional lterators。</li><li>Random Access lterator：前四种迭代器都只供应一部分指针算术能力（前三种支持operator++，第四种再加上operator–），第五种则涵盖所有指针算术能力，包括<code>p+n，p-n，p[n]，pl-p2，p1&lt;p2</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客——Git-Github-Hexo搭建博客（二）</title>
      <link href="/2019/12/18/bo-ke-git-github-hexo-da-jian-bo-ke-er/"/>
      <url>/2019/12/18/bo-ke-git-github-hexo-da-jian-bo-ke-er/</url>
      
        <content type="html"><![CDATA[<!-- password: --><hr><p>主题主体下载地址： <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery</a></p><hr><h1 id="hexo-theme-matery主题设置注意事项"><a href="#hexo-theme-matery主题设置注意事项" class="headerlink" title="hexo-theme-matery主题设置注意事项"></a>hexo-theme-matery主题设置注意事项</h1><h2 id="layout文件"><a href="#layout文件" class="headerlink" title="layout文件"></a>layout文件</h2><p>这个文件是整个博客网页的显示设置</p><p>menu名称.ejs:<br>  都是显示菜单选项的</p><p>  记得在hexo根目录下新建相关的page后，在index中加上type: “”和layout: “”</p><p>layout.ejs:</p><p>  一般是整个博客版面的特效显示在该文件下设置，比如下雪、2D人物插件、天气等插件</p><p>post.ejs: </p><p>  是发表文章的版页显示</p><p>  比如公式，等显示</p><h3 id="widge文件"><a href="#widge文件" class="headerlink" title="-widge文件"></a>-widge文件</h3><p>这个文件是一些浮动窗口插件的设置</p><p>比如音乐、视频、天气、日历等等，其实内部都是一个独立的窗口显示，只不过有些是将其固定在一个版面上而已</p><h3 id="partial文件"><a href="#partial文件" class="headerlink" title="-partial文件"></a>-partial文件</h3><p>这是一些详细的细节设置和插件</p><p>一般根据文件名就知道了其设置和具体作用是什么</p><p>footer.js:</p><p>  网页页脚显示设置，比如版权，运行时间等等</p><p>header.ejs:</p><p>  网页页眉（页头）显示设置，比如menu菜单，头像，网页log等</p><p>  navigation.ejs:</p><pre><code>这是页眉版面的详细设置</code></pre><h2 id="source文件"><a href="#source文件" class="headerlink" title="source文件"></a>source文件</h2><p>这是一些图片、动画、脚本、js、css等自己加入的一些资源</p><h3 id="css文件"><a href="#css文件" class="headerlink" title="css文件"></a>css文件</h3><p>渲染效果特效</p><p>matry.css：</p><p>  这个博客版面渲染特效：</p><p>  比如手机、平板、电脑等版面显示</p><p>  还有导航栏颜色(bg-color)、背景颜色(bg)、代码框(code)边距等设置</p><p>其他的就是自己根据所需添加的渲染</p><h3 id="js文件"><a href="#js文件" class="headerlink" title="js文件"></a>js文件</h3><p>同样是一些特效渲染设置</p><h3 id="libs文件"><a href="#libs文件" class="headerlink" title="libs文件"></a>libs文件</h3><p>一些插件具体实现的文件</p><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>我额外加入的插件具体实现的文件，比如看板娘</p><h3 id="img"><a href="#img" class="headerlink" title="img"></a>img</h3><p>图库</p><h3 id="medias"><a href="#medias" class="headerlink" title="medias"></a>medias</h3><p>图片滚动资源</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>一些资源包，比如看板娘的具体动画</p><h1 id="添加渲染"><a href="#添加渲染" class="headerlink" title="添加渲染"></a>添加渲染</h1><h2 id="添加雪花"><a href="#添加雪花" class="headerlink" title="添加雪花"></a>添加雪花</h2><p>在 js目录下添加snow.js</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*样式一*/</span><span class="token comment" spellcheck="true">/*样式一*/</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>$<span class="token punctuation">)</span> <span class="token punctuation">{</span>    $<span class="token punctuation">.</span>fn<span class="token punctuation">.</span>snow <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> $flake <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'&lt;div id="snowbox" />'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                <span class="token string">'position'</span><span class="token punctuation">:</span> <span class="token string">'absolute'</span><span class="token punctuation">,</span>                <span class="token string">'z-index'</span><span class="token punctuation">:</span> <span class="token string">'9999'</span><span class="token punctuation">,</span>                <span class="token string">'top'</span><span class="token punctuation">:</span> <span class="token string">'-50px'</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">'❄'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            documentHeight <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            documentWidth <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            defaults <span class="token operator">=</span> <span class="token punctuation">{</span>                minSize<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>                maxSize<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>                newOn<span class="token punctuation">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>                flakeColor<span class="token punctuation">:</span> <span class="token string">"#AFDAEF"</span> <span class="token comment" spellcheck="true">/* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            options <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> defaults<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> interval <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> startPositionLeft <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> documentWidth <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">,</span>                startOpacity <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                sizeFlake <span class="token operator">=</span> options<span class="token punctuation">.</span>minSize <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> options<span class="token punctuation">.</span>maxSize<span class="token punctuation">,</span>                endPositionTop <span class="token operator">=</span> documentHeight <span class="token operator">-</span> <span class="token number">200</span><span class="token punctuation">,</span>                endPositionLeft <span class="token operator">=</span> startPositionLeft <span class="token operator">-</span> <span class="token number">500</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">500</span><span class="token punctuation">,</span>                durationFall <span class="token operator">=</span> documentHeight <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5000</span><span class="token punctuation">;</span>            $flake<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendTo</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                left<span class="token punctuation">:</span> startPositionLeft<span class="token punctuation">,</span>                opacity<span class="token punctuation">:</span> startOpacity<span class="token punctuation">,</span>                <span class="token string">'font-size'</span><span class="token punctuation">:</span> sizeFlake<span class="token punctuation">,</span>                color<span class="token punctuation">:</span> options<span class="token punctuation">.</span>flakeColor            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                top<span class="token punctuation">:</span> endPositionTop<span class="token punctuation">,</span>                left<span class="token punctuation">:</span> endPositionLeft<span class="token punctuation">,</span>                opacity<span class="token punctuation">:</span> <span class="token number">0.2</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> durationFall<span class="token punctuation">,</span> <span class="token string">'linear'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>newOn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jQuery<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    $<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">snow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        minSize<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/* 定义雪花最小尺寸 */</span>        maxSize<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/* 定义雪花最大尺寸 */</span>        newOn<span class="token punctuation">:</span> <span class="token number">300</span> <span class="token comment" spellcheck="true">/* 定义密集程度，数字越小越密集 */</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*样式二*/</span><span class="token comment" spellcheck="true">//背景雪花飘落特效</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>$<span class="token punctuation">)</span><span class="token punctuation">{</span>  $<span class="token punctuation">.</span>fn<span class="token punctuation">.</span>snow <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> $flake <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'&lt;div id="snowbox" />'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'position'</span><span class="token punctuation">:</span> <span class="token string">'absolute'</span><span class="token punctuation">,</span><span class="token string">'z-index'</span><span class="token punctuation">:</span><span class="token string">'9999'</span><span class="token punctuation">,</span> <span class="token string">'top'</span><span class="token punctuation">:</span> <span class="token string">'-50px'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">'&amp;#10052;'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  documentHeight  <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  documentWidth <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  defaults <span class="token operator">=</span> <span class="token punctuation">{</span>    minSize   <span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    maxSize   <span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    newOn   <span class="token punctuation">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>    flakeColor  <span class="token punctuation">:</span> <span class="token string">"#AFDAEF"</span> <span class="token comment" spellcheck="true">/* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  options <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> defaults<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> interval<span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> startPositionLeft <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> documentWidth <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">,</span>  startOpacity <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  sizeFlake <span class="token operator">=</span> options<span class="token punctuation">.</span>minSize <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> options<span class="token punctuation">.</span>maxSize<span class="token punctuation">,</span>  endPositionTop <span class="token operator">=</span> documentHeight <span class="token operator">-</span> <span class="token number">200</span><span class="token punctuation">,</span>  endPositionLeft <span class="token operator">=</span> startPositionLeft <span class="token operator">-</span> <span class="token number">500</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">500</span><span class="token punctuation">,</span>  durationFall <span class="token operator">=</span> documentHeight <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5000</span><span class="token punctuation">;</span>  $flake<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendTo</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    left<span class="token punctuation">:</span> startPositionLeft<span class="token punctuation">,</span>    opacity<span class="token punctuation">:</span> startOpacity<span class="token punctuation">,</span>    <span class="token string">'font-size'</span><span class="token punctuation">:</span> sizeFlake<span class="token punctuation">,</span>    color<span class="token punctuation">:</span> options<span class="token punctuation">.</span>flakeColor  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    top<span class="token punctuation">:</span> endPositionTop<span class="token punctuation">,</span>    left<span class="token punctuation">:</span> endPositionLeft<span class="token punctuation">,</span>    opacity<span class="token punctuation">:</span> <span class="token number">0.2</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>durationFall<span class="token punctuation">,</span><span class="token string">'linear'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>newOn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jQuery<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    $<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">snow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>       minSize<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 定义雪花最小尺寸 */</span>      maxSize<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">/* 定义雪花最大尺寸 */</span>      newOn<span class="token punctuation">:</span> <span class="token number">500</span>  <span class="token comment" spellcheck="true">/* 定义密集程度，数字越小越密集 */</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在layout.ejs添加</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 雪花特效<span class="token number">1</span> <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>snow<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"/js/snow.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 雪花特效 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>xuehuapiaoluo<span class="token punctuation">.</span>enable<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>        <span class="token keyword">var</span> windowWidth <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>windowWidth <span class="token operator">></span> <span class="token number">768</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'&lt;script type="text/javascript" src="/js/xuehuapiaoluo.js">&lt;\/script>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在/config.yml设置</p><pre><code>wenzi:  enable: truexuehuapiaoluo:  enable: truesakura:  enable: true</code></pre><p>在/config.yml添加</p><pre><code>libs:  js:    sakura: /js/sakura.js    fireworks: /js/fireworks.js    wenzi: /js/wenzi.js    xuehuapiaoluo: /js/xuehuapiaoluo.js</code></pre><h2 id="添加文字特效"><a href="#添加文字特效" class="headerlink" title="添加文字特效"></a>添加文字特效</h2><p>在js下新建wenzi.js</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* 鼠标点击文字特效 */</span><span class="token keyword">var</span> a_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">jQuery</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>$<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// var a = new Array("❤富强❤","❤民主❤","❤文明❤","❤和谐❤","❤自由❤","❤平等❤","❤公正❤","❤法治❤","❤爱国❤","❤敬业❤","❤诚信❤","❤友善❤");</span>        <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token string">"富强"</span><span class="token punctuation">,</span><span class="token string">"民主"</span><span class="token punctuation">,</span><span class="token string">"文明"</span><span class="token punctuation">,</span><span class="token string">"和谐"</span><span class="token punctuation">,</span><span class="token string">"自由"</span><span class="token punctuation">,</span><span class="token string">"平等"</span><span class="token punctuation">,</span><span class="token string">"公正"</span><span class="token punctuation">,</span><span class="token string">"法治"</span><span class="token punctuation">,</span><span class="token string">"爱国"</span><span class="token punctuation">,</span><span class="token string">"敬业"</span><span class="token punctuation">,</span><span class="token string">"诚信"</span><span class="token punctuation">,</span><span class="token string">"友善"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> $i <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"&lt;span>&lt;/span>"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>a_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a_idx <span class="token operator">=</span> <span class="token punctuation">(</span>a_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">var</span> x <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX<span class="token punctuation">,</span>        y <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY<span class="token punctuation">;</span>        $i<span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            <span class="token string">"z-index"</span><span class="token punctuation">:</span> <span class="token number">999999999999999999999999999999999999999999999999999999999999999999999</span><span class="token punctuation">,</span>            <span class="token string">"top"</span><span class="token punctuation">:</span> y <span class="token operator">-</span> <span class="token number">20</span><span class="token punctuation">,</span>            <span class="token string">"left"</span><span class="token punctuation">:</span> x<span class="token punctuation">,</span>            <span class="token string">"position"</span><span class="token punctuation">:</span> <span class="token string">"absolute"</span><span class="token punctuation">,</span>            <span class="token string">"font-weight"</span><span class="token punctuation">:</span> <span class="token string">"bold"</span><span class="token punctuation">,</span>            <span class="token string">"color"</span><span class="token punctuation">:</span> <span class="token string">"rgb("</span><span class="token operator">+</span><span class="token operator">~</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token operator">*</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span><span class="token operator">~</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token operator">*</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span><span class="token operator">~</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token operator">*</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">")"</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>$i<span class="token punctuation">)</span><span class="token punctuation">;</span>        $i<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            <span class="token string">"top"</span><span class="token punctuation">:</span> y <span class="token operator">-</span> <span class="token number">180</span><span class="token punctuation">,</span>            <span class="token string">"opacity"</span><span class="token punctuation">:</span> <span class="token number">0</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token number">1500</span><span class="token punctuation">,</span>        <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            $i<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用仿上面</p><h2 id="添加天气"><a href="#添加天气" class="headerlink" title="添加天气"></a>添加天气</h2><p>在layout.ejs中添加</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 天气 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>weather<span class="token punctuation">.</span>enable<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_widget/weather'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在_widget中添加weather.ejs</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> weather <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>  WIDGET <span class="token operator">=</span> <span class="token punctuation">{</span>FID<span class="token punctuation">:</span> <span class="token string">'iBarNbUMlb'</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"https://apip.weatherdt.com/float/static/js/r.js?v=1111"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在config中添加</p><pre><code>weather:true</code></pre><h2 id="添加2D人物"><a href="#添加2D人物" class="headerlink" title="添加2D人物"></a>添加2D人物</h2><p>在layout.ejs中添加</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token operator">&lt;</span>script <span class="token keyword">async</span> type<span class="token operator">=</span><span class="token string">"text/javascript"</span> size<span class="token operator">=</span><span class="token string">"90"</span> alpha<span class="token operator">=</span><span class="token string">"0.2"</span> zIndex<span class="token operator">=</span><span class="token string">"0"</span> src<span class="token operator">=</span><span class="token string">"&lt;%- url_for('plugins/ribbon.js/ribbon.min.js') %>"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span> <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span># <span class="token string">"Live2D看板娘：https://github.com/JoeyBling/live2d-widget.js"</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>live2d <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>enable<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/live2d-widget'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在_partial中添加live2d-widget.ejs</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"&lt;%- url_for('plugins/live2d-widget.js/L2Dwidget.min.js') %>"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>  <span class="token comment" spellcheck="true">/**   * 完整配置请参考：https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init   */</span>  <span class="token keyword">var</span> pluginModelPath <span class="token operator">=</span> <span class="token string">"assets/"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 模型的文件路径，无需更改</span>    pluginRootPath <span class="token operator">=</span> <span class="token string">"&lt;%- url_for('/live2d_models/') %>"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 插件的路径，无需更改</span>  <span class="token comment" spellcheck="true">//特定的模型json文件名称</span>  <span class="token keyword">var</span> modelPathJson <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"epsilon2_1"</span><span class="token punctuation">:</span> <span class="token string">"Epsilon2.1"</span><span class="token punctuation">,</span>    <span class="token string">"gf"</span><span class="token punctuation">:</span> <span class="token string">"Gantzert_Felixander"</span><span class="token punctuation">,</span>    <span class="token string">"haru/01"</span><span class="token punctuation">:</span> <span class="token string">"haru01"</span><span class="token punctuation">,</span>    <span class="token string">"haru/02"</span><span class="token punctuation">:</span> <span class="token string">"haru02"</span><span class="token punctuation">,</span>    <span class="token string">"nietzsche"</span><span class="token punctuation">:</span> <span class="token string">"nietzche"</span>  <span class="token punctuation">}</span>  <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>model<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token keyword">var</span> modelName <span class="token operator">=</span> <span class="token string">"&lt;%- theme.live2d.model %>"</span><span class="token punctuation">;</span>  <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token keyword">var</span> modelName <span class="token operator">=</span> <span class="token string">"hibiki"</span><span class="token punctuation">;</span>  <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>  <span class="token keyword">var</span> modelJsonPath <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>modelPathJson<span class="token punctuation">[</span>modelName<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    modelJsonPath <span class="token operator">=</span> pluginRootPath <span class="token operator">+</span> modelName <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> pluginModelPath <span class="token operator">+</span> modelPathJson<span class="token punctuation">[</span>modelName<span class="token punctuation">]</span> <span class="token operator">+</span>      <span class="token string">".model.json"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    modelJsonPath <span class="token operator">=</span> pluginRootPath <span class="token operator">+</span> modelName <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> pluginModelPath <span class="token operator">+</span> modelName <span class="token operator">+</span> <span class="token string">".model.json"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  L2Dwidget<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    model<span class="token punctuation">:</span> <span class="token punctuation">{</span>      jsonPath<span class="token punctuation">:</span> modelJsonPath    <span class="token punctuation">}</span><span class="token punctuation">,</span>    display<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display<span class="token punctuation">.</span>position<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span> position<span class="token punctuation">:</span> <span class="token string">"&lt;%- theme.live2d.display.position %>"</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display<span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span> width<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display<span class="token punctuation">.</span>width <span class="token operator">%</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span> height<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display<span class="token punctuation">.</span>height <span class="token operator">%</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display<span class="token punctuation">.</span>hOffset<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span> hOffset<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display<span class="token punctuation">.</span>hOffset <span class="token operator">%</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display<span class="token punctuation">.</span>vOffset<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span> vOffset<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>display<span class="token punctuation">.</span>vOffset <span class="token operator">%</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mobile<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>mobile <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>mobile<span class="token punctuation">.</span>show <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span> show<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>mobile<span class="token punctuation">.</span>show <span class="token operator">%</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>mobile <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>mobile<span class="token punctuation">.</span>scale<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span> scale<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>mobile<span class="token punctuation">.</span>scale <span class="token operator">%</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    react<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>react <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>react<span class="token punctuation">.</span>opacity<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span> opacity<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> theme<span class="token punctuation">.</span>live2d<span class="token punctuation">.</span>react<span class="token punctuation">.</span>opacity <span class="token operator">%</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在source中添加动画库，下载地址：<a href="https://github.com/JoeyBling/hexo-theme-yilia-plus.git" target="_blank" rel="noopener">https://github.com/JoeyBling/hexo-theme-yilia-plus.git</a><br>在source/plugins添加文件，下载地址：<a href="https://github.com/JoeyBling/hexo-theme-yilia-plus.git" target="_blank" rel="noopener">https://github.com/JoeyBling/hexo-theme-yilia-plus.git</a></p><p>在config中添加</p><pre><code># 看板娘动态模型插件## https://github.com/JoeyBling/live2d-widget.jslive2d:  # (关闭请设置为false)  enable: true  model: shizuku  display:    position: right # 显示位置：left/right(default: &#39;right&#39;)    width: 145  # 模型的长度(default: 150)    height: 315 # 模型的高度(default: 300)    hOffset: 50 # 水平偏移(default: 0)    vOffset: 35 # 垂直偏移(default: -20)  mobile:    show: false # 是否在移动设备上显示(default: true)    scale: 0.6 # 移动设备上的缩放(default: 0.5)  react:    opacity: 0.8 # 模型透明度(default: 0.7)</code></pre><h2 id="添加页面标题切换功能"><a href="#添加页面标题切换功能" class="headerlink" title="添加页面标题切换功能"></a>添加页面标题切换功能</h2><p>在header.ejs中的第一个<a>, </a>之间添加：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>tab_title_change <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>tab_title_change<span class="token punctuation">.</span>enable<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token comment" spellcheck="true">/* 标签页标题切换 */</span>  <span class="token keyword">var</span> originTitle <span class="token operator">=</span> document<span class="token punctuation">.</span>title<span class="token punctuation">;</span>  <span class="token keyword">var</span> titleTime<span class="token punctuation">;</span>  document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"visibilitychange"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>hidden<span class="token punctuation">)</span> <span class="token punctuation">{</span>      document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"&lt;%- theme.tab_title_change.left_tab_title %>"</span> <span class="token operator">+</span> originTitle<span class="token punctuation">;</span>      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>titleTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"&lt;%- theme.tab_title_change.return_tab_title %>"</span> <span class="token operator">+</span> originTitle<span class="token punctuation">;</span>      titleTime <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        document<span class="token punctuation">.</span>title <span class="token operator">=</span> originTitle<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在config中添加</p><pre><code># Tab Title Change | 标签页标题切换tab_title_change:  enable: true  left_tab_title: &#39;(つェ⊂) 我藏好了哦~ &#39;  return_tab_title: &#39;(*´∇｀*) 被你发现啦~ &#39;</code></pre><h2 id="添加github-的fork-me"><a href="#添加github-的fork-me" class="headerlink" title="添加github 的fork me"></a>添加github 的fork me</h2><p>在header.ejs中的第一个</nav>之前添加：</p><pre><code>&lt;% if (theme.githubLink &amp;&amp; theme.githubLink.enable) { %&gt;    &lt;%- partial(&#39;_partial/github-link&#39;) %&gt;&lt;% } %&gt;</code></pre><p>在_partial中添加github-link.ejs</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>style<span class="token operator">></span>    <span class="token punctuation">.</span>nav<span class="token operator">-</span>transparent <span class="token punctuation">.</span>github<span class="token operator">-</span>corner <span class="token punctuation">{</span>        display<span class="token punctuation">:</span> none <span class="token operator">!</span>important<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>github<span class="token operator">-</span>corner <span class="token punctuation">{</span>        position<span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>        z<span class="token operator">-</span>index<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">;</span>        top<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        right<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        border<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        transform<span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>github<span class="token operator">-</span>corner svg <span class="token punctuation">{</span>        color<span class="token punctuation">:</span> #0f9d58<span class="token punctuation">;</span>        fill<span class="token punctuation">:</span> #fff<span class="token punctuation">;</span>        height<span class="token punctuation">:</span> 64px<span class="token punctuation">;</span>        width<span class="token punctuation">:</span> 64px<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>github<span class="token operator">-</span>corner<span class="token punctuation">:</span>hover <span class="token punctuation">.</span>octo<span class="token operator">-</span>arm <span class="token punctuation">{</span>        animation<span class="token punctuation">:</span> a <span class="token number">0</span><span class="token punctuation">.</span>56s ease<span class="token operator">-</span><span class="token keyword">in</span><span class="token operator">-</span>out<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>github<span class="token operator">-</span>corner <span class="token punctuation">.</span>octo<span class="token operator">-</span>arm <span class="token punctuation">{</span>        animation<span class="token punctuation">:</span> none<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @keyframes a <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token operator">%</span><span class="token punctuation">,</span>        to <span class="token punctuation">{</span>            transform<span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token number">20</span><span class="token operator">%</span><span class="token punctuation">,</span>        <span class="token number">60</span><span class="token operator">%</span> <span class="token punctuation">{</span>            transform<span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token operator">-</span>25deg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token number">40</span><span class="token operator">%</span><span class="token punctuation">,</span>        <span class="token number">80</span><span class="token operator">%</span> <span class="token punctuation">{</span>            transform<span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>10deg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- theme.githubLink.url %>"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"github-corner tooltipped hide-on-med-and-down"</span> target<span class="token operator">=</span><span class="token string">"_blank"</span>   data<span class="token operator">-</span>tooltip<span class="token operator">=</span><span class="token string">"&lt;%- theme.githubLink.title %>"</span> data<span class="token operator">-</span>position<span class="token operator">=</span><span class="token string">"left"</span> data<span class="token operator">-</span>delay<span class="token operator">=</span><span class="token string">"50"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>svg viewBox<span class="token operator">=</span><span class="token string">"0 0 250 250"</span> aria<span class="token operator">-</span>hidden<span class="token operator">=</span><span class="token string">"true"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>path d<span class="token operator">=</span><span class="token string">"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>path<span class="token operator">></span>        <span class="token operator">&lt;</span>path d<span class="token operator">=</span><span class="token string">"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"</span>              fill<span class="token operator">=</span><span class="token string">"currentColor"</span> style<span class="token operator">=</span><span class="token string">"transform-origin: 130px 106px;"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"octo-arm"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>path<span class="token operator">></span>        <span class="token operator">&lt;</span>path d<span class="token operator">=</span><span class="token string">"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"</span>              fill<span class="token operator">=</span><span class="token string">"currentColor"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"octo-body"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>path<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>svg<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在config中添加</p><pre><code># Whether to display fork me on github icon and link, default true, You can change it to your repo address# 配置是否在 header 中显示 fork me on github 的图标，默认为true，你可以修改为你的仓库地址.githubLink:  enable: true  url: https://github.com/zzw1024  title: Fork Me</code></pre><h2 id="添加音乐"><a href="#添加音乐" class="headerlink" title="添加音乐"></a>添加音乐</h2><p>在layout.ejs中添加</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 音乐 <span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>music<span class="token punctuation">.</span>enable<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_widget/music'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在_widget中新建music.esj</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token keyword">var</span> audiosJson <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>site<span class="token punctuation">.</span>data<span class="token punctuation">.</span>musics<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">"stylesheet"</span> href<span class="token operator">=</span><span class="token string">"&lt;%- theme.libs.css.aplayer %>"</span><span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"&lt;% if (theme.music.enable &amp;&amp; !theme.music.fixed) { %>music-player&lt;% } %>"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>music<span class="token punctuation">.</span>showTitle<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"title center-align"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>i <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"fas fa-music"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> theme<span class="token punctuation">.</span>music<span class="token punctuation">.</span>title <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"row"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"col l8 offset-l2 m10 offset-m1 s12"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"aplayer"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"music"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"&lt;%- theme.libs.js.aplayer %>"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">APlayer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        container<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'aplayer'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        fixed<span class="token punctuation">:</span> <span class="token string">'&lt;%- theme.music.fixed %>'</span> <span class="token operator">===</span> <span class="token string">'true'</span><span class="token punctuation">,</span>        autoplay<span class="token punctuation">:</span> <span class="token string">'&lt;%- theme.music.autoplay %>'</span> <span class="token operator">===</span> <span class="token string">'true'</span><span class="token punctuation">,</span>        theme<span class="token punctuation">:</span> <span class="token string">'&lt;%- theme.music.theme %>'</span><span class="token punctuation">,</span>        loop<span class="token punctuation">:</span> <span class="token string">'&lt;%- theme.music.loop %>'</span><span class="token punctuation">,</span>        order<span class="token punctuation">:</span> <span class="token string">'&lt;%- theme.music.order %>'</span><span class="token punctuation">,</span>        preload<span class="token punctuation">:</span> <span class="token string">'&lt;%- theme.music.preload %>'</span><span class="token punctuation">,</span>        volume<span class="token punctuation">:</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'&lt;%- theme.music.volume %>'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        listFolded<span class="token punctuation">:</span> <span class="token string">'&lt;%- theme.music.listFolded %>'</span> <span class="token operator">===</span> <span class="token string">'true'</span><span class="token punctuation">,</span>        listMaxHeight<span class="token punctuation">:</span> <span class="token string">'&lt;%- theme.music.listMaxHeight %>'</span><span class="token punctuation">,</span>        audio<span class="token punctuation">:</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> audiosJson <span class="token operator">%</span><span class="token operator">></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在config中添加</p><pre><code># Whether to display the musics.# 是否在首页显示音乐.music:  enable: false  showTitle: true  title: &#39;亲，听听音乐放松放松。。。&#39;  fixed: false # 开启吸底模式  autoplay: false # 是否自动播放  theme: &#39;#42b983&#39;  loop: &#39;all&#39; # 音频循环播放, 可选值: &#39;all&#39;, &#39;one&#39;, &#39;none&#39;  order: &#39;list&#39; # 音频循环顺序, 可选值: &#39;list&#39;, &#39;random&#39;  preload: &#39;auto&#39; # 预加载，可选值: &#39;none&#39;, &#39;metadata&#39;, &#39;auto&#39;  volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: false # 列表默认折叠  listMaxHeight: #列表最大高度</code></pre><h1 id="添加项目栏"><a href="#添加项目栏" class="headerlink" title="添加项目栏"></a>添加项目栏</h1><h2 id="添加分类标签等menu"><a href="#添加分类标签等menu" class="headerlink" title="添加分类标签等menu"></a>添加分类标签等menu</h2><p><strong>其他的比如分类标签如下</strong></p><p>添加page</p><pre><code>hexo new page &quot;menuName&quot;</code></pre><p>并且编辑对应的index</p><pre><code>---title: tagsdate: 2018-12-12 21:25:30type: &quot;tags&quot;   //一定得有layout: &quot;tags&quot;  //一定得有---</code></pre><h2 id="添加友链："><a href="#添加友链：" class="headerlink" title="添加友链："></a>添加友链：</h2><p>添加page</p><pre><code>hexo new page &quot;friends&quot;</code></pre><p>并且编辑对应的index</p><pre><code>---title: friendsdate: 2018-12-12 21:25:30type: &quot;friends&quot;layout: &quot;friends&quot;  //一定的有---</code></pre><p>在hexo/source下新建 _data(下划线data) 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示：  </p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"ttps://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加好文收藏"><a href="#添加好文收藏" class="headerlink" title="添加好文收藏"></a>添加好文收藏</h2><pre><code>hexo new page &quot;goodpapers&quot;</code></pre><p>修改站点_config.yml文件</p><pre><code>menu:  好文收藏:    url: /goodpapers    icon: fa-coffee</code></pre><p>修该goodpapers/index.md</p><pre><code>---title: 好文收藏date: 2019-02-18 11:09:48---1. [我的八年博士生涯](https://www.huxiu.com/article/273773.html?f=member_collections)         2. [我曾是性用品微商](https://www.huxiu.com/article/285040.html?f=member_collections)3. [乔布斯回归：从任性国王到铁腕企业家](https://www.huxiu.com/article/285320.html)4. [那些简历造假拿 Offer 的程序员，后来都怎么样了？](https://mp.weixin.qq.com/s/a2rscuxJ0fl07OJ-0Shxfg)5. [知网是个什么东西啊，好暴利](https://www.huxiu.com/article/285502.html)</code></pre><h2 id="添加相册"><a href="#添加相册" class="headerlink" title="添加相册"></a>添加相册</h2><h1 id="功能修改添加备忘录"><a href="#功能修改添加备忘录" class="headerlink" title="功能修改添加备忘录"></a>功能修改添加备忘录</h1><p>添加简历(matery):<br>  在about.ejs中加入一个新的card，直接复制上面的就行    </p><p>修改简历:<br>  在自己的about/index里面写表格建立</p><p>添加收藏文章:<br>  在goodpapers/index里面写</p><p>添加友链：<br>  在source/_data/friends.json里面按照格式写</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客——Git-Github-Hexo搭建博客（一）</title>
      <link href="/2019/12/18/bo-ke-git-github-hexo-da-jian-bo-ke-yi/"/>
      <url>/2019/12/18/bo-ke-git-github-hexo-da-jian-bo-ke-yi/</url>
      
        <content type="html"><![CDATA[<!-- password: --><h1 id="新建博客以及新电脑使用博客说明"><a href="#新建博客以及新电脑使用博客说明" class="headerlink" title="新建博客以及新电脑使用博客说明"></a>新建博客以及新电脑使用博客说明</h1><hr><p>新电脑与新建博客步骤类似，就直接从GitHub中clone的文件放入hexo文件中<br>注意，好像是不要hexo初始化，直接将clone的文件放入就行<br>注意，添加node插件，需要哪些后面会说<br>注意，后面hexo g -d 上传部分</p><hr><p><strong>Git + Github + Hexo</strong></p><ol><li>安装Git</li></ol><p>去Git官网根据你的电脑参数，下载对应版本。</p><ol start="2"><li>安装Node.js  </li></ol><p>在 Windows 环境下安装 Node.js 非常简单，仅须到官网下载安装文件并执行即可完成安装。</p><ol start="3"><li>安装Hexo</li></ol><ul><li><p>使用git安装：</p><pre><code>npm install hexo-cli -gnpm install hexo-deployer-git --save</code></pre></li><li><p>hexo初始化</p><pre><code>hexo init</code></pre></li></ul><hr><p>以下部分只是针对新建博客， 新电脑不需要的</p><hr><ol start="4"><li>部署到远程</li></ol><p><strong>以下操作都是在git中执行</strong></p><ul><li><p>注册github账号（或者coding或者码云）</p></li><li><p>新建项目  </p><ul><li><strong>github注意</strong><br>项目名称严格为 GitHub账号名 + .github.io<br>在网页上直接输入该项目名字就可以访问博客了，这是部署到GitHub的最大优势！</li></ul></li><li><p>配置SSH密钥</p><ul><li><p>查看是否有密钥</p><pre><code>$ cd ~/.ssh</code></pre></li><li><p>不存在的话新建密钥  </p><pre><code>$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;#这将按照你提供的邮箱地址，创建一对密钥Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</code></pre><ul><li><p>相关提示</p><pre><code>Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again]</code></pre></li><li><p>显示信息</p><pre><code>Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</code></pre></li></ul></li><li><p>在github中添加公钥 </p><ul><li><p>复制ssh</p><pre><code>clip &lt; ~/.ssh/id_rsa.pub</code></pre></li><li><p>进入github的账户设置中，选择ssh keys 直接粘贴</p></li></ul></li><li><p>测试</p><pre><code>$ ssh -T git@github.com</code></pre><ul><li>反馈<pre><code>The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?   //输入yes</code></pre></li></ul></li></ul></li><li><p>上传github中 并且分流到其他仓库<br>在congfig中进行设置  </p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.html  https://gitee.com/zzw1024/myBlog.gitdeploy:type: gitrepository:   github: https://github.com/zzw1024/zzw1024.github.io.git    //github项目地址  gitee: https://gitee.com/zzw1024/myBlog.git                 //码云项目地址branch: master</code></pre></li></ul><ol start="5"><li>上传</li></ol><pre><code>hexo g -d</code></pre><p>如果报错</p><pre><code>ERROR Deployer not found: git</code></pre><p>再次运行</p><pre><code>npm install hexo-deployer-git --save</code></pre><ol start="7"><li>添加域名</li></ol><p><strong>只有部署在GitHub不一定需要添加域名，其他仓库都需要</strong><br>在仓库的项目设置中找到添加域名的项，把你子啊阿里或者其他地方买的域名写入</p><ul><li>阿里购买域名<br>登录阿里云，选择域名进行购买，购买完成后选择自己的后台控制，进行域名解析，一天后域名成效</li></ul><ol start="8"><li>美化</li></ol><p>从网上找到的主题clone到theme文件夹下<br>然后更改config</p><pre><code># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: matery  //主题名字</code></pre><ol start="9"><li>备份博客文件</li></ol><p><strong>只针对博客文件所在的第一台电脑中</strong><br>直接在hexo文件内git init<br>然后在上传到你新建的一个项目中（最好是私有仓库，因为里面有你的账号信息）</p><h1 id="config-yml设置额外添加说明"><a href="#config-yml设置额外添加说明" class="headerlink" title="config.yml设置额外添加说明"></a>config.yml设置额外添加说明</h1><hr><p>一般在新电脑中需要添加而外的功能<br>注意，一般clone下来的config.yml已经有功能，只不过需要npm安装环境<br>需不需要，先运行博客试看一下，然后再查看有没有设置，最后再考虑要不要安装</p><hr><p><strong>以下操作都是在hexo文件在的cmd中执行</strong></p><h2 id="修改新建文章、page、draft的自动添加内容"><a href="#修改新建文章、page、draft的自动添加内容" class="headerlink" title="修改新建文章、page、draft的自动添加内容"></a>修改新建文章、page、draft的自动添加内容</h2><p>在scaffolds的各个文件里面直接设置就行</p><h2 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h2><p>找到language： 后面一定是选中主题下language文件下的语言语言名字，比如：zh-CN<br>记得将自己主题设置config及其相关设置文件下的英文对应的中文名添加到主题下language/zh-CN 里面</p><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre><code>npm i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：</p><pre><code>highlight:  enable: falseprism_plugin:  mode: &#39;preprocess&#39;    # realtime/preprocess  theme: &#39;tomorrow&#39;  line_number: false    # default false  custom_css:</code></pre><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre><code>npm install hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><pre><code>search:  path: search.xml  field: post</code></pre><h2 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h2><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。<br>安装命令如下：</p><pre><code>npm i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><pre><code>permalink_pinyin:  enable: true  separator: &#39;-&#39; # default: &#39;-&#39;</code></pre><h2 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h2><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。<br>安装命令如下：</p><pre><code>npm i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 _config.yml 文件中，激活以下配置项即可：</p><pre><code>wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true</code></pre><h2 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h2><p>本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下：</p><pre><code>npm install hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><pre><code>feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: &#39; &#39;  order_by: -date</code></pre><p>执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。</p><h2 id="添加goole广告投送"><a href="#添加goole广告投送" class="headerlink" title="添加goole广告投送"></a>添加goole广告投送</h2><ul><li><p>注册登录<a href="https://www.google.com/adsense/" target="_blank" rel="noopener">google Adsense官网</a><br>打开网站之后就可以开始注册了（即使你有google账户也要注册！）</p><ol><li><p>官网点击注册（sign up）,进入注册页面</p></li><li><p>在注册页面填写你的信息（网站地址不可以是二级域名）</p></li><li><p>在之后填写你的地址信息</p></li><li><p>地址信息填完毕之后会给你一串代码，类似如下：</p><pre><code>&lt;script async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;&lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({ google_ad_client: &quot;ca-pub-8955547868703063&quot;, enable_page_level_ads: true});&lt;/script&gt;</code></pre></li><li><p>把这一串代码放在<br>博客目录\themes\yilia\layout_partial\head.ejs文件的 <head>与<meta name="generator" content="Hexo 4.0.0"><link rel="alternate" href="/atom.xml" title="自由の翼" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>之间</p></li><li><p>更新上传</p></li></ol></li><li><p>返回官网进行确认检测</p></li><li><p>审核通过<br>稍等一天时间，如果没有问题，即可审核通过。<br>有问题就改问题，然后在申请。</p></li><li><p>添加展示广告</p><ol><li><p>在网页上找到“广告” -&gt; “广告单元” -&gt; “创建新的广告单元” -&gt; “展示广告”</p></li><li><p>然后再界面里面先填写一个名字(例如ad_google_1)</p></li><li><p>点击创建</p></li><li><p>将生成的代码添加到<br>博客目录</p><pre><code>\themes\yilia\layout\_partial\article.ejs</code></pre><p>中对应适当位置即可，注意别让广告扰乱了页面布局，影响全局美感。</p><p>添加代码如下：</p><pre><code>可以在文章开头添加：&lt;!--文章头google图片--&gt;&lt;% if ((theme.googlead_type === 2 || (theme.googlead_type === 1 &amp;&amp; post.googlead)) &amp;&amp; !index){ %&gt; &lt;hr&gt; &lt;strong&gt;⬇️下面这个看起来像广告的东西，其实是只个图片，根本打不开的。不过听说有时候⬇️&lt;/strong&gt; &lt;br&gt; &lt;script async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt; &lt;!-- googlead1 --&gt; &lt;ins class=&quot;adsbygoogle&quot;      style=&quot;display:block&quot;      data-ad-client=&quot;ca-pub-8955547868703063&quot;      data-ad-slot=&quot;3853918361&quot;      data-ad-format=&quot;auto&quot;      data-full-width-responsive=&quot;true&quot;&gt;&lt;/ins&gt; &lt;script&gt;      (adsbygoogle = window.adsbygoogle || []).push({}); &lt;/script&gt;&lt;% } %&gt;&lt;!--文章头google图片结束--&gt;可以在结尾处添加：&lt;!-- 尾google广告 --&gt;   &lt;% if ((theme.googlead_type === 2 || (theme.googlead_type === 1 &amp;&amp; post.googlead)) &amp;&amp; !index){ %&gt;       &lt;hr&gt;       &lt;strong&gt;⬇️下面这个才是真正的广告哦，如果感觉真的从文章中有带走新东西的话，可以帮我点一下哦⬇️&lt;/strong&gt;     &lt;br&gt;       这里是google网页生成的代码   &lt;% } %&gt;&lt;!-- 尾google广告 --&gt;</code></pre><p>然后还需要在</p><pre><code>/theme/yilia/_config.yml</code></pre><p>中合适位置添加</p><pre><code>#google广告基础设定：0-关闭广告； 1-文章对应的md文件里有googlead: true属性，才有广告； 2-所有文章均有广告googlead_type: 1</code></pre><p>使用教程如上面提示：<br>0-关闭广告；<br>1-文章对应的md文件里有googlead: true属性，才有广告；<br>2-所有文章均有广告   </p></li></ol></li><li><p>添加完毕</p><p>  在网页中点击“大功告成”</p></li><li><p>网页上传</p><pre><code>hexo cleanhexo ghexo d</code></pre></li><li><p>等待一小时左右大约会出现广告</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题设置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美好回忆——电影录像</title>
      <link href="/2019/12/08/mei-hao-hui-yi-dian-ying-lu-xiang/"/>
      <url>/2019/12/08/mei-hao-hui-yi-dian-ying-lu-xiang/</url>
      
        <content type="html"><![CDATA[<p>哈哈哈，除了学习，也要生活么，所以希望此贴少更新哦。。。</p><a id="more"></a><h1 id="剧"><a href="#剧" class="headerlink" title="剧"></a>剧</h1><h4 id="好剧"><a href="#好剧" class="headerlink" title="好剧"></a>好剧</h4><p><strong>亮剑</strong><br>是吧</p><p><strong>康熙王朝</strong><br>康乾盛世的开端</p><p><strong>神雕侠侣</strong><br>过儿</p><p><strong>我的团长我的团</strong><br>国军的溃败，英雄的兴叹</p><p><strong>请回答1988</strong><br>一代人的青春史</p><h4 id="史诗"><a href="#史诗" class="headerlink" title="史诗"></a>史诗</h4><p><strong>权力的游戏</strong><br>当之无愧</p><h4 id="烧脑"><a href="#烧脑" class="headerlink" title="烧脑"></a>烧脑</h4><p><strong>毛骗</strong><br>看了才会赞</p><p><strong>河神</strong><br>应该是李现的出名作</p><p><strong>杀不死</strong><br>值得的</p><h4 id="搞笑"><a href="#搞笑" class="headerlink" title="搞笑"></a>搞笑</h4><p><strong>武林外传</strong><br>指如疾风，势如闪电</p><p><strong>爱情公寓</strong><br>好男人就是我，我就是好男人</p><h4 id="恐怖"><a href="#恐怖" class="headerlink" title="恐怖"></a>恐怖</h4><h1 id="影"><a href="#影" class="headerlink" title="影"></a>影</h1><h4 id="科幻"><a href="#科幻" class="headerlink" title="科幻"></a>科幻</h4><p><strong>魔戒</strong><br>一定是首位，我心中的史诗级</p><p><strong>阿凡达</strong><br>值得回看</p><p><strong>夺宝奇兵</strong><br>一定要看完</p><p><strong>生化危机</strong><br>终结了</p><p><strong>复仇者联盟</strong><br>是吧</p><p><strong>加勒比海盗</strong><br>杰克斯派罗</p><h4 id="激情"><a href="#激情" class="headerlink" title="激情"></a>激情</h4><p><strong>速度与激情</strong><br>可以的</p><p><strong>怒火攻心</strong></p><p><strong>绝命速递</strong></p><p><strong>极品飞车</strong></p><h4 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h4><p><strong>假如爱有天意</strong></p><p><strong>恋爱这件小事</strong></p><p><strong>怦然心动</strong></p><p><strong>罗马假日</strong></p><p><strong>生死之恋</strong></p><p><strong>泰坦尼克号</strong></p><h4 id="搞笑-1"><a href="#搞笑-1" class="headerlink" title="搞笑"></a>搞笑</h4><p><strong>三傻大闹宝莱坞</strong></p><p><strong>唐人街神探</strong></p><p><strong>夏洛特烦恼</strong></p><h4 id="烧脑-1"><a href="#烧脑-1" class="headerlink" title="烧脑"></a>烧脑</h4><p><strong>盗梦空间</strong></p><h4 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h4><p><strong>宫崎骏系列</strong></p><p><strong>你的名字</strong></p><h4 id="恐怖-1"><a href="#恐怖-1" class="headerlink" title="恐怖"></a>恐怖</h4><p><strong>静寂岭</strong></p><p><strong>林正英系列</strong></p><h1 id="记录片"><a href="#记录片" class="headerlink" title="记录片"></a>记录片</h1><h4 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h4><p><strong>舌尖上的中国</strong></p><h4 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h4><p><strong>超级工程</strong></p>]]></content>
      
      
      <categories>
          
          <category> 美好回忆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影视 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习百态——我的阅读世界</title>
      <link href="/2019/12/08/xue-xi-bai-tai-yue-du-shi-jie/"/>
      <url>/2019/12/08/xue-xi-bai-tai-yue-du-shi-jie/</url>
      
        <content type="html"><![CDATA[<p>用来记录自己的读书记录：一是记忆，二是勉励，望此贴时常更新。。。</p><!-- <img src="http:" width="250" height="250" align=center> --><h2 id="IT事业"><a href="#IT事业" class="headerlink" title="IT事业"></a>IT事业</h2><h3 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h3><ul><li><p><a href="https://item.jd.com/12194885.html" target="_blank" rel="noopener">c语言程序设计</a></p><img src="http://img10.360buyimg.com/n1/jfs/t9694/74/1296611139/79088/5c26d2d9/59df3587N5defa858.jpg" width="250" height="250" align=center></li><li><p><a href="http://product.dangdang.com/27849226.html" target="_blank" rel="noopener">C程序设计语言</a></p><img src="http://img3m6.ddimg.cn/31/29/27849226-1_w_1.jpg" width="250" height="250" align=center></li><li><p><a href="http://product.dangdang.com/1592311664.html" target="_blank" rel="noopener">Objective-C基础教程(第二版)</a></p><img src="http://img3m4.ddimg.cn/20/14/1592311664-1_w_1.jpg" width="250" height="250" align=center></li><li><p><a href="http://product.dangdang.com/25100126.html" target="_blank" rel="noopener">Swift编程权威指南（第2版）</a></p><img src="http://img3m6.ddimg.cn/62/29/25100126-1_w_3.jpg" width="250" height="250" align=center></li><li><p><a href="http://product.dangdang.com/23321562.html" target="_blank" rel="noopener">C++ prime 5th</a></p><img src="http://img3m2.ddimg.cn/33/18/23321562-1_u_24.jpg" width="250" height="250" align=cenyer></li><li><p><a href="https://item.jd.com/11017238.html" target="_blank" rel="noopener">C++ Primer Plus（第6版 中文版)</a></p><img src="http://img13.360buyimg.com/n1/jfs/t20314/139/439767662/251385/77521300/5b0e07ffN4152350d.jpg" width="250" height="250" align=cenyer></li><li><p><a href="https://item.jd.com/11993134.html" target="_blank" rel="noopener">Python编程：从入门到实践</a></p><img src="http://img14.360buyimg.com/n1/jfs/t17953/201/1450663539/451183/3262b8de/5acb3627N8191c867.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12259774.html" target="_blank" rel="noopener">汇编语言</a></p><img src="http://img14.360buyimg.com/n1/jfs/t12286/298/2106223981/563949/84b36489/5a323c60N27f039d1.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12443890.html" target="_blank" rel="noopener">鸟哥的linux私房菜基础学习篇</a></p><img src="http://img10.360buyimg.com/n1/jfs/t30046/50/220320157/307090/726c45e1/5beb9d94N19d87979.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12212242.html" target="_blank" rel="noopener">SQL基础教程</a></p><img src="http://img12.360buyimg.com/n1/jfs/t7279/118/3075645481/234908/b49a48c/59b8dc1bNad0874f7.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11232698.html" target="_blank" rel="noopener">SQL必知必会</a></p><img src="http://img13.360buyimg.com/n1/jfs/t5587/209/2000109185/478227/657008a1/592bf166N231dc63b.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/45930848568.html" target="_blank" rel="noopener">MySQL必知必会</a></p><img src="http://img13.360buyimg.com/n1/jfs/t1/31418/37/13875/317816/5cbc0b99E96703320/9a4862b23d7fadde.jpg" width="250" height="250" align=center></li></ul><h3 id="2、进阶"><a href="#2、进阶" class="headerlink" title="2、进阶"></a>2、进阶</h3><ul><li><p><a href="https://item.jd.com/10062654.html" target="_blank" rel="noopener">C陷阱与缺陷</a></p><img src="http://img14.360buyimg.com/n1/jfs/t9259/32/2059524034/30433/3fbf733e/59c3194aN5d8f6cd7.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/10393318.html" target="_blank" rel="noopener">Effective C++ </a></p><img src="http://img13.360buyimg.com/n1/jfs/t22993/92/1057202855/205103/5c5f7a40/5b4eeb87Nba09e1e0.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/10484020.html" target="_blank" rel="noopener">More Effective C++</a></p><img src="http://img10.360buyimg.com/n1/jfs/t1/2335/38/16849/237870/5c064fb0Ebea2164a/0e60fe977aea55bf.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/34247882106.html" target="_blank" rel="noopener">STL源码剖析</a></p><img src="http://img11.360buyimg.com/n1/jfs/t1/21704/11/6414/112934/5c4d4873E63ec0ae4/aca4946cc68d6b50.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12715718.html" target="_blank" rel="noopener">unix 网络编程</a></p><img src="http://img13.360buyimg.com/n1/jfs/t1/44445/18/12367/160454/5d8b030cEcf2213c9/97988b477efb3b02.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11253710.html" target="_blank" rel="noopener">图解 TCP/IP</a></p><img src="http://img10.360buyimg.com/n1/jfs/t5797/240/2066590798/290678/a64c50f0/592bf164N5dde581e.jpg" width="250" height="250" align=center></li><li><p><a href="http://product.dangdang.com/23462067.html" target="_blank" rel="noopener">图解 HTTP</a></p><img src="http://img3m7.ddimg.cn/57/34/23462067-1_w_5.jpg" width="250" height="250" align=center></li></ul><h3 id="3、算法与数据结构"><a href="#3、算法与数据结构" class="headerlink" title="3、算法与数据结构"></a>3、算法与数据结构</h3><ul><li><p><a href="https://item.jd.com/10663703.html" target="_blank" rel="noopener">大话数据结构</a></p><img src="http://img13.360buyimg.com/n1/14980/389ebb70-14b7-4563-ba45-210fa5ed662a.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12518392.html" target="_blank" rel="noopener">程序员代码面试指南</a></p><img src="http://img12.360buyimg.com/n1/jfs/t1/28927/36/3792/504545/5c2c2b04E516761b0/a6d4ae76f2cb8751.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11973614.html" target="_blank" rel="noopener">算法笔记</a></p><img src="http://img14.360buyimg.com/n1/jfs/t2725/77/2752569532/249798/7b2fad5/5771c493N9add12e2.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11939121.html" target="_blank" rel="noopener">算法笔记上机训练实战指南</a></p><img src="http://img11.360buyimg.com/n1/jfs/t2830/50/2756998147/266871/3fba589b/5771c64eNabd14c3b.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11477302.html" target="_blank" rel="noopener">啊哈，算法</a></p><img src="http://img12.360buyimg.com/n1/jfs/t5863/201/1981195052/596029/d1380115/592bf169N864816a5.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11144230.html" target="_blank" rel="noopener">算法导论</a></p><img src="http://img10.360buyimg.com/n1/g9/M03/10/0C/rBEHalDFX10IAAAAAAMtdd_bKwEAADM6gOC6NoAAy2N265.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12153875.html" target="_blank" rel="noopener">趣学算法</a></p><img src="http://img10.360buyimg.com/n1/jfs/t6865/315/2169296158/105968/a555a962/59893d21Nbe9e4233.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12148832.html" target="_blank" rel="noopener">图解算法</a></p><img src="http://img12.360buyimg.com/n1/jfs/t6076/140/741632533/410964/9aebd688/592bf171N7145cf2d.jpg" width="250" height="250" align=center></li></ul><h3 id="4、程序人生"><a href="#4、程序人生" class="headerlink" title="4、程序人生"></a>4、程序人生</h3><ul><li><p><a href="https://item.jd.com/12163054.html" target="_blank" rel="noopener">剑指offer</a></p><img src="http://img14.360buyimg.com/n1/jfs/t4324/224/3099445550/166356/d8c1775c/58db5d3bN661ab10f.jpg" width="250" height="250" align=center></li><li><p><a href="https://www.nowcoder.com/coin/index?productId=98" target="_blank" rel="noopener">C++校招面试题库</a></p><img src="hhttps://uploadfiles.nowcoder.com/images/20190326/826546_1553600943362_8517196A9781517E70492DBE6F51D130" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11772830.html" target="_blank" rel="noopener">程序员面试宝典</a></p><img src="http://img10.360buyimg.com/n1/jfs/t2098/97/757859405/511208/81e99b18/5628afe1Nc70a8283.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/10079261.html" target="_blank" rel="noopener">大话设计模式</a></p><img src="http://img11.360buyimg.com/n1/17173/c3f6016e-fd9e-45a7-95bb-8a981c3d3f93.jpg" width="250" height="250" align=center></li></ul><h3 id="5、网络文献"><a href="#5、网络文献" class="headerlink" title="5、网络文献"></a>5、网络文献</h3><ul><li><p>《彻底搞定C指针》——姚云飞    </p></li><li><p>《跟我一起写 Makefile》——陈皓</p></li><li><p>《Objective-C培训教程》——黑马程序员</p></li><li><p>《Swift5.0手册》——官网</p></li><li><p>《MFC基础教程》——黑马程序员</p></li></ul><h2 id="休闲小憩"><a href="#休闲小憩" class="headerlink" title="休闲小憩"></a>休闲小憩</h2><h3 id="1、古代历史"><a href="#1、古代历史" class="headerlink" title="1、古代历史"></a>1、古代历史</h3><ul><li><p><a href="https://item.jd.com/12491161.html" target="_blank" rel="noopener">大秦帝国</a></p><img src="http://img11.360buyimg.com/n1/jfs/t1/27417/24/15211/85597/5cad9c2cEc6d5478c/4f12b0eed0f1ebf7.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11670589.html" target="_blank" rel="noopener">唐朝那些事</a></p><img src="http://img14.360buyimg.com/n1/jfs/t976/128/738317813/593432/47ea30be/554c69f6N7ead339f.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/58047259743.html" target="_blank" rel="noopener">宋朝那些事</a></p><img src="http://img13.360buyimg.com/n1/jfs/t1/64861/6/11735/402618/5d919bfdEec30d85e/feed276478dbb3cf.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/61272949260.html" target="_blank" rel="noopener">话说明朝</a></p><img src="http://img10.360buyimg.com/n1/jfs/t1/95713/5/1701/17048/5dc47d6eE04c66091/ad1cc44c8beabdb8.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/62626132049.html" target="_blank" rel="noopener">话说汉朝</a></p><img src="http://img14.360buyimg.com/n1/jfs/t1/94252/17/3241/13374/5ddccc14E6083d2c9/4c70c23c7c5b2fcd.jpg" width="250" height="250" align=center></li></ul><h3 id="2、世界近现代史"><a href="#2、世界近现代史" class="headerlink" title="2、世界近现代史"></a>2、世界近现代史</h3><ul><li><p><a href="https://item.jd.com/12214228.html" target="_blank" rel="noopener">中国近代史</a></p><img src="http://img13.360buyimg.com/n1/jfs/t6031/294/3033465686/238108/7b751f3b/594b87e6N0449a36a.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11080274.html" target="_blank" rel="noopener">红墙往事</a></p><img src="http://img14.360buyimg.com/n1/g9/M03/05/0F/rBEHaVBIY_EIAAAAAAEIQGuDjeoAABEbwCeGEsAAQhY423.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/10045430.html" target="_blank" rel="noopener">红墙见证录</a></p><img src="http://img10.360buyimg.com/n1/14694/0ac4e589-437d-4a17-86e5-508bb401612c.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/31279331407.html" target="_blank" rel="noopener">红墙大事:共和国重大历史事件的来龙去脉</a></p><img src="http://img12.360buyimg.com/n1/jfs/t1/28182/29/1240/179853/5c108172Eb7b9b44a/af1ba20245bcc987.png" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/61441126577.html" target="_blank" rel="noopener">自由与荣耀</a></p><img src="http://img12.360buyimg.com/n1/jfs/t1/89791/25/1739/89612/5dc44661E11694782/e4dabe6d4bff997a.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/65481262691.html" target="_blank" rel="noopener">中苏外交档案解密</a></p><img src="http://img11.360buyimg.com/n1/jfs/t1/108404/32/5552/32725/5e3a7596E220bb1ae/881874f618049827.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/45630125356.html" target="_blank" rel="noopener">海湾战争全史</a></p><img src="http://img11.360buyimg.com/n1/jfs/t1/33613/4/4210/25613/5cb6d7e9E72b0daa9/39bb40c73e4458ea.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.paipai.com/38916780927.html" target="_blank" rel="noopener">中越战争秘录</a></p><img src="http://img12.360buyimg.com/n1/s450x450_jfs/t1/15009/7/775/27387/5c0cc194E947b152c/09f44fc07bbfee13.jpg" width="250" height="250" align=center></li></ul><h3 id="3、地缘政治"><a href="#3、地缘政治" class="headerlink" title="3、地缘政治"></a>3、地缘政治</h3><ul><li><p><a href="https://item.jd.com/12071687.html" target="_blank" rel="noopener">世界大格局，中国有态度</a></p><img src="http://img12.360buyimg.com/n1/jfs/t4393/354/4114490199/391452/5d294a60/59097e51Nb744763d.jpg" width="250" height="250" align=center></li><li><p><a href="http://e.dangdang.com/products/1900634473.html" target="_blank" rel="noopener">看懂世界格局的第一本书</a></p><img src="http://img61.ddimg.cn/digital/product/44/73/1900634473_ii_cover.jpg?version=1ed2c50b-c027-4b07-a0e3-a6d2321df555555" width="250" height="250" align=center></li><li><p><a href="http://product.dangdang.com/25173947.html" target="_blank" rel="noopener">一本书看懂地缘政治</a></p><img src="http://img3m7.ddimg.cn/29/35/25173947-1_u_4.jpg" width="250" height="250" align=center></li><li><p><a href="http://e.dangdang.com/products/1900668452.html" target="_blank" rel="noopener">用地图看懂世界格局</a></p><img src="http://img62.ddimg.cn/digital/product/84/52/1900668452_ii_cover.jpg?version=76e02bb9-826a-4a28-8eb6-b515d3978331555" width="250" height="250" align=center></li><li><p><a href="http://product.dangdang.com/1576825974.html" target="_blank" rel="noopener">石油战争</a></p><img src="http://img3m4.ddimg.cn/9/8/1576825974-1_w_1.jpg" width="250" height="250" align=center></li></ul><h3 id="4、-人物传记"><a href="#4、-人物传记" class="headerlink" title="4、 人物传记"></a>4、 人物传记</h3><ul><li><p><a href="https://item.jd.com/12162901.html" target="_blank" rel="noopener">亮剑</a></p><img src="http://img11.360buyimg.com/n1/jfs/t7174/310/2456531485/118619/56824d37/599694dcNecf2e1be.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/10120027.html" target="_blank" rel="noopener">我的伯父周恩来</a></p><img src="http://img12.360buyimg.com/n1/16644/22ff06db-beee-4990-a8bf-7629f31daa04.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/63994231748.html" target="_blank" rel="noopener">历史转折中的邓小平</a></p><img src="http://img13.360buyimg.com/n1/jfs/t1/85878/35/6934/26396/5df6abf9E5d3bcbe0/85cfc932302be621.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12418005.html" target="_blank" rel="noopener">我的前半生</a></p><img src="http://img10.360buyimg.com/n1/jfs/t26932/160/71966900/436933/ac82b48c/5b83ae0aNf346063d.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11556741.html" target="_blank" rel="noopener">诸葛亮：大谋小计五十年</a></p><img src="http://img11.360buyimg.com/n1/jfs/t2269/195/2047163896/345715/f37e9c78/56a5fdf9N8b3e6b02.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/35068972100.html" target="_blank" rel="noopener">杜月笙全传</a></p><img src="http://img10.360buyimg.com/n1/jfs/t28357/189/3151177/385149/2505d978/5be5147cNc02d6d5a.jpg" width="250" height="250" align=center></li></ul><h3 id="5、金融世界"><a href="#5、金融世界" class="headerlink" title="5、金融世界"></a>5、金融世界</h3><ul><li><a href="https://item.jd.com/59295431675.html" target="_blank" rel="noopener">货币战争</a><img src="http://img10.360buyimg.com/n1/jfs/t10303/354/2798180560/47637/a5811475/5cd815dcN035cae3d.jpg" width="250" height="250" align=center></li></ul><h3 id="6、人文社科"><a href="#6、人文社科" class="headerlink" title="6、人文社科"></a>6、人文社科</h3><ul><li><p><a href="https://item.jd.com/32150869543.html" target="_blank" rel="noopener">群书治要</a></p><img src="http://img13.360buyimg.com/n1/jfs/t1/64714/30/10767/402701/5d832683E75c2368a/a593e9744fd41462.png" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12150765.html" target="_blank" rel="noopener">易经的奥秘</a></p><img src="http://img10.360buyimg.com/n1/jfs/t5971/101/8970259116/345652/90be8969/598d828eNff2c17ce.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/61786080403.html" target="_blank" rel="noopener">左手塔木德，右手羊皮卷</a>   </p><img src="http://img13.360buyimg.com/n1/jfs/t1/64325/8/15473/28861/5dcdc68eEeed37615/610755a7e4835a6e.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/10008245.html" target="_blank" rel="noopener">红楼梦</a></p><img src="http://img10.360buyimg.com/n1/jfs/t1/63654/33/2304/258890/5d0a144cEbfdd8b73/b6a56c1a8095ab1d.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11794250.html" target="_blank" rel="noopener">杜拉拉升职记</a></p><img src="//img10.360buyimg.com/n1/jfs/t2479/100/868521057/560014/5d5fee60/562f2bd2N516df8d3.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12451212.html" target="_blank" rel="noopener">藏地密码</a></p><img src="http://img12.360buyimg.com/n1/jfs/t1/31618/4/8990/406257/5ca43de7E711f329a/8fdecad409c4b689.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/29625677500.html" target="_blank" rel="noopener">鬼谷子的局</a></p><img src="http://img10.360buyimg.com/n1/jfs/t1/94318/5/7040/160834/5df84a1dEa5fd35f5/de2c7cb3048e58b7.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12354843.html" target="_blank" rel="noopener">古董局中局</a></p><img src="http://img13.360buyimg.com/n1/jfs/t20785/144/140374415/220947/a3d0ec07/5afe9e67Nb1782540.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/57606262387.html" target="_blank" rel="noopener">长安十二时辰</a></p><img src="//img12.360buyimg.com/n1/jfs/t1/71388/10/11086/116305/5d89c6ccE174d22d9/e666a6051a254c8b.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12269599850.html" target="_blank" rel="noopener">花开半夏</a></p><img src="http://img10.360buyimg.com/n1/jfs/t4426/137/4018553897/14451/6dce0d60/59089761N92d71535.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/27996394377.html" target="_blank" rel="noopener">匆匆那年</a></p><img src="http://img12.360buyimg.com/n1/jfs/t18979/199/2307683036/82875/799f7d90/5af1231cN0d5d8980.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12406643.html" target="_blank" rel="noopener">谁的青春不迷茫</a></p><img src="http://img13.360buyimg.com/n1/jfs/t23998/232/1847046070/304646/d1c0c4aa/5b6a85e7N2de8100d.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12182317.html" target="_blank" rel="noopener">我在未来等你</a></p><img src="http://img12.360buyimg.com/n1/jfs/t8176/149/1451400837/507149/70f143d2/59ba4a72N42919975.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/11468070.html" target="_blank" rel="noopener">你的孤独，虽败犹荣</a></p><img src="http://img10.360buyimg.com/n1/jfs/t1087/117/17567832/287734/ed31c962/54e19eb9Nde737f97.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12161410.html" target="_blank" rel="noopener">向着光亮那方</a></p><img src="http://img10.360buyimg.com/n1/jfs/t4507/181/2190607495/193263/21dd657f/58ec9ed6N257528ca.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12057175.html" target="_blank" rel="noopener">拿什么拯救你，我的爱人</a></p><img src="http://img10.360buyimg.com/n1/jfs/t4519/209/1095580665/443816/a5d18482/58d8cc0cN9a1c2dfd.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12059453.html" target="_blank" rel="noopener">永不瞑目</a></p><img src="http://img13.360buyimg.com/n1/jfs/t5068/263/64357031/379941/45e33aa5/58da0f9eNe04ed1bf.jpg" width="250" height="250" align=center></li><li><p><a href="https://item.jd.com/12168088.html" target="_blank" rel="noopener">一场风花雪月的事</a></p><img src="http://img13.360buyimg.com/n1/jfs/t5020/283/1063459764/307817/337dad02/58ec43bcNfacd0bd2.jpg" width="250" height="250" align=center></li></ul><h3 id="4、个人兴趣"><a href="#4、个人兴趣" class="headerlink" title="4、个人兴趣"></a>4、个人兴趣</h3><h2 id="听见真知"><a href="#听见真知" class="headerlink" title="听见真知"></a>听见真知</h2><h3 id="1、历史"><a href="#1、历史" class="headerlink" title="1、历史"></a>1、历史</h3><ul><li><a href="https://www.ximalaya.com/lishi/16909213/" target="_blank" rel="noopener">太平洋战争实录</a></li><li><a href="https://www.ximalaya.com/search/世界大战实录之冷战" target="_blank" rel="noopener">世界大战实录之冷战</a></li><li><a href="https://www.ximalaya.com/lishi/7493158/" target="_blank" rel="noopener">百年中国</a></li><li><a href="https://www.ximalaya.com/lishi/12116906/" target="_blank" rel="noopener">元朝那些事</a></li><li><a href="https://www.ximalaya.com/lishi/7967331/" target="_blank" rel="noopener">纪连海说清史</a></li><li><a href="https://www.ximalaya.com/youshengshu/261600/" target="_blank" rel="noopener">纪实小说——枭雄末路（卡扎菲 萨达姆 本拉丹）</a></li><li><a href="https://www.ximalaya.com/lishi/296746/" target="_blank" rel="noopener">帝师刘伯温</a></li><li><a href="https://www.ximalaya.com/renwen/32775280/" target="_blank" rel="noopener">地缘看世界</a></li></ul><h3 id="2、人文"><a href="#2、人文" class="headerlink" title="2、人文"></a>2、人文</h3><ul><li><a href="https://www.ximalaya.com/renwen/11438153/" target="_blank" rel="noopener">郭论</a></li></ul><h3 id="3、金融"><a href="#3、金融" class="headerlink" title="3、金融"></a>3、金融</h3><ul><li><a href="https://www.ximalaya.com/shangye/13634866/" target="_blank" rel="noopener">常见金融常识</a></li></ul><h3 id="4、兴趣"><a href="#4、兴趣" class="headerlink" title="4、兴趣"></a>4、兴趣</h3>]]></content>
      
      
      <categories>
          
          <category> 学习百态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习百态——我的学习记录</title>
      <link href="/2019/12/08/xue-xi-bai-tai-xue-xi-ji-lu/"/>
      <url>/2019/12/08/xue-xi-bai-tai-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>此博文是用来记录自己的学习生涯中，所学到的知识以及其掌握程度。。。</p><a id="more"></a><h1 id="基础【了解】"><a href="#基础【了解】" class="headerlink" title="基础【了解】"></a>基础【了解】</h1><p>C<br>Object-C<br>C++<br>Swift<br>shell<br>linux<br>QT<br>汇编<br>计算机网络<br>操作系统<br>python<br>MySQL<br>HTML<br>CSS<br>JavaScript<br>HTTP<br>TCP/IP<br>makefile</p><h1 id="精通"><a href="#精通" class="headerlink" title="精通"></a>精通</h1><p>C<br>Object-C<br>C++<br>MATLAB<br>Linux命令<br>git</p><p>算法与数据结构</p><h1 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h1><p>A_start 算法<br>Dijkstra<br>人工势场<br>遗传算法<br>蚁群算法<br>粒子群算法<br>无人避障<br>水流算法<br>免疫算法</p>]]></content>
      
      
      <categories>
          
          <category> 学习百态 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级终结——心得总结</title>
      <link href="/2019/12/08/pat-jia-ji-zhong-jie-xin-de-zong-jie/"/>
      <url>/2019/12/08/pat-jia-ji-zhong-jie-xin-de-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="首先报喜一波"><a href="#首先报喜一波" class="headerlink" title="首先报喜一波"></a>首先报喜一波</h2><p>第一次考，满分，4道题总共花了2个小时做完，一部分是题简单的原因，一部分也是自己三刷了PAT的心血吧。</p><a id="more"></a><h2 id="刷PAT的经验"><a href="#刷PAT的经验" class="headerlink" title="刷PAT的经验"></a>刷PAT的经验</h2><p><strong>神指导</strong>： 胡凡-《算法笔记》<br><strong>神助攻</strong>：柳婼的博客，百度即可。<br><strong>战场</strong>：PAT官网和牛客PAT专项</p><p>首先,按照算法笔记这本书从一页认真看到最后一页，里面讲的各种算法和数据结构都特别全，特别详细，你按照这本书的章节去练习PAT题，按章节一刷，同时总结每个章节的思路和方法。</p><p>二刷就按题号走，这样就打乱了刷题顺序，让你不会一下就知道使用什么思路了。</p><p>三刷 就刷你前面一直没有刷通过的题。</p><p><strong>刷题技巧</strong>：按照算法笔记那本书的方法解题，并结合一下柳婼大神的答案，因为她很有一些解题技巧的。记住，调试代码的时候在牛客上调，因为牛客会给出测试样例，而PAT官网只告诉你错了，都不知道错了的样例是什么，牛客只有前100题，而PAT有所有题集。</p><h2 id="最后总结我的技巧："><a href="#最后总结我的技巧：" class="headerlink" title="最后总结我的技巧："></a>最后总结我的技巧：</h2><p><strong>声明</strong>：我不是大神，方法只适合考试的时候用，不建议用来总结算法方法，因为以下的方法不推荐。</p><p>记住，20分的题不需要考虑任何空间和时间的限制，因为这道题不需要你去设计高大上的算法，你想到了最笨的方法一般都能通过的，在考场，时间是一切，想到了方法就直接上手，不要考虑会不会超时等因素。</p><p>25，30分的题，是要讲究技巧的，一般一定考验了你对STL【C++的代码者】的使用。<br>能不能用暴力的笨方法，看数据量，我感觉在500以内的暴力，在三层for循环内都不会超时间【个人看法】，一旦超过了这个数量级，只要你的算法设计有2层for，铁定不行的，不用浪费时间敲出来，自己先别的方法。</p><p><strong>20分的题</strong><br>一般20分的题，恶心，麻烦，不难<br>10分钟没思路，或，20分钟没调出代码，跳过先，跳过先，跳过先<br>一般考数据处理：字母大小写，一句话带空格的输入，正表达式<br>素数，分数的处理，大数运算</p><p><strong>树的题</strong>：<br>问输出某某序列，一定是重构出二叉树【笨的就直接真的重构出来，聪明的就使用静态重构树】<br>问什么路径，一定是DFS啥都别想</p><p><strong>图的题</strong>：<br>路径问题，一定是先Dijkstra，然后再DFS<br>集合，团体问题：一定使用并查集【算法笔记有讲解】或者加上DFS</p><p><strong>动态规划</strong><br>听说是PAT超纲了，不会考，但也得看，因为考过的<br>动态规划题，不需要花大时间复习，因为考的概率很少，其次很难，碰上了放弃的概率大。<br>主要复习两大类即可：<br>背包问题：0-1，完全<br>上楼梯问题：青蛙跳，机器人走路</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一定的多练习原题，一天不要贪多，但每天都得刷<br>有任何问题，欢迎留言联系，小伙我人不聪明，但人热情哦o(<em>￣▽￣</em>)o</p>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1025 PAT Ranking</title>
      <link href="/2019/12/05/pat-jia-ji-a1025-pat-ranking/"/>
      <url>/2019/12/05/pat-jia-ji-a1025-pat-ranking/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.</p><a id="more"></a><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains a positive number N (≤), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (≤), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:<br>registration_number final_rank location_number local_rank</p><p>The locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.</p><p>Sample Input:<br>2<br>5<br>1234567890001 95<br>1234567890005 100<br>1234567890003 95<br>1234567890002 77<br>1234567890004 85<br>4<br>1234567890013 65<br>1234567890011 25<br>1234567890014 100<br>1234567890012 85</p><p>Sample Output:<br>9<br>1234567890005 1 1 1<br>1234567890014 1 2 1<br>1234567890001 3 1 2<br>1234567890003 3 1 2<br>1234567890004 5 1 4<br>1234567890012 5 2 2<br>1234567890002 7 1 5<br>1234567890013 8 2 3<br>1234567890011 9 2 4</p>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1024 Palindromic Numberr</title>
      <link href="/2019/12/05/pat-jia-ji-a1024-palindromic-numberr/"/>
      <url>/2019/12/05/pat-jia-ji-a1024-palindromic-numberr/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p><a id="more"></a><p>Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. For example, if we start from 67, we can obtain a palindromic number in 2 steps: 67 + 76 = 143, and 143 + 341 = 484.</p><p>Given any positive integer N, you are supposed to find its paired palindromic number and the number of steps taken to find it.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case consists of two positive numbers N and K, where N (≤) is the initial numer and K (≤) is the maximum number of steps. The numbers are separated by a space.</p><p><strong>Output Specification:</strong></p><p>For each test case, output two numbers, one in each line. The first number is the paired palindromic number of N, and the second number is the number of steps taken to find the palindromic number. If the palindromic number is not found after K steps, just output the number obtained at the Kth step and K instead.</p><p><strong>Sample Input 1:</strong></p><pre><code>67 3</code></pre><p><strong>Sample Output 1:</strong></p><pre><code>4842</code></pre><p><strong>Sample Input 2:</strong></p><pre><code>69 3</code></pre><p><strong>Sample Output 2:</strong></p><pre><code>13533</code></pre><p><strong>Solution:</strong></p><p>问一个数加上自己的 反转数，这样加k次后的和是不是回文数？<br>感觉能使用STL的reverse()函数的回文题都不是难题<br>记得不能直接相加，使用string进行加减</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> s3<span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k<span class="token punctuation">;</span>    cin <span class="token operator">>></span> s1 <span class="token operator">>></span> k<span class="token punctuation">;</span>    <span class="token keyword">do</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> temp<span class="token punctuation">;</span>        s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            temp <span class="token operator">=</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span> <span class="token operator">+</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span> <span class="token operator">+</span> index<span class="token punctuation">;</span>            s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> temp <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            s1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> s1 <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1023 Have Fun with Numbers</title>
      <link href="/2019/12/05/pat-jia-ji-a1023-have-fun-with-numbers/"/>
      <url>/2019/12/05/pat-jia-ji-a1023-have-fun-with-numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!</p><a id="more"></a><p>Now you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.</p><p><strong>Input Specification:</strong></p><p>Each input contains one test case. Each case contains one positive integer with no more than 20 digits.</p><p><strong>Output Specification:</strong></p><p>For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.</p><p><strong>Sample Input:</strong></p><pre><code>1234567899</code></pre><p><strong>Sample Output:</strong></p><pre><code>Yes2469135798</code></pre><p><strong>Solution:</strong></p><p>问，一个数的double后，是不是还是由原来的数字组成的？<br>说白了就是问，一个数加上自己是不是自己的一个排列？</p><p>使用nums[10]来记录原来的数的各个数字出现的次数，然后与其和对比<br>或者直接排序后对比是不是一样的<br>注意：大数运算， 用字符实现加减</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> s3<span class="token punctuation">;</span>    cin <span class="token operator">>></span> s1<span class="token punctuation">;</span>    s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>    <span class="token keyword">int</span> temp<span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        temp <span class="token operator">=</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span> <span class="token operator">+</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span> <span class="token operator">+</span> index<span class="token punctuation">;</span>        s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">'0'</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> temp <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        s2<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s3 <span class="token operator">=</span> s2<span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> s1 <span class="token operator">!=</span> s2<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"No"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">else</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yes"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> s3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1022 Digital Library</title>
      <link href="/2019/12/05/pat-jia-ji-a1022-digital-library/"/>
      <url>/2019/12/05/pat-jia-ji-a1022-digital-library/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID’s.</p><a id="more"></a><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤) which is the total number of books. Then Nblocks follow, each contains the information of a book in 6 lines:</p><pre><code>* Line #1: the 7-digit ID number;* Line #2: the book title -- a string of no more than 80 characters;* Line #3: the author -- a string of no more than 80 characters;* Line #4: the key words -- each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space;* Line #5: the publisher -- a string of no more than 80 characters;* Line #6: the published year -- a 4-digit number which is in the range [1000, 3000].</code></pre><p>It is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers.</p><p>After the book information, there is a line containing a positive integer M (≤) which is the number of user’s search queries. Then M lines follow, each in one of the formats shown below:</p><pre><code>* 1: a book title* 2: name of an author* 3: a key word* 4: name of a publisher* 5: a 4-digit number representing the year</code></pre><p><strong>Output Specification:</strong></p><p>For each query, first print the original query in a line, then output the resulting book ID’s in increasing order, each occupying a line. If no book is found, print Not Found instead.</p><p><strong>Sample Input:</strong></p><pre><code>31111111The Testing BookYue Chentest code debug sort keywordsZUCS Print20113333333Another Testing BookYue Chentest code sort keywordsZUCS Print220122222222The Testing BookCYLLkeywords debug bookZUCS Print2201161: The Testing Book2: Yue Chen3: keywords4: ZUCS Print5: 20113: blablabla</code></pre><p><strong>Sample Output:</strong></p><pre><code>1: The Testing Book111111122222222: Yue Chen111111133333333: keywords1111111222222233333334: ZUCS Print11111115: 2011111111122222223: blablablaNot Found</code></pre><p><strong>Solution:</strong></p><p>使用map映射：</p><p>第一种方法<br>以时间换空间，就是个ID保留一组信息，查询时遍历查询<br>但可能导致时间复杂度过大</p><p>第二种方法[推荐使用方法二]<br>以空间换时间，每种信息对应一个ID，查找时，时间复杂度为O(1)<br>但可能导致空间复杂度太大</p><p>注意一些字符输入的细节</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sstream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span>map<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>    string str<span class="token punctuation">,</span> substr<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>                cin <span class="token operator">>></span> id<span class="token punctuation">;</span>        <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                istringstream <span class="token function">ss</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>ss<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    ss <span class="token operator">>></span> substr<span class="token punctuation">;</span>                    map<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>substr<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            map<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cin <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        id <span class="token operator">=</span> str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>        str<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">==</span> map<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Not Found"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ptr <span class="token operator">=</span> map<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ptr <span class="token operator">!=</span> map<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ptr<span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%07d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1021 Deepest Root</title>
      <link href="/2019/12/05/pat-jia-ji-a1021-deepest-root/"/>
      <url>/2019/12/05/pat-jia-ji-a1021-deepest-root/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root.</p><a id="more"></a><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N−1 lines follow, each describes an edge by given the two adjacent nodes’ numbers.</p><p><strong>Output Specification:</strong></p><p>For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print Error: K componentswhere K is the number of connected components in the graph.</p><p><strong>Sample Input 1:</strong></p><pre><code>51 21 31 42 5</code></pre><p><strong>Sample Output 1:</strong></p><pre><code>345</code></pre><p><strong>Sample Input 2:</strong></p><pre><code>51 31 42 53 4</code></pre><p><strong>Sample Output 2:</strong></p><pre><code>Error: 2 components</code></pre><p><strong>Solution:</strong></p><p>求树的最深度<br>首先求出是否为一个连通块，不是的话，那就直接输出ERROR<br>都使用DFS，求连通块和最深度</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> maxDeep <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span>v<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span>visit<span class="token punctuation">;</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>res<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>    visit<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visit<span class="token punctuation">[</span>v<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">calComponents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> nums <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        visit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>nums<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> deep<span class="token punctuation">)</span><span class="token punctuation">{</span>    visit<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>deep <span class="token operator">></span> maxDeep<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        maxDeep <span class="token operator">=</span> deep<span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>deep <span class="token operator">==</span> maxDeep<span class="token punctuation">)</span>        res<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visit<span class="token punctuation">[</span>v<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> v<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> deep <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>        cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>        v<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        v<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    visit<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nums <span class="token operator">=</span> <span class="token function">calComponents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error: "</span> <span class="token operator">&lt;&lt;</span> nums <span class="token operator">&lt;&lt;</span> <span class="token string">" components"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    visit<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            visit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ptr <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ptr <span class="token operator">!=</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ptr<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树的深度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1020 Tree Traversals</title>
      <link href="/2019/12/05/pat-jia-ji-a1020-tree-traversals/"/>
      <url>/2019/12/05/pat-jia-ji-a1020-tree-traversals/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p><a id="more"></a><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.</p><p><strong>Output Specification:</strong></p><p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><p><strong>Sample Input:</strong></p><pre><code>72 3 1 5 7 6 41 2 3 4 5 6 7</code></pre><p><strong>Sample Output:</strong></p><pre><code>4 1 6 3 5 7 2</code></pre><p><strong>Solution:</strong></p><p>已知后序遍历和中序遍历输出层序遍历<br>这里是使用重构二叉树来求解的<br>当然也可以不用重构二叉树，直接根据数值的数组位置即可</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> Node<span class="token punctuation">{</span>    <span class="token keyword">int</span> v<span class="token punctuation">;</span>    Node <span class="token operator">*</span>l<span class="token punctuation">,</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">v</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">l</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>pos<span class="token punctuation">,</span> in<span class="token punctuation">,</span> level<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>Node<span class="token operator">*</span> <span class="token function">reCreateTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> inL<span class="token punctuation">,</span> <span class="token keyword">int</span> inR<span class="token punctuation">,</span> <span class="token keyword">int</span> posL<span class="token punctuation">,</span> <span class="token keyword">int</span> posR<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inL <span class="token operator">></span> inR<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    Node<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>pos<span class="token punctuation">[</span>posR<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> inL<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> inR<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>in<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pos<span class="token punctuation">[</span>posR<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            k <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    m <span class="token operator">=</span> k <span class="token operator">-</span> inL<span class="token punctuation">;</span>    root<span class="token operator">-</span><span class="token operator">></span>l <span class="token operator">=</span> <span class="token function">reCreateTree</span><span class="token punctuation">(</span>inL<span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> posL<span class="token punctuation">,</span> posL <span class="token operator">+</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token operator">-</span><span class="token operator">></span>r <span class="token operator">=</span> <span class="token function">reCreateTree</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inR<span class="token punctuation">,</span> posL <span class="token operator">+</span> m<span class="token punctuation">,</span> posR <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span>q<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Node<span class="token operator">*</span> p <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        level<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>l <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>r <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    pos<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    in<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        cin <span class="token operator">>></span> pos<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        cin <span class="token operator">>></span> in<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    Node<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token function">reCreateTree</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">levelOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> <span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1019 General Palindromic Numberr</title>
      <link href="/2019/12/05/pat-jia-ji-a1019-general-palindromic-numberr/"/>
      <url>/2019/12/05/pat-jia-ji-a1019-general-palindromic-numberr/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p><a id="more"></a><p>Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N&gt;0 in base b≥2, where it is written in standard notation with k+1 digits a​i​​ as (. Here, as usual, 0 for all i and a​k​​ is non-zero. Then N is palindromic if and only if a​i​​=a​k−i​​ for all i. Zero is written 0 in any base and is also palindromic by definition.</p><p>Given any positive decimal integer N and a base b, you are supposed to tell if N is a palindromic number in base b.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case consists of two positive numbers N and b, where 0 is the decimal number and 2 is the base. The numbers are separated by a space.</p><p><strong>Output Specification:</strong></p><p>For each test case, first print in one line Yes if N is a palindromic number in base b, or No if not. Then in the next line, print N as the number in base b in the form “a​k​​ a​k−1​​ … a​0​​”. Notice that there must be no extra space at the end of output.</p><p><strong>Sample Input 1:</strong></p><pre><code>27 2</code></pre><p><strong>Sample Output 1:</strong></p><pre><code>Yes1 1 0 1 1</code></pre><p><strong>Sample Input 2:</strong></p><pre><code>121 5</code></pre><p><strong>Sample Output 2:</strong></p><pre><code>No4 4 1</code></pre><p><strong>Solution:</strong></p><p>题意：</p><p>根据指定的进制，将给出的数进行转换<br>然后问，是不是回文数字？</p><p>很简单啦，直接使用STL里面的reverse()函数即可</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> B<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span>res<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>N<span class="token operator">%</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        N <span class="token operator">/</span><span class="token operator">=</span> B<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> N <span class="token operator">>></span> B<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>    s1 <span class="token operator">=</span> s2 <span class="token operator">=</span> <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yes"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">else</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"No"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> <span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1018 Public Bike Management</title>
      <link href="/2019/12/05/pat-jia-ji-a1018-public-bike-management/"/>
      <url>/2019/12/05/pat-jia-ji-a1018-public-bike-management/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city.</p><a id="more"></a><p>The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well.</p><p>When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen.</p><p>The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex S is the current number of bikes stored at S. Given that the maximum capacity of each station is 10. To solve the problem at S​3​​, we have 2 different shortest paths:</p><ol><li>PBMC -&gt; S​1​​ -&gt; S​3​​. In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from S​1​​ and then take 5 bikes to S​3​​, so that both stations will be in perfect conditions.</li></ol><ol start="2"><li>PBMC -&gt; S​2​​ -&gt; S​3​​. This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen.</li></ol><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line contains 4 numbers: C​max​​ (≤), always an even number, is the maximum capacity of each station; N (≤), the total number of stations; S​p​​, the index of the problem station (the stations are numbered from 1 to N, and PBMC is represented by the vertex 0); and M, the number of roads. The second line contains N non-negative numbers C​i​​ (,) where each C​i​​ is the current number of bikes at S​i​​ respectively. Then M lines follow, each contains 3 numbers: S​i​​, S​j​​, and T​ij​​ which describe the time T​ij​​ taken to move betwen stations S​i​​ and S​j​​. All the numbers in a line are separated by a space.</p><p><strong>Output Specification:</strong></p><p>For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of S​p​​ is adjusted to perfect.</p><p>Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique.</p><p><strong>Sample Input:</strong></p><pre><code>10 3 3 56 7 00 1 10 2 10 3 31 3 12 3 1</code></pre><p><strong>Sample Output:</strong></p><pre><code>3 0-&gt;2-&gt;3 0</code></pre><p><strong>Solution:</strong></p><p>题意：</p><p>小黄车进行调度，每个站点不够的需要从公司运去，站点太多了的还需要带回去<br>其中路过的站点可以相互调度，但只能从出发点到终点单方向的</p><p>使用Dijkstra和DFS结合</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> theC<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> den<span class="token punctuation">,</span> cap<span class="token punctuation">[</span><span class="token number">505</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">505</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">505</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>father<span class="token punctuation">[</span><span class="token number">505</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Dijstra</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">path</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT32_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token function">visit</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> minD <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visit<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> minD <span class="token operator">></span> path<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                index <span class="token operator">=</span> j<span class="token punctuation">;</span>                minD <span class="token operator">=</span> path<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>        visit<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> u <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>u<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visit<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">></span> path<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    path<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> path<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>                    father<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    father<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> path<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>                    father<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> minNeed <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> minBack <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>temp<span class="token punctuation">,</span> res<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    temp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> need <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> back <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> dis <span class="token operator">=</span> cap<span class="token punctuation">[</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> theC <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dis <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>                back <span class="token operator">+</span><span class="token operator">=</span> dis<span class="token punctuation">;</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>back <span class="token operator">+</span> dis <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//带回去的可以补充缺少的</span>                    back <span class="token operator">+</span><span class="token operator">=</span> dis<span class="token punctuation">;</span>                <span class="token keyword">else</span><span class="token comment" spellcheck="true">//缺太多</span>                <span class="token punctuation">{</span>                    need <span class="token operator">-</span><span class="token operator">=</span> <span class="token punctuation">(</span>back <span class="token operator">+</span> dis<span class="token punctuation">)</span><span class="token punctuation">;</span>                    back <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>need <span class="token operator">&lt;</span> minNeed<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            res <span class="token operator">=</span> temp<span class="token punctuation">;</span>            minNeed <span class="token operator">=</span> need<span class="token punctuation">;</span>            minBack <span class="token operator">=</span> back<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>need <span class="token operator">==</span>minNeed <span class="token operator">&amp;&amp;</span> back <span class="token operator">&lt;</span> minBack<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            minBack <span class="token operator">=</span> back<span class="token punctuation">;</span>            res <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> theC <span class="token operator">>></span> n <span class="token operator">>></span> den <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        cin <span class="token operator">>></span> cap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>        cin <span class="token operator">>></span> a <span class="token operator">>></span> b <span class="token operator">>></span> c<span class="token punctuation">;</span>        v<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token function">Dijstra</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DFS</span><span class="token punctuation">(</span>den<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> minNeed <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> minBack<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1017 Queueing at Bank</title>
      <link href="/2019/12/05/pat-jia-ji-a1017-queueing-at-bank/"/>
      <url>/2019/12/05/pat-jia-ji-a1017-queueing-at-bank/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Suppose a bank has K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour.</p><a id="more"></a><p>Now given the arriving time T and the processing time P of each customer, you are supposed to tell the average waiting time of all the customers.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤) - the total number of customers, and K (≤) - the number of windows. Then N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time.</p><p>Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average.</p><p><strong>Output Specification:</strong></p><p>For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place.</p><p><strong>Sample Input:</strong></p><pre><code>7 307:55:00 1617:00:01 207:59:59 1508:01:00 6008:00:00 3008:00:02 208:03:00 10</code></pre><p><strong>Sample Output:</strong></p><pre><code>8.2</code></pre><p><strong>Solution:</strong></p><p>这道题与前面的排队题是一样的，关键在于时间处理上了</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> k<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span>v<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token function">windows</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> hh<span class="token punctuation">,</span> mm<span class="token punctuation">,</span> ss<span class="token punctuation">,</span> tt<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d:%d:%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mm<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ss<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hh <span class="token operator">*</span> <span class="token number">3600</span> <span class="token operator">+</span> mm <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">+</span> ss <span class="token operator">&lt;</span> <span class="token number">17</span> <span class="token operator">*</span> <span class="token number">3600</span><span class="token punctuation">)</span>            v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>hh <span class="token operator">*</span> <span class="token number">3600</span> <span class="token operator">+</span> mm <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">+</span> ss<span class="token punctuation">,</span> tt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>a<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>first<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> k<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            windows<span class="token punctuation">[</span>i<span class="token operator">%</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">&lt;</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">3600</span> <span class="token operator">?</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">3600</span> <span class="token operator">:</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录的是其结束时间</span>            sum <span class="token operator">+</span><span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">&lt;</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">3600</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token number">3600</span> <span class="token operator">-</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> minTime <span class="token operator">=</span> windows<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>windows<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> minTime<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                minTime <span class="token operator">=</span> windows<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        sum <span class="token operator">+</span><span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">></span> windows<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>windows<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>        windows<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">></span> windows<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">:</span> windows<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录的是其结束时间</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.1f\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>sum <span class="token operator">/</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1016 Phone Bills</title>
      <link href="/2019/12/05/pat-jia-ji-a1016-phone-bills/"/>
      <url>/2019/12/05/pat-jia-ji-a1016-phone-bills/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A long-distance telephone company charges its customers by the following rules:</p><a id="more"></a><p>Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records.</p><p>The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day.</p><p>The next line contains a positive number N (≤), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (mm:dd:hh:mm), and the word on-line or off-line.</p><p>For each test case, all dates will be within a single month. Each on-line record is paired with the chronologically next record for the same customer provided it is an off-linerecord. Any on-line records that are not paired with an off-line record are ignored, as are off-line records not paired with an on-line record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.</p><p><strong>Output Specification:</strong></p><p>For each test case, you must print a phone bill for each customer.</p><p>Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:hh:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.</p><p><strong>Sample Input:</strong></p><pre><code>10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 1010CYLL 01:01:06:01 on-lineCYLL 01:28:16:05 off-lineCYJJ 01:01:07:00 off-lineCYLL 01:01:08:03 off-lineCYJJ 01:01:05:59 on-lineaaa 01:01:01:03 on-lineaaa 01:02:00:01 on-lineCYLL 01:28:15:41 on-lineaaa 01:05:02:24 on-lineaaa 01:04:23:59 off-line</code></pre><p><strong>Sample Output:</strong></p><pre><code>CYJJ 0101:05:59 01:07:00 61 $12.10Total amount: $12.10CYLL 0101:06:01 01:08:03 122 $24.4028:15:41 28:16:05 24 $3.85Total amount: $28.25aaa 0102:00:01 04:23:59 4318 $638.80Total amount: $638.80</code></pre><p><strong>Solution:</strong></p><p>题意：</p><p>就是求一个电话煲的话费单，记得电话的接与挂要匹配上</p><p>然后就是注意时间处理了，处理不好就巨麻烦</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> N<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">calMoney</span><span class="token punctuation">(</span>string str<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> time<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> d<span class="token punctuation">,</span> h<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token keyword">double</span> money <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    d <span class="token operator">=</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> str<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>    h <span class="token operator">=</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> str<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>    m <span class="token operator">=</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> str<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>    money <span class="token operator">+</span><span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> d <span class="token operator">+</span> cost<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">*</span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> h<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        money <span class="token operator">+</span><span class="token operator">=</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span>    time <span class="token operator">=</span> <span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> d <span class="token operator">+</span> h <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">+</span> m<span class="token punctuation">;</span>    <span class="token keyword">return</span> money<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">24</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin <span class="token operator">>></span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        cost<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">,</span>less<span class="token operator">&lt;</span>string<span class="token operator">>></span>data<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//外部用名字排序,名字是用降序排序，内部用时间排序,时间时用默认升序排序</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        string name<span class="token punctuation">,</span> time<span class="token punctuation">,</span> type<span class="token punctuation">;</span>        cin <span class="token operator">>></span> name <span class="token operator">>></span> time <span class="token operator">>></span> type<span class="token punctuation">;</span>        data<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">[</span>time<span class="token punctuation">]</span> <span class="token operator">=</span> type<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ptr <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ptr <span class="token operator">!=</span> data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ptr<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> st <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> et <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        string sl<span class="token punctuation">,</span>el<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> ptr<span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> ptr<span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> ptr<span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">auto</span> pt <span class="token operator">=</span> it<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>it<span class="token operator">-</span><span class="token operator">></span>second <span class="token operator">==</span> <span class="token string">"off-line"</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">--</span>pt<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>second <span class="token operator">==</span> <span class="token string">"on-line"</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    cout <span class="token operator">&lt;&lt;</span> ptr<span class="token operator">-</span><span class="token operator">></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                    f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                s <span class="token operator">=</span> <span class="token function">calMoney</span><span class="token punctuation">(</span>it<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">,</span> et<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">calMoney</span><span class="token punctuation">(</span>pt<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">,</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>                sl<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>pt<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> pt<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                el<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>it<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> it<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cout <span class="token operator">&lt;&lt;</span> sl <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> el <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>et <span class="token operator">-</span> st<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"$%0.2f\n"</span><span class="token punctuation">,</span> s<span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sum <span class="token operator">+</span><span class="token operator">=</span> s<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Total amount: $%0.2f\n"</span><span class="token punctuation">,</span> sum<span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1015 Reversible Prime</title>
      <link href="/2019/12/05/pat-jia-ji-a1015-reversible-prime/"/>
      <url>/2019/12/05/pat-jia-ji-a1015-reversible-prime/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A reversible prime in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.</p><a id="more"></a><p>Now given any two positive integers N (&lt;) and D (1), you are supposed to tell if N is a reversible prime with radix D.</p><p><strong>Input Specification:</strong></p><p>The input file consists of several test cases. Each case occupies a line which contains two integers N and D. The input is finished by a negative N.</p><p><strong>Output Specification:</strong></p><p>For each test case, print in one line Yes if N is a reversible prime with radix D, or No if not.</p><p><strong>Sample Input:</strong></p><pre><code>73 1023 223 10-2</code></pre><p><strong>Sample Output:</strong></p><pre><code>YesYesNo</code></pre><p><strong>Solution:</strong></p><p>题意：</p><p>根据给出的进制将数反转，请问反转后是不是仍然为素数</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> d<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> x <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">*</span>i <span class="token operator">&lt;=</span> x<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">%</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getDeciaml</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> temp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        res <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token operator">*</span>temp<span class="token punctuation">;</span>        temp <span class="token operator">*</span><span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span>string <span class="token function">getString</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span><span class="token keyword">int</span> x <span class="token punctuation">)</span><span class="token punctuation">{</span>    string s <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        s <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> x <span class="token operator">+</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到的是反向的进制数</span>        num <span class="token operator">/</span><span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string str<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin <span class="token operator">>></span> n <span class="token operator">>></span> d<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>        str <span class="token operator">=</span> <span class="token function">getString</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到的就是反转二进制</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPrime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token function">getDeciaml</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yes"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"No"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1014 Waiting in Linee</title>
      <link href="/2019/12/05/pat-jia-ji-a1014-waiting-in-linee/"/>
      <url>/2019/12/05/pat-jia-ji-a1014-waiting-in-linee/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Suppose a bank has N windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are:</p><a id="more"></a><ul><li><p>The space inside the yellow line in front of each window is enough to contain a line with M customers. Hence when all the N lines are full, all the customers after (and including) the (st one will have to wait in a line behind the yellow line.</p></li><li><p>Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number. </p></li><li><p>Customer​i​​ will take T​i​​ minutes to have his/her transaction processed.</p></li><li><p>The first N customers are assumed to be served at 8:00am.</p></li></ul><p>Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done.</p><p>For example, suppose that a bank has 2 windows and each window may have 2 custmers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, customer​1​​ is served at window​1​​while customer​2​​ is served at window​2​​. Customer​3​​ will wait in front of window​1​​ and customer​4​​ will wait in front of window​2​​. Customer​5​​ will wait behind the yellow line.</p><p>At 08:01, customer​1​​ is done and customer​5​​ enters the line in front of window​1​​ since that line seems shorter now. Customer​2​​ will leave at 08:02, customer​4​​ at 08:06, customer​3​​ at 08:07, and finally customer​5​​ at 08:10.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case starts with a line containing 4 positive integers: N (≤, number of windows), M (≤, the maximum capacity of each line inside the yellow line), K (≤, number of customers), and Q (≤, number of customer queries).</p><p>The next line contains K positive integers, which are the processing time of the Kcustomers.</p><p>The last line contains Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K.</p><p><strong>Output Specification:</strong></p><p>For each of the Q customers, print in one line the time at which his/her transaction is finished, in the format HH:MM where HH is in [08, 17] and MM is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output Sorry instead.</p><p><strong>Sample Input:</strong></p><pre><code>2 2 7 51 2 6 4 3 534 23 4 5 6 7</code></pre><p><strong>Sample Output:</strong></p><pre><code>08:0708:0608:1017:00Sorry</code></pre><p><strong>Solution:</strong><br>题的大意：</p><p>N个窗口，每个窗口线内排队M个人，其他人在线外等候<br>哪个窗口有空缺，那么就上那个窗口去排队<br>当有多个窗口空缺，则选择小号排队<br>问每个人从早上8.00到他办完业务的具体时间</p><p>题解：<br>使用队列来代替窗口<br>有个点得注意一下，就是当有个人排队在16：59开始办业务，<br>就算他要办1000分钟的业务，他也是算能办上业务的，不应输出sorry</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> M<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Q<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> N <span class="token operator">>></span> M <span class="token operator">>></span> K <span class="token operator">>></span> Q<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token function">windows</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//N个窗口</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">endTime</span><span class="token punctuation">(</span>K <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token function">Sorry</span><span class="token punctuation">(</span>K <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//若前面那个人的业务办理时间超过下班时间，那么你是排不上的</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> time<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> K<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin <span class="token operator">>></span> a<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> N <span class="token operator">*</span> M<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//先将窗口的位子按序排满，存的是该人完成业务的时间</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>windows<span class="token punctuation">[</span>i<span class="token operator">%</span>N<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                time <span class="token operator">=</span> windows<span class="token punctuation">[</span>i<span class="token operator">%</span>N<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token punctuation">;</span>                windows<span class="token punctuation">[</span>i<span class="token operator">%</span>N<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>                Sorry<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> windows<span class="token punctuation">[</span>i<span class="token operator">%</span>N<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">540</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                time <span class="token operator">=</span> a<span class="token punctuation">;</span>                windows<span class="token punctuation">[</span>i<span class="token operator">%</span>N<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token comment" spellcheck="true">//线外的人选择窗口排队</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> minTime <span class="token operator">=</span> windows<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//找到最先出现空位的窗口，然后去选择该窗口排队</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>minTime <span class="token operator">></span> windows<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    index <span class="token operator">=</span> j<span class="token punctuation">;</span>                    minTime <span class="token operator">=</span> windows<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            Sorry<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> windows<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">540</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            time <span class="token operator">=</span> windows<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token punctuation">;</span>            windows<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//排完对队就离开</span>            windows<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//排队</span>        <span class="token punctuation">}</span>        endTime<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> time<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Q<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin <span class="token operator">>></span> a<span class="token punctuation">;</span>        time <span class="token operator">=</span> endTime<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Sorry<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sorry\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%02d:%02d\n"</span><span class="token punctuation">,</span> <span class="token number">8</span> <span class="token operator">+</span> time <span class="token operator">/</span> <span class="token number">60</span><span class="token punctuation">,</span> time <span class="token operator">%</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1013 Battle Over Cities</title>
      <link href="/2019/12/05/pat-jia-ji-a1013-battle-over-cities/"/>
      <url>/2019/12/05/pat-jia-ji-a1013-battle-over-cities/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.</p><a id="more"></a><p>For example, if we have 3 cities and 2 highways connecting city​1​​-city​2​​ and city​1​​-city​3​​. Then if city​1​​ is occupied by the enemy, we must have 1 highway repaired, that is the highway city​2​​-city​3​​.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case starts with a line containing 3 numbers N (&lt;), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing Knumbers, which represent the cities we concern.</p><p><strong>Output Specification:</strong></p><p>For each of the K cities, output in a line the number of highways need to be repaired if that city is lost.</p><p><strong>Sample Input:</strong></p><pre><code>3 2 31 21 31 2 3</code></pre><p><strong>Sample Output:</strong></p><pre><code>100</code></pre><p><strong>Solution:</strong></p><p>题意：</p><p>城市之间有马路相互连着，请问当一座城市被摧毁时，要想其他城市保持着相互连接，需要加修几条马路</p><p>题解：</p><p>就是一道连通块问题，计算剩下的城市有几个连通块，一个则是相互连着的，n个连通块需要n-1条马路</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> k<span class="token punctuation">,</span> res<span class="token punctuation">;</span><span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">bool</span> visit<span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    visit<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> b <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m <span class="token operator">>></span> k<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>        cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>        v<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> b<span class="token punctuation">;</span>        cin <span class="token operator">>></span> b<span class="token punctuation">;</span>        res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">fill</span><span class="token punctuation">(</span>visit<span class="token punctuation">,</span> visit <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> b<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token operator">++</span>res<span class="token punctuation">;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS,连通块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A10012 The Best Rank</title>
      <link href="/2019/12/05/pat-jia-ji-a1012-the-best-rank/"/>
      <url>/2019/12/05/pat-jia-ji-a1012-the-best-rank/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algrbra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p><a id="more"></a><p>For example, The grades of C, M, E and A - Average of 4 students are given as the following:</p><pre><code>StudentID  C  M  E  A310101     98 85 88 90310102     70 95 88 84310103     82 87 94 88310104     91 91 91 91</code></pre><p>Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (≤), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C, M and E. Then there are M lines, each containing a student ID.</p><p><strong>Output Specification:</strong></p><p>For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.</p><p>The priorities of the ranking methods are ordered as A &gt; C &gt; M &gt; E. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p><p>If a student is not on the grading list, simply output N/A.</p><p><strong>Sample Input:</strong></p><pre><code>5 6310101 98 85 88310102 70 95 88310103 82 87 94310104 91 91 91310105 85 90 90310101310102310103310104310105999999</code></pre><p>Sample Output:</p><pre><code>1 C1 M1 E1 A3 AN/A</code></pre><p><strong>Solution:</strong></p><p>题意：</p><p>就是根据成绩进行排序，输出的排名是选择最好的名次输出<br>记得得分一样的人排名是一样的</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> Node<span class="token punctuation">{</span>    <span class="token keyword">int</span> id<span class="token punctuation">,</span> C<span class="token punctuation">,</span> M<span class="token punctuation">,</span> E<span class="token punctuation">,</span> A<span class="token punctuation">,</span> rankC<span class="token punctuation">,</span> rankM<span class="token punctuation">,</span> rankE<span class="token punctuation">,</span> rankA<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>Node a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> rank<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">.</span>rankA<span class="token punctuation">,</span>a<span class="token punctuation">.</span>rankC<span class="token punctuation">,</span>a<span class="token punctuation">.</span>rankM<span class="token punctuation">,</span>a<span class="token punctuation">.</span>rankE <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">,</span><span class="token string">'M'</span><span class="token punctuation">,</span><span class="token string">'E'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> min <span class="token operator">=</span> rank<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">></span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            min <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> min <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Node<span class="token operator">></span>students<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>Node<span class="token operator">></span>v<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> id<span class="token punctuation">,</span> C<span class="token punctuation">,</span> M<span class="token punctuation">,</span> E<span class="token punctuation">;</span>        cin <span class="token operator">>></span> id <span class="token operator">>></span> C <span class="token operator">>></span> M <span class="token operator">>></span> E<span class="token punctuation">;</span>        v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> C<span class="token punctuation">,</span> M<span class="token punctuation">,</span> E<span class="token punctuation">,</span> C <span class="token operator">+</span> M <span class="token operator">+</span> E<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Node a<span class="token punctuation">,</span> Node b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">.</span>A <span class="token operator">></span> b<span class="token punctuation">.</span>A<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>A <span class="token operator">==</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>A<span class="token punctuation">)</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rankA <span class="token operator">=</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rankA<span class="token punctuation">;</span>        <span class="token keyword">else</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rankA <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Node a<span class="token punctuation">,</span> Node b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">.</span>C <span class="token operator">></span> b<span class="token punctuation">.</span>C<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>C <span class="token operator">==</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>C<span class="token punctuation">)</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rankC <span class="token operator">=</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rankC<span class="token punctuation">;</span>        <span class="token keyword">else</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rankC <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Node a<span class="token punctuation">,</span> Node b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">.</span>M <span class="token operator">></span> b<span class="token punctuation">.</span>M<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>M <span class="token operator">==</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>M<span class="token punctuation">)</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rankM <span class="token operator">=</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rankM<span class="token punctuation">;</span>        <span class="token keyword">else</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rankM <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Node a<span class="token punctuation">,</span> Node b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">.</span>E <span class="token operator">></span> b<span class="token punctuation">.</span>E<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>E <span class="token operator">==</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>E<span class="token punctuation">)</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rankE <span class="token operator">=</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rankE<span class="token punctuation">;</span>        <span class="token keyword">else</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rankE <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> v<span class="token punctuation">)</span>        students<span class="token punctuation">[</span>a<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span>        cin <span class="token operator">>></span> id<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>students<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">!=</span> students<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">print</span><span class="token punctuation">(</span>students<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"N/A"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A10011 World Cup Betting</title>
      <link href="/2019/12/05/pat-jia-ji-a1011-world-cup-betting/"/>
      <url>/2019/12/05/pat-jia-ji-a1011-world-cup-betting/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p><a id="more"></a><p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p><p>For example, 3 games’ odds are given as the following:<br> W    T    L<br>1.1  2.5  1.7<br>1.2  3.1  1.6<br>4.1  1.2  1.1</p><p>To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be ( yuans (accurate up to 2 decimal places).</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.</p><p><strong>Output Specification:</strong></p><p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p><p><strong>Sample Input:</strong></p><pre><code>1.1 2.5 1.71.2 3.1 1.64.1 1.2 1.1</code></pre><p><strong>Sample Output:</strong></p><pre><code>T T W 39.31</code></pre><p><strong>Solution:</strong></p><p>不用多说，就是一个水题，找到最大赔率就行</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> res<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> num<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> w<span class="token punctuation">,</span> t<span class="token punctuation">,</span> l<span class="token punctuation">,</span> maxV<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin <span class="token operator">>></span> w <span class="token operator">>></span> t <span class="token operator">>></span> l<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">>=</span> t<span class="token operator">&amp;&amp;</span> w <span class="token operator">>=</span> l<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'W'</span><span class="token punctuation">;</span>            num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">>=</span> l <span class="token operator">&amp;&amp;</span> t <span class="token operator">>=</span> w<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'T'</span><span class="token punctuation">;</span>            num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'L'</span><span class="token punctuation">;</span>            num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c %c %c %.2f"</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> num<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> num<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">0.65</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A10010 Radix</title>
      <link href="/2019/12/05/pat-jia-ji-a1010-radix/"/>
      <url>/2019/12/05/pat-jia-ji-a1010-radix/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number.</p><a id="more"></a><p>Now for any pair of positive integers N​1​​ and N​2​​, your task is to find the radix of one number while that of the other is given.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case occupies a line which contains 4 positive integers:</p><p>N1 N2 tag radix</p><p>Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a-z } where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2.</p><p><strong>Output Specification:</strong></p><p>For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible. If the solution is not unique, output the smallest possible radix.</p><p><strong>Sample Input 1:</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">6</span> <span class="token number">110</span> <span class="token number">1</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Sample Output 1:</strong></p><pre><code>2</code></pre><p><strong>Sample Input 2:</strong></p><pre><code>1 ab 1 2</code></pre><p><strong>Sample Output 2:</strong></p><pre><code>Impossible</code></pre><p><strong>Solution:</strong></p><p>题意：</p><p>根据给出的数，求出另一个数的满足要求的进制</p><p>题解：</p><p>这题不难，主要是要考虑数据溢出的问题(巨恶心，搞了我半天)<br>记得要使用二分法去寻找匹配的进制（这个一超时就能想起）</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>string n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> k<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据进制计算十进制数值</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">calValue</span><span class="token punctuation">(</span>string x<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token function">atoi</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">+</span><span class="token operator">=</span> k <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">*</span><span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">calRadix</span><span class="token punctuation">(</span>string x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//首先计算x中的最大数值</span>    <span class="token keyword">int</span> maxV <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> x<span class="token punctuation">)</span>        maxV <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxV<span class="token punctuation">,</span> <span class="token function">isalpha</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token string">'a'</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> nV <span class="token operator">=</span> <span class="token function">calValue</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计算n的十进制数</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> L <span class="token operator">=</span> maxV <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R <span class="token operator">=</span> nV <span class="token operator">></span> <span class="token number">36</span> <span class="token operator">?</span> nV <span class="token operator">:</span> <span class="token number">36</span><span class="token punctuation">,</span> mid<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一定得使用二分法</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>L <span class="token operator">&lt;=</span> R<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        mid <span class="token operator">=</span> L <span class="token operator">+</span> <span class="token punctuation">(</span>R <span class="token operator">-</span> L<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> mV <span class="token operator">=</span> <span class="token function">calValue</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nV <span class="token operator">==</span> mV<span class="token punctuation">)</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mV <span class="token operator">></span> nV <span class="token operator">||</span> mV<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//mV&lt;0表示溢出，进制太大了</span>            R <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            L <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m <span class="token operator">>></span> t <span class="token operator">>></span> k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token function">swap</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记住n为已知的进制数</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token function">calRadix</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token operator">></span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1009 Product of Polynomials</title>
      <link href="/2019/12/05/pat-jia-ji-a1009-product-of-polynomials/"/>
      <url>/2019/12/05/pat-jia-ji-a1009-product-of-polynomials/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>This time, you are supposed to find A×B where A and B are two polynomials.</p><a id="more"></a><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p><p>K N​1​​ a​N​1​​​​ N​2​​ a​N​2​​​​ … N​K​​ a​N​K​​​​</p><p>where K is the number of nonzero terms in the polynomial, N​i​​ and a​N​i​​​​ (,) are the exponents and coefficients, respectively. It is given that 1≤K≤10,<br>0≤ N​K​​ &lt;⋯&lt;N​2​​ &lt;N​1​​ ≤1000</p><p><strong>Output Specification:</strong></p><p>For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.</p><p><strong>Sample Input:</strong></p><pre><code>2 1 2.4 0 3.22 2 1.5 1 0.5</code></pre><p><strong>Sample Output:</strong></p><pre><code>3 3 3.6 2 6.0 1 1.6</code></pre><p><strong>Solution:</strong></p><p>题意：</p><p>两个多项式相乘</p><p>题解：</p><p>很简单，同样是使用map映射，然后直接每项相乘就行</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> k<span class="token punctuation">,</span> a<span class="token punctuation">;</span>    <span class="token keyword">double</span> b<span class="token punctuation">;</span>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span>m<span class="token punctuation">,</span> res<span class="token punctuation">;</span>    cin <span class="token operator">>></span> k<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>        m<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cin <span class="token operator">>></span> k<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ptr <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ptr <span class="token operator">!=</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ptr<span class="token punctuation">)</span>            res<span class="token punctuation">[</span>a <span class="token operator">+</span> ptr<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> b <span class="token operator">*</span> ptr<span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ptr <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ptr <span class="token operator">!=</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ptr<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %d %.1f"</span><span class="token punctuation">,</span> ptr<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">,</span> ptr<span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相乘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1008 Elevator</title>
      <link href="/2019/12/05/pat-jia-ji-a1008-elevator/"/>
      <url>/2019/12/05/pat-jia-ji-a1008-elevator/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.</p><a id="more"></a><p>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.</p><p><strong>Output Specification:</strong></p><p>For each test case, print the total time on a single line.</p><p><strong>Sample Input:</strong></p><pre><code>3 2 3 1</code></pre><p><strong>Sample Output:</strong></p><pre><code>41</code></pre><p><strong>Solution:</strong></p><p>直接按照电梯上下来计算时间即可</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> now<span class="token punctuation">,</span>sum <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> N<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上一次停留在哪？现在要去的楼层，时间初始为要在 每一层的总停留时间</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin <span class="token operator">>></span> now<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>now <span class="token operator">-</span> pre<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//上</span>            sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> pre<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>now <span class="token operator">-</span> pre<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//下</span>            sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>pre <span class="token operator">-</span> now<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>        pre <span class="token operator">=</span> now<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更新楼层</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1007 Maximum Subesequence Sum</title>
      <link href="/2019/12/05/pat-jia-ji-a1007-maximum-subesequence-sum/"/>
      <url>/2019/12/05/pat-jia-ji-a1007-maximum-subesequence-sum/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a sequence of K integers { N​1​​, N​2​​, …, N​K​​ }. A continuous subsequence is defined to be { N​i​​, N​i+1​​, …, N​j​​ } where 1. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><a id="more"></a><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤). The second line contains K numbers, separated by a space.</p><p><strong>Output Specification:</strong></p><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><p><strong>Sample Input:</strong></p><pre><code>10-10 1 2 3 4 -5 -23 3 7 -21</code></pre><p><strong>Sample Output:</strong></p><pre><code>10 1 4</code></pre><p><strong>Solution</strong></p><p>题意：</p><p>求解和为最大的子序列</p><p>题解：</p><p>使用滑动窗口思想和双指针思想，首先固定住左指针，滑动右指针，计算之间的累加和，并不断的更新最大累加和，并记录左右指针位置<br>但遇到和为负数，则将左指针移到右指针位置，并继续滑动右指针</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> K<span class="token punctuation">;</span>cin <span class="token operator">>></span> K<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">v</span><span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> K <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//所求的左、右边界，累加和，以及临时的累加和、左边界</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> K<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    temp <span class="token operator">+</span><span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果和小于0，则直接抛弃</span>    <span class="token punctuation">{</span>        temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//选下一个点为新左点</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">></span> sum<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获得更大值</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> temp<span class="token punctuation">;</span>        l <span class="token operator">=</span> index<span class="token punctuation">;</span>        r <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1006 Sign In and Sign Out</title>
      <link href="/2019/12/05/pat-jia-ji-a1006-sign-in-and-sign-out/"/>
      <url>/2019/12/05/pat-jia-ji-a1006-sign-in-and-sign-out/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p><a id="more"></a><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:<br>ID_number Sign_in_time Sign_out_time</p><p>where times are given in the format HH:MM:SS, and ID_number is a string with no more than 15 characters.</p><p><strong>Output Specification:</strong></p><p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p><p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p><p><strong>Sample Input:</strong></p><pre><code>3CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40</code></pre><p><strong>Sample Output:</strong></p><pre><code>SC3021234 CS301133</code></pre><p><strong>Solution:</strong></p><p>题意：根据公司的打卡器，求出谁最早来，谁最晚来<br>直接通过输入即可判断得到最早与最晚</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//很简单，就是找到来的最早的人和回去最晚的人即可</span><span class="token keyword">int</span> <span class="token function">getTime</span><span class="token punctuation">(</span>string Time<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//由于时间时标准输入，所以很好计算</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Time<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Time<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">+</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>Time<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Time<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">+</span>         <span class="token punctuation">(</span>Time<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Time<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> M<span class="token punctuation">;</span>    cin <span class="token operator">>></span> M<span class="token punctuation">;</span>    string firstMan<span class="token punctuation">,</span> lastMan<span class="token punctuation">;</span>    <span class="token keyword">int</span> firstTime<span class="token punctuation">,</span> lastTime<span class="token punctuation">;</span>    firstTime <span class="token operator">=</span> <span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//24小时多一秒，属于第二天了</span>    lastTime <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//属于前一天</span>    string No<span class="token punctuation">,</span> InTime<span class="token punctuation">,</span> OutTime<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin <span class="token operator">>></span> No <span class="token operator">>></span> InTime <span class="token operator">>></span> OutTime<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstTime <span class="token operator">></span> <span class="token function">getTime</span><span class="token punctuation">(</span>InTime<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            firstTime <span class="token operator">=</span> <span class="token function">getTime</span><span class="token punctuation">(</span>InTime<span class="token punctuation">)</span><span class="token punctuation">;</span>            firstMan <span class="token operator">=</span> No<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lastTime <span class="token operator">&lt;</span> <span class="token function">getTime</span><span class="token punctuation">(</span>OutTime<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            lastTime <span class="token operator">=</span> <span class="token function">getTime</span><span class="token punctuation">(</span>OutTime<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastMan <span class="token operator">=</span> No<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> firstMan <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> lastMan <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1005 Spell It Right</title>
      <link href="/2019/12/05/pat-jia-ji-a1005-spell-it-right/"/>
      <url>/2019/12/05/pat-jia-ji-a1005-spell-it-right/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.</p><a id="more"></a><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10^100).</p><p><strong>Output Specification:</strong></p><p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p><p><strong>Sample Input:</strong></p><pre><code>12345</code></pre><p><strong>Sample Output:</strong></p><pre><code>one five</code></pre><p><strong>Solution:</strong></p><p>很简单，就是将给出数的每一位相加，得到和，然后读出这个数即可<br>记得给出的数使用string，不然就超出了范围</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span>words <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"zero"</span><span class="token punctuation">,</span><span class="token string">"one"</span><span class="token punctuation">,</span><span class="token string">"two"</span><span class="token punctuation">,</span><span class="token string">"three"</span><span class="token punctuation">,</span><span class="token string">"four"</span><span class="token punctuation">,</span><span class="token string">"five"</span><span class="token punctuation">,</span><span class="token string">"six"</span><span class="token punctuation">,</span><span class="token string">"seven"</span><span class="token punctuation">,</span><span class="token string">"eight"</span><span class="token punctuation">,</span><span class="token string">"nine"</span><span class="token punctuation">,</span><span class="token string">"ten"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    string num<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不能用数字类型存储，会导致溢出的</span>    cin <span class="token operator">>></span> num<span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> num<span class="token punctuation">)</span>        sum <span class="token operator">+</span><span class="token operator">=</span> a <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> words<span class="token punctuation">[</span>num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> words<span class="token punctuation">[</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数的运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1004 Countion Leaves</title>
      <link href="/2019/12/05/pat-jia-ji-a1004-countion-leaves/"/>
      <url>/2019/12/05/pat-jia-ji-a1004-countion-leaves/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.</p><a id="more"></a><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case starts with a line containing 0, the number of nodes in a tree, and M (&lt;), the number of non-leaf nodes. Then M lines follow, each in the format:<br>ID K ID[1] ID[2] … ID[K]</p><p>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01.</p><p>The input ends with N being 0. That case must NOT be processed.</p><p><strong>Output Specification:</strong></p><p>For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.</p><p>The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output 0 1 in a line.</p><p><strong>Sample Input:</strong></p><pre><code>2 101 1 02</code></pre><p><strong>Sample Output:</strong></p><pre><code>0 1</code></pre><p><strong>Solution:</strong><br>题目意思是：家族成员如同一棵树一样，让你输出每一层【每一代】的叶子节点个数【空节点个数】<br>先使用数组存储信息，然后记录每一层的空节点即可<br>可使用DFS和BFS<br><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> k<span class="token punctuation">,</span> maxL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>nodes<span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">level</span><span class="token punctuation">(</span><span class="token number">105</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">)</span><span class="token punctuation">{</span>    maxL <span class="token operator">=</span> maxL <span class="token operator">></span> L <span class="token operator">?</span> maxL <span class="token operator">:</span> L<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nodes<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">++</span>level<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> nodes<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> L <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>        cin <span class="token operator">>></span> a <span class="token operator">>></span> k<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cin <span class="token operator">>></span> b<span class="token punctuation">;</span>            nodes<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token number">01</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxL<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> <span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树的DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1002 A+B for Polynomials</title>
      <link href="/2019/12/05/pat-jia-ji-a1002-a-b-for-polynomials/"/>
      <url>/2019/12/05/pat-jia-ji-a1002-a-b-for-polynomials/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Each input file contains one test case. </p><a id="more"></a><p><strong>Input Specification:</strong></p><p>Each case occupies 2 lines, and each line contains the information of a polynomial:</p><p>K N​1​​ a​N​1​​​​ N​2​​ a​N​2​​​​ … N​K​​ a​N​K​​​​</p><p>where K is the number of nonzero terms in the polynomial, N​i​​ and a​N​i​​​​ (i=1,2,…,) are the exponents and coefficients, respectively. It is given that<br>1&lt;=K&lt;=10, 0&lt;=Nk&lt;…&lt;N2&lt;N1&lt;=1000.</p><p><strong>Output Specification:</strong></p><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><p><strong>Sample Input:</strong></p><pre><code>2 1 2.4 0 3.22 2 1.5 1 0.5</code></pre><p><strong>Sample Output:</strong></p><pre><code>3 2 1.5 1 2.9 0 3.2</code></pre><p><strong>Solution:</strong><br>这道题意思是，两个带指数形式的多项式相加，求其和的多项式<br>很简单，我们使用map映射每个指数的系数相加和即可<br>但需注意输出格式，指数为0也要输出，系数为则不用</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">//#include &lt;vector></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stack></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    map<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span>greater<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span>data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从大到小排序</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输入两组数据</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> k<span class="token punctuation">;</span>        cin <span class="token operator">>></span> k<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//接受每组数据</span>        <span class="token punctuation">{</span>            <span class="token keyword">double</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>            cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>            data<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> b<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//系数为0则删除</span>                data<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ptr <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ptr <span class="token operator">!=</span> data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ptr<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> ptr<span class="token operator">-</span><span class="token operator">></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.1f"</span><span class="token punctuation">,</span> ptr<span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级——A1001 A+BFormat</title>
      <link href="/2019/12/05/pat-jia-ji-a1001-a-bformat/"/>
      <url>/2019/12/05/pat-jia-ji-a1001-a-bformat/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><a id="more"></a><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case contains a pair of integers a and b where −. The numbers are separated by a space.</p><p><strong>Output Specification:</strong></p><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p><p><strong>Sample Input:</strong></p><pre><code>-1000000 9</code></pre><p><strong>Sample Output:</strong></p><pre><code>-999,991</code></pre><p><strong>Solution:</strong></p><p>转换为字符串string即可</p><p><strong>Code</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>    cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>    string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> len <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">","</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——构造函数替代加减乘除</title>
      <link href="/2019/12/04/suan-fa-gou-zao-han-shu-ti-dai-jia-jian-cheng-chu/"/>
      <url>/2019/12/04/suan-fa-gou-zao-han-shu-ti-dai-jia-jian-cheng-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="如何通过使用构造函数来替代加减乘除"><a href="#如何通过使用构造函数来替代加减乘除" class="headerlink" title="如何通过使用构造函数来替代加减乘除"></a>如何通过使用构造函数来替代加减乘除</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><a id="more"></a><h3 id="1、利用类的构造函数"><a href="#1、利用类的构造函数" class="headerlink" title="1、利用类的构造函数"></a>1、利用类的构造函数</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Temp</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Temp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>N<span class="token punctuation">;</span> sum <span class="token operator">+</span><span class="token operator">=</span> N<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//有类外初始化，这句代码应该可以不用</span>    <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">getRes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> sum<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一定得是静态，否则每次创建是会重新赋值</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> Temp<span class="token operator">::</span>N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//类外初始化</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> Temp<span class="token operator">::</span>sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">Sum_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Temp<span class="token operator">::</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Temp <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token keyword">new</span> Temp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//也可以直接在main函数中</span>        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>t<span class="token punctuation">;</span>        t <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Temp<span class="token operator">::</span><span class="token function">getRes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、利用类的析构"><a href="#2、利用类的析构" class="headerlink" title="2、利用类的析构"></a>2、利用类的析构</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">;</span>A <span class="token operator">*</span>Array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token keyword">public</span> A <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Array<span class="token punctuation">[</span><span class="token operator">!</span><span class="token operator">!</span>n<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">sum</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    A a<span class="token punctuation">;</span>    B b<span class="token punctuation">;</span>    Array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    Array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    <span class="token keyword">return</span> Array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">sum</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、利用函数指针"><a href="#3、利用函数指针" class="headerlink" title="3、利用函数指针"></a>3、利用函数指针</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">Solution3_Teminator</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">Sum_Solution3</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> fun f<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> Solution3_Teminator<span class="token punctuation">,</span> Sum_Solution3 <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> n <span class="token operator">+</span> f<span class="token punctuation">[</span><span class="token operator">!</span><span class="token operator">!</span>n<span class="token punctuation">]</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 利用模板</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token operator">></span> <span class="token keyword">struct</span> Sum_Solution4<span class="token punctuation">{</span>    <span class="token keyword">enum</span> Value <span class="token punctuation">{</span> N <span class="token operator">=</span> Sum_Solution4<span class="token operator">&lt;</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">></span><span class="token operator">::</span>N <span class="token operator">+</span> n <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">struct</span> Sum_Solution4<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">enum</span> Value <span class="token punctuation">{</span> N <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">struct</span> Sum_Solution4<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">enum</span> Value <span class="token punctuation">{</span> N <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——算法中常用的数学</title>
      <link href="/2019/12/04/suan-fa-suan-fa-zhong-chang-yong-de-shu-xue/"/>
      <url>/2019/12/04/suan-fa-suan-fa-zhong-chang-yong-de-shu-xue/</url>
      
        <content type="html"><![CDATA[<h3 id="1、求最大公约数"><a href="#1、求最大公约数" class="headerlink" title="1、求最大公约数"></a>1、求最大公约数</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//a,b不分大小</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token operator">%</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><h3 id="2、最小公倍数"><a href="#2、最小公倍数" class="headerlink" title="2、最小公倍数"></a>2、最小公倍数</h3><pre class="line-numbers language-cpp"><code class="language-cpp">a <span class="token operator">/</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//a,b不分大小</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、判断素数【质数】："><a href="#3、判断素数【质数】：" class="headerlink" title="3、判断素数【质数】："></a>3、判断素数【质数】：</h3><ul><li>常用的判断法则<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">static</span> boolean <span class="token function">isPrime3</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//1,2是素数</span>      <span class="token keyword">return</span> N<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//记得缩小范围</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>最优：【围绕6展开】 <pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">static</span> boolean <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> num <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 不在6的倍数两侧的一定不是质数</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">6</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">%</span> <span class="token number">6</span> <span class="token operator">!=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> sqrt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sqrt<span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> num <span class="token operator">%</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4、建立素数表"><a href="#4、建立素数表" class="headerlink" title="4、建立素数表"></a>4、建立素数表</h3><p>使用埃氏筛选法，它的时间复杂度为O(nloglogn)。<br>“筛法”是众多筛法中最简单且容易理解的一种，即Eratosthenes筛法。更优的欧拉筛法可以达到O(n)的时间复杂度。<br>素数筛法的关键就在一个“筛”字。<br>算法从小到大枚举所有数，对每一个素数，==筛去它的所有倍数==，剩下的就都是素数了。<br>可能有读者问，一开始并不知道哪些数是素数，何来的“对每一个素数”呢？下面来看一个例子：求1~15中的所有素数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">101</span><span class="token punctuation">;</span><span class="token keyword">int</span> prime<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span>，plum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>boolp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>maxn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//2是素数，从2开始筛选</span>        <span class="token punctuation">{</span>            prime<span class="token punctuation">[</span>pNum<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录素数</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span> maxn<span class="token punctuation">;</span>j<span class="token operator">+</span><span class="token operator">=</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//筛去素数的倍数</span>                p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>inti<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span>pNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span>，prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、求解整数的质因子分解"><a href="#5、求解整数的质因子分解" class="headerlink" title="5、求解整数的质因子分解"></a>5、求解整数的质因子分解</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> sqr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//n的根号</span><span class="token comment" spellcheck="true">//枚举根号n以内的质因子</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> pNum <span class="token comment" spellcheck="true">/*素数表的大小*/</span>  <span class="token operator">&amp;&amp;</span> prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> sqr<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果prime[i]是n的因子</span>        fac<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token operator">=</span>prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录该因子</span>        fac<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">.</span>cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">%</span>prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//计算出质因子prime[i]的个数</span>            fac<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">.</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>            n<span class="token operator">/</span><span class="token operator">=</span>prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不同质因子个数加1</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//及时退出循环，节省点时间</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果无法被根号n以内的质因子除尽 比如 n=2*191919191991,后面是个大的素数，我们没必要建立那么大的素数表</span><span class="token punctuation">{</span>    fac<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token operator">=</span>n<span class="token punctuation">;</span>    fac<span class="token punctuation">[</span>num<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cnt<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、计算n-中有多少个质因子P"><a href="#6、计算n-中有多少个质因子P" class="headerlink" title="6、计算n!中有多少个质因子P"></a>6、计算n!中有多少个质因子P</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//计算n！中有多少个质因子p </span><span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n，<span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ans <span class="token operator">+</span><span class="token operator">=</span> n<span class="token operator">/</span>p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//累加n/pk </span>        n<span class="token operator">/</span><span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//相当于分母多乘一个p </span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7、计算组合数："><a href="#7、计算组合数：" class="headerlink" title="7、计算组合数："></a>7、计算组合数：</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//使用简单的暴力法，会导致数据溢出;</span><span class="token comment" spellcheck="true">//使用递归法：</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">,</span><span class="token keyword">long</span> <span class="token keyword">long</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> m<span class="token operator">==</span>n<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token function">C</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">C</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//传统的递归会导致大量的重复计算！</span><span class="token comment" spellcheck="true">//改进：</span><span class="token keyword">const</span> <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">calC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化边界</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>intj<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>res<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递推计算C(i，j)</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//C(i，i-j)=C(i，j)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//先乘再除：</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> n，<span class="token keyword">long</span> <span class="token keyword">long</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> ans<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        ans<span class="token operator">=</span>ans<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">-</span>m<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">/</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意一定要先乘再除</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8、浮点数进行比较大小："><a href="#8、浮点数进行比较大小：" class="headerlink" title="8、浮点数进行比较大小："></a>8、浮点数进行比较大小：</h3><p>由于浮点数的精度问题，我们不能简单的使用==进行比较<br>应该使用精度来比较</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> eps = 1e-8</span><span class="token comment" spellcheck="true">//相等：</span>    <span class="token macro property">#<span class="token directive keyword">define</span> Equ(a,b)    ((abs((a)-(b)))&lt;(eps))</span><span class="token comment" spellcheck="true">//此处的括号一定不能省！！！这样可以保证式子也成立</span><span class="token comment" spellcheck="true">//大于：</span>    <span class="token macro property">#<span class="token directive keyword">define</span> More(a,b)    (((a)-(b))>(eps))</span><span class="token comment" spellcheck="true">//此处的括号一定不能省！！！这样可以保证式子也成立</span><span class="token comment" spellcheck="true">//小于：</span>    <span class="token macro property">#<span class="token directive keyword">define</span> Less(a,b)    (((a)-(b))&lt;(-eps))</span><span class="token comment" spellcheck="true">//此处的括号一定不能省！！！这样可以保证式子也成立</span><span class="token comment" spellcheck="true">//大于等于：</span>    <span class="token macro property">#<span class="token directive keyword">define</span> MoreEqu(a,b)    (((a)-(b))>(-eps))</span><span class="token comment" spellcheck="true">//此处的括号一定不能省！！！这样可以保证式子也成立</span><span class="token comment" spellcheck="true">//小于等于：</span>    <span class="token macro property">#<span class="token directive keyword">define</span> LessEqu(a,b)    (((a)-(b))&lt;(eps))</span><span class="token comment" spellcheck="true">//此处的括号一定不能省！！！这样可以保证式子也成立</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学函数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
