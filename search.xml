<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>读书笔记——《图解HTTP》（四）</title>
      <link href="/2020/04/15/du-shu-bi-ji-tu-jie-http-si/"/>
      <url>/2020/04/15/du-shu-bi-ji-tu-jie-http-si/</url>
      
        <content type="html"><![CDATA[<h2 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h2><h3 id="为何认证："><a href="#为何认证：" class="headerlink" title="为何认证："></a>为何认证：</h3><pre><code>计算机本身无法判断坐在显示器前的使用者的身份、进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务器，就得让对方的客户端自报家门。可是，就算正在访问服务器的对方声称自己是ueno，身份是否属实这点却也无从谈起。为确认ueno本人是否真的具有访问系统的权限，就需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”。   </code></pre><ul><li><p>核对的信息通常是指以下这些。 </p><ul><li>密码：只有本人才会知道的字符串信息。   </li><li>动态令牌：仅限本人持有的设备内显示的一次性密码。   </li><li>数字证书：仅限本人（终端）持有的信息。</li><li>生物认证：指纹和虹膜等本人的生理信息。       </li><li>IC卡等：仅限本人持有的信息。  </li></ul></li><li><p>HTTP使用的认证方式<br>  HTTP/1.1使用的认证方式如下所示。  </p><ul><li>BASIC 认证（基本认证）  </li><li>DIGEST认证（摘要认证）  </li><li>SSL客户端认证  </li><li>FormBase认证（基于表单认证）<br>此外，还有Windows统一认证（Keberos认证、NTLM认证）。  </li></ul></li></ul><h3 id="BASIC认证："><a href="#BASIC认证：" class="headerlink" title="BASIC认证："></a>BASIC认证：</h3><pre><code>BASIC认证（基本认证）是从HTTP/1.0就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是Web服务器与通信客户端之间进行的认证方式。</code></pre><p>认证步骤：</p><ol><li><p>步骤1：<br> 当请求的资源需要BASIC认证时，服务器会随状态码401 Authorization Required，返回带     WWW-Authenticate首部字段的响应。该字段内包含认证的方式（BASIC）及Request-URI 安全域字符串（realm）。</p></li><li><p>步骤2：<br> 接收到状态码401的客户端为了通过BASIC认证，需要将用户ID及密码发送给服务器。发送的字符串内容是由用户ID和密码构成，两者中间以冒号(:)连接后，再经过Base64编码处理。把这串字符串写入首部字段Authorization后，发送请求。<br> 当用户代理为浏览器时，用户仅需输入用户ID和密码即可，之后，浏览器会自动完成到Base64编码的转换工作。</p></li><li><p>步骤3：<br> 接收到包含首部字段Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含Request-URI资源的响应。</p><p> BASIC认证虽然采用Base64编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户ID和密码，在HTTP等非加密通信的线路上进行BASIC认证的过程中，如果被人窃听，被盗的可能性极高。<br> 另外，除此之外想再进行一次BASIC认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一BASIC认证使用上不够便捷灵活，且达不到多数Web网站期望的安全性等级，因此它并不常用。     </p></li></ol><h3 id="DIGEST认证"><a href="#DIGEST认证" class="headerlink" title="DIGEST认证"></a>DIGEST认证</h3><pre><code>为弥补BASIC认证存在的弱点，从HTTP/1.1起就有了DIGEST认证。DIGEST认证同样使用质询/响应的方式（challenge/response），但不会像BASIC认证那样直接发送明文密码。      所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。        </code></pre><p>认证步骤：  </p><ol><li><p>步骤1：<br> 请求需认证的资源时，服务器会随着状态码401 Authorization Required，返回带WWW-Authenticate首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）。首部字段wWW-Authenticate内必须包含realm和nonce这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。<br> nonce是一种每次随返回的401响应生成的任意随机字符串。该字符串通常推荐由Base64编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现。      </p></li><li><p>步骤2：<br> 接收到401状态码的客户端，返回的响应中包含DIGEST认证必须的首部字段Authorization信息。首部字段Authorization内必须包含username、 realm、 nonce、 uri和response的字段信息。其中，realm和nonce就是之前从服务器接收到的响应中的字段。username是realm限定范围内可进行认证的用户名。uri （digest-uri） 即Request-URI的值，但考虑到经代理转发后Request-URI的值可能被修改，因此事先会复制一份副本保存在uri内。response也可叫做Request-Digest，存放经过MD5运算后的密码字符串，形成响应码。响应中其他的实体请参见第6章的请求首部字段Authorization。</p></li><li><p>步骤3：<br> 接收到包含首部字段Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则返回包含Request-URI资源的响应。并且这时会在首部字段Authentication-Info写入一些认证成功的相关信息。DIGEST认证提供了高于BASIC认证的安全等级，但是和HTTPS的客户端认证相比仍旧很弱。DIGEST认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。DIGEST认证和BASIC认证一样，使用上不那么便捷灵活，且仍达不到多数Web网站对高度安全等级的追求标准。因此它的适用范围也有所受限。    </p></li></ol><h3 id="SSL客户端认证"><a href="#SSL客户端认证" class="headerlink" title="SSL客户端认证"></a>SSL客户端认证</h3><pre><code>从使用用户ID和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果用户ID和密码被盗，就很有可能被第三者冒充。利用SSL客户端认证则可以避免该情况的发生。       SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。为达到SSL客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。     </code></pre><ol><li>步骤1：<br> 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。 </li><li>步骤2：<br> 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate 报文方式发送给服务器。 </li><li>步骤3：<br> 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信。  </li></ol><h3 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h3><pre><code>基于表单的认证方法并不是在HTTP协议中定义的。客户端会向服务器上的Web应用程序发送登录信息（Credential），按登录信息的验证结果认证。根据Web应用程序的实际安装，提供的用户界面及认证方式也各不相同。     </code></pre><ul><li><p>认证多半为基于表单认证<br>  由于使用上的便利性及安全性问题，HTTP协议标准提供的BASIC认证和DIGEST认证几乎不怎么使用。另外，SL客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。</p></li><li><p>Session 管理及Cookie应用<br>  基于表单认证的标准规范尚未有定论，一般会使用Cookie来管理Session（会话）。基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。但鉴于HTTP是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用Cookie来管理Session,以弥补HTTP协议中不存在的状态管理功能。</p></li></ul><ol><li>步骤1：<br> 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。</li><li>步骤2：<br> 服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。<br> 向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID（如PHPSESSID=028a8c…）。你可以把Session ID想象成一种用以区分不同用户的等位号。然而，如果Session ID被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止Session ID被盗，或被猜出。为了做到这点，Session ID应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。<br> 另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上htponly属性。</li><li>步骤3：<br>客户端接收到从服务器端发来的SessionID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以SessionID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。   </li></ol><h2 id="第九章-基于HTTP的功能追加协议"><a href="#第九章-基于HTTP的功能追加协议" class="headerlink" title="第九章 基于HTTP的功能追加协议"></a>第九章 基于HTTP的功能追加协议</h2><h3 id="消除HTTP瓶颈的SPDY"><a href="#消除HTTP瓶颈的SPDY" class="headerlink" title="消除HTTP瓶颈的SPDY"></a>消除HTTP瓶颈的SPDY</h3><pre><code>Google在2010年发布了SPDY（取自SPeeDY，发音同speedy），其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）。</code></pre><ul><li><p>HTTP的瓶颈<br>  在Facebook和Twitter等SNS网站上，几乎能够实时观察到海量用户公开发布的内容，这也是一种乐趣。当几百、几千万的用户发布内容时，Web网站为了保存这些新增内容，在很短的时间内就会发生大量的内容更新。为了尽可能实时地显示这些更新的内容，服务器上一有内容更新，就需要直接把那些内容反馈到客户端的界面上。虽然看起来挺简单的，但HTTP却无法妥善地处理好这项任务。<br>  使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。若想在现有web实现所需的功能，以下这些HTTP标准就会成为瓶颈。      </p><ul><li>一条连接上只可发送一个请求。  </li><li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。     </li><li>请求/响应首部未经压缩就发送。首部信息越多延迟越大。   </li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。       </li><li>可任意选择数据压缩格式。非强制压缩发送。   </li></ul></li><li><p>SPDY的设计与功能<br>  SPDY没有完全改写HITP协议，而是在TCP/ IP的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。<br>  SPDY以会话层的形式加人，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。<br>  <img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415151718425-740453936.png" alt=""></p></li></ul><p>使用SPDY后，HTTP协议额外获得以下功能：  </p><ul><li><p>多路复用流<br>通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。</p></li><li><p>赋予请求优先级<br>SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</p></li><li><p>压缩HTTP首部<br>压缩HTTP请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。</p></li><li><p>推送功能<br>支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p></li><li><p>服务器提示功能<br>服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</p></li></ul><h3 id="使用浏览器进行全双工通信的WebSocket"><a href="#使用浏览器进行全双工通信的WebSocket" class="headerlink" title="使用浏览器进行全双工通信的WebSocket"></a>使用浏览器进行全双工通信的WebSocket</h3><p>利用Ajax和Comet技术进行通信可以提升web的浏览速度。但问题在于通信若使用HTTP协议，就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及API。   </p><ul><li><p>*WebSocket的设计与功能<br>WebSocket，即web浏览器与web服务器之间全双工通信标准。其中，WebSocket协议由IETF定为标准，WebSocketAPI由W3C定为标准。仍在开发中的技术主要是为了解决Ajax和Comet里XMLHttpRequest附带的缺陷所引起的问题。</p></li><li><p>WebSocket协议<br>一旦web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p></li></ul><p>下面我们列举一下WebSocket协议的主要特点。</p><ul><li><p>推送功能<br>支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p></li><li><p>减少通信量<br>只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。</p></li></ul><p>为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次“握手”（Handshaking）的步骤。</p><h3 id="期盼已久的HTTP-2-0"><a href="#期盼已久的HTTP-2-0" class="headerlink" title="期盼已久的HTTP/2.0"></a>期盼已久的HTTP/2.0</h3><p>目前主流的HTTP/1.1标准，自1999年发布的RFC2616之后再未进行过改订。SPDY和WebSocket等技术纷纷出现，很难断言HTTP/1.1仍是适用于当下的Web的协议。</p><p>负责互联网技术标准的IETF（Internet Engineering Task Force，互联网工程任务组）创立httpbis工作组，其目标是推进下一代HTTP——HTTP/2.0在2014年11月实现标准化。</p><ul><li><p>HTTP/2.0的特点<br>HTTP/2.0的目标是改善用户在使用Web时的速度体验。由于基本上都会先通过HTTP/1.1与TCP连接，现在我们以下面的这些协议为基础，探讨一下它们的实现方法。</p><ul><li>SPDY</li><li>HTTP Speed+Mobility</li><li>Network-Friendly HTTP Upgrade</li></ul></li></ul><p>http2.0技术讨论：<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415151940900-59375749.png" alt=""></p><h2 id="第十章-构建Web内容的技术"><a href="#第十章-构建Web内容的技术" class="headerlink" title="第十章 构建Web内容的技术"></a>第十章 构建Web内容的技术</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML（HyperText Markup Language，超文本标记语言）是为了发送Web上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在HTML文档内的这种特殊字符串叫做HTML标签（Tag）。  </p><h3 id="设计应用CSS"><a href="#设计应用CSS" class="headerlink" title="设计应用CSS"></a>设计应用CSS</h3><p>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现HTML内的各种元素，属于样式表标准之一。即使是相同的HTML文档，通过改变应用的CSS，用浏览器看到的页面外观也会随之改变。CSS的理念就是让文档的结构和设计分离，达到解耦的目的。</p><h3 id="动态HTML"><a href="#动态HTML" class="headerlink" title="动态HTML"></a>动态HTML</h3><p>所谓动态HTML（Dynamic HTML），是指使用客户端脚本语言将静态的HTML内容变成动态的技术的总称。鼠标单击点开的新闻、Google Maps等可滚动的地图就用到了动态HTML。</p><p>动态HTML技术是通过调用客户端脚本语言JavaScript，实现对HTML的Web页面的动态改造。利用DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的HTML元素。</p><h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><p>Web应用是指通过Web功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和e-learning等。互联网（Internet）或企业内网（Intranet）上遍布各式各样的Web应用。</p><p>原本应用HTTP协议的Web的机制就是对客户端发来的请求，返回事前准备好的内容。可随着Web越来越普及，仅靠这样的做法已不足以应对所有的需求，更需要引入由程序创建HTML内容的做法。类似这种由程序创建的内容称为动态内容，而事先准备好的内容称为静态内容。Web应用则作用于动态内容之上。</p><h3 id="数据发布的格式及语言"><a href="#数据发布的格式及语言" class="headerlink" title="数据发布的格式及语言"></a>数据发布的格式及语言</h3><p>XML（extensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用XML，使互联网数据共享变得更容易。<br>XML和HTML都是从标准通用标记语言SGML（Standard Generalized Markup Language）简化而成。与HTML相比，它对数据的记录方式做了特殊处理。</p><h2 id="第十一章-Web的攻击技术"><a href="#第十一章-Web的攻击技术" class="headerlink" title="第十一章 Web的攻击技术"></a>第十一章 Web的攻击技术</h2><h3 id="针对Web的攻击技术"><a href="#针对Web的攻击技术" class="headerlink" title="针对Web的攻击技术"></a>针对Web的攻击技术</h3><p>简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等资源才是攻击且标。目前，来自互联网的攻击大多是冲着Web站点来的，它们大多把Web应用作为攻击目标。</p><ul><li><p>*以服务器为目标的主动攻击<br>主动攻击（active attack）是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击。</p></li><li><p>以服务器为目标的被动攻击<br>被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标Web应用访问发起攻击。<br>被动攻击通常的攻击模式如下所示。</p></li></ul><ul><li>步骤1：攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的HTTP请求。  </li><li>步骤2：当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。   </li><li>步骤3：中招后的用户浏览器会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击代码。  </li><li>步骤4：执行完攻击代码，存在安全漏洞的Web应用会成为攻击者的跳板，可能导致用户所持的Cookie等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。   </li></ul><p>被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</p><h3 id="因输出值转义不完全引发的安全漏洞"><a href="#因输出值转义不完全引发的安全漏洞" class="headerlink" title="因输出值转义不完全引发的安全漏洞"></a>因输出值转义不完全引发的安全漏洞</h3><p>实施Web应用的安全对策可大致分为以下两部分。  </p><ul><li>客户端的验证  </li><li>Web应用端（服务器端）的验证   <ul><li>输入值验证   </li><li>输出值转义   </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《图解HTTP》（三）</title>
      <link href="/2020/04/15/du-shu-bi-ji-tu-jie-http-san/"/>
      <url>/2020/04/15/du-shu-bi-ji-tu-jie-http-san/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h2><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143112867-1087293884.png" alt=""></p><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143120863-947712630.png" alt=""></p><h3 id="HTTP首部字段类型"><a href="#HTTP首部字段类型" class="headerlink" title="HTTP首部字段类型"></a>HTTP首部字段类型</h3><ul><li>通用首部字段（General Header Fields）<br>  请求报文和响应报文两方都会使用的首部。   </li><li>请求首部字段（Request Header Fields）<br>  从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。   </li><li>响应首部字段（Response Header Fields）<br>  从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。   </li><li>实体首部字段（Entity Header Fields）<br>  针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。   </li></ul><h3 id="HTTP-1-1通用首部字段"><a href="#HTTP-1-1通用首部字段" class="headerlink" title="HTTP/1.1通用首部字段"></a>HTTP/1.1通用首部字段</h3><ul><li><p>Cache-Control<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143305662-1773928462.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143334645-713960820.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143343440-114223268.png" alt=""></p></li><li><p>public表示其他用户也可利用缓存   </p></li><li><p>private表示响应只以特定的用户作为对象 </p></li></ul><h3 id="no-cache指令："><a href="#no-cache指令：" class="headerlink" title="no-cache指令："></a>no-cache指令：</h3><pre><code>使用no-cache指令的目的是为了防止从缓存中返回过期的资源。客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</code></pre><h3 id="HTTP1-1警告码："><a href="#HTTP1-1警告码：" class="headerlink" title="HTTP1.1警告码："></a>HTTP1.1警告码：</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143438442-1432162543.png" alt=""><br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415143443501-283778518.png" alt=""></p><h3 id="请求首部字段："><a href="#请求首部字段：" class="headerlink" title="请求首部字段："></a>请求首部字段：</h3><pre><code>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</code></pre><ul><li><p>文本文件<br>  text/htm1，text/plain，text/css…<br>  application/xhtml+xml,application/xml…   </p></li><li><p>图片文件<br>  image/jpeg,image/gif,image/png…   </p></li><li><p>视频文件<br>  video/mpeg，video/quicktime….    </p></li><li><p>应用程序使用的二进制文件<br>  application/octet-stream,application/zip…   </p></li><li><p>gzip<br>  由文件压缩程序gzip（GNUzip）生成的编码格式（RFC1952），采用Lempel-Ziv算法（LZ77）及32位循环冗余校验（Cyclic Redundancy Check，通称CRC）。  </p></li><li><p>compress<br>  由UNIX文件压缩程序compress生成的编码格式，采用Lempel-Ziv-Welch算法（LZW）。    </p></li><li><p>deflate<br>  组合使用zlib格式（RFC1950）及由deflate压缩算法（RFC1951）生成的编码格式。         </p></li><li><p>identity<br>  不执行压缩或不会变化的默认编码格式    </p><p>  采用权重q值来表示相对优先级、这点与首部字段Accept相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。 </p></li></ul><h3 id="响应首部字段："><a href="#响应首部字段：" class="headerlink" title="响应首部字段："></a>响应首部字段：</h3><pre><code>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。     </code></pre><h3 id="实体首部字段："><a href="#实体首部字段：" class="headerlink" title="实体首部字段："></a>实体首部字段：</h3><pre><code>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</code></pre><h3 id="为Cookies服务的首部字段："><a href="#为Cookies服务的首部字段：" class="headerlink" title="为Cookies服务的首部字段："></a>为Cookies服务的首部字段：</h3><pre><code>管理服务器与客户端之间状态的Cookie，虽然没有被编入标准化HTTP/1.1的RFC2616中，但在Web网站方面得到了广泛的应用。   Cookie的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该      Web网站时，可通过通信方式取回之前发放的Cookie。调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露。   至2013年5月，Cookie的规格标准文档有以下4种。     </code></pre><ul><li>由网景公司颁布的规格标准<br>  网景通信公司设计并开发了Cookie，并制定相关的规格标准。1994年前后，Cookie正式应用在网景浏览器中。目前最为普及的Cookie方式也是以此为基准的。  </li><li>RFC2109<br>  某企业尝试以独立技术对Cookie规格进行标准化统筹。原本的意图是想和网景公司制定的标准交互应用，可惜发生了微妙的差异。现在该标准已淡出了人们的视线。           </li><li>RFC2965<br>  为终结Internet Explorer 浏览器与Netscape Navigator的标准差异而导致的浏览器战争，RFC2965内定义了新的HTTP首部Set-Cookie2和Cookie2。可事实上，它们几乎没怎么投入使用。       </li><li>RFC6265<br>  将网景公司制定的标准作为业界事实标准（De facto standard），重新定义Cookie标准后的产物。</li></ul><h3 id="其他首部字段："><a href="#其他首部字段：" class="headerlink" title="其他首部字段："></a>其他首部字段：</h3><p>X-Frame-Options:<br>    DENY：属于HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题。主要为了防止点击劫持攻击。 </p><ul><li>DENY：拒绝     </li><li>SAMEORIGIN：仅同源域名下的页面匹配时许可。      </li></ul><p>X-XSS-Protection：<br>    属于响应首部，用于控制浏览器XSS防护机制的开关。  </p><ul><li>0：将XSS过滤设置成无效状态    </li><li>1：将XSS过滤设置成有效状态     </li></ul><p>DNT：<br>    请求首部，Do Not Track，拒绝个人信息被收集，是表示拒绝被精确广告追踪的一种方法。<br>    0：同意<br>    1：拒绝    </p><p>P3P（在线隐私偏好平台）：<br>    响应首部，可以让Web网站上的个人隐私编程一种仅供程序可理解的形式，以达到保护用户隐私的作用。    </p><ul><li>创建P3P隐私  </li><li>保存在/w3c/p3p.xml   </li><li>从P3P隐私中新建Compact policies后，输出到HTTP响应中。     </li></ul><h2 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h2><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><p>HTTP主要有这些不足，例举如下。    </p><ul><li><p>通信使用明文（不加密），内容可能会被窃听  </p></li><li><p>不验证通信方的身份，因此有可能遭遇伪装   </p></li><li><p>无法证明报文的完整性，所以有可能已遭篡改      </p></li><li><p>TCP/IP是可能被窃听的网络<br>  如果要问为什么通信时不加密是一个缺点，这是因为，按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。<br>  所谓互联网，是由能连通到全世界的网络组成的。无论世界哪个角落的服务器在和客户端通信时，在此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节中会遭到恶意窥视行为。 </p></li><li><p>通信的加密<br>  一种方式就是将通信加密。HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容。<br>  用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL。     </p></li><li><p>内容的加密<br>  还有一种将参与通信的内容本身加密的方式。由于HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。在这种情况下，客户端需要对HTTP报文进行加密处理后再发送请求。<br>  由于该方式不同于SSL或TES将整个通信线路加密处理，所以内容仍有被篡改的风险。稍后我们会加以说明。        </p></li><li><p>任何人都可以发起请求<br>  HTTP协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。     </p><ul><li>无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器。  </li><li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。   </li><li>无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。  </li><li>无法判定请求是来自何方、出自谁手。  </li><li>即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击）。     </li></ul></li></ul><h3 id="SSL中的数字证书："><a href="#SSL中的数字证书：" class="headerlink" title="SSL中的数字证书："></a>SSL中的数字证书：</h3><pre><code>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外、伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。另外，客户端持有证书即可完成个人身份的确认，也可用于对Web网站的认证环节。    由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。   换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。      </code></pre><h3 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS = HTTP + 加密 + 认证 + 完整性保护"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h3><ul><li><p>HTTPS是身披SSL(TLS)外壳的HTTP<br>  通常HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415144719450-1082315715.png" alt=""></p><p>  SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术。</p></li><li><p>使用两把密钥的公开密钥加密<br>  公开密钥加密方式很好地解决了共享密钥加密的困难。<br>  公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。<br>  另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。</p></li><li><p>HTTPS采用混合加密机制<br>  HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势，将多种方法组合起来用于通信。<br>  在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p></li><li><p>HTTPS中的数字证书：<br>  为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。<br>  数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。    </p><ul><li>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。    </li><li>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。   </li><li>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。<br>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。<br>数字证书认证机构的私有密钥  </li></ul><ul><li>服务器把自己的公开密钥登录至数字证书认证机构   </li><li>数字证书认证机构用自己的私有密钥向服务器的公开密码署数字签名并颁发公钥证书   </li><li>数字证书认证机构的公开密钥已事先植入到浏览器里了。客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性。   </li><li>使用服务器的公开密钥对报文加密后发送   </li><li>服务器用私有密钥对报文解密 </li></ul></li><li><p>可证明组织真实性的EV SSL证书<br>  证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是EVSSL证书（Extended Validation SSL Certificate）。<br>  EVSSL证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的Web网站能够获得更高的认可度。<br>  持有EVSSL证书的Web网站的浏览器地址栏处的背景色是绿色的，从视觉上就能一眼辨别出。而且在地址栏的左侧显示了SSL证书中记录的组织名称以及颁发证书的认证机构的名称。  </p></li></ul><h3 id="HTTPS安全通信机制："><a href="#HTTPS安全通信机制：" class="headerlink" title="HTTPS安全通信机制："></a>HTTPS安全通信机制：</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415150519883-141471649.png" alt=""></p><ol><li>步骤1：客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li><li>步骤2：服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>步骤3：之后服务器发送Certificate报文。报文中包含公开密钥证书。</li><li>步骤4：最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。</li><li>步骤5：SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。</li><li>步骤6：接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。</li><li>步骤7：客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li><li>步骤8：服务器同样发送Change Cipher Spec报文。</li><li>步骤9：服务器同样发送Finished报文。</li><li>步骤10：服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。</li><li>步骤11：应用层协议通信，即发送HTTP响应。</li><li>步骤12：最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCPFIN报文来关闭与TCP的通信。</li></ol><h3 id="SSL和TLS："><a href="#SSL和TLS：" class="headerlink" title="SSL和TLS："></a>SSL和TLS：</h3><pre><code>HTTPS使用SSL（Secure Socket Layer）和TLS（Transport Layer Security）这两个协议。  SSL技术最初是由浏览器开发商网景通信公司率先倡导的，开发过SSL3.0之前的版本。目前主导权已转移到IETF（Internet Engineering Task Force，Internet工程任务组）的手中。IETF以SSL3.0为基准，后又制定了TLS1.0、TLS1.1和TLS1.2。  TSL是以SSL为原型开发的协议，有时会统一称该协议为SSL。当前主流的版本是SSL3.0和TLS1.0。由于SSL1.0协议在设计之初被发现出了问题，就没有实际投入使用。SSL2.0也被发现存在问题，所以很多浏览器直接废除了该协议版本。  </code></pre><h3 id="SSL速度慢吗"><a href="#SSL速度慢吗" class="headerlink" title="SSL速度慢吗"></a>SSL速度慢吗</h3><pre><code>HTTPS也存在一些问题，那就是当使用SSL时，它的处理速度会变慢。  由于HTTPS还需要做服务器、客户端双方加密及解密处理，因此会消耗CPU和内存等硬件资源。和HTTP通信相比，SSL通信部分消耗网络资源。而SSL通信部分，又因为要对通信进行处理，所以时间上又延长了。HTTPS比HTTP要慢2到100倍。   SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU及内存等资源，导致处理速度变慢。和使用HTTP相比，网络负载可能会变慢2到100倍。除去和TCP连接、发送HTTP请求+响应以外，还必须进行SSL通信，因此整体上处理通信量不可避免会增加。  另一点是SSL必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起HTTP会更多地消耗服务器和客户端的硬件资源，导致负载增强。  针对速度变慢这一问题，并没有根本性的解决方案，我们会使用SSL加速器这种（专用服务器）硬件来改善该问题。该硬件为SSL通信专用硬件，相对软件来讲，能够提高数倍SSL的计算速度。仅在SSL处理时发挥SSL加速器的功效，以分担负载。   </code></pre><p>解决方法：  </p><ul><li>不全都用HTTPS<br>  如果是非敏感信息则使用HTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS加密通信。</li><li>通信内容部分加密<br>  在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《图解HTTP》（二）</title>
      <link href="/2020/04/15/du-shu-bi-ji-tu-jie-http-er/"/>
      <url>/2020/04/15/du-shu-bi-ji-tu-jie-http-er/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-HTTP报文内的HTTP信息"><a href="#第三章-HTTP报文内的HTTP信息" class="headerlink" title="第三章 HTTP报文内的HTTP信息"></a>第三章 HTTP报文内的HTTP信息</h2><p>HTTP报文：<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415135639051-562443235.png" alt=""></p><p>请求报文和响应报文首部内容由以下几部分组成。           </p><ul><li>请求行：包含用于请求的方法、请求 URI 和 HTTP 版本        </li><li>状态行：包含表明响应结果的状态码、原因短语和 HTTP 版本        </li><li>首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部：通用首部、请求首部、响应首部和实体首部。    </li></ul><h3 id="编码提升传输效率："><a href="#编码提升传输效率：" class="headerlink" title="编码提升传输效率："></a>编码提升传输效率：</h3><ul><li>报文主体和实体主体的区别</li></ul><p>HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p><ul><li>压缩传输的内容编码</li></ul><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。<br>常用的内容编码有以下几种：gzip(GNU zip)、compress(UNIX 系统的标准压缩)、deflate(zlib) 和 identity(不进行压缩)</p><ul><li>分割发送的分块传输编码</li></ul><p>分块传输编码会将实体主体分为多个部分。使用分块传输编码的实体主体会由接收的客户端负责界面，恢复到编码前的实体主体。</p><h3 id="内容协商："><a href="#内容协商：" class="headerlink" title="内容协商："></a>内容协商：</h3><ul><li><p>服务器驱动协商（Server-driven Negotiation）<br>由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。</p></li><li><p>客户端驱动协商（Agent-driven Negotiation）<br>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。</p></li><li><p>透明协商（Transparent Negotiation）<br>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</p></li></ul><h2 id="第四章-返回结果的HTTP状态码"><a href="#第四章-返回结果的HTTP状态码" class="headerlink" title="第四章 返回结果的HTTP状态码"></a>第四章 返回结果的HTTP状态码</h2><h3 id="状态码返回告知："><a href="#状态码返回告知：" class="headerlink" title="状态码返回告知："></a>状态码返回告知：</h3><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415135650140-517015800.png" alt=""></p><ul><li><p>2XX 成功<br>200 OK  客户端发送的请求在服务端正常处理<br>204 No Content  服务端成功处理请求，但没有资源返回<br>206 Partial Content 客户端进行了范围请求，而服务器成功执行    </p></li><li><p>3XX 重定向<br>301 Moved Permanently   永久性重定向<br>302 Found   临时性重定向<br>303 See Other   由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。<br>304 Not Modified    客户端请求的资源找到，但未符合条件的请求<br>307 Temporary Redirect  临时重定向，与302不同的是不会从POST变成GET<br>当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。<br>301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做。     </p></li><li><p>4XX 客户端错误<br>400 Bad Request 客户端请求报文出错<br>401 Unauthorized    客户端的请求需要HTTP认证<br>403 Forbidden   请求资源被拒绝访问<br>404 Not Found   访问的资源不存在     </p></li><li><p>5XX 服务器错误<br>500 Internal Server Error   服务器在执行请求时发生错误<br>503 Service Unavailable 服务器无法访问     </p></li></ul><h2 id="第五章-与HTTP协作"><a href="#第五章-与HTTP协作" class="headerlink" title="第五章 与HTTP协作"></a>第五章 与HTTP协作</h2><h3 id="用单台虚拟主机实现多个域名："><a href="#用单台虚拟主机实现多个域名：" class="headerlink" title="用单台虚拟主机实现多个域名："></a>用单台虚拟主机实现多个域名：</h3><p>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。即使在物理层面只有一台服务器，但只要利用虚拟主机的功能，则可以假想已具有多台服务器。</p><p>在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发生 HTTP 请求时，必须在 Host 首部内完整指定主机或域名的 URI。</p><h3 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h3><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p><p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p><ul><li><p>缓存代理<br>代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</p></li><li><p>透明代理<br>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。</p></li></ul><h3 id="网关："><a href="#网关：" class="headerlink" title="网关："></a>网关：</h3><p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。</p><p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p><h3 id="隧道："><a href="#隧道：" class="headerlink" title="隧道："></a>隧道：</h3><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</p><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</p><p>隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p><h3 id="保存资源的缓存："><a href="#保存资源的缓存：" class="headerlink" title="保存资源的缓存："></a>保存资源的缓存：</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p><p>缓存服务器是代理服务器的一种，并归类在缓存代理类型中。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本在代理服务器上。</p><ul><li>缓存的有效期限<br>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</li></ul><p>缓存的有效期限：即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题。<br>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器会再次从源服务器上获取”新”资源。</p><ul><li>客户端的缓存<br>缓存不仅可以存在于缓存服务器内，也可以存在客户端浏览器中。浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。</li></ul><p>另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《图解HTTP》（一）</title>
      <link href="/2020/04/15/du-shu-bi-ji-tu-jie-http-yi/"/>
      <url>/2020/04/15/du-shu-bi-ji-tu-jie-http-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-了解Web及网络基础"><a href="#第一章-了解Web及网络基础" class="headerlink" title="第一章 了解Web及网络基础"></a>第一章 了解Web及网络基础</h2><h3 id="http的诞生："><a href="#http的诞生：" class="headerlink" title="http的诞生："></a>http的诞生：</h3><ul><li>http0.9为1990年问世，由于没有正式标准建立，从而成为http1.0的前身，为http0.9</li><li>http1.0为1996年正式发布，为最初的标准协议。</li><li>http1.1为1997年正式发布，为目前最主流的协议版本。</li><li>http2.0正在制定中。。。</li></ul><h3 id="TCP-IP："><a href="#TCP-IP：" class="headerlink" title="TCP/IP："></a>TCP/IP：</h3><p>分为4层：应用层、传输层、网络层、数据链路层。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131038348-1877806121.png" alt=""></p><p>每一层必须打上上一层的首部。</p><h3 id="URI："><a href="#URI：" class="headerlink" title="URI："></a>URI：</h3><p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。<br>绝对URI格式：<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131511968-1204698359.png" alt=""></p><ol><li><p>使用http：<br>或https：等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号：。也可使用data：或javascript：这类指定数据或脚本程序的方案名。 </p></li><li><p>登录信息（认证）<br>指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</p></li><li><p>服务器地址<br>使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的Pv6地址名。</p></li><li><p>服务器端口<br>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。带层次的文件路径。指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p></li><li><p>带层次的文件路径<br>指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似。</p></li><li><p>查询字符串<br>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</p></li><li><p>片段标识符<br>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项。</p></li></ol><h2 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h2><p>查看网页header部分：<br>F12后进入开发者模式，然后选中All,然后F5刷新网页，在name中随便打开一个，就可以打开其相关的Headers信息了。</p><p>HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。现在使用Cookie技术来达到一个处理状态的。</p><h3 id="GET：获取资源"><a href="#GET：获取资源" class="headerlink" title="GET：获取资源"></a>GET：获取资源</h3><p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGl（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131534612-2146907352.png" alt=""></p><h3 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h3><p>POST方法用来传输实体的主体。虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131551408-24285555.png" alt=""></p><h3 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h3><p>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST （REpresentational State Transfer，表征状态转移）标准的同类Web网站，就可能会开放使用PUT方法。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131618502-930083218.png" alt=""></p><h3 id="HEAD：获得报文首部"><a href="#HEAD：获得报文首部" class="headerlink" title="HEAD：获得报文首部"></a>HEAD：获得报文首部</h3><p>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131636235-887066925.png" alt=""></p><h3 id="DELETE：删除文件"><a href="#DELETE：删除文件" class="headerlink" title="DELETE：删除文件"></a>DELETE：删除文件</h3><p>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131648573-1336804768.png" alt=""></p><h3 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h3><p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131719681-671783301.png" alt=""></p><h3 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h3><p>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。<br>发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200OK的响应。<br>客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。<br>但是，TRACE方法本来就不怎么常用，再加上它容易引发XST<br>（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131835697-42751909.png" alt=""></p><h3 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h3><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<br>CONNECT方法的格式如下所示。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131912889-1239429781.png" alt=""></p><p><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131918318-1673449996.png" alt=""></p><h3 id="持久连接："><a href="#持久连接：" class="headerlink" title="持久连接："></a>持久连接：</h3><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一TCP连接。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131925966-392111315.png" alt=""></p><h4 id="持久连接：-1"><a href="#持久连接：-1" class="headerlink" title="持久连接："></a>持久连接：</h4><p>为解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive或HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。<br>在HTTP/1.1中，所有的连接默认都是持久连接，但在HTTP/1.0内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131945115-1106583189.png" alt=""></p><h4 id="管线化："><a href="#管线化：" class="headerlink" title="管线化："></a>管线化：</h4><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。<br>从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。<br>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。<br><img src="https://img2020.cnblogs.com/blog/1463063/202004/1463063-20200415131955435-1090784576.png" alt=""></p><h3 id="使用Cookie："><a href="#使用Cookie：" class="headerlink" title="使用Cookie："></a>使用Cookie：</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。<br>假设要求登录认证的Web页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。<br>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。<br>Cookie会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。<br>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《More Effective C++》</title>
      <link href="/2020/01/01/du-shu-bi-ji-more-effective-c/"/>
      <url>/2020/01/01/du-shu-bi-ji-more-effective-c/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础议题-Basics"><a href="#一、基础议题-Basics" class="headerlink" title="一、基础议题(Basics)"></a>一、基础议题(Basics)</h2><h3 id="1、仔细区别-pointers【指针】-和-references"><a href="#1、仔细区别-pointers【指针】-和-references" class="headerlink" title="1、仔细区别 pointers【指针】 和 references"></a>1、仔细区别 pointers【指针】 和 references</h3><p>二者之间的区别是：在任何情况下都不能用指向空值的引用，而指针则可以；指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变</p><p>在以下情况下使用指针：一是存在不指向任何对象的可能性；二是需要能够在不同的时刻指向不同的对象</p><p>在以下情况使用引用：总是指向一个对象且一旦指向一个对象之后就不会改变指向；重载某个操作符时，使用指针会造成语义误解</p><h3 id="2、最好使用-C-转型操作符"><a href="#2、最好使用-C-转型操作符" class="headerlink" title="2、最好使用 C++ 转型操作符"></a>2、最好使用 C++ 转型操作符</h3><p>为解决 C 旧式转型的缺点（允许将任何类型转为任何类型，且难以辨识），C++ 导入 4 个新的转型操作符（cast operators）：</p><p>static_cast , const_cast , dynamic_cast , reinterpret_cast：分别是常规类型转换，去常量转换，继承转换，函数指针转换</p><p>static_cast：功能上基本上与C风格的类型转换一样强大，含义也一样但是不能把struct转换成int类型或者把double类型转换成指针类型另外，它不<br>能从表达式中去除const属性。用来针对一个继承体系做向下的安全转换，目标类型必须为指针或者引用。基类中要有虚函数，否则会编译出错；static_cast则没有这个限制。原因是：存在虚函数，说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。必须保证源类型跟目标类型本来就是一致的，否则返回 null 指针。这个函数使用的是RTTI机制，所以编译器必须打开这个选项才能编译。</p><p>const_cast：用于类型转换掉表达式的const或volatileness属性但是不能用它来完成修改这两个属性之外的事情</p><p>dynamic_cast：用于安全地沿着类的继承关系向下类型转换失败的转换将返回空指针或者抛出异常</p><p>reinterpret_cast：这个操作符被用于的类型转换的转换结果时实现时定义因此，使用它的代码很难移植最普通的用途就是在函数指针之间进行转换</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//想要使用 dynamic_cast ，基类中必须有虚函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//i == 3</span><span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pj <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//int *pj = (int*)(&amp;j);     //等同于上面</span>    <span class="token operator">*</span>pj <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//虽然 *pj的地址和 j 的地址是一样的，但是值却不一样。</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>pj<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//20</span>    cout<span class="token operator">&lt;&lt;</span>j<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//10</span>B <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>D<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FunPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>FunPtr<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fun<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//尽量避免使用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、绝对不要以多态方式处理数组"><a href="#3、绝对不要以多态方式处理数组" class="headerlink" title="3、绝对不要以多态方式处理数组"></a>3、绝对不要以多态方式处理数组</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"base print()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> B<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"derived print()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果没有此句，执行将正确，因为基类对象和子类对象长度相同  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> B array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B barray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span>barray<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D darray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span>darray<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>array[i] 其实是一个指针算术表达式的简写，它代表的其实是 *(array+i)，array是一个指向数组起始处的指针。在 for 里遍历 array 时，必须要知道每个元素之间相差多少内存，而编译器则根据传入参数来计算得知为 sizeof(B)，而如果传入的是派生类数组对象，它依然认为是 sizeof(B)，除非正好派生类大小正好与基类相同，否则运行时会出现错误。但是如果我们设计软件的时候，不要让具体类继承具体类的话，就不太可能犯这种错误。（理由是，一个类的父类一般都会是一个抽象类，抽象类不存在数组） </p><h3 id="4、避免无用的-default-constructors"><a href="#4、避免无用的-default-constructors" class="headerlink" title="4、避免无用的 default constructors"></a>4、避免无用的 default constructors</h3><p>没有缺省构造函数造成的问题：通常不可能建立对象数组，对于使用非堆数组，可以在定义时提供必要的参数。另一种方法是使用指针数组，但是必须删除数组里的每个指针指向的对象，而且还增加了内存分配量。</p><p>提供无意义的缺省构造函数会影响类的工作效率，成员函数必须测试所有的部分是否都被正确的初始化。</p><h2 id="二、操作符-Operators"><a href="#二、操作符-Operators" class="headerlink" title="二、操作符(Operators)"></a>二、操作符(Operators)</h2><h3 id="5、对定制的“类型转换函数”保持警觉"><a href="#5、对定制的“类型转换函数”保持警觉" class="headerlink" title="5、对定制的“类型转换函数”保持警觉"></a>5、对定制的“类型转换函数”保持警觉</h3><p>定义类似功能的函数，而抛弃隐式类型转换，使得类型转换必须显示调用。例如 String类没有定义对Char*的隐式转换，而是用c_str函数来实施这个转换。拥有单个参数（或除第一个参数外都有默认值的多参数）构造函数的类，很容易被隐式类型转换，最好加上 explicit 防止隐式类型转换。</p><h3 id="6、区别-increment-decrement-操作符的前置和后置形式"><a href="#6、区别-increment-decrement-操作符的前置和后置形式" class="headerlink" title="6、区别 increment/decrement 操作符的前置和后置形式"></a>6、区别 increment/decrement 操作符的前置和后置形式</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>id <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//返回值为 const ，以避免 a++++这种形式</span>        <span class="token comment" spellcheck="true">//因为第二个 operator++ 所改变的对象是第一个 operator++ 返回的对象</span>        <span class="token comment" spellcheck="true">//最终结果其实也只是累加了一次，a++++ 也还是相当于 a++，这是违反直觉的</span>        <span class="token keyword">const</span> A <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            A a <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>id <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">++</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//++++a;   也是允许的，但 a++++ 不允许。</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">++</span><span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span>id<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后置operator++(int) 的叠加是不允许的，原因有两个：一是与内建类型行为不一致（内建类型支持前置叠加)；二是其效果跟调用一次 operator++(int) 效果一样，这是违反直觉的。另外，后置式操作符使用 operator++(int)，参数的唯一目的只是为了区别前置式和后置式而已，当函数被调用时，编译器传递一个0作为int参数的值传递给该函数。<br>处置用户定制类型时，尽可能使用前置式，因为后置式会产生一个临时对象。</p><h3 id="7、千万不要重载-amp-amp-和-操作符"><a href="#7、千万不要重载-amp-amp-和-操作符" class="headerlink" title="7、千万不要重载 &amp;&amp;, || 和 , 操作符"></a>7、千万不要重载 &amp;&amp;, || 和 , 操作符</h3><pre><code>int *pi = NULL;if(pi != 0 &amp;&amp; cout&lt;&lt;*pi&lt;&lt;endl) { }</code></pre><p>上面的代码不会报错，虽然 pi 是空指针，但 &amp;&amp; 符号采用”骤死式”评估方式，如果 pi == 0 的话，不会执行后面的语句。</p><p>不要重载这些操作符，是因为我们无法控制表达式的求解优先级，不能真正模仿这些运算符。操作符重载的目的是使程序更容易阅读，书写和理解，而不是来迷惑其他人。如果没有一个好理由重载操作符，就不要重载。而对于&amp;&amp;，||和“，”，很难找到一个好理由。 </p><h3 id="8、了解各种不同意义的-new-和-delete"><a href="#8、了解各种不同意义的-new-和-delete" class="headerlink" title="8、了解各种不同意义的 new 和 delete"></a>8、了解各种不同意义的 new 和 delete</h3><p>new 操作符的执行过程：</p><ol><li>调用operator new分配内存 ；//这一步可以使用 operator new 或 placement new 重载。</li><li>调用构造函数生成类对象；</li><li>返回相应指针。</li></ol><p>函数 operator new 通常声明如下： </p><p>void * operator new(size_t size);　　//第一个参数必须为 size_t，表示需要分配多少内存。</p><p>返回值为void型指针，表示这个指针指向的内存中的数据的类型要由用户来指定。比如内存分配函数malloc函数返回的指针就是void *型，用户在使用这个指针的时候，要进行强制类型转换，如（int *)malloc(1024)。任何类型的指针都可以直接赋给 void * 变量，而不必强制转换。如果函数的参数可以为任意类型的指针，则可以声明为 void * 了。 </p><p>void 有两个地方可以使用，第一是函数返回值，第二是作为无参函数的参数。（因为在C语言中，可以给无参函数传任意类型的参数，而且C语言中，没有指定函数返回值时，默认返回为 int 值）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"size: "</span><span class="token operator">&lt;&lt;</span>size<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span>std<span class="token operator">::</span>string str<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"size: "</span><span class="token operator">&lt;&lt;</span>size <span class="token operator">&lt;&lt;</span><span class="token string">"\nname: "</span> <span class="token operator">&lt;&lt;</span> str<span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    User<span class="token operator">*</span> user1 <span class="token operator">=</span> <span class="token keyword">new</span> User<span class="token punctuation">;</span>    User<span class="token operator">*</span> user2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token string">"JIM"</span><span class="token punctuation">)</span>User<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>    pi <span class="token operator">=</span> p<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>pi<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、异常-Exceptions"><a href="#三、异常-Exceptions" class="headerlink" title="三、异常(Exceptions)"></a>三、异常(Exceptions)</h2><h3 id="9、利用-destructors-避免泄漏资源"><a href="#9、利用-destructors-避免泄漏资源" class="headerlink" title="9、利用 destructors 避免泄漏资源"></a>9、利用 destructors 避免泄漏资源</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">void</span> <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>pi<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">try</span>    <span class="token punctuation">{</span>        <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果此处抛出异常而未处理，则无法执行 delete 语句，造成内存泄漏。</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>        <span class="token keyword">throw</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">delete</span> pi<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 一个函数在堆里申请内存到释放内存的过程中，如果发生异常，如果自己不处理而只交给调用程序处理，则可能由于未调用 delete 导致内存泄漏。上面的方法可以解决这一问题，不过这样的代码使人看起来心烦且难于维护，而且必须写双份的 delete 语句。函数返回时局部对象总是释放（调用其析构函数），无论函数是如何退出的。（仅有的一种例外是当调用 longjmp 时，而 longjmp 这个缺点也是C++最初支持异常处理的原因）</p><p>所以这里使用智能指针或类似于智能指针的对象是比较好的办法：</p><ul><li>auto_ptr; — 基本被弃用.</li><li>shared_ptr; — 共享指针, 引用计数为零就销毁对象空间.</li><li>weak_ptr; — weak_ptr是用来解决shared_ptr相互引用时的死锁问题. 弱引用不会增加引用计数.</li><li>unique_ptr; — unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权.<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">void</span> <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ap</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用 auto_ptr 包装一下</span>  std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>pi<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token function">exception_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>上面的代码看起来简洁多了，因为 auto_ptr 会在离开作用域时调用其析构函数，析构函数中会做 delete 动作。  </p><h3 id="10、在-constructors-内阻止资源泄漏"><a href="#10、在-constructors-内阻止资源泄漏" class="headerlink" title="10、在 constructors 内阻止资源泄漏"></a>10、在 constructors 内阻止资源泄漏</h3><p>这一条讲得其实是捕获构造函数里的异常的重要性。</p><p><strong>堆栈辗转开解（stack-unwinding）：</strong>如果一个函数中出现异常，在函数内即通过 try..catch 捕捉的话，可以继续往下执行；如果不捕捉就会抛出（或通过 throw 显式抛出）到外层函数，则当前函数会终止运行，释放当前函数内的局部对象（局部对象的析构函数就自然被调用了），外层函数如果也没有捕捉到的话，会再次抛出到更外层的函数，该外层函数也会退出，释放其局部对象……如此一直循环下去，直到找到匹配的 catch 子句，如果找到 main 函数中仍找不到，则退出程序。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> userid_<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> username_ <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string address_ <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token function">userid</span><span class="token punctuation">(</span>userid_<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">username</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            username <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>username_<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//构造函数里抛出异常的话，由于对象没有构造完成，不会执行析构函数</span>            address <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>address_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//此例中不会执行,会导致内存泄漏</span>        <span class="token punctuation">{</span>            <span class="token keyword">delete</span> username<span class="token punctuation">;</span>            <span class="token keyword">delete</span> address<span class="token punctuation">;</span>            std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~B()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> userid<span class="token punctuation">;</span>        std<span class="token operator">::</span>string<span class="token operator">*</span> username<span class="token punctuation">;</span>        std<span class="token operator">::</span>string<span class="token operator">*</span> address<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>runtime_error<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> C++拒绝为没有完成构造函数的对象调用析构函数，原因是避免开销，因为只有在每个对象里加一些字节来记录构造函数执行了多少步，它会使对象变大，且减慢析构函数的运行速度。</p><p>一般建议不要在构造函数里做过多的资源分配，而应该把这些操作放在一个类似于 init 的成员函数中去完成。这样当 init 成员函数抛出异常时，如果对象是在栈上，析构函数仍会被调用(异常会自动销毁局部对象，调用局部对象的析构函数，见下面)，如果是在堆上，需要在捕获异常之后 delete 对象来调用析构函数。</p><h3 id="11、禁止异常流出-destructors-之外"><a href="#11、禁止异常流出-destructors-之外" class="headerlink" title="11、禁止异常流出 destructors 之外"></a>11、禁止异常流出 destructors 之外</h3><p>这一条讲得其实是捕获析构函数里的异常的重要性。第一是防止程序调用 terminate 终止（这里有个名词叫：堆栈辗转开解 stack-unwinding）；第二是析构函数内如果发生异常，则异常后面的代码将不执行，无法确保我们完成我们想做的清理工作。</p><p>之前我们知道，析构函数被调用，会发生在对象被删除时，如栈对象超出作用域或堆对象被显式 delete (还有继承体系中，virtual 基类析构函数会在子类对象析构时调用)。除此之外，在异常传递的堆栈辗转开解（stack-unwinding）过程中，异常处理系统也会删除局部对象，从而调用局部对象的析构函数，而此时如果该析构函数也抛出异常，C++程序是无法同时处理两个异常的，就会调用 terminate()终止程序(会立即终止，连局部对象也不释放)。另外，如果异常被抛出，析构函数可能未执行完毕，导致一些清理工作不能完成。</p><p>所以不建议在析构函数中抛出异常，如果异常不可避免，则应在析构函数内捕获，而不应当抛出。 场景再现如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> T<span class="token punctuation">{</span>    <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"T()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">"init() throw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~T() begin"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">"~T() throw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> pi<span class="token punctuation">;</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"~T() end"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pi<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        T t<span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下面也会引发 terminate</span>    <span class="token comment" spellcheck="true">/*    try    {        int *p2 = new int[1000000000000L];    }catch(std::bad_alloc&amp;)    {        std::cout&lt;&lt;"bad_alloc"&lt;&lt;std::endl;    }    */</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">terminate_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"my terminate_handler()"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">set_terminate</span><span class="token punctuation">(</span>terminate_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12、了解-“抛出一个-exception-”-与-“传递一个参数”-或-“调用一个虚函数”之间的差异"><a href="#12、了解-“抛出一个-exception-”-与-“传递一个参数”-或-“调用一个虚函数”之间的差异" class="headerlink" title="12、了解 “抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异"></a>12、了解 “抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异</h3><p>抛出异常对象，到 catch 中，有点类似函数调用，但是它有几点特殊性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>        <span class="token keyword">throw</span> pi<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pi指向的对象是静态的，所以才能抛出指针</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果抛出的是 int 对象的异常，是不能用 double 类型接收的，这一点跟普通函数传参不一样。异常处理中，支持的类型转换只有两种，一种是上面例子中演示的从”有型指针”转为”无型指针”，所以用 const void* 可以捕捉任何指针类型的 exception。另一种是继承体系中的类转换，可见下一条款的例子。<br>另外，它跟虚拟函数有什么不同呢？异常处理可以出现多个 catch 子句，而匹配方式是按先后顺序来匹配的（所以如 exception 异常一定要写在 runtime_error异常的后面，如果反过来的话，runtime_error异常语句永远不会执行），而虚函数则是根据虚函数表来的。</p><h3 id="13、以-by-reference-方式捕捉-exceptions"><a href="#13、以-by-reference-方式捕捉-exceptions" class="headerlink" title="13、以 by reference 方式捕捉 exceptions"></a>13、以 by reference 方式捕捉 exceptions</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>id <span class="token operator">=</span> b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里是静态对象</span>    <span class="token keyword">throw</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//只有该对象是静态对象或全局对象时，才能以指针形式抛出</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">try</span><span class="token punctuation">{</span>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>B<span class="token operator">*</span> b<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//这里以指针形式接收</span> <span class="token punctuation">{</span>     std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>b<span class="token operator">-</span><span class="token operator">></span>id<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出3</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用指针方式来捕捉异常，上面的例子效率很高，没有产生临时对象。但是这种方式只能运用于全局或静态的对象（如果是 new 出来的堆中的对象也可以，但是该何时释放呢？）身上，否则的话由于对象离开作用域被销毁，catch中的指针指向不复存在的对象。接下来看看对象方式和指针方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"print():B"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"D copy"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"print():D"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    D d<span class="token punctuation">;</span>    <span class="token keyword">throw</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>B b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//注意这里</span>    <span class="token punctuation">{</span>        b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子会输出：</p><p>可是如果把 catch(B b) 改成 catch(B&amp; b) 的话，则会输出：</p><p>该条款的目的就是告诉我们，请尽量使用引用方式来捕捉异常，它可以避免 new 对象的删除问题，也可以正确处理继承关系的多态问题，还可以减少异常对象的复制次数。 </p><h3 id="14、明智运用-exception-specifications"><a href="#14、明智运用-exception-specifications" class="headerlink" title="14、明智运用 exception specifications"></a>14、明智运用 exception specifications</h3><p>C++提供了一种异常规范，即在函数后面指定要抛出的异常类型，可以指定多个：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//必须这样声明，而不能是 void fun(void);</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//说明可能抛出 int 和 double 异常</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>d<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="15、了解异常处理的成本"><a href="#15、了解异常处理的成本" class="headerlink" title="15、了解异常处理的成本"></a>15、了解异常处理的成本</h3><p>大致的意思是，异常的开销还是比较大的，只有在确实需要用它的地方才去用。</p><h2 id="四、效率-Efficiency"><a href="#四、效率-Efficiency" class="headerlink" title="四、效率(Efficiency)"></a>四、效率(Efficiency)</h2><h3 id="16、谨记-80-20-法则"><a href="#16、谨记-80-20-法则" class="headerlink" title="16、谨记 80-20 法则"></a>16、谨记 80-20 法则</h3><p>大致的意思是说，程序中80%的性能压力可能会集中在20%左右的代码处。那怎么找出这20%的代码来进行优化呢？可以通过Profiler分析程序等工具来测试，而不要凭感觉或经验来判断。</p><h3 id="17、考虑使用-lazy-evaluation（缓式评估）"><a href="#17、考虑使用-lazy-evaluation（缓式评估）" class="headerlink" title="17、考虑使用 lazy evaluation（缓式评估）"></a>17、考虑使用 lazy evaluation（缓式评估）</h3><p>懒惰计算法的含义是拖延计算的时间，等到需要时才进行计算其作用为：能避免不需要的对象拷贝，通过使用operator[]区分出读写操作，避免不需要的数据库读取操作，避免不需要的数字操作但是，如果计算都是重要的，懒惰计算法可能会减慢速度并增加内存的使用</p><h3 id="18、分期摊还预期的计算成本"><a href="#18、分期摊还预期的计算成本" class="headerlink" title="18、分期摊还预期的计算成本"></a>18、分期摊还预期的计算成本</h3><ul><li><p>over-eager evaluation, 如果程序常常用到某个计算, 设计一份数据结构以便能够及有效率地处理需求</p></li><li><p>(caching)利用告诉缓存暂存使用频率高的内容.</p></li><li><p>caching是分期摊还预期计算成本的一种做法. 预先取出是另一种做法. ◦系统调用往往比进程内的函数调用慢.</p></li><li><p>较快的速度往往导致较大的内存, 空间交换时间.</p></li><li><p>较大对象比较不容易塞入虚内存分页(virtual memory page)或缓存分页(cache page). ◦对象变大可能会降低性能, 因为换页活动会增加,<br>缓存命中率(cache hit rate)会降低. </p></li></ul><h3 id="19、了解临时对象的来源"><a href="#19、了解临时对象的来源" class="headerlink" title="19、了解临时对象的来源"></a>19、了解临时对象的来源</h3><p>C++真正所谓的临时对象是不可见的——只要产生一个 non-heap object 而没有为它命名，就产生了一个临时对象。它一般产生于两个地方：</p><p>一是函数参数的隐式类型转换，</p><p>二是函数返回对象时。 </p><p>任何时候，只要你看到一个 reference-to-const参数，就极可能会有一个临时对象被产生出来绑定至该参数上；任何时候，只要你看到函数返回一个对象，就会产生临时对象（并于稍后销毁）。</p><h3 id="20、协助完成“返回值优化-RVO-”"><a href="#20、协助完成“返回值优化-RVO-”" class="headerlink" title="20、协助完成“返回值优化(RVO)”"></a>20、协助完成“返回值优化(RVO)”</h3><p>不要在一个函数里返回一个局部对象的地址，因为它离开函数体后就析构了。不过在GCC下可以正常运行，无论是否打开优化；而在VS2010中如果关闭优化，就会看到效果。</p><p>这个条款想说的是：const Test fun(){ return Test(); } 比 const Test fun(){Test test; return test; }  好，更能使编译器进行优化。<br>不过现在看来，在经过编译器优化之后，这两个好像已经没有什么区别了。</p><h3 id="21、利用重载技术避免隐式类型转换"><a href="#21、利用重载技术避免隐式类型转换" class="headerlink" title="21、利用重载技术避免隐式类型转换"></a>21、利用重载技术避免隐式类型转换</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b1<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>id <span class="token operator">+</span> b2<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//const B operator+(const B&amp; b1,int i)    //如果重载此方法，就不会产生临时对象了</span><span class="token comment" spellcheck="true">//{</span><span class="token comment" spellcheck="true">//  return B(b1.id + i);</span><span class="token comment" spellcheck="true">//}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    B b3 <span class="token operator">=</span> b1<span class="token operator">+</span> b2<span class="token punctuation">;</span>    B b4 <span class="token operator">=</span> b1 <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//会把 6 先转换成B对象，产生临时对象</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="22、考虑以操作符复合形式-op-取代其独身形式-op"><a href="#22、考虑以操作符复合形式-op-取代其独身形式-op" class="headerlink" title="22、考虑以操作符复合形式(op=)取代其独身形式(op)"></a>22、考虑以操作符复合形式(op=)取代其独身形式(op)</h3><p>使用 operator+= 的实现来实现 operator= ，其它如果 operator*=、operator-= 等类似。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        B<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            id <span class="token operator">+</span><span class="token operator">=</span>  b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>id<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b1<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不用声明为 B 的 friend 函数,而且只需要维护 operator+= 即可。</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>B<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token operator">=</span> b2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里要去掉b1的const属性，才能带入operator+= 中的 this 中</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b3</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>b1<span class="token operator">+</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10    这里进行 operator+ 操作，会改变 b1 的值，这个不应该吧</span>    b1<span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//10</span>    b3<span class="token operator">+</span><span class="token operator">=</span>b1<span class="token punctuation">;</span>    b3<span class="token punctuation">.</span><span class="token function">print_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//110</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="23、考虑使用其它程序库"><a href="#23、考虑使用其它程序库" class="headerlink" title="23、考虑使用其它程序库"></a>23、考虑使用其它程序库</h3><p>提供类似功能的程序库，可能在效率、扩充性、移植性和类型安全方面有着不同的表现。比如说 iostream 和 stdio 库，所以选用不同的库可能会大幅改善程序性能。</p><h3 id="24、了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification-的成本"><a href="#24、了解-virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification-的成本" class="headerlink" title="24、了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本"></a>24、了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本</h3><p>在使用虚函数时，大部分编译器会使用所谓的 virtual tables 和 virtual table pointers ，通常简写为 vtbls 和 vptrs 。vtbl 通常是由 “函数指针” 架构而成的数组，每一个声明（或继承）虚函数的类都有一个 vtbl ，而其中的条目就是该 class 的各个虚函数实现体的指针。<br>虚函数的第一个成本：必须为每个拥有虚函数的类耗费一个 vtbl 空间，其大小视虚函数的个数（包括继承而来的）而定。不过，一个类只会有一个 vtbl 空间，所以一般占用空间不是很大。</p><p>不要将虚函数声明为 inline ，因为虚函数是运行时绑定的，而 inline 是编译时展开的，即使你对虚函数使用 inline ，编译器也通常会忽略。<br>虚函数的第二个成本：必须为每个拥有虚函数的类的对象，付出一个指针的代价，即 vptr ，它是一个隐藏的 data member，用来指向所属类的 vtbl。</p><p>调用一个虚函数的成本，基本上和通过一个函数指针调用函数相同，虚函数本身并不构成性能上的瓶颈。</p><p>虚函数的第三个成本：事实上等于放弃了 inline。（如果虚函数是通过对象被调用，倒是可以 inline，不过一般都是通过对象的指针或引用调用的）</p><ul><li><p>虚函数真正的运行时期成本发生在和inlining互动的时候. 虚函数不应该inline. ◦因为inline函数需要在编译器将函数本体拷贝, 而virtual意味着等待, 直到运行期才知道运行谁.</p></li><li><p>多重继承往往导致虚基类的需求(virtual base class), 会形成更复杂和特殊的虚表.</p></li><li><p>一个类只需一份RTTI信息(运行时类型识别), 当某种类型至少拥有一个虚函数, 才能保证检验该对象的动态类型. </p><ul><li><p>RTTI的设计理念根据类的虚表(vtbl)来实现的.</p></li><li><p>RTTI的空间成本只需在每个类的虚表(vtbl)内增加一个条目, 即一个类型信息(type_info)对象空间.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> B1 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B2 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B3 <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> D <span class="token operator">:</span> <span class="token keyword">virtual</span> B1<span class="token punctuation">,</span> <span class="token keyword">virtual</span> B2<span class="token punctuation">,</span> <span class="token keyword">virtual</span> B3 <span class="token punctuation">{</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B1<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//8</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B2<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//4</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>B3<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//4</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//16</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//D 中只包含了三个 vptr ，D和B1共享了一个。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="五、技术-Techniques-Idioms-Patterns"><a href="#五、技术-Techniques-Idioms-Patterns" class="headerlink" title="五、技术(Techniques,Idioms,Patterns)"></a>五、技术(Techniques,Idioms,Patterns)</h2><h3 id="25、将-constructor-和-non-member-functions-虚化"><a href="#25、将-constructor-和-non-member-functions-虚化" class="headerlink" title="25、将 constructor 和 non-member functions 虚化"></a>25、将 constructor 和 non-member functions 虚化</h3><p>这里所谓的虚拟构造函数，并不是真的指在构造函数前面加上 virtual 修饰符，而是指能够根据传入不同的参数建立不同继承关系类型的对象。<br>被派生类重定义的虚函数可以与基类的虚函数具有不同的返回类型。所以所谓的虚拟复制构造函数，可以在基类里声明一个 virtual B* clone() const = 0 的纯虚函数，在子类中实现 virtual D* clone() const {return new D(*this);}</p><p>同样的，非成员函数虚化，这里也并不是指使用 virtual 来修饰非成员函数。比如下面这个输出 list 中多态对象的属性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">value</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">virtual</span> ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span><span class="token operator">:</span>        string value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D1</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">D1</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token string">"protect value"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//子类构造函数中，要先调用基类构造函数初始化基类</span>        ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>id<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//如果基类虚函数是 const 方法，则这里也必须使用 const 修饰</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D2</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">D2</span><span class="token punctuation">(</span><span class="token keyword">int</span> id_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token string">"protect value"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">id</span><span class="token punctuation">(</span>id_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//子类构造函数中，要先调用基类构造函数初始化基类</span>        ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">"\t"</span><span class="token operator">&lt;&lt;</span>id<span class="token punctuation">;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> s<span class="token punctuation">,</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span> lt<span class="token punctuation">;</span>    D1 <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    D2 <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>    lt<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d2<span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>it <span class="token operator">!=</span> lt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//D1   D2</span>        it<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，即使给每一个继承类单独实现友元的 operator&lt;&lt; 方法，也不能实现动态绑定，只会调用基类的方法。那么，在基类里写 operator&lt;&lt; 用 virtual 修饰不就行了吗？遗憾的，虚函数不能是友元。</p><h3 id="26、限制某个-class-所能产生的对象数量"><a href="#26、限制某个-class-所能产生的对象数量" class="headerlink" title="26、限制某个 class 所能产生的对象数量"></a>26、限制某个 class 所能产生的对象数量</h3><p>只有一个对象：使用单一模式，将类的构造函数声明为private，再声明一个静态函数，该函数中有一个类的静态对象不将该静态对象放在类中原因是放在函数中时，执行函数时才建立对象，并且对象初始化时间确定的，即第一次执行该函数时另外，该函数不能声明为内联，如果内联可能造成程序的静态对象拷贝超过一个限制对象个数：建立一个基类，构造函数中计数加一，若超过最大值则抛出异常；析构函数中计数减一</p><p>编程点滴：</p><p>将模板类的定义和实现放在一个文件中，否则将造成引用未定义错误（血的教训）；</p><p>静态数据成员需要先声明再初始化；</p><p>用常量值作初始化的有序类型的const静态数据成员是一个常量表达式（可以作为数组定义的维数）；</p><p>构造函数中抛出异常，将导致静态数组成员重新初始化</p><h3 id="27、要求（或禁止）对象产生于-heap-中"><a href="#27、要求（或禁止）对象产生于-heap-中" class="headerlink" title="27、要求（或禁止）对象产生于 heap 中"></a>27、要求（或禁止）对象产生于 heap 中</h3><p>析构函数私有，有一个致命问题：妨碍了继承和组合（内含）。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span>    <span class="token comment" spellcheck="true">//禁止对象产生于 heap 中</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B1"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B2</span>    <span class="token comment" spellcheck="true">//要求对象产生于 heap 中</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//模拟的析构函数</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token operator">~</span><span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//B1* b1  = new B1; //Error!</span>    B1 b1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//B2 b2;    //Error</span>    B2<span class="token operator">*</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> B2<span class="token punctuation">;</span>    b2<span class="token operator">-</span><span class="token operator">></span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="28、Smart-Pointer（智能指针）"><a href="#28、Smart-Pointer（智能指针）" class="headerlink" title="28、Smart Pointer（智能指针）"></a>28、Smart Pointer（智能指针）</h3><ul><li><p>智能指针是一个看起来, 用起来, 感觉起来都像内建指针, 但是提供了更多机能的一种对象. </p><ul><li>资源管理;</li><li>自动的重复写码工作.</li></ul></li><li><p>以智能指针取代C++内建指针: </p><ul><li>构造和析构: 何时被产生以及何时被销毁.</li><li>赋值和复制(Assignment and Copying), 复制和赋值其所指对象, 执行所谓的深拷贝(deep copy).</li><li>解引用(Dereferencing): 智能指针有权决定所指之物发生了什么事情. </li><li>采用lazy fetching方法.</li></ul></li><li><p>远程过程调用(remote procedure calls, RPC).</p></li><li><p>只能指针的构造, 赋值和析构 </p><ul><li>只有当确定要将对象所有权传递给函数的某个参数时, 才应该以by value方式传递auto_ptrs.</li></ul></li><li><p>实现解引操作符(Dereferencing Operators): </p><ul><li>返回引用值.</li></ul></li><li><p>测试智能指针是否为null: </p><ul><li>提供一个隐式类型转换操作符来进行测试.</li></ul></li><li><p>将智能指针(smart pointers) 转换为内建指针(Dumb Pointers). </p><ul><li>不要提供对内建指针的隐式转换操作符, 除非不得已.</li></ul></li><li><p>智能指针(Smart Pointers)和继承有关的类型转换 </p><ul><li>每个只能指针有个隐式类型转换操作符, 用来转换至另一个只能指针类.</li><li>函数调用的自变量匹配规则;</li><li>隐式类型转换函数;</li><li>template函数的暗自实例化;</li><li>成员函数模板(member function templates)等技术.</li></ul></li><li><p>智能指针与const: </p><ul><li>const用来修饰被指之物, 或是指针本身, 或是两者都可以. 智能指针也具有同样的弹性.</li><li>对于智能指针只有一个地方可以放置const: 只能放置与指针身上, 不能置于所指的对象.</li><li>non-const转换至const是安全的, 从const转换至non-const则不安全.</li></ul></li><li><p>自己实现的智能指针不容易实现, 了解和维护.</p></li></ul><h3 id="29、Reference-counting（引用计数）"><a href="#29、Reference-counting（引用计数）" class="headerlink" title="29、Reference counting（引用计数）"></a>29、Reference counting（引用计数）</h3><p>使用引用计数后，对象自己拥有自己，当没有人再使用它时，它自己自动销毁自己因此，引用计数是个简单的垃圾回收体系</p><p>在基类中调用delete this将导致派生类的对象被销毁</p><p>写时拷贝：与其它对象共享一个值直到写操作时才拥有自己的拷贝它是Lazy原则的特例</p><p>精彩的类层次结构：<br>RCObject类提供计数操作；<br>StringValue包含指向数据的指针并继承RCObject的计数操作；<br>RCPtr是一个灵巧指针，封装了本属于String的一些计数操作</p><h3 id="30、Proxy-classes（替身类、代理类）"><a href="#30、Proxy-classes（替身类、代理类）" class="headerlink" title="30、Proxy classes（替身类、代理类）"></a>30、Proxy classes（替身类、代理类）</h3><ul><li><p>凡是用来代表(象征)其他对象的对象, 常被称为proxy object(替身对象), 替身对象的类称为代理类. </p><ul><li>二维数组是观念上并不存在的一维数组.</li></ul></li><li><p>读取动作是所谓的右值运用(rvalue usage); 写动作是所谓的左值运用(lvalue usages).</p></li><li><p>返回字符串中字符的proxy, 而不返回字符本身.</p></li><li><p>对于一个proxy, 只有3间事情可做: </p><ul><li>产生它;</li><li>以它作为赋值动作的目标(接收端).</li><li>以其他方式使用它.</li></ul></li><li><p>Proxy 类很适合用来区分operator[]的左值运用和右值运用.</p></li><li><p>对proxy取址所获得的指针类型和对真是对象取址所获得的指针类型不同.</p></li><li><p>用户将proxy传递给接受引用到非const对象的函数.</p></li><li><p>ploxies难以完全取代真正对象的最后一个原因在于隐式类型转换.</p></li><li><p>proxy 对象是一种临时对象, 需要被产生和被销毁.</p></li><li><p>类的身份从与真实对象合作转移到与替身对象(proxies)合作, 往往会造成类语义的改变, 因为proxy 对象所展现的行为常常和真正的行为有些隐微差异.</p></li></ul><h3 id="31、让函数根据一个以上的对象类型来决定如何虚化"><a href="#31、让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="31、让函数根据一个以上的对象类型来决定如何虚化"></a>31、让函数根据一个以上的对象类型来决定如何虚化</h3><ul><li><p>面向对象函数调用机制(mutil-method): 根据所希望的多个参数而虚化的函数; — C++暂时不支持.</p></li><li><p>消息派分(message dispatch): 虚函数调用动作.</p></li><li><p>虚函数+RTTI(运行时期类型辨识): </p><ul><li>虚函数可以实现single dispatch, 利用typeid操作符来获取一个类的类型参数值.</li></ul></li><li><p>虚函数被发明的主要原因: </p><ul><li>把生产及维护”以类型为行事基准的函数”的负荷, 从程序员转移给编译器.</li></ul></li><li><p>只用虚函数: </p><ul><li>将double dispatching以两个single dispatches(两个分离的虚函数调用)实现出来: <ul><li>一个用来决定第一对象的动态类型.</li><li>另一个用来决定第二对象的动态类型.</li></ul></li><li>编译器必须根据此函数所获得的自变量的静态类型(被声明时的类型), 才能解析出哪一组函数被调用.</li></ul></li></ul><h2 id="六、杂项讨论-Miscellany"><a href="#六、杂项讨论-Miscellany" class="headerlink" title="六、杂项讨论(Miscellany)"></a>六、杂项讨论(Miscellany)</h2><h3 id="32、在未来时态下发展程序"><a href="#32、在未来时态下发展程序" class="headerlink" title="32、在未来时态下发展程序"></a>32、在未来时态下发展程序</h3><p>要用语言提供的特性来强迫程序符合设计，而不要指望使用者去遵守约定。比如禁止继承，禁止复制，要求类的实例只能创建在堆中等等。处理每个类的赋值和拷贝构造函数，如果这些函数是难以实现的，则声明它们为私有。</p><p>所提供的类的操作和函数有自然的语法和直观的语义，和内建类型（如 int）的行为保持一致。</p><p>尽可能写可移植性的代码，只有在性能极其重要时不可移植的结构才是可取的。</p><p>多为未来的需求考虑，尽可能完善类的设计。</p><h3 id="33、将非尾端类设计为抽象类"><a href="#33、将非尾端类设计为抽象类" class="headerlink" title="33、将非尾端类设计为抽象类"></a>33、将非尾端类设计为抽象类</h3><p>如果有一个实体类公有继承自另一个实体类，应该将两个类的继承层次改为三个类的继承层次，通过创造一个新的抽象类并将其它两个实体类都从它继承因此，设计类层次的一般规则是：非尾端类应该是抽象类在处理外来的类库，可能不得不违反这个规则</p><p>编程点滴：抽象类的派生类不能是抽象类；实现纯虚函数一般不常见，但对纯虚析构函数，它必须实现</p><h3 id="34、如何在同一个程序中结合-C-和-C"><a href="#34、如何在同一个程序中结合-C-和-C" class="headerlink" title="34、如何在同一个程序中结合 C++ 和 C"></a>34、如何在同一个程序中结合 C++ 和 C</h3><ul><li><p>结合C++和C程序需要考虑的问题: </p><ul><li>名称重整(name mangling): <ul><li>名称重整(name mangling)是C++中的一种程序, 为每个函数编出独一无二的名称.</li><li>绝不要重整其他语言编写函数的名称.</li><li>压制名称重整(name mangling), 必须在C++中使用extern “C” { … }指令. — 进行C连接.</li><li>不同编译器以不同的方法进行重整名称.        </li></ul></li><li>static的初始化: <ul><li>在main之前执行的代码: static class对象, 全局对象, namespace内的对象, 文件范围(file scope)内的对象, 其构造函数都在main函数之前执行.</li></ul></li></ul></li><li><p>动态内存分配: </p><ul><li>C++中使用new和delete, C中使用malloc和free.</li></ul></li><li><p>数据结构的兼容性: </p><ul><li>structs可以安全地在C++和C之间往返.</li></ul></li><li><p>在同一程序中混用C++和C, 应该记住以下几个简单规则: </p><ul><li>确定C++和C编译器产出兼容的目标文件(object file).</li><li>将双方都使用的函数声明为extern “C”.</li><li>如果可能, 尽量在C++中撰写main.</li><li>总是以delete删除new返回的内存, 总是以free释放malloc返回的内存.</li><li>将两个语言间的数据结构传递限制于C所能了解的形式; C++structs如果内涵非虚函数, 倒是不受此限制.</li></ul></li></ul><h3 id="35、让自己习惯于标准-C-语言"><a href="#35、让自己习惯于标准-C-语言" class="headerlink" title="35、让自己习惯于标准 C++ 语言"></a>35、让自己习惯于标准 C++ 语言</h3><ul><li><p>新的语言特性: </p><ul><li>RTTI, 命名空间(namespace), bool, 关键字mutable, 关键字explicit, enums作为重载函数的自变量所引发的类型晋升转换, 在类中为const static成员变量设定初值.</li></ul></li><li><p>STL(standard template library) — C++标准程序库中最大的组成部分. </p><ul><li>迭代器(iterators)是一种行为类似指针的对象, 针对STL 容器而定义.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《Effective C++》</title>
      <link href="/2020/01/01/du-shu-bi-ji-effective-c/"/>
      <url>/2020/01/01/du-shu-bi-ji-effective-c/</url>
      
        <content type="html"><![CDATA[<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h3><ul><li>C语言</li><li>面对对象</li><li>C++模板</li><li>STL容器</li></ul><h3 id="尽量以const，enum，inline替换-define"><a href="#尽量以const，enum，inline替换-define" class="headerlink" title="尽量以const，enum，inline替换#define"></a>尽量以const，enum，inline替换#define</h3><ol><li>const的好处： <ol><li>define直接常量替换，出现编译错误不易定位(不知道常量是哪个变量)</li><li>define没有作用域，const有作用域提供了封装性</li></ol></li><li>enum的好处： <ol><li>提供了封装性</li><li>编译器肯定不会分配额外内存空间(其实const也不会)</li></ol></li><li>inline的好处： <ol><li>define宏函数容易造成误用(下面有个例子)</li></ol></li></ol><p>//define误用举例</p><pre><code>#define MAX(a, b) a &gt; b ? a : bint a = 5, b = 0;MAX(++a, b) //a++调用2次MAX(++a, b+10) //a++调用一次</code></pre><p>然而，了解宏的机制以后，我们也可以用宏实现特殊的技巧。例如：C++反射，TEST</p><h3 id="宏实现工厂模式"><a href="#宏实现工厂模式" class="headerlink" title="宏实现工厂模式"></a>宏实现工厂模式</h3><ol><li>需要一个全局的map用于存储类的信息以及创建实例的函数</li><li>需要调用全局对象的构造函数用于注册</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>register_fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CCFactory</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">NewInstance</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> map_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>class_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>it <span class="token operator">==</span> map_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span>      <span class="token keyword">return</span> it<span class="token operator">-</span><span class="token operator">></span><span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Register</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">,</span> register_fun func<span class="token punctuation">)</span><span class="token punctuation">{</span>    map_<span class="token punctuation">[</span>class_name<span class="token punctuation">]</span> <span class="token operator">=</span> func<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">static</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> register_fun<span class="token operator">></span> map_<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> register_fun<span class="token operator">></span> CCFactory<span class="token operator">::</span>map_<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Register</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Register</span><span class="token punctuation">(</span>string class_name<span class="token punctuation">,</span> register_fun func<span class="token punctuation">)</span><span class="token punctuation">{</span>    CCFactory<span class="token operator">::</span><span class="token function">Register</span><span class="token punctuation">(</span>class_name<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> REGISTER_CLASS(class_name); \  const Register class_name_register(#class_name, []()->void *{return new class_name;});</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h3><ol><li>const定义接口，防止误用</li><li>const成员函数，代表这个成员函数承诺不会改变对象值 <ol><li>const成员只能调用const成员函数(加-fpermissive编译选项就可以了)</li><li>非const成员可以调用所有成员函数</li></ol></li></ol><p>尽量使用const来修饰函数名和参数变量名</p><p>尽量使用const来修饰类名<br><code>void function(classA  test);  //classA为自定义的类型</code></p><p>这样使用值传参的缺点：</p><ul><li>会导致自定义类型的构造函数和析构函数多次被调用，当自定义类型的构造函数和析构函数比较费时的时候，效率比较底下。</li><li>在传递派生类时容易产生对象被切割的问题。</li></ul><p>建议：<br><code>void function(const classA &amp;s);</code></p><p>优点：</p><ul><li>可以回避自定义类型的构造和析构函数的调用，不会影响效率。</li><li>不会产生对象切割问题，因为引用的底层其实就是指针，在内存中只有一份实例。</li></ul><p>原则：</p><ul><li>如果可以的话，尽量传递 const 的引用作为函数的参数。</li><li>不要将这个条款应用在内置类型上，对于内置类型(int double)，pass-by-value更适合。</li></ul><h3 id="确定对象使用前已被初始化"><a href="#确定对象使用前已被初始化" class="headerlink" title="确定对象使用前已被初始化"></a>确定对象使用前已被初始化</h3><ol><li>内置类型需要定义时初始化</li><li>最好使用初始化序列(序列顺序与声明顺序相同)，而不是在构造函数中赋值</li><li>跨编译单元定义全局对象不能确保初始化顺序 </li></ol><p>将static对象放入一个函数<br>Fuck&amp; fuck(){<br>    static Fuck f;<br>    return f;<br>}</p><h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="了解C-默默编调用了哪些函数"><a href="#了解C-默默编调用了哪些函数" class="headerlink" title="了解C++默默编调用了哪些函数"></a>了解C++默默编调用了哪些函数</h3><p>如果类中没有定义，程序却调用了，编译器会产生一些函数</p><ul><li><p>一个 default 构造函数</p></li><li><p>一个 copy 构造函数</p></li><li><p>一个 copy assignment 操作符</p></li><li><p>一个析构函数(non virtual)</p></li><li><p>如果自己构造了带参数的构造函数，编译器不会产生default构造函数</p></li><li><p>base class如果把拷贝构造函数或者赋值操作符设置为private，不会产生这两个函数</p></li><li><p>含有引用成员变量或者const成员变量不产生赋值操作符</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Fuck</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>  std<span class="token operator">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用定义后不能修改绑定对象</span>  <span class="token keyword">const</span> std<span class="token operator">::</span>string con_str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//const对象定义后不能修改</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>将默认生成的函数声明为private，或者C++ 11新特性”=delete”</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Uncopyable</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Uncopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h3><ol><li>给多态基类应该主动声明virtual析构函数</li><li>非多态基类，没有virtual函数，不要声明virtual析构函数</li></ol><h3 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h3><p>构造函数可以抛出异常，析构函数不能抛出异常。</p><p>因为析构函数有两个地方可能被调用。一是用户调用，这时抛出异常完全没问题。二是前面有异常抛出，正在清理堆栈，调用析构函数。这时如果再抛出异常，两个异常同时存在，异常处理机制只能terminate().</p><p>构造函数抛出异常，会有内存泄漏吗？</p><p>不会</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第二步，调用构造函数构造对象</span>    <span class="token keyword">new</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>T<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// placement new: 只调用T的构造函数</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 释放第一步分配的内存</span>    <span class="token keyword">throw</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 重抛异常，通知应用程序</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绝不在构造和析构过程中调用virtual函数"><a href="#绝不在构造和析构过程中调用virtual函数" class="headerlink" title="绝不在构造和析构过程中调用virtual函数"></a>绝不在构造和析构过程中调用virtual函数</h3><p>构造和析构过程中，虚表指针指向的虚表在变化。调用的是对应虚表指针指向的函数。</p><h3 id="令operator-返回一个reference-to-this"><a href="#令operator-返回一个reference-to-this" class="headerlink" title="令operator= 返回一个reference to *this"></a>令operator= 返回一个reference to *this</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x，y，z；x<span class="token operator">=</span>y<span class="token operator">=</span>z<span class="token operator">=</span><span class="token number">15</span>；同样有趣的是，赋值采用右结合律，x<span class="token operator">=</span>（y<span class="token operator">=</span>（z<span class="token operator">=</span><span class="token number">15</span>））；Widget<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span>（<span class="token keyword">const</span> Widget<span class="token operator">&amp;</span>rhs）<span class="token comment" spellcheck="true">//返回类型是个reference，</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token operator">*</span><span class="token keyword">this</span>；<span class="token operator">/</span>返回左侧对象<span class="token punctuation">}</span><span class="token operator">*</span> 在<span class="token keyword">operator</span><span class="token operator">=</span> 里处理自我赋值Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span>    ···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制对象时务忘其每一个成分"><a href="#复制对象时务忘其每一个成分" class="headerlink" title="复制对象时务忘其每一个成分"></a>复制对象时务忘其每一个成分</h3><ol><li>记得实现拷贝构造函数和赋值操作符的时候，调用base的相关函数</li><li>可以让拷贝构造函数和赋值操作符调用一个共同的函数，例如init</li></ol><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h3><ol><li>为了防止资源泄漏，请使用RAII对象，在构造函数里面获得资源，在析构函数里面释放资源</li><li>shared_ptr，unique_lock都是RAII对象</li></ol><h3 id="在资源管理类小心copy行为"><a href="#在资源管理类小心copy行为" class="headerlink" title="在资源管理类小心copy行为"></a>在资源管理类小心copy行为</h3><ul><li>常见的RAII对象copy行为 <ol><li>禁止copy</li><li>引用计数</li><li>深度复制</li><li>转移资源拥有权</li></ol></li></ul><h3 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h3><p>用户可能需要原始资源作为参数传入某个接口。有两种方式：</p><ul><li>提供显示调用接口</li><li>提供隐式转换接口(不推荐)</li></ul><h3 id="成对使用new和delete要采用相同的格式"><a href="#成对使用new和delete要采用相同的格式" class="headerlink" title="成对使用new和delete要采用相同的格式"></a>成对使用new和delete要采用相同的格式</h3><p>new和delete对应；new []和delete []对应</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//前面还分配了4个字节代表数组的个数</span><span class="token keyword">int</span> <span class="token operator">*</span>A <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前面分配了8个字节，分别代表对象的个数和Object的大小</span>Object <span class="token operator">*</span>O <span class="token operator">=</span> <span class="token keyword">new</span> Object<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="以独立的语句将newd对象置入智能指针"><a href="#以独立的语句将newd对象置入智能指针" class="headerlink" title="以独立的语句将newd对象置入智能指针"></a>以独立的语句将newd对象置入智能指针</h3><p>调用std::make_shared，而不要调用new，防止new Obeject和传入智能指针的过程产生异常<br>process(new Widget, priority);</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//其实这样也可以，独立的语句</span>shard_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">process</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="让接口容易被正确使用，不易被误用"><a href="#让接口容易被正确使用，不易被误用" class="headerlink" title="让接口容易被正确使用，不易被误用"></a>让接口容易被正确使用，不易被误用</h3><ol><li>好的接口很容易被正确使用，不容易被误用。努力达成这些性质(例如 explicit关键字)</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容</li><li>“防治误用”b包括建立新类型，限制类型上的操作，束缚对象值，以及消除用户的资源管理责任</li><li>shared_ptr支持定制deleter，需要灵活使用</li></ol><ul><li>宁以pass-by-refrence-to-const替换pass-by-value</li></ul><p>1.尽量以pass-by-reference-to-const替换pass-by-value，比较高效，并且可以避免切割问题<br>2.以上规则并不使用内置类型，以及STL迭代器，和函数对象。它们采用pass-by-value更合适(其实采用pass-by-reference-to-const也可以)<br>对象以by value的方式传递，其实际意义是由该对象的copy constructor决定的。这可能会使pass-by-value成为成本很高的动作。<br>以pass by reference，还可以避免所谓的“切割slicing问题”，又称为“upcasting问题”。详见《Thingking in C＋＋》P629<br>pass by reference是一件美妙的事情，但会导致某些复杂性。最知名的问题就是aliasing(别名问题)，见条款17。某些情况下必须pass by value。references的底层几乎都是指针完成，所以passing by reference通常意味着传递的是指针。如果有个小对象，例如一个int，那么pass by value可能比pass by reference的效率更高一些。  </p><ul><li>必须返回对象时，别妄想返回其reference</li></ul><p>1.不要返回pointer或者reference指向一个on stack对象(被析构)<br>2.不要返回pointer或者reference指向一个on heap对象(需要用户delete，我觉得必要的时候也不是不可以)<br>3.不要返回pointer或者reference指向local static对象，却需要多个这样的对象(static只能有一份)</p><ul><li>将成员变量申明为private</li></ul><p>1.切记将成员变量申明为private<br>2.protected并不比public更有封装性(用户可能继承你的base class)</p><h3 id="宁以non-member，non-friend替换member"><a href="#宁以non-member，non-friend替换member" class="headerlink" title="宁以non-member，non-friend替换member"></a>宁以non-member，non-friend替换member</h3><p>作者说多一个成员函数，就多一分破坏封装性，好像有点道理，但是我们都没有这样遵守。直接写member函数方便一些。</p><h3 id="若所有参数都需要类型转换，请为此采用non-member函数"><a href="#若所有参数都需要类型转换，请为此采用non-member函数" class="headerlink" title="若所有参数都需要类型转换，请为此采用non-member函数"></a>若所有参数都需要类型转换，请为此采用non-member函数</h3><p>如果调用member函数，就使得第一个参数的类失去一次类型转换的机会。</p><h3 id="考虑写一个不抛出异常的swap函数"><a href="#考虑写一个不抛出异常的swap函数" class="headerlink" title="考虑写一个不抛出异常的swap函数"></a>考虑写一个不抛出异常的swap函数</h3><ol><li><p>当std::swap效率不高(std::swap调用拷贝构造函数和赋值操作符，如果是深拷贝，效率不会高)，提供一个swap成员函数，并确定不会抛出异常。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token keyword">const</span> Obj<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//深拷贝}</span> Obj<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Obj<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>深拷贝<span class="token keyword">private</span><span class="token operator">:</span> OtherClass <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果提供一个member swap，也该提供一个non-member swap用来调用前者</p></li></ol><ol start="3"><li><p>调用swap时应该针对std::swap使用using声明式，然后调用swap不带任何”命名空间修饰”</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Obj<span class="token operator">&amp;</span> o1<span class="token punctuation">,</span> Obj<span class="token operator">&amp;</span> o2<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这样可以让编译器自己决定调用哪个swap，万一用户没有实现针对Obj的swap，还能调用std::swap</span> <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span> <span class="token function">swap</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>不要往std命名空间里面加东西</p></li></ol><h3 id="在constructor中尽量以initialization动作取代assignment动作"><a href="#在constructor中尽量以initialization动作取代assignment动作" class="headerlink" title="在constructor中尽量以initialization动作取代assignment动作"></a>在constructor中尽量以initialization动作取代assignment动作</h3><p>【尽量使用初始化列表来代替赋值】<br>const members和reference members只能被初始化，不能够被赋值（assigned）。这个时候，如果在构造函数中要对其初始化时必须用member initialization list。 另外，从效率方面考虑，也建议用以initialization动作取代assignment动作。<br>例外的情况：</p><ol><li>static class member不应该在构造函数中初始化。</li><li>如果有很多built-in type类型的class member要初始化，建议使用assignment，这和initialization在效率上没有什么区别，而且容易维护。</li><li>initialization list中的members初始化次序应该和其在class内的声明次序相同</li></ol><p>class members系以它们在class内的声明次序来初始化，和它们在member initialization list中出现的次序完全无关。基类的成员变量永远在继承类成员变量之前被初始化，所以如果运用了继承，你应该在member intialization lists起始处列出base class的初始设定值。</p><p>结论是：对象被初始化时，如果你希望确实掌握真正发生了什么事，请以class内的members声明次序，将各个memebers列于initialization list中。    </p><h3 id="区分member-functions，non-member-functions和friend-functions三者"><a href="#区分member-functions，non-member-functions和friend-functions三者" class="headerlink" title="区分member functions，non-member functions和friend functions三者"></a>区分member functions，non-member functions和friend functions三者</h3><p>member functions和non-member functions的区别是：member functions可以是虚函数，而non-member functions不可以。<br>在一个类中，只要能够避免friend函数，就应该尽量避免，“因为就像真实世界一样，朋友带来的麻烦常常多于其价值。”：）^_^</p><ol><li>虚拟函数必须是class members。</li><li>绝不要让operator&gt;&gt;和operator&lt;&lt;成为members。</li><li>如果non-member functions需要用到class的non-public members，让它成为class的friend functions。   </li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="尽可能延后变量定义式出现的时间"><a href="#尽可能延后变量定义式出现的时间" class="headerlink" title="尽可能延后变量定义式出现的时间"></a>尽可能延后变量定义式出现的时间</h3><p>C语言推荐在函数开始的时候定义所有变量(最开始的C语言编译器要求，现在并不需要)，C++推荐在使用对象前才定义对象</p><h3 id="尽量少做转型动作"><a href="#尽量少做转型动作" class="headerlink" title="尽量少做转型动作"></a>尽量少做转型动作</h3><ol><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。</li><li>如果转型是必要的，试着将它隐藏于某个函数后。客户可以随时调用该函数，而不需要将转型放入自己的代码。</li><li>使用C++风格的转型。</li></ol><h3 id="避免返回handles指向对象内部成分"><a href="#避免返回handles指向对象内部成分" class="headerlink" title="避免返回handles指向对象内部成分"></a>避免返回handles指向对象内部成分</h3><p>简单说，就是成员函数返回指针或者非const引用不要指向成员变量，这样会破坏封装性</p><h3 id="为“异常安全”而努力是值得的"><a href="#为“异常安全”而努力是值得的" class="headerlink" title="为“异常安全”而努力是值得的"></a>为“异常安全”而努力是值得的</h3><ul><li><p>“异常安全函数”承诺即使发生异常也不会有资源泄漏。在这个基础下，它有3个级别 </p><ol><li>基本保证：抛出异常，需要用户处理程序状态改变(自己写代码保证这个级别就行了把)</li><li>强烈保证：抛出异常，程序状态恢复到调用前</li><li>不抛异常：内置类型的操作就绝不会抛出异常</li></ol></li><li><p>“强烈保证”往往可以通过copy-and-swap实现，但是”强烈保证”并非对所有函数都具有实现意义</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//我反正从来没有这样写过</span><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>  Object <span class="token function">new_obj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  new_obj<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token function">swap</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> new_obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="透彻了解inline函数的里里外外"><a href="#透彻了解inline函数的里里外外" class="headerlink" title="透彻了解inline函数的里里外外"></a>透彻了解inline函数的里里外外</h3><p>这里插播一个C++处理定义的重要原则，一处定义原则：</p><ul><li><p>全局变量，静态数据成员，非内联函数和成员函数只能整个程序定义一次</p></li><li><p>类类型(class，struct,union)，内联函数可以每个翻译单元定义一次 </p><ol><li>template类的成员函数或者template函数，定义在头文件中，编译器可以帮忙去重</li><li>普通类的template函数，定义在头文件中，需要加inline</li></ol></li><li><p>inline应该限制在小的，频繁调用的函数上</p></li><li><p>inline只是给编译器的建议，编译器不一定执行</p></li></ul><h3 id="将文件的编译依存关系降到最低"><a href="#将文件的编译依存关系降到最低" class="headerlink" title="将文件的编译依存关系降到最低"></a>将文件的编译依存关系降到最低</h3><ol><li>支持”编译依存最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes(impl对象提供服务)和Interface classes。</li></ol><p>其实就是使用前置声明，下面有个需要注意的点</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Obj.h</span><span class="token keyword">class</span> <span class="token class-name">ObjImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>ObjImpl<span class="token operator">></span> pObjImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上面的写法会报错，因为编译器会再.h文件里面产生默认的析构函数，</span><span class="token comment" spellcheck="true">//析构函数要调用ObjImpl的析构函数，然后我们现在只有声明式，不能调用ObjImpl的实现。</span><span class="token comment" spellcheck="true">//下面的实现才是正确的</span><span class="token comment" spellcheck="true">//Obj.h</span><span class="token keyword">class</span> <span class="token class-name">ObjImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//声明</span>    <span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>ObjImpl<span class="token operator">></span> pObjImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Obj.cpp</span><span class="token comment" spellcheck="true">//现在可以看到ObjImpl的实现</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;ObjImpl></span></span>Obj<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于STL的对象不需要前置声明。</p><h2 id="继承与面对对象设计"><a href="#继承与面对对象设计" class="headerlink" title="继承与面对对象设计"></a>继承与面对对象设计</h2><h3 id="确定你的public继承塑模出is-a模型"><a href="#确定你的public继承塑模出is-a模型" class="headerlink" title="确定你的public继承塑模出is-a模型"></a>确定你的public继承塑模出is-a模型</h3><p>public继承意味着is-a。适用于base class身上的每一个函数也一定适用于derived class。</p><h3 id="避免遮掩继承而来的名称"><a href="#避免遮掩继承而来的名称" class="headerlink" title="避免遮掩继承而来的名称"></a>避免遮掩继承而来的名称</h3><p>子作用域会遮掩父作用域的名称。一般来讲，我们可以有以下几层作用域</p><ul><li>global作用域</li><li>namespace作用域 <ul><li>Base class作用域 <ul><li>Drive class作用域 <ul><li>成员函数 <ul><li>控制块作用域</li></ul></li></ul></li></ul></li><li>非成员函数作用域 <ul><li>控制块作用域</li></ul></li></ul></li></ul><p>注意：遮掩的是上一层作用域的名称，重载(不同参数)的函数也会直接遮掩</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//会遮掩f1()，子类并没有继承f1()</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Drive d<span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误</span>d<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>可以通过<span class="token keyword">using</span>声明式或者<span class="token keyword">inline</span>转交解决这一问题<span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//using 声明式</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token operator">::</span>f1<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//inline转交</span><span class="token keyword">class</span> <span class="token class-name">Drive</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Base<span class="token operator">::</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区分接口继承和实现继承"><a href="#区分接口继承和实现继承" class="headerlink" title="区分接口继承和实现继承"></a>区分接口继承和实现继承</h3><ol><li>纯虚函数：提供接口继承 <ol><li>Drived class必须实现纯虚函数</li><li>不能构造含有纯虚函数的类</li><li>纯虚函数可以有成员变量</li><li>可以给纯虚函数提供定义(wtf)</li></ol></li><li>虚函数：提供接口继承和默认的实现继承</li><li>非虚函数：提供了接口继承和强制的实现继承(最好不要在Drived class重新定义非虚函数)</li></ol><p>在编写自己的 class 时，你应该明白提供下面 3 种类型函数的理由</p><ul><li>pure virtual function</li><li>virtual function</li><li>no-virtual function</li></ul><p>何时提供 pure virtual function？</p><p>要求派生类只继承接口时，提供纯虚函数。【就像下单函数一样，其作用就是提供接口让你来重写】</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span>vitrual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>；何时提供 <span class="token keyword">virtual</span> function？要求派生类只继承接口和缺省实现时，提供虚函数。<span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span>vitrual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>何时提供 no-virtual function？</p><p>要求派生类只继承接口的强制实现时，提供非虚函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment" spellcheck="true">//派生类只继承接口</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原则</strong></p><ul><li>纯虚函数指定接口继承。//这跟XTP中的订阅反馈函数的重载一样</li><li>虚函数指定接口和缺省实现继承。  //</li><li>非虚函数指定接口的强制实现继承。</li><li>接口继承和实现继承不同。</li></ul><h3 id="考虑virtual函数以外的选择"><a href="#考虑virtual函数以外的选择" class="headerlink" title="考虑virtual函数以外的选择"></a>考虑virtual函数以外的选择</h3><pre class="line-numbers language-cpp"><code class="language-cpp">non<span class="token operator">-</span><span class="token keyword">virtual</span> interface：提供非虚接口<span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优点：</strong></p><ul><li>可以在调用虚函数的前后，做一些准备工作(抽出一段重复代码)</li><li>提供良好的ABI兼容性</li></ul><h3 id="聊一聊ABI兼容性"><a href="#聊一聊ABI兼容性" class="headerlink" title="聊一聊ABI兼容性"></a>聊一聊ABI兼容性</h3><p>我们知道，程序库的优势之一是库版本升级，只要保证借口的一致性，用户不用修改任何代码。<br>一般一个设计完好的程序库都会提供一份C语言接口，为什么呢，我们来看看C++ ABI有哪些脆弱性。</p><ul><li>虚函数的调用方式，通常是 vptr/vtbl 加偏移量调用</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Object.h</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>···    <span class="token keyword">virtual</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第3个虚函数</span>···<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用户代码</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Object <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> Object<span class="token punctuation">;</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//编译器：vptr[3]()</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//如果加了虚函数，用户代码根据偏移量找到的是newfun函数</span><span class="token comment" spellcheck="true">//Object.h</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>···    <span class="token keyword">virtual</span> <span class="token function">newfun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第3个虚函数</span>    <span class="token keyword">virtual</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第4个虚函数</span>···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>name mangling 名字粉碎实现重载</li></ul><p>C++没有为name mangling制定标准。例如void fun(int)，有的编译器定为fun_int_，有的编译器指定为fun%int%。<br>因此，C++接口的库要求用户必须和自己使用同样的编译器(这个要求好过分)</p><ul><li>其实C语言接口也不完美</li></ul><p>例如struct和class。编译阶段，编译器将struct或class的对象对成员的访问通过偏移量来实现</p><h3 id="使用std-fun提供回调"><a href="#使用std-fun提供回调" class="headerlink" title="使用std::fun提供回调"></a>使用std::fun提供回调</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> doInterface<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="古典策略模式"><a href="#古典策略模式" class="headerlink" title="古典策略模式"></a>古典策略模式</h3><p>用另外一个继承体系替代</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        p<span class="token operator">-</span><span class="token operator">></span><span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；        ···    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token operator">:</span>    BaseInterface <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BaseInterface</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">doInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绝不重新定义继承而来的non-virtual函数"><a href="#绝不重新定义继承而来的non-virtual函数" class="headerlink" title="绝不重新定义继承而来的non-virtual函数"></a>绝不重新定义继承而来的non-virtual函数</h3><p>记住就行</p><h3 id="绝不重新定义继承而来的缺省参数值"><a href="#绝不重新定义继承而来的缺省参数值" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Drive "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                                                                 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                                                          Base <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> Drive<span class="token punctuation">;</span>                                                               b<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//   vptr[0](1)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Drive 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺省参数值是静态绑定</li><li>虚函数是动态绑定</li><li>遵守这条规定防止出错</li></ul><h3 id="通过复合塑模出has-a或者”根据某物实现出”"><a href="#通过复合塑模出has-a或者”根据某物实现出”" class="headerlink" title="通过复合塑模出has-a或者”根据某物实现出”"></a>通过复合塑模出has-a或者”根据某物实现出”</h3><ol><li>复合的意义和public完全不一样</li><li>根据某物实现出和is-a的区别：</li></ol><p>这个也是什么时候使用继承，什么时候使用复合。复合代表使用了这个对象的某些方法，但是却不想它的接口入侵。</p><h3 id="明智而审慎地使用private继承"><a href="#明智而审慎地使用private继承" class="headerlink" title="明智而审慎地使用private继承"></a>明智而审慎地使用private继承</h3><ol><li>private继承是”根据某物实现出“</li><li>唯一一个使用private继承的理由就是，可以使用空白基类优化技术，节约内存空间</li></ol><h3 id="C-对空类的处理"><a href="#C-对空类的处理" class="headerlink" title="C++对空类的处理"></a>C++对空类的处理</h3><p>C++ 设计者在设计这门语言要求所有的对象必须要有不同的地址(C语言没有这个要求)。C++编译器的实现方式是给让空类占据一个字节。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//8个字节</span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    Base b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4个字节</span>classObject <span class="token operator">:</span> <span class="token keyword">private</span> Base<span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="明智而审慎地使用多重继承"><a href="#明智而审慎地使用多重继承" class="headerlink" title="明智而审慎地使用多重继承"></a>明智而审慎地使用多重继承</h3><p>首先我们来了解一下多重继承的内存布局。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//包含A对象</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B对象</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,C对象</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,A,B,C,D对象</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span><span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C<span class="token punctuation">{</span><span class="token punctuation">}</span>由于菱形继承，基类被构造了两次。其实，C<span class="token operator">++</span>也提供了针对菱形继承的解决方案的<span class="token comment" spellcheck="true">//包含A对象</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B对象</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,C对象</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含A,B,C,D对象</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span><span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C<span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用虚继承，B,C对象里面会产生一个指针指向唯一一份A对象。这样付出的代价是必须再运行期根据这个指针的偏移量寻找A对象。</p><p>多重继承唯一的那么一点点用就是一个Base class提供public继承，另一个Base class提供private继承。(还是没什么用啊，干嘛不适用复合)</p><h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="了解隐式接口和编译期多态"><a href="#了解隐式接口和编译期多态" class="headerlink" title="了解隐式接口和编译期多态"></a>了解隐式接口和编译期多态</h3><ol><li>接口：强制用户实现某些函数</li><li>多态：相同的函数名，却有不同的实现</li><li>继承和模板都支持接口和多态</li><li>对继承而言，接口是显式的，以函数为中心，多态发生在运行期；</li><li>对模板而言，接口是隐式的，多态表现在template具象化和函数重载<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//这里接口要求T必须实现operator ></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T <span class="token function">max</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="了解typename的双重意义"><a href="#了解typename的双重意义" class="headerlink" title="了解typename的双重意义"></a>了解typename的双重意义</h3><ol><li>声明template参数时，前缀关键字class和typename可以互换</li><li>使用typename表明嵌套类型(防止产生歧义)</li></ol><p><strong>第一层：</strong>作为类模板的参数时，与 class 功能相同。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyType</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyTYpe</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个定义完全相同。</p><p><strong>第二层：</strong> typename 可以让模板里面定义嵌套从属名称的类型变成有效的类型，因为 C++ 的解析器在模板中遇到嵌套从属类型时，默认认为它是无效的类型。</p><p>例如：无效的嵌套从属类型</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>        T<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要认为指定它为有效的嵌套从属类型</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">typename</span> T<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况 当你想在 template 中指定一个有效的嵌套从属类型名称，只需要在嵌套从属类型前面加上 typename 关键字即可。<br><strong>例外</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">*</span> 不得在 base <span class="token keyword">class</span> <span class="token class-name">list</span> 中使用 <span class="token keyword">typename</span><span class="token comment" spellcheck="true">/* 错误用法 */</span><span class="token keyword">class</span> <span class="token class-name">Deriver</span> <span class="token operator">:</span> <span class="token keyword">public</span> <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>MyType<span class="token punctuation">;</span><span class="token operator">*</span> 不得在 member initialization list 中使用 <span class="token keyword">typename</span><span class="token keyword">class</span> <span class="token class-name">Deriver</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>MyType<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment" spellcheck="true">/* 错误用法 */</span>  <span class="token keyword">explicit</span> <span class="token function">Deriver</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">MyType</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原则</strong></p><ul><li><p>class 和 typename 在声明模板参数时作用相同。</p></li><li><p>使用 typename 标识嵌套从属类型，但是不得在 base class list 和 member initialization list 中使用。</p></li></ul><h3 id="学习处理模板化基类内的名称"><a href="#学习处理模板化基类内的名称" class="headerlink" title="学习处理模板化基类内的名称"></a>学习处理模板化基类内的名称</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>                                                                        <span class="token keyword">public</span><span class="token operator">:</span>                                                                              <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>                                                             <span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>                                                    <span class="token keyword">public</span><span class="token operator">:</span>                                                                            <span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span><span class="token punctuation">{</span>                                                            <span class="token comment" spellcheck="true">//error 编译器不知道基类有print函数</span>    <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解决方案</span><span class="token comment" spellcheck="true">//this->print();</span><span class="token comment" spellcheck="true">//using Base&lt;T>::print</span><span class="token comment" spellcheck="true">//base&lt;T>::print直接调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将参数无关代码抽离template"><a href="#将参数无关代码抽离template" class="headerlink" title="将参数无关代码抽离template"></a>将参数无关代码抽离template</h3><ol><li>非类型模板参数造成的代码膨胀：以函数参数或者成员变量替换</li><li>类型模板参数造成的代码膨胀：特化它们，让含义相近的类型模板参数使用同一份底层代码。例如int，long, const int</li></ol><h3 id="运用成员函数模版接收所有兼容类型"><a href="#运用成员函数模版接收所有兼容类型" class="headerlink" title="运用成员函数模版接收所有兼容类型"></a>运用成员函数模版接收所有兼容类型</h3><p>我们来考虑一下智能指针的拷贝构造函数和赋值操作符怎么实现。它需要子类的智能指针能够隐式转型为父类智能指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//拷贝构造函数，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//赋值操作符，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//声明正常的拷贝构造函数</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span>；    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    T <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用成员函数模版生成“可接受所有兼容类型”的函数</li><li>即使有了“泛化拷贝构造函数”和“泛化的赋值操作符”，仍然需要声明正常的拷贝构造函数和赋值操作符</li><li>在一个类模版内，template名称可被用来作为作为“template和其参数”的简略表达式</li></ul><h3 id="所有参数需要类型转换的时候请为模版定义非成员函数"><a href="#所有参数需要类型转换的时候请为模版定义非成员函数" class="headerlink" title="所有参数需要类型转换的时候请为模版定义非成员函数"></a>所有参数需要类型转换的时候请为模版定义非成员函数</h3><ol><li>当我们编写一个模版类，某个相关函数都需要类型转换，需要把这个函数定义为非成员函数</li><li>但是模版的类型推到遇见了问题，需要把这个函数声明为友元函数帮助推导</li><li>模版函数只有声明编译器不会帮忙具现化，所以我们需要实现的是友元模版函数<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">{</span> … <span class="token keyword">friend</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">Rational</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">GetNumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">.</span><span class="token function">GetNumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         a<span class="token punctuation">.</span><span class="token function">GetDenominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">.</span><span class="token function">GetDenominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> …<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="请使用traits-classes表现类型信息"><a href="#请使用traits-classes表现类型信息" class="headerlink" title="请使用traits classes表现类型信息"></a>请使用traits classes表现类型信息</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">type_traits</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">ccSizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> type_traits<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>size<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>traits采用类模版和特化的方式，为不同的类型提供了相同的类型抽象(都由size)</li><li>为某些类型提供编译期测试，例如is_fundamental(是否为内置类型)</li></ul><h2 id="模版元编程"><a href="#模版元编程" class="headerlink" title="模版元编程"></a>模版元编程</h2><p>本质上就是函数式编程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//上楼梯，每次上一步或者两步，有多少种</span><span class="token keyword">int</span> <span class="token function">climb</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//元编程，采用类模版</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>n <span class="token operator">+</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-2</span><span class="token operator">></span><span class="token operator">::</span>n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>C++元编程可以将计算转移到编译期，执行速度迅速(缺陷？)</li></ul><h2 id="函数调用的栈结构："><a href="#函数调用的栈结构：" class="headerlink" title="函数调用的栈结构："></a>函数调用的栈结构：</h2><p>当编译器为函数调用生成代码时，首先将参数从右至左压栈，然后是函数返回的地址（Return Address）压栈，同时在函数内部，生成代码来将堆栈指针移动（向上或向下，这要视机器而定），为函数的本地变量提供存储空间。当函数调用完毕，栈指针将移动到函数（Return Address）的位置，这样函数的本地变量出栈。那么函数的返回值（尤其是一个自定义的类型）存放在什么地方？答案是将函数的返回值作为一个参数压栈，直接将返回值的信息拷贝至该参数中。这个答案没有解决所有的问题，但它效率很高。</p><p>下面是一个函数调用的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> f（<span class="token keyword">int</span> x，<span class="token keyword">char</span> c）；<span class="token keyword">int</span> g＝f（a，b）；看一下它对应的汇编代码：push b；push a；call f（）；add sp，<span class="token number">4</span>；mov g，<span class="token keyword">register</span> a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先是两个参数压栈，然后调用函数，完了将参数出栈，将返回值放在寄存器中（因为int是built-in type），传递给返回值g。这与上面讲的函数调用的过程稍有不同。插一句：前段时间碰到很多次stack overflow的错误，搞死我了。但是当我理解了函数调用背后的故事后，stack overflow的问题终于暂时解决了。</p><p>何为copy constructor？</p><p>当需要从一个已存在的对象创建另一个对象时，会调用copy constructor。当然，我们也可以阻止这样的行为。忠告中会讲到。<br>看下面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//copy constructor</span><span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//assignment operator</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">char</span> <span class="token operator">*</span>m_data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果缺少了copy constructor和assignment operator，当进行复制时会进行bitcopy，也就是按位进行拷贝。试想如果上面的类中没有copy constructor和assignment operator，调用如下语句时的问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">String a（“hello”）；<span class="token comment" spellcheck="true">//m_data指向字符串“hello”</span>String b（“World”）；<span class="token comment" spellcheck="true">//m_data指向字符串“world”</span>b＝a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样，经过bitcopy，a和b中的m_data都指向“hello”，“world”没人管了，Memory Leak！！！而且，当a或b中的一个调用了析构函数后，“hello”所在的内存将被释放，这样另一个中的指针指向了一片非法内存！！！</p><p>忠告：如果class的成员变量中含有任何指针，请为这个类写copy constructor和assignment operator。但是你如果确信你的class不会执行copy和assignment动作，这时候写copy constructor和assignment operator会觉得有点得不偿失，这时候将copy-construction（No definition）声明为private，将阻止使用值传递方式(pass an object of your class by value)。呵呵，我知道这个时候你的头在游泳了。</p><h2 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h2><h3 id="了解new-handler的行为"><a href="#了解new-handler的行为" class="headerlink" title="了解new-handler的行为"></a>了解new-handler的行为</h3><p>new和malloc对比：</p><ul><li>new构造对象，malloc不会</li><li>new分配不出内存会抛异常，malloc返回NULL</li><li>new分配不出内存可以调用用户设置的new-handler，malloc没有<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> std<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>new_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回旧的handler</span>  new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以为每个类设置专属new handler</li></ul><h3 id="了解new和delete合理的替换时机"><a href="#了解new和delete合理的替换时机" class="headerlink" title="了解new和delete合理的替换时机"></a>了解new和delete合理的替换时机</h3><p>C++中对象的构造和析构经历了都两个阶段</p><ul><li>operator new, operator delete：分配和释放内存</li><li>调用构造函数，调用析构函数</li></ul><p>替换new和delete的理由，就是需要收集分配内存的资源信息</p><h3 id="编写符合常规的new和delete"><a href="#编写符合常规的new和delete" class="headerlink" title="编写符合常规的new和delete"></a>编写符合常规的new和delete</h3><ol><li>operator new应该内含一个无穷循环尝试分配内存，如果无法满足，就调用new-handler。class版本要处理“比正确大小更大的(错误)申请”</li><li>operator deleter应该处理Null。classz专属版本还要处理“比正确大小更小的(错误)申请”</li></ol><h3 id="写了operator-new也要写相应的operator-delete"><a href="#写了operator-new也要写相应的operator-delete" class="headerlink" title="写了operator new也要写相应的operator delete"></a>写了operator new也要写相应的operator delete</h3><p>我们知道，new一个对象要经历两步。如果在调用构造函数失败，编译器会寻找一个“带相同额外参数”的operator delete，否则就不调用，造成资源泄漏</p><p>我觉得这个条款讲的不是太通俗，所以我决定来个“俗”点的：<br>重载new和delete时必须要做到的，这里的重载包括（参见《Thinking in C++》）：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Overloading global <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>Overloading <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span> fro a <span class="token keyword">class</span><span class="token punctuation">;</span>Overloading <span class="token keyword">new</span> <span class="token operator">&amp;</span> <span class="token keyword">delete</span> <span class="token keyword">for</span> arrays。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不过现在有了这练习上乘内功的口诀，就不怕走火入魔了。</p><p>口诀：</p><ol><li>正确的返回值</li><li>内存不足，调用错误处理函数</li><li>不索求任何内存时的调用</li><li>避免不经意遮掩了“正常”形式的new(见条款9)</li></ol><h3 id="问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？"><a href="#问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？" class="headerlink" title="问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？"></a>问题：当重载了new后，我们有时候需要调用“正规形式”的new，这时怎么办？</h3><p>解决：</p><ol><li><p>祭出inline函数，搞定！</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span><span class="token keyword">public</span>：<span class="token keyword">void</span> f（）；<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">,</span> new_handler p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//我们重载，为了区别，则多添加一个参数</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这是系统自己的</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为自己重载new添加的额外参数添加默认参数值，一样搞定！</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span><span class="token keyword">public</span>：<span class="token keyword">void</span> f（）；<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>（size_t size<span class="token punctuation">,</span> new_handler p＝<span class="token number">0</span>）<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="绝不重新定义继承而来的缺省参数值-1"><a href="#绝不重新定义继承而来的缺省参数值-1" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"Base "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Drive</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Drive "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                                                                 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                                                          Base <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> Drive<span class="token punctuation">;</span>                                                               b<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//   vptr[0](1)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Drive 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺省参数值是静态绑定</li><li>虚函数是动态绑定</li><li>遵守这条规定防止出错</li></ul><h3 id="运用成员函数模版接收所有兼容类型-1"><a href="#运用成员函数模版接收所有兼容类型-1" class="headerlink" title="运用成员函数模版接收所有兼容类型"></a>运用成员函数模版接收所有兼容类型</h3><p>我们来考虑一下智能指针的拷贝构造函数和赋值操作符怎么实现。它需要子类的智能指针能够隐式转型为父类智能指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//拷贝构造函数，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//赋值操作符，接受所有能够从U*隐式转换到T*的参数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">p</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//声明正常的拷贝构造函数</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span>；    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span> <span class="token operator">&amp;</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    T <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用成员函数模版生成“可接受所有兼容类型”的函数</li><li>即使有了“泛化拷贝构造函数”和“泛化的赋值操作符”，仍然需要声明正常的拷贝构造函数和赋值操作符</li><li>在一个类模版内，template名称可被用来作为作为“template和其参数”的简略表达式</li></ul><h2 id="模版元编程-1"><a href="#模版元编程-1" class="headerlink" title="模版元编程"></a>模版元编程</h2><p>本质上就是函数式编程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//上楼梯，每次上一步或者两步，有多少种</span><span class="token keyword">int</span> <span class="token function">climb</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climb</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//元编程，采用类模版</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>n <span class="token operator">+</span> Climb<span class="token operator">&lt;</span>N<span class="token number">-2</span><span class="token operator">></span><span class="token operator">::</span>n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Climb</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++元编程可以将计算转移到编译期，执行速度迅速(缺陷？)</p><h2 id="STL使用小细节"><a href="#STL使用小细节" class="headerlink" title="STL使用小细节"></a>STL使用小细节</h2><h3 id="删除连续容器-vector-deque-string-的元素"><a href="#删除连续容器-vector-deque-string-的元素" class="headerlink" title="删除连续容器(vector,deque,string)的元素"></a>删除连续容器(vector,deque,string)的元素</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 当c是vector、string，删除value</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除</span><span class="token keyword">bool</span> <span class="token function">assertFun</span><span class="token punctuation">(</span>valuetype<span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove_if</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> assertFun<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 有时候我们不得不遍历去完成，并删除</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除list中某个元素"><a href="#删除list中某个元素" class="headerlink" title="删除list中某个元素"></a>删除list中某个元素</h3><pre class="line-numbers language-cpp"><code class="language-cpp">c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除    </span>c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>assertFun<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span> 删除关联容器<span class="token punctuation">(</span>set<span class="token punctuation">,</span>map<span class="token punctuation">)</span>中某个元素c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《STL源码剖析》（第七、八章：仿函数与接配器）</title>
      <link href="/2019/12/24/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-qi-ba-zhang-fang-han-shu-yu-jie-pei-qi/"/>
      <url>/2019/12/24/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-qi-ba-zhang-fang-han-shu-yu-jie-pei-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章：仿函数"><a href="#第七章：仿函数" class="headerlink" title="第七章：仿函数"></a>第七章：仿函数</h1><h2 id="7-1、仿函数（函数对象）概观"><a href="#7-1、仿函数（函数对象）概观" class="headerlink" title="7.1、仿函数（函数对象）概观"></a>7.1、仿函数（函数对象）概观</h2><p>STL仿函数的分类，若以操作数（operand）的个数划分，可分为一元和二元仿函数，若以功能划分，可分为算术运算（Arithmetic）、关系运算（Rational）、逻辑运算（Logical）三大类。任何应用程序欲使用STL内建的仿函数，都必须含人&lt; functiona1 &gt;头文件，SGI则将它们实际定义于&lt; st1_function.h &gt;文件中。以下分别描述。<br>重载 () 所以函数的对象 使用（）像函数调用是类 而不是普通的函数<br><strong>内部记录状态：</strong><br>作为类型 与模板进行配合使用  </p><ol><li>函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可内联编译，性能好。用函数指针几乎不可能</li><li>模版函数对象使函数对象具有通用性，这也是它的优势之一</li></ol><h2 id="7-2、可配接（adaptable）的关键"><a href="#7-2、可配接（adaptable）的关键" class="headerlink" title="7.2、可配接（adaptable）的关键"></a>7.2、可配接（adaptable）的关键</h2><ul><li><p>unary_function<br>unary_function用来呈现一元函数的参数型别和回返值型别。其定义非常简单：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000914459-1414387869.png" alt=""></p></li><li><p>binary_function<br>binary_function 用来呈现二元函数的第一参数型别、第二参数型别，以及回返值型别。其定义非常简单：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000925773-1298919017.png" alt=""></p></li></ul><h2 id="7-3、算术类（Arithmetic）仿函数"><a href="#7-3、算术类（Arithmetic）仿函数" class="headerlink" title="7.3、算术类（Arithmetic）仿函数"></a>7.3、算术类（Arithmetic）仿函数</h2><p>STL内建的“算术类仿函数”，支持加法、减法、乘法、除法、模数（余数，modulus）和否定（negation）运算。除了“否定”运算为一元运算，其它都是二元运算。</p><ul><li>加法：plus<T></li><li>减法：minus<T></li><li>乘法：multiplies<T></li><li>除法：divides<T></li><li>模取（modulus）：modulus<T></li><li>否定（negation）：negate<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000940335-1676139172.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000955791-618196543.png" alt=""></p><h2 id="7-4、关系运算类（Relational）仿函数"><a href="#7-4、关系运算类（Relational）仿函数" class="headerlink" title="7.4、关系运算类（Relational）仿函数"></a>7.4、关系运算类（Relational）仿函数</h2><p>STL内建的“关系运算类仿函数”支持了等于、不等于、大于、大于等于、小于、小于等于六种运算。每一个都是二元运算。</p><ul><li>等于（equality）：equal_to<T></li><li>不等于（inequality）：not_equal_tocT&gt;</li><li>大于（greater than）：greater<T></li><li>大于或等于（greater than or equal）：greater_-equal<T></li><li>小于（less than）：1ess<T></li><li>小于或等于（less than or equal）：1ess_equal<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001007466-1276806188.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001020777-765884354.png" alt=""></p><h2 id="7-5、逻辑运算类（Logical）仿函数"><a href="#7-5、逻辑运算类（Logical）仿函数" class="headerlink" title="7.5、逻辑运算类（Logical）仿函数"></a>7.5、逻辑运算类（Logical）仿函数</h2><p>STL内建的“逻辑运算类仿函数”支持了逻辑运算中的 And、or、Not三种运算，其中And和or为二元运算，Not为一元运算。</p><ul><li>逻辑运算And：1ogical_and<T></li><li>逻辑运算or：1ogical_or<T></li><li>逻辑运算Not:logical_not<T><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001032087-1471946754.png" alt=""></li></ul><p>使用：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001043598-1146445021.png" alt=""></p><h2 id="7-6、证同（identity）、选择（select）、投射（project）"><a href="#7-6、证同（identity）、选择（select）、投射（project）" class="headerlink" title="7.6、证同（identity）、选择（select）、投射（project）"></a>7.6、证同（identity）、选择（select）、投射（project）</h2><ul><li><p>identity<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001057404-685324224.png" alt=""></p></li><li><p>select<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001110220-114459234.png" alt=""></p></li><li><p>project<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001119469-1357538208.png" alt=""></p></li></ul><h2 id="7-7、自建函数function"><a href="#7-7、自建函数function" class="headerlink" title="7.7、自建函数function"></a>7.7、自建函数function</h2><ul><li><p>包装普通函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">g_Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> g_Minus<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>包装模板函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>T <span class="token function">g_Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> g_Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>包装lambda表达式</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> g_Minus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>int main()<br>{<br>    function&lt;int(int, int)&gt; f = g_Minus;<br>    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1<br>    return 1;<br>}</p><pre><code>* 包装函数对象**非模板类型：**```cppstruct Minus{    int operator() (int i, int j)    {        return i - j;    }};int main(){    function&lt;int(int, int)&gt; f = Minus();    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1    return 1;}</code></pre><p><strong>模板类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> Minus<span class="token punctuation">{</span>    T <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>包装类静态成员函数</li><li><em>非模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>模板类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>    <span class="token keyword">static</span> T <span class="token function">Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>包装类对象成员函数</li><li><em>非模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">int</span> <span class="token function">Minus</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   Math m<span class="token punctuation">;</span>   function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Math<span class="token operator">::</span>Minus<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token operator">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// -1</span>   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><em>模板类型：*</em><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Math</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>   T <span class="token function">Minus</span><span class="token punctuation">(</span>T i<span class="token punctuation">,</span> T j<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>int main()<br>{<br>    Math m;<br>    function&lt;int(int, int)&gt; f = bind(&amp;Math::Minus<int>, &amp;m, placeholders::_1, placeholders::_2);<br>    cout &lt;&lt; f(1, 2) &lt;&lt; endl;                                            // -1<br>    return 1;<br>}</p><pre><code># 第x章：匿名函数（lambda）* 格式： [](){};</code></pre><p>[ ](int val){ cout &lt;&lt; val “”; }<br>//匿名函数  lambda表达式  <a href=""></a>{};<br>for_each(v.begin(), v.end(), [](int val) { cout &lt;&lt; val &lt;&lt; “ “; });</p><pre><code>* 捕获：需要捕获的参数放置在[ ]中！！！```[a](int b){return a+b;}```[ ]中为需要捕获的参数，一般存在与函数体中！！！* 传参放置在（）中：```cpppint a = 45;int sum = [a](int b){return a+b;};cout &lt;&lt; sum (14)&lt;&lt; endl;</code></pre><p>注意：<br>捕获参数a需自己定义，调用函数不需写明！<br>而传参需要调用函数传入进去！！！<br>( )中一般使用的是容器中的元素。   </p><pre class="line-numbers language-cpp"><code class="language-cpp">eg<span class="token operator">:</span>string ss<span class="token punctuation">;</span><span class="token keyword">float</span> f<span class="token punctuation">;</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span>m<span class="token punctuation">;</span>vecot<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span>v<span class="token punctuation">;</span><span class="token keyword">auto</span> pt<span class="token operator">=</span><span class="token function">find_if</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ss<span class="token punctuation">]</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span>ps<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> ps<span class="token punctuation">.</span>second<span class="token operator">==</span>ss<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pt<span class="token operator">=</span><span class="token function">find_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">float</span> fa<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> fa <span class="token operator">==</span> f<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>lambda表达式语法定义</li></ul><p>lambda表达式的语法定义如下：<br><code>[capture] （parameters） mutable -&gt;return-type {statement};</code></p><ol><li><p>[capture]: 捕捉列表。捕捉列表总是出现在lambda函数的开始处。实质上，[]是lambda引出符（即独特的标志符）<br>　　编译器根据该引出符判断接下来的代码是否是lambda函数<br>　　捕捉列表能够捕捉上下文中的变量以供lambda函数使用<br>　　捕捉列表由一个或多个捕捉项组成，并以逗号分隔，捕捉列表一般有以下几种形式：   </p><ul><li><p>[]：默认不捕获任何变量；</p></li><li><p>[=]：默认以值捕获所有变量；</p></li><li><p>[&amp;]：默认以引用捕获所有变量；</p></li><li><p>[x]：仅以值捕获x，其它变量不捕获；</p></li><li><p>[&amp;x]：仅以引用捕获x，其它变量不捕获；</p></li><li><p>[=, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；</p></li><li><p>[&amp;, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；</p></li><li><p>[this]：通过引用捕获当前对象（其实是复制指针）；</p></li><li><p>[*this]：通过传值方式捕获当前对象；</p><p>　　- &lt;1&gt; [var] 表示值传递方式捕捉变量var</p><ul><li>&lt;2&gt; [=] 表示值传递方式捕捉所有父作用域的变量（包括this指针） 【即该作用域中说所有的变量】</li><li>&lt;3&gt; [&amp;var] 表示引用传递捕捉变量var</li><li>&lt;4&gt; [&amp;] 表示引用传递捕捉所有父作用域的变量（包括this指针）<pre><code>  讲解一下使用&amp;的作用</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">5678</span><span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> f<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>k<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">return</span> i<span class="token operator">+</span>j<span class="token operator">+</span>k<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>k<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  输出为：1234，记住，当生命lambda声明时，参数已经捕获完毕，即i为值传递，不可改变，j,k为引用传递，可以改变，故最终传入的参数为：  i=1234, j=2, k=3;</code></pre>　　- &lt;5&gt; [this] 表示值传递方式捕捉当前的this指针,    当要使用类成员时，不能使用[=]进行捕获，需使用[this]来捕获      <ul><li>&lt;6&gt; [=，&amp;a，&amp;b] 表示以引用传递的方式捕捉变量 a 和 b，而以值传递方式捕捉其他所有的变量  </li><li>&lt;7&gt; [&amp;，a，this] 表示以值传递的方式捕捉 a 和 this，而以引用传递方式捕捉其他所有变量   <pre><code>备注：父作用域是指包含lambda函数的语句块{ }    </code></pre>  另外，需要注意的是，捕捉列表不允许变量重复传递。下面的例子就是典型的重复，会导致编译错误：<br>  [=， a] 这里 = 已经以值传递方式捕捉了所有的变量，那么再捕捉 a 属于重复<br>  [&amp;，&amp;this] 这里 &amp; 已经以引用传递方式捕捉了所有变量，那么再捕捉 this 属于重复   </li></ul></li></ul></li></ul></li><li><p>parameters）:参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号（）一起省略</p></li><li><p>mutable : mutable修饰符。默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性（后面有详解）在使用该修饰符时，参数列表不可省略（即使参数为空）</p></li><li><p>-&gt;return-type : 返回类型。用追踪返回类型形式声明函数的返回类型。　出于方便，不需要返回值的时候也可以连同符号-&gt;一起省略　　此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导</p></li><li><p>{statement} : 函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量,在lambda函数的定义中，参数列表和返回类型都是可选的部分，而捕捉列表和函数体都可能为空<br>那么，在极端情况下，C++11中最为简单的lambda函数只需要声明为：　[] {};</p><ul><li><p>当使用多个捕获时：<br>  当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。<br>  当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了&amp;），则显式捕获命名变量必须采用值方式，因此不能在其名字前使用&amp;。类似的，如果隐式捕获采用的是值方式（使用了=），则显式捕获命名变量必须采用引用方式，即，在名字前使用&amp;。<br>  默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表：<br>  <code>auto f=[v1]()mutable{return ++vl;};</code></p></li><li><p>声明返回类型：<br>默认返回为void类型，当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型；<br><code>[](int i)-&gt;int{if (i&lt;0)return-i;else return i;}</code></p></li></ul></li></ol><h1 id="第八章：配接器（adapters）"><a href="#第八章：配接器（adapters）" class="headerlink" title="第八章：配接器（adapters）"></a>第八章：配接器（adapters）</h1><h2 id="8-1、配接器之概观与分类"><a href="#8-1、配接器之概观与分类" class="headerlink" title="8.1、配接器之概观与分类"></a>8.1、配接器之概观与分类</h2><ul><li><p>应用于容器，container adapters</p></li><li><p>应用于迭代器，iterator adapters<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001308017-749591728.png" alt=""></p></li><li><p>应用于仿函数，functor adapters<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001318958-461090507.png" alt=""></p></li></ul><h2 id="8-2、container-adapters"><a href="#8-2、container-adapters" class="headerlink" title="8.2、container adapters"></a>8.2、container adapters</h2><ul><li><p>stack<br>stack的底层由deque构成。从以下接口可清楚看出stack与deque的关系：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{</span><span class="token keyword">protected</span>：Sequence c；<span class="token comment" spellcheck="true">//底层容器</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>queue<br>queue的底层由deque构成。从以下接口可清楚看出queue与deque的关系：   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">=</span>deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">queue</span><span class="token punctuation">{</span><span class="token keyword">protected</span>：Sequence c；<span class="token comment" spellcheck="true">//底层容器</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="8-3、iterator-adapters"><a href="#8-3、iterator-adapters" class="headerlink" title="8.3、iterator adapters"></a>8.3、iterator adapters</h2><ul><li><p>insert iterators</p></li><li><p>reverse iterators<br>所谓 reverse iterator，就是将迭代器的移动行为倒转。如果STL算法接受的不是一般正常的迭代器，而是这种逆向迭代器，它就会以从尾到头的方向来处理序列中的元素。例如：<br>//将所有元素逆向拷贝到ite所指位置上<br>//rbegin（）和rend（）与reverse_iterator有关copy（id.rbegin（），id.rend（），ite）；看似单纯，实现时却大有文章。  </p></li><li><p>stream iterators<br>所谓 stream iterators，可以将迭代器绑定到一个stream（数据流）对象身上。<br>绑定到istream对象（例如std:：cin）者，称为istream iterator，拥有输人能力；<br>绑定到ostream对象（例如std:：cout）者，称为ostream_iterator，拥有输出能力。   </p></li></ul><h2 id="8-4、function-adapters"><a href="#8-4、function-adapters" class="headerlink" title="8.4、function adapters"></a>8.4、function adapters</h2><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225001339871-20879902.png" alt=""></p><ul><li>对返回值进行逻辑否定：not1，not2</li><li>对参数进行绑定：bindls t，bind2nd</li><li>用于函数合成：compose1，compose2 </li><li>用于函数指针：ptr_fun</li></ul><p>定义一个函数指针类型。<br>比如你有三个函数：   </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"你好!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">bye</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"再见！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"好的！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>typdef void (*funcptr)(void);</code><br><code>typede[函数返回类型][*函数指针名][函数参数类型]</code><br>这样就构造了一个通用的函数<br>你用的时候可以这样：  </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>funcptr words<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&amp;</span>hello<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bye<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ok<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将函数指针存入</span>funcptr fun <span class="token operator">=</span> words<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>就会显示“你好！”；<span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>就会显示“再见！”；<span class="token function">speak</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>就会显示“好的！”<span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sayHelloPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> sayHello<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//其中，括号是必不可少的</span>    <span class="token punctuation">(</span><span class="token operator">*</span>sayHelloPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于成员函数指针：memfun，mem fun_ref</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《STL源码剖析》（第五、六章：关联容器与算法）</title>
      <link href="/2019/12/24/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-wu-liu-zhang-guan-lian-rong-qi-yu-suan-fa/"/>
      <url>/2019/12/24/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-wu-liu-zhang-guan-lian-rong-qi-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章、关联容器"><a href="#第五章、关联容器" class="headerlink" title="第五章、关联容器"></a>第五章、关联容器</h1><h2 id="5-0、关联容器"><a href="#5-0、关联容器" class="headerlink" title="5.0、关联容器"></a>5.0、关联容器</h2><ul><li><p>标准的STL关联式容器分为set（集合）和map（映射表）两大类，以及这两大类的衍生体multiset（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。</p></li><li><p>SGISTL还提供了一个不在标准规格之列的关联式容器：hash_table（散列表），以及以此hash_table为底层机制而完成的hash_set（散列集合）、hash_map（散列映射表）、hash_multiset（散列多键集合）、hash_multimap（散列多键映射表）。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235640834-174846146.png" alt=""></p></li><li><p>所谓关联式容器，观念上类似关联式数据库：每笔数据（每个元素）都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器内部结构（可能是RB-tree，也可能是hash-table）便依照其键值大小，以某种特定规则将这个元素放置于适当位置。关联式容器没有所谓头尾（只有最大元素和最小元素），所以不会有所谓 push_back()、push_front()、pop_back()、pop_front()、begin()【即无法通过*.begin()取出数据】、endt()这样的操作行为。</p></li></ul><h2 id="5-1、树的导览"><a href="#5-1、树的导览" class="headerlink" title="5.1、树的导览"></a>5.1、树的导览</h2><p>即讲解数据结构中的二叉树、二叉搜索树、平衡二叉树。。。</p><h2 id="5-2、RB-tree（红黑树）"><a href="#5-2、RB-tree（红黑树）" class="headerlink" title="5.2、RB-tree（红黑树）"></a>5.2、RB-tree（红黑树）</h2><h3 id="红黑树定义及其特性"><a href="#红黑树定义及其特性" class="headerlink" title="红黑树定义及其特性"></a>红黑树定义及其特性</h3><ol><li>每个节点或是黑色或是红色 </li><li>根节点是黑色 </li><li>每个叶节点是黑色（叶节点为空节点） </li><li>如果一个节点是红色，则它的两个子节点必须是黑色 </li><li>从任意的一个节点到该节点的所有叶节点的路径包含相同数目的黑色节点</li><li>红黑树是一种平衡二叉树，当不是完全的平衡二叉树，红黑树只要求最多三次旋转来尽可能达到平衡<br> 【也就是说没有规定左子树与右子树的高度差必须&lt;=1!!!!!!】</li></ol><ul><li>迭代器</li><li><em>operator++*</em><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235713829-442804034.png" alt=""></li></ul><p><strong>operator–</strong><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235737458-1520435092.png" alt=""></p><p><strong>自身迭代器</strong><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235806708-1498398018.png" alt=""></p><p>关于红黑树的具体数据结构，请看<a href="http://zzw1024.top/2019/12/22/hong-hei-shu/" target="_blank" rel="noopener"><strong>博文</strong></a></p><h2 id="5-3、-set"><a href="#5-3、-set" class="headerlink" title="5.3、 set"></a>5.3、 set</h2><ul><li>set底层是由红黑树构造的 </li><li>set key值不能重复</li><li>set中的key值不允许改变</li><li>STL特别提供了一组set/multiset相关算法，包括交集set_intersection、联集set_union、差集 set_difference、对称差集set_symmetric_difference。</li></ul><h2 id="5-4、map"><a href="#5-4、map" class="headerlink" title="5.4、map"></a>5.4、map</h2><ul><li>map不可以通过迭代器修改键值，但可以修改实值</li><li>map拥有list的某些性质：即增删改查其迭代器不会失效</li><li>map几乎是在调用RBTree的接口函数</li><li>map底层仍然是红黑树构造的</li></ul><h2 id="5-5、multiset"><a href="#5-5、multiset" class="headerlink" title="5.5、multiset"></a>5.5、multiset</h2><ul><li>与set一样，只不过是允许键值存在重复</li></ul><h2 id="5-6、multimap"><a href="#5-6、multimap" class="headerlink" title="5.6、multimap"></a>5.6、multimap</h2><p>与map一样，但允许键值重复</p><h2 id="5-7-、hashtable"><a href="#5-7-、hashtable" class="headerlink" title="5.7 、hashtable"></a>5.7 、hashtable</h2><ul><li>详细讲解请见<a href="http://zzw1024.top/2019/12/23/hash-biao-xiang-jie/" target="_blank" rel="noopener"><strong>博文</strong></a>      </li><li>hashtable没有向后的迭代器operator–()</li></ul><h2 id="5-8、hash-set"><a href="#5-8、hash-set" class="headerlink" title="5.8、hash_set"></a>5.8、hash_set</h2><p>hash_set拥有set的功能，底层使用的是hashtable，且不排序</p><h2 id="5-9、hash-map"><a href="#5-9、hash-map" class="headerlink" title="5.9、hash_map"></a>5.9、hash_map</h2><p>hash_map拥有map的功能，但底层是由hashtable组成的，且无排序功能</p><h2 id="5-10、hash-multiset"><a href="#5-10、hash-multiset" class="headerlink" title="5.10、hash_multiset"></a>5.10、hash_multiset</h2><ul><li>与multiset功能完全相同，其底层换成了hashtable</li><li>与hash_set的区别就是可以键值重复</li></ul><h2 id="5-11、-hash-multimap"><a href="#5-11、-hash-multimap" class="headerlink" title="5.11、 hash_multimap"></a>5.11、 hash_multimap</h2><p>hash_multimap与multimap的功能完全类似，但底层是以hashmap基本</p><h1 id="第六章-算法algorithms"><a href="#第六章-算法algorithms" class="headerlink" title="第六章 算法algorithms"></a>第六章 算法algorithms</h1><h2 id="6-1、概述"><a href="#6-1、概述" class="headerlink" title="6.1、概述"></a>6.1、概述</h2><ul><li><p>算法的五大特征如下：</p><ul><li>有穷性（Finiteness）。算法的有穷性是指算法必须能在执行有限个步骤之后终止；</li><li>确切性(Definiteness)。算法的每一步骤必须有确切的定义；</li><li>输入项(Input)。一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；</li><li>输出项(Output)。一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；</li><li>可行性(Effectiveness)。算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）。</li></ul></li><li><p>时间复杂度<br>时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为O(n)），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于常数时间内的操作（对应时间复杂度O(1)）。</p></li></ul><p>在化简某算法时间复杂度表达式时需遵循以下规则：<br>对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如O(n^2)+O(n)可化简为O(n^2)，O(n)+O(1)可化简为O(n)<br>可省去样本量前的常量系数，如O(2n)可化简为O(n)，O(8)可化简为O(1),对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如O(logm)+O(n^2)不能化简为O(n^2)或O(logm)。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为O(logm)，因为表达式增量是由样本量决定的。</p><ul><li><p>额外空间复杂度<br>算法额外空间复杂度指的是对于输入样本，经过算法操作需要的额外空间。比如使用冒泡排序对一个数组排序，期间只需要一个临时变量temp，那么该算法的额外空间复杂度为O(1)。又如归并排序，在排序过程中需要创建一个与样本数组相同大小的辅助数组，尽管在排序过后该数组被销毁，但该算法的额外空间复杂度为O(n)。</p></li><li><p>算法：<br>算法主要是由头文件<algorithm> <functional> <numeric>组成。<br><algorithm>是所有 STL 头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等…<br><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.<br><functional> 定义了一些模板类,用以声明函数对象。          </p></li><li><p>STL算法概况</p></li><li><p><em>质变指定是算法的稳定性*</em><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235934523-639435368.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191224235940226-890758197.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000001776-1055970874.png" alt=""><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000010021-477313739.png" alt=""></p></li><li><p>质变的算法——会改变操作对象之值<br>所有的STL算法都作用在由迭代器[first，last）所标示出来的区间上。所谓“质变算法”，是指运算过程中会更改区间内（迭代器所指）的元素内容。诸如拷贝（copy）、互换（swap）、替换（replace）、填写（fill）、删除（remove）、排列组合（permutation）、分割（partition）、随机重排（random shuffling）、排序（sort）等算法，都属此类。</p></li><li><p>不质变的算法——不改变操作对象之值<br>所有的STL算法都作用在由迭代器[first，last）所标示出来的区间上。所谓“非质变算法”，是指运算过程中不会更改区间内（迭代器所指）的元素内容。<br>诸如查找（find）、匹配（search）、计数（count）、巡访（for_each）、比较（equal，mismatch）、寻找极值（max，min）等算法，都属此类。但是如果你在for_each（巡访每个元素）算法身上应用一个会改变元素内容的仿函数（functor）。   </p></li></ul><h2 id="6-2、算法的泛化过程"><a href="#6-2、算法的泛化过程" class="headerlink" title="6.2、算法的泛化过程"></a>6.2、算法的泛化过程</h2><ul><li>算法函数传参最好是传引用参数，这样可以避免由于对象的庞大而付出大的代价</li><li>这样的find（）很好，几乎适用于任何容器——只要该容器允许指针指入，而指针们又都支持以下四种find（）函数中出现的操作行为：<ul><li>inequality（判断不相等）操作符</li><li>dereferencelm（提领，取值）操作符</li><li>prefix increment（前置式递增）操作符</li><li>copy（复制）行为（以便产a’x生函数的返回值）</li></ul></li></ul><h2 id="6-3、数值算法"><a href="#6-3、数值算法" class="headerlink" title="6.3、数值算法"></a>6.3、数值算法<stl numeric.h></h2><ul><li><p>头文件<numeric><br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000202562-1209119902.png" alt="">    </p></li><li><p>accumlate<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000222791-1493346367.png" alt=""></p></li></ul><p>算法accumulate用来计算init和[first，last）内所有元素的总和。注意，你一定得提供一个初始值init，这么做的原因之一是当[first，last）为空区间时仍能获得一个明确定义的值。如果希望计算[first，1ast）中所有数值的总和，应该将init设为0.</p><ul><li>adjacent_difference<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000240388-361851450.png" alt=""></li></ul><p>算法adjacent_difference用来计算[first，last）中相邻元素的差额。也就是说，它将<em>first 赋值给</em>result，并针对[first+1，last）内的每个迭代器i，将<em>i-</em>（i-1）之值赋值给*（result+（i-first））。<br>注意，你可以采用就地（in place）运算方式，也就是令result等于first。</p><ul><li><p>inner_product<br>算法inner_product能够计算[first1，last1）和[first2，first2+<br>（1ast1-first1））的一般内积（generalized inner product）。注意，你一定得提供初值init。这么做的原因之一是当[first，last）为空时，仍可获得一个明确定义的结果。如果你想计算两个vectors的一般内积，应该将init设为0.</p></li><li><p>partical_sum<br>算法partial_sum用来计算局部总和。它会将<em>first赋值给</em>result，将<em>first和</em>（first+1）的和赋值给*（result+1），依此类推。注意，result可以等于first，这使我们得以完成就地（in place）计算。在这种情况下它是一个质变算法（mutating algorithm）。</p></li></ul><p>运算中的总和首先初始为*first，然后赋值给<em>result。对于<br>[first+1，last）中每个迭代器i，从头至尾依序执行sum=sum+</em>i（第一版本）或sum=binary_op（sum，<em>i）（第二版本），然后再将sum赋值给</em>（result+（i-first））。此式所用之二元仿函数不必满足交换律（commutative）和结合律（associative）。所有运算行为的顺序都有明确设定。<br>本算法返回输出区间的最尾端位置：result+（last-first）。</p><ul><li><p>power<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000323728-288517597.png" alt=""></p></li><li><p>itoa<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000336197-1995376542.png" alt=""></p></li></ul><h2 id="6-4、基本算法"><a href="#6-4、基本算法" class="headerlink" title="6.4、基本算法"></a>6.4、基本算法<stl algobase.h></h2><ul><li><p>for_each</p></li><li><p>equal</p></li><li><p>fill</p></li><li><p>fill_n</p></li><li><p>iter_swap</p></li><li><p>lexicographical_compare</p><ul><li>以“字典排列方式”对两个序列[first1，last1）和tfirst2，1ast2）进行比较。比较操作针对两序列中的对应位置上的元素进行，并持续直到<ul><li>（1）某一组对应元素彼此不相等；</li><li>（2）同时到达1ast1和last2（当两序列的大小相同）；</li><li>（3）到达1ast1或last2（当两序列的大小不同）。</li></ul></li></ul></li><li><p>当这个函数在对应位置上发现第一组不相等的元素时，有下列几种可能：</p><ul><li>如果第一序列的元素较小，返回true.否则返回false。</li><li>如果到达last1而尚未到达last2，返回true。</li><li>如果到达last2而尚未到达last1，返回false。</li><li>如果同时到达last1和last2（换句话说所有元素都匹配），返回false；</li></ul></li><li><p>max</p></li><li><p>min</p></li><li><p>mism atch</p></li></ul><p>用来平行比较两个序列，指出两者之间的第一个不匹配点。返回一对迭代器，分别指向两序列中的不匹配点，如下图。如果两序列的所有对应元素都匹配，返回的便是两序列各自的last迭代器。缺省情况下是以equality操作符来比较元素；但第二版本允许用户指定比较操作。如果第二序列的元素个数比第一序列多，多出来的元素忽略不计。如果第二序列的元素个数比第一序列少，会发生未可预期的行为。</p><ul><li>swap</li><li>copy<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000358486-2111604671.png" alt=""></li></ul><h2 id="6-5、set相关算法"><a href="#6-5、set相关算法" class="headerlink" title="6.5、set相关算法"></a>6.5、set相关算法</h2><p>STL一共提供了四种与set（集合）相关的算法，分别是并集（union）、交集（intersection）、差集（difference）、对称差集（symmetric difference）。</p><h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><p>算法set_union可构造s1、s2之并集。也就是说，它能构造出集合s1Us2，此集合内含s1或s2内的每一个元素。s1、s2及其并集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此，如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现max（m，n）次，其中n个来自s1，其余来自s2。</p><p>set_union 是一种稳定（stable）操作，意思是输入区间内的每个元素的相对顺序都不会改变。set-union有两个版本，差别在于如何定义某个元素小于另一个元素。</p><h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><p>算法 set_intersection可构造s1、s2之交集。也就是说，它能构造出集合s1 n s2，此集合内含同时出现于s1和s2内的每一个元素。s1、s2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现min（m，n）次，并且全部来自s1。</p><p>set_intersection 是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和s1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。</p><h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><p>算法 set_difference可构造s1、s2之差集。也就是说，它能构造出集合s1-s2，此集合内含“出现于s1但不出现于s2”的每一个元素。s1、s2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现max（n-m，0）次，并且全部来自S1。</p><h3 id="set-difference-1"><a href="#set-difference-1" class="headerlink" title="set_difference"></a>set_difference</h3><p>是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和S1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p><h3 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h3><p>算法setsymmetric_difference 可构造s1、s2之对称差集。也就是说，它能构造出集合（S1-S2）U（S2-S1），此集合内含“出现于s1但不出现于s2”<br>以及“出现于s2但不出现于s1”的每一个元素。S1、S2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于s1和s2内的每个元素都不需唯一，因此如果某个值在s1出现n次，在s2出现m次，那么该值在输出区间中会出现ln-ml次。如果n&gt;m，输出区间内的最后n-m个元素将由s1复制而来，如果n&lt; m则输出区间内的最后m-n个元素将由s2复制而来。在STL set容器内，m≤1且n&lt;=1。</p><p>setsymmetric_difference 是一种稳定（stable）操作，意思是输入区间内的元素相对顺序不会被改变。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operators进行比较，第二版本采用仿函数comp。</p><h2 id="6-6、heap算法"><a href="#6-6、heap算法" class="headerlink" title="6.6、heap算法"></a>6.6、heap算法</h2><h2 id="6-7、其它算法"><a href="#6-7、其它算法" class="headerlink" title="6.7、其它算法"></a>6.7、其它算法</h2><p>深入源代码之前，先观察每一个算法的表现，是个比较好的学习方式。以下程序示范本节每一个算法的用法。程序中有时使用STL内建的仿函数（functors，如less，greater，equeal_to）和配接器（adapters，如bind2nd），有时使用自定义的仿函数（如display，even_by_two）。</p><ul><li><p>adjacent find<br>找出第一组满足条件的相邻元素。这里所谓的条件，在版本一中是指“两元素相等”，在版本二中允许用户指定一个二元运算，两个操作数分别是相邻的第一元素和第二元素。</p></li><li><p>count<br>运用equality操作符，将[first，last）区间内的每一个元素拿来和指定值value比较，并返回与value相等的元素个数。</p></li><li><p>count_if<br>将指定操作（一个仿函数）pred实施于[first，1ast）区间内的每一个元素身上，并将“造成pred之计算结果为true”的所有元素的个数返回。</p></li><li><p>find</p></li><li><p>find it</p></li><li><p>find_end</p></li><li><p>find_first of</p></li><li><p>for_each</p></li><li><p>generate</p></li><li><p>generate_n</p></li><li><p>includes（应用于有序区间）</p></li><li><p>max element</p></li><li><p>merge（应用于有序区间）</p></li><li><p>min_element</p></li><li><p>partition</p></li></ul><p>partition 会将区间[first，last）中的元素重新排列。所有被一元条件运算pred判定为true的元素，都会被放在区间的前段，被判定为false的元素，都会被放在区间的后段。这个算法并不保证保留元素的原始相对位置。如果需要保留原始相对位置，应使用stable_partition。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000454758-820817564.png" alt=""></p><ul><li><p>remove移除（但不删除）<br>移除[first，1ast）之中所有与value相等的元素。这一算法并不真正从容器中删除那些元素（换句话说容器大小并未改变），而是将每一个不与value相等（也就是我们并不打算移除）的元素轮番赋值给first之后的空间。返回值Fonwarditerator 标示出重新整理后的最后元素的下一位置。<br>例如序列<br>{0，1，0，2，0，3，0，4]，如果我们执行remove（），希望移除所有0值元素，执行结果将是{1，23，4，0，3.0.4]。每一个与0不相等的元素，1，2，3，4，分别被拷贝到第一、二、三、四个位置上。第四个位置以后不动，换句话说是第四个位置之后是这一算法留下的残余数据。返回值Forwardlterator 指向第五个位置。如果要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase（）member function。注意，array 不适合使用remove（）和remove_if（），因为array无法缩小尺寸，导致残余数据永远存在。对array而言，较受欢迎的算法是remove_copy（）和</p></li><li><p>remove_copy</p></li><li><p>remove_if</p></li><li><p>remove_copy.if</p></li><li><p>replace</p></li><li><p>replace_copy</p></li><li><p>replace if</p></li><li><p>replace_copy._if</p></li><li><p>reverse</p></li><li><p>reverse_copy</p></li><li><p>rotate<br>将[first，middle）内的元素和[middle，last）内的元素互换。middle所指的元素会成为容器的第一个元素。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191225000526836-1762719892.png" alt=""></p></li><li><p>rotate_copy</p></li><li><p>search</p></li><li><p>search_n</p></li></ul><p>在序列[first，last）所涵盖的区间中，查找“连续count个符合条件之元素”所形成的子序列，并返回一个迭代器指向该子序列起始处。如果找不到这样的子序列，就返回迭代器last。上述所谓的“某条件”，在search_n版本一指的是相等条件“equality”，在search_n版本二指的是用户指定的某个二元运算（以仿函数呈现）。</p><p>例如，面对序列{10，8，8，7，2，8，7，2，2，8，7，0}，查找“连续两个8”所形成的子序列起点，可以这么写：<br>iter1 = search_n（iv.begin（），iv.end（），2，8）；</p><p>查找“连续三个小于8的元素”所形成的子序列起点，可以这么写：<br>iter2 = search_n（iv.begin（），iv.end（），3，8，1ess&lt; int &gt;（）；</p><ul><li><p>swap_ranges</p></li><li><p>transform</p></li><li><p>unique</p></li><li><p>unique_copy</p></li><li><p>lower_bound（应用于有序区间）<br>这是二分查找（binary search）的一种版本，试图在已排序的（first，last）中寻找元素value。如果[first，last）具有与value相等的元素（s），便返回一个迭代器，指向其中第一个元素。如果没有这样的元素存在，便返回“假设这样的元素存在时应该出现的位置”。也就是说，它会返回一个迭代器，指向第一个“不小于value”的元素。如果value大于[first，last）内的任何一个元素，则返回last。以稍许不同的观点来看1ower_bound，其返回值是“在不破坏排序状态的原则下，可插入value的第一个位置”。 </p></li><li><p>upper_bound（应用于有序区间）<br>算法upper_bound是二分查找（binary search）法的一个版本。它试图在已排序的[first，last）中寻找value。更明确地说，它会返回“在不破坏顺序的情况下，可插入value的最后一个合适位置”。</p></li><li><p>binary_search（应用于有序区间）<br>算法binary_search 是一种二分查找法，试图在已排序的[first，last）中寻找元素value。如果[first，last）内有等同于value的元素，便返回true，否则返回false。</p></li></ul><p>返回单纯的bool或许不能满足你，前面所介绍的lower_bound和upper_bound能够提供额外的信息。事实上binary_search便是利用lower_bound先找出“假设value存在的话，应该出现的位置”，然后再对比该位置上的值是否为我们所要查找的目标，并返回对比结果。</p><ul><li>next_permutation<br>STL提供了两个用来计算排列组合关系的算法，分别是nextpermucation和 prev_permutation。首先我们必须了解什么是“下一个”排列组合，什么是“前一个”排列组合。</li></ul><p>考虑三个字符所组成的序列（a，b，c）。这个序列有六个可能的排列组合：abc，acb，bac，bca，cab，cba。这些排列组合根据less-than操作符做字典顺序（lexicographical）的排序。也就是说，abc名列第一，因为每一个元素都小于其后的元素。</p><p>next_permutation（）会取得[first，last）所标示之序列的下一个排列组合。如果没有下一个排列组合，便返回false；否则返回true。</p><ul><li><p>prev_permutation<br>所谓“前一个”排列组合，其意义已在上一节阐述。实际做法简述如下，其中所用的符号如图6-8所示。首先，从最尾端开始往前寻找两个相邻元素，令第一元素为<em>i，第二元素为</em>ii，且满足*i&gt;*ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个小于*i的元素，令为*j，将i，j元素对调，再将ii之后的所有元素颠倒排列。此即所求之“前一个”排列组合。</p></li><li></li><li><p>random_shufle<br>这个算法将[first，last）的元素次序随机重排。也就是说，在N！种可能的元素排列顺序中随机选出一种，此处N为last-first。</p></li></ul><p>N个元素的序列，其排列方式有N！种，random_shuffle会产生一个均匀分布，因此任何一个排列被选中的机率为1/N！。这很重要，因为有不少算法在其第一阶段过程中必须获得序列的随机重排，但如果其结果未能形成“在N！个可能排列上均匀分布（uniform distribution）”，便很容易造成算法的错误。</p><ul><li><p>partial_sort/partial_sort<br>本算法接受一个middle 迭代器（位于序列[first，last）之内），然后重新安排[first，last），使序列中的middle-first个最小元素以递增顺序排序，置于（first，middle）内。其余1ast-middle个元素安置于[middle，last）中，不保证有任何特定顺序。</p></li><li><p>sort<br>STL的sort 算法，数据量大时采用Quick Sort，分段递归排序。<br>一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷（overhead），就改用Insertion Sort。<br>如果递归层次过深，还会改用Heap Sort。</p></li><li><p>equal_range（应用于有序区间）<br>算法equal_range是二分查找法的一个版本，试图在已排序的[first，last）中寻找value。它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即1ower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound）。因此，[i，j）内的每个元素都等同于value，而且[i，j）是(first，last)之中符合此一性质的最大子区间。<br>于是，算法lower_bound返回区间A的第一个迭代器，算法upper_bound返回区间A的最后元素的下一位置，算法equalrange则是以pair的形式将两者都返回。</p></li><li><p>inplace_merge（应用于有序区间）<br>如果两个连接在一起的序列[first，middle）和[middle，last）都已排序，那么inplacemerge可将它们结合成单一一个序列，并仍保有序性（sorted）。</p></li></ul><p>如果原先两个序列是递增排序，执行结果也会是递增排序，如果原先两个序列是递减排序，执行结果也会是递减排序。</p><p>和merge一样，inplace_merge也是一种稳定（stable）操作。每个作为数据来源的子序列中的元素相对次序都不会变动；如果两个子序列有等同的元素，第一序列的元素会被排在第二序列元素之前。</p><ul><li>nth_element<br>这个算法会重新排列[first，last），使迭代器nth所指的元素，与“整个<br>[first，1ast）完整排序后，同一位置的元素”同值。此外并保证（nth，last）内没有任何一个元素小于（更精确地说是不大于）[first，nth）内的元素，但对于[first，nth）和[nth，last）两个子区间内的元素次序则无任何保证一—这一点也是它与partial_sort很大的不同处。以此观之，nth_element比较近似partition 而非 sort 或 partial_sort。</li></ul><p>例如，假设有序列{22，30，30，17，33，40，17，23，22，12，20}，以下操作：<br>nth_element(iv.begin()，iv.begin()+5，iv.end())；便是将小于*(iv.begin()+5)(本例为40)的元素置于该元素之左，其余置于该元素之右，并且不保证维持原有的相对位置。获得的结果为{20，12，22，17，17，<br>22，23，30，30，33，40]。执行完毕后的5th个位置上的元素值22，与整个序列完整排序后{12，17，17，20，22，22，23，30，30，33，40]的5th个位置上的元素值相同。</p><ul><li>6.7.13 merge sort<br>以上的排序算法详见<a href="http://zzw1024.top/2019/12/23/shi-da-jing-dian-pai-xu-suan-fa/" target="_blank" rel="noopener"><strong>博文</strong></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《STL源码剖析》（第四章、序列容器）</title>
      <link href="/2019/12/22/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-si-zhang-xu-lie-rong-qi/"/>
      <url>/2019/12/22/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-si-zhang-xu-lie-rong-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="1、容器的概观与分类"><a href="#1、容器的概观与分类" class="headerlink" title="1、容器的概观与分类"></a>1、容器的概观与分类</h2><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111112044-1498089234.png" alt=""><br>所谓序列式容器，其中的元素都可序（ordered）【比如可以使用sort进行排序】，但未必有序（sorted）。C++语言本身提供了一个序列式容器array，STL另外再提供vector，list，deque，stack，queue，priority-queue 等等序列式容器。其中stack和queue由于只是将 deque 头换面而成，技术上被归类为一种配接器（adapter)。</p><h2 id="2、vector"><a href="#2、vector" class="headerlink" title="2、vector"></a>2、vector</h2><p>vector的数据安排以及操作方式，与array非常相似。两者的唯一差别在于空间的运用的灵活性。<br>array是静态空间，一旦配置了就不能改变；要换个大（或小）一点的房子，可以，一切琐细得由客户端自己来：首先配置一块新空间，然后将元素从旧址一一搬往新址，再把原来的空间释还给系统。<br>vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而一开始就要求一个大块头array了，我们可以安心使用vector，吃多少用多少。</p><h3 id="常用的源码："><a href="#常用的源码：" class="headerlink" title="常用的源码："></a>常用的源码：</h3><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111144693-777575451.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111148942-1191823589.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111153586-106686768.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111156636-189118959.png" alt=""></p><p><strong>注意：</strong></p><ul><li>size() &amp; captical：<br>表示已存储数据的大小，而capital则是内部开辟的空间的大小所以，在erase、pop_back、clear等删除操作，都不会使得其captial产生变化，只会变的就是size()</li></ul><h3 id="动态空间配置："><a href="#动态空间配置：" class="headerlink" title="动态空间配置："></a>动态空间配置：</h3><p>注意，所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。这是程序员易犯的一个错误，务需小心。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111220346-523302115.png" alt=""> </p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111228720-2046744508.png" alt=""></p><h3 id="insert-："><a href="#insert-：" class="headerlink" title="insert()："></a>insert()：</h3><p>insert()会根据需要插入元素的位置p以及p后面的元素个数与需要插入元素个数n进行比较，分两种情况进行插入<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111242126-1491471714.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111250514-499650255.png" alt=""></p><h3 id="emplace-back-VS-push-back-减少内存拷贝和移动"><a href="#emplace-back-VS-push-back-减少内存拷贝和移动" class="headerlink" title="emplace_back()  VS   push_back()减少内存拷贝和移动"></a>emplace_back()  VS   push_back()减少内存拷贝和移动</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> President<span class="token punctuation">{</span>    <span class="token function">President</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string <span class="token operator">&amp;&amp;</span> p_name<span class="token punctuation">,</span> std<span class="token operator">::</span>string <span class="token operator">&amp;&amp;</span> p_country<span class="token punctuation">,</span> <span class="token keyword">int</span> p_year<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p_name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">country</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p_country<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">year</span><span class="token punctuation">(</span>p_year<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I am being constructed.\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">President</span><span class="token punctuation">(</span>President<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">country</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>country<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">year</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>year<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I am being moved.\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    President<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> President<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>President<span class="token operator">></span> elections<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"emplace_back:\n"</span><span class="token punctuation">;</span>    elections<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"Nelson Mandela"</span><span class="token punctuation">,</span> <span class="token string">"South Africa"</span><span class="token punctuation">,</span> <span class="token number">1994</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>President<span class="token operator">></span> reElections<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\npush_back:\n"</span><span class="token punctuation">;</span>    reElections<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">President</span><span class="token punctuation">(</span><span class="token string">"Franklin Delano Roosevelt"</span><span class="token punctuation">,</span> <span class="token string">"the USA"</span><span class="token punctuation">,</span> <span class="token number">1936</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>emplace_back<span class="token operator">:</span>I am being constructed<span class="token punctuation">.</span>push_back<span class="token operator">:</span>I am being constructed<span class="token punctuation">.</span>I am being moved<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="merge-函数："><a href="#merge-函数：" class="headerlink" title="merge()函数："></a>merge()函数：</h3><pre><code>merge方式要注意三点：merge(vec1.begin(),vec1.end(),vec2.begin(),vec2.end(),vec3.begin());1. vec1,和vec2需要经过排序，merge只能合并排序后的集合，不然会报错。2. vec3需要指定好大小，不然会报错。3. merge的时候指定vec3的位置一定要从begin开始，如果指定了end，它会认为没有空间，当然，中间的位置我没有试，回头有空试一下。</code></pre><h2 id="3、list"><a href="#3、list" class="headerlink" title="3、list"></a>3、list</h2><p>相较于vector的连续线性空间，1ist就显得复杂许多，它的好处是每次插人或删除一个元素，就配置或释放一个元素空间。因此，list 对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插人或元素移除，list永远是常数时间。</p><p>由于STL1ist是一个双向链表（double linked-list），迭代器必须具备前移、后移的能力，所以1ist 提供的是Bidirectional lterators。</p><p>list 有一个重要性质：插入操作（insert）和接合操作（splice）都不会造成原有的list迭代器失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效。甚至1ist的元素删除操作（erase），也只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。<br>    <img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111347787-1579187860.png" alt=""> </p><ul><li>SGI list 是一个环状双向链表，它只需要一个指针就可以完整表现整个链表<br>  <img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111355799-334800690.png" alt=""></li></ul><h3 id="list链表的初始结构："><a href="#list链表的初始结构：" class="headerlink" title="list链表的初始结构："></a>list链表的初始结构：</h3><pre><code>    node-&gt;next = node;    node-&gt;prv = node;</code></pre><pre><code>![](https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111405617-453133763.png)</code></pre><h3 id="transfter-迁移函数"><a href="#transfter-迁移函数" class="headerlink" title=".transfter() //迁移函数"></a>.transfter() //迁移函数</h3><pre><code>```void transfer(iterator position, iterator first, iterator last);```将list2的first-last之间的元素插入到list1中的position中</code></pre><h3 id="splice-衔接函数"><a href="#splice-衔接函数" class="headerlink" title=".splice()  //衔接函数"></a>.splice()  //衔接函数</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;</span> other <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;&amp;</span> other <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;</span> other<span class="token punctuation">,</span> const_iterator it <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">,</span> const_iterator it <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;</span> other<span class="token punctuation">,</span> const_iterator first<span class="token punctuation">,</span> const_iterator last<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span> const_iterator pos<span class="token punctuation">,</span> list<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">,</span> const_iterator first<span class="token punctuation">,</span> const_iterator last <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从一个 list 转移元素给另一个。<br>不复制或移动元素，仅重指向链表结点的内部指针。若 get_allocator() != other.get_allocator() 则行为未定义。没有迭代器或引用被非法化,指向被移动元素的迭代器保持合法，但现在指代到 *this 中，而非到 other 中。</p><ol><li>从 other 转移所有元素到 *this 中。元素被插入到 pos 所指向的元素之前。操作后容器 other 变为空。若 other 与 *this 指代同一对象则行为未定义。</li><li>从 other 转移 it 所指向的元素到 *this 。元素被插入到 pos 所指向的元素之前。</li><li>从 other 转移范围 [first, last) 中的元素到 *this 。元素被插入到 pos 所指向的元素之前。若 pos 是范围 [first,last) 中的迭代器则行为未定义。<br>参数<br>pos            -    将插入内容到其前的元素<br>other        -    要自之转移内容的另一容器<br>it            -    要从 other 转移到 *this 的元素<br>first, last    -    要从 other 转移到 *this 的元素范围</li></ol><h3 id="merge"><a href="#merge" class="headerlink" title=".merge()"></a>.merge()</h3><pre class="line-numbers language-cpp"><code class="language-cpp">    c1<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//合并2个有序的链表并使之有序,从新放到c1里,释放c2。</span>    c1<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>c2<span class="token punctuation">,</span>comp<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//合并2个有序的链表并使之按照自定义规则排序之后从新放到c1中,释放c2。</span>    c1<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>beg<span class="token punctuation">,</span>c2<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//将c2连接在c1的beg位置,释放c2</span>    c1<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>beg<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c2<span class="token punctuation">.</span>beg<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//将c2的beg位置的元素连接到c1的beg位置，并且在c2中释放掉beg位置的元素</span>    c1<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>beg<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c2<span class="token punctuation">.</span>beg<span class="token punctuation">,</span>c2<span class="token punctuation">.</span>end<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//将c2的[beg,end)位置的元素连接到c1的beg位置并且释放c2的[beg,end)位置的元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并二个已排序链表为一个。链表应以升序排序。<br>不复制元素。操作后容器 other 变为空。若 other 与 *this 指代同一对象则函数不做任何事。若 get_allocator() != other.get_allocator() ，则行为未定义。没有引用和迭代器变得非法，除了被移动元素的迭代器现在指代到*this 中， 而非到 other 中，第一版本用 operator&lt; 比较元素，第二版本用给定的比较函数 comp 。<br>此操作是稳定的：对于二个链表中的等价元素，来自 *this 的元素始终前驱来自 other 的元素，而且 *this  和 other 的等价元素顺序不更改。<br>参数<br>    other    -    要交换的另一容器<br>    comp    -    比较函数对象（即满足比较 (Compare) 概念的对象），若第一参数小于（即先序于）第二参数则返回 ​true 。<br>    比较函数的签名应等价于如下：<br>     bool cmp(const Type1 &amp;a, const Type2 &amp;b);<br>    虽然签名不必有 const &amp; ，函数也不能修改传递给它的对象，而且必须接受（可为 const 的）类型 Type1 与 Type2的值，无关乎值类别（从而不允许 Type1 &amp; ，亦不允许 Type1 ，除非 Type1 的移动等价于复制 (C++11 起)）。<br>    类型 Type1 与 Type2 必须使得 list&lt;T,Allocator&gt;::const_iterator 类型的对象能在解引用后隐式转换到这两个类型。 ​</p><h2 id="4、deque"><a href="#4、deque" class="headerlink" title="4、deque"></a>4、deque</h2><p>deque和vector的最大差异:【vector与deque都可以随机读取】<br>一在于deque允许于常数时间内对起头端进行元素的插入或移除操作，<br>二在于deque没有所谓容量（capacity）观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</p><h3 id="中控器："><a href="#中控器：" class="headerlink" title="中控器："></a>中控器：</h3><p>deque是连续空间（至少逻辑上看来如此）。</p><p>deque系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。</p><p>deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。</p><p>deque采用一块所谓的map（注意，不是STL的map容器）作为主控。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。SGI STL允许我们指定缓冲区大小，默认值0表示将使用512bytes缓冲区。<br>当map的空间也不够后，会开辟另一个大的map空间<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111504070-550240525.png" alt=""></p><h3 id="迭代器："><a href="#迭代器：" class="headerlink" title="迭代器："></a>迭代器：</h3><p>deque是分段连续空间。维持其“整体连续”假象的任务，落在了迭代器的operator++和operator–两个运算子身上。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222111510713-2032044283.png" alt=""></p><h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><p>deque 除了维护一个先前说过的指向map的指针外，也维护 start，finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素（的下一位置）。此外，它当然也必须记住目前的map大小。因为一旦map所提供的节点不足，就必须重新配置更大的一块map。</p><p>什么时候map需要重新整治？这个问题的判断由 reserve_map_at_back（）和 reserve_map_at_front（）进行，实际操作则由reallocate_map（）执行;</p><p>一个deque对象包含四个成员变量，_M_map指向主控器，_M_map_size表示中控器的大小，能够容纳多少个指针，_M_start表示deque的迭代器，所有元素的起始位置，_M_finish表示deque的迭代器，所有元素的终止位置。<br>odeque的insert()操作：首先判断插入的地方是头或者尾，如果都不是则在调用一个名为insert_aux的辅助函数。此辅助函数通过判断当前的插入位置更靠近头端或者尾端。<br>odeque的+=操作：首先判断是否在同一级缓冲区区域，如果不在，在确定应该夸几个缓冲区，然后到相应的缓冲区后，再移动。</p><h2 id="5、stack"><a href="#5、stack" class="headerlink" title="5、stack"></a>5、stack</h2><ul><li><p>sack定义完整列表<br>deque是双向开口的数据结构，若以deque为底部结构并封闭其头端开口，便轻而易举地形成了一个stack。因此，SGI STL便以deque作为缺省情况下的stack底部结构，stack的实现因而非常简单，源代码十分简短，</p></li><li><p>stack没有迭代器</p></li><li><p>以list作为stack的底层容器</p></li></ul><h2 id="6、queue"><a href="#6、queue" class="headerlink" title="6、queue"></a>6、queue</h2><ul><li><p>queue定义完整列表<br>odeque是双向开口的数据结构，若以deque为底部结构并封闭其底端的出口和前端的入口，便轻而易举地形成了一个queue。因此，SGISTL便以deque作为缺省情况下的queue底部结构，queue的实现因而非常简单。</p></li><li><p>queue没有迭代器</p></li><li><p>以list作为queue的底层容器</p></li><li><p>优先队列<br>opriority_queue&lt;Type, Container, Functional&gt;</p></li></ul><h2 id="7、-heap（隐式表述，implicit-representation）【堆排序】"><a href="#7、-heap（隐式表述，implicit-representation）【堆排序】" class="headerlink" title="7、 heap（隐式表述，implicit representation）【堆排序】"></a>7、 heap（隐式表述，implicit representation）【堆排序】</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>heap并不归属于STL容器组件，它是个幕后英雄，扮演priority queue<br>的助手。顾名思义，priority queue允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高（也就是数值最高）的元素开始取。binary max heap正是具有这样的特性，适合作为priority queue的底层机制。</p><p>如果使用list作为priority queue的底层机制，元素插入操作可享常数时间。但是要找到list中的极值，却需要对整个list进行线性扫描。我们也可以改变做法，让元素插人前先经过排序这一关，使得list的元素值总是由小到大（或由大到小），但这么一来，收之东隅却失之桑榆：虽然取得极值以及元素删除操作达到最高效率，可元素的插入却只有线性表现。</p><p>以binary search tree作为priority queue的底层机制。这么一来，元素的插入和极值的取得就有O(logN）的表现。<br>但杀鸡用牛刀，未免小题大做，一来binary search tree的输入需要足够的随机性，二来binary search tree并不容易实现。priority queue的复杂度，最好介于queue和binary search tree 之间，才算适得其所。binary heap便是这种条件下的适当候选人。</p><p>binary heap就是一种 complete binary tree（完全二叉树）2，也就是说，整棵binary tree除了最底层的叶节点（s）之外，是填满的，而最底层的叶节点（s）由左至右又不得有空隙。【即是一棵完全搜索二叉树】</p><h3 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h3><ul><li>push_heap<br>实现的是堆排序中的插入操作<pre class="line-numbers language-CPP"><code class="language-CPP">//向上调整void  upAdjust(int L, int R){  int  i = R, j = (i - 1) / 2;//i为欲调整结点，j为其父亲  while (j >= L)  {      if (v[j] < v[i])//父节点小了，那么就将孩子节点调上来      {          swap(v[i], v[j]);          i = j;          j = (i - 1) / 2;//继续向上遍历      }      else//无需调整          break;  }}void insert(int  x){  v[n] = x;//将新加入的值放置在数组的最后，切记保证数组空间充足  upAdjust(0, n);//向上调整新加入的结点n}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h3><p>实现的是堆排序的删除操作</p><pre class="line-numbers language-CPP"><code class="language-CPP">//向下调整void downAdjust(int L, int R){    int i = L, j = 2 * L + 1;//i为父节点，j为左子节点    while (j <= R)    {        if (j + 1 <= R && v[j + 1] > v[j])//若有右节点，且右节点大，那么就选右节点,即选取最大的子节点与父节点对比            ++j;//选取了右节点        if (v[j] <= v[i])//孩子节点都比父节点小，满足条件，无需调整            break;        //不满足的话，那么我就将最大孩子节点j与父节点i对调,        swap(v[i], v[j]);        i = j;        j = 2 * i + 1;//继续向下遍历    }}//删除堆顶元素void deleteTop(){    v[0] = v[n - 1];//也就是堆顶使用最后一个数值来替代    downAdjust(0, n - 2);//然后对前n-1个数进行排序}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h3><p>就是不断的pop出最大的元素<br>实现的就是堆排序</p><pre class="line-numbers language-CPP"><code class="language-CPP">for (int i = n - 1; i > 0; --i)//从最后开始交换，直到只剩下最后一个数字{    swap(v[i], v[0]);//每次都将最大值放到最后    downAdjust(0, i - 1);//将前0-i个数字重新构成大根堆}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h3><p>实现的是堆排序的构建</p><pre class="line-numbers language-CPP"><code class="language-CPP">//建堆void createHeap(){    for (int i = n / 2; i >= 0; --i)        downAdjust(i, n - 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>heap没有迭代器</strong></p><h2 id="8、-priority-queue"><a href="#8、-priority-queue" class="headerlink" title="8、 priority_queue"></a>8、 priority_queue</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>opriority_queue带有权值观念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列（通常权值以实值表示）。权值最高者，排在最前面。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>由于priority_queue 完全以底部容器为根据，再加上heap处理规则，所以其实现非常简单。缺省情况下是以vector为底部容器。具有这种“修改某物接口，形成另一种风貌”之性质者，称为adapter（配接器），因此，STL priority-queue往往不被归类为container（容器），而被归类为container adapter。</p><p><strong>没有迭代器</strong></p><h2 id="9、slist"><a href="#9、slist" class="headerlink" title="9、slist"></a>9、slist</h2><ul><li><p>概述<br>STL list是个双向链表（double linked list）。SGI STL另提供了一个单向链表（single linked list），名为slist。</p></li><li><p>slist和list的主要差别在于，前者的迭代器属于单向的Forward lerator，后者的迭代器属于双向的Bidirectional lterator。单向链表所耗用的空间更小，某些操作更快，不失为另一种选择。</p></li><li><p>注意，根据STL的习惯，插入操作会将新元素插入于指定位置之前，而非之后。然而作为一个单向链表，slist没有任何方便的办法可以回头定出前一个位置，因此它必须从头找起。换句话说，除了slist起点处附近的区域之外，在其它位置上采用insert或erase操作函数，都属不智之举。这便是slist相较于1ist之下的大缺点。为此，slist 特别提供了insert_after（）和erase_after（）供灵活运用。<br>迭代器</p></li></ul><h2 id="10、常见错误总结："><a href="#10、常见错误总结：" class="headerlink" title="10、常见错误总结："></a>10、常见错误总结：</h2><p>迭代器失效：</p><ul><li><p>由于vector在扩容时，是在一块新地址上开辟空间，然后将原数据复制过来，并把原来的内存空间给释放了，所以一旦vector发生扩容，那么指向原来迭代器将会失效。</p></li><li><p>由于list不是连续空间，所以删除和添加都在原的内存上添加或删除一个空间即可，所以指向原来的迭代器不会失效【除非该迭代器指向的位置被删除了】。</p></li><li><p>迭代器不仅可以后移，而且可以前进的，–ptr, ++ptr</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记——《STL源码剖析》（第一、二、三章）</title>
      <link href="/2019/12/22/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-yi-er-san-zhang/"/>
      <url>/2019/12/22/du-shu-bi-ji-stl-yuan-ma-pou-xi-di-yi-er-san-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：概论："><a href="#第一章：概论：" class="headerlink" title="第一章：概论："></a>第一章：概论：</h1><p>换句话说，STL所实现的，是依据泛型思维架设起来的一个概念结构。这个以抽象概念（abstract concepts）为主体而非以实际类（classes）为主体的结构，形成了一个严谨的接口标准。在此接口之下，任何组件都有最大的独立性，并以所谓迭代器（iterator）胶合起来，或以所谓配接器（adapter）互相配接，或以所谓仿函数（functor）动态选择某种策略（policy或strategy）。</p><h2 id="STL提供六大组件"><a href="#STL提供六大组件" class="headerlink" title="STL提供六大组件"></a>STL提供六大组件</h2><ol><li><p>容器（containers）：<br>各种数据结构，如 vector，list，deque，set，map，用来存放数据，详见本书4，5两章。从实现的角度来看，STL容器是一种class template。就体积而言，这一部分很像冰山在海面下的比率。</p></li><li><p>算法（algorithms）：<br>各种常用算法如sort，search，copy，erase…详见第6章。从实现的角度来看，STL算法是一种function template。</p></li><li><p>迭代器（iterators）：    扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，详见第3章。共有五种类型，以及其它衍生变化。从实现的角度来看，迭代器是一种将 operator*，operator-&gt;，operatort+，operator–等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器——是的，只有容器设计者才知道如何遍历自己的元素。原生指针（native pointer）也是一种迭代器。</p></li><li><p>仿函数（functors）：行为类似函数，可作为算法的某种策略（policy），详见第7章。从实现的角度来看，仿函数是一种重载了operator（）的class或class template.一般函数指针可视为狭义的仿函数。</p></li><li><p>配接器（adapters）：<br>一种用来修饰容器（containers）或仿函数（functors）<br>或迭代器（iterators）接口的东西。例如，STL提供的queue和stack，虽然看似容器，其实只能算是一种容器配接器，因为它们的底部完全借助 deque，所有操作都由底层的deque供应。改变functor接口者，称为function adapter；改变container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。配接器的实现技术很难一言以蔽之，必须逐一分析，详见第8章。</p></li><li><p>配置器（allocators）：     负责空间配置与管理，详见第2章。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">alloc</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="C-11-STL中的容器"><a href="#C-11-STL中的容器" class="headerlink" title="C++11 STL中的容器"></a>C++11 STL中的容器</h2><h3 id="一、顺序容器："><a href="#一、顺序容器：" class="headerlink" title="一、顺序容器："></a>一、顺序容器：</h3><p>vector：可变大小数组；<br>deque：双端队列；<br>list：双向链表；<br>forward_list：单向链表；<br>array：固定大小数组；<br>string：与vector相似的容器，但专门用于保存字符。</p><h3 id="二、关联容器："><a href="#二、关联容器：" class="headerlink" title="二、关联容器："></a>二、关联容器：</h3><h4 id="按关键字有序保存元素：（底层实现为红黑树）"><a href="#按关键字有序保存元素：（底层实现为红黑树）" class="headerlink" title="按关键字有序保存元素：（底层实现为红黑树）"></a>按关键字有序保存元素：（底层实现为红黑树）</h4><p>map：关联数组；保存关键字-值对；<br>set：关键字即值，即只保存关键字的容器；<br>multimap：关键字可重复的map；<br>multiset：关键字可重复的set；</p><h4 id="无序集合："><a href="#无序集合：" class="headerlink" title="无序集合："></a>无序集合：</h4><p>不会按字典规则进行排序<br>unordered_map：用哈希函数组织的map；<br>unordered_set：用哈希函数组织的set；<br>unordered_multimap：哈希组织的map；关键字可以重复出现；<br>unordered_multiset：哈希组织的set；关键字可以重复出现。    </p><h3 id="三、其他项："><a href="#三、其他项：" class="headerlink" title="三、其他项："></a>三、其他项：</h3><ol><li><p>stack、queue、valarray、bitset<br>随机访问中，[ ]与 .at( )功能相同，但是[ ]越界了会直接导致程序崩溃，而 .at( )会抛出异常，故其更安全！</p></li><li><p>size、capacity与shrink_to_fit<br>size表示目前容器的实际大小、capacity表示容器的空间，一般 &gt;=size，因为容器初始化或者赋值时，系统会根据情况给予容器一个适当的空间，避免每次增加数据时又得重新新分配空间，索性一次给多点，但也不会很大,为了节省空间，你可以使用shrink_to_fit将容器空间capacity缩小为size</p></li></ol><h3 id="四、迭代器删除失效："><a href="#四、迭代器删除失效：" class="headerlink" title="四、迭代器删除失效："></a>四、迭代器删除失效：</h3><ol><li><p>vector，erase(pos)，直接把pos+1到finish的数据拷贝到以pos为起点的区间上，也就是vector的长度会逐渐变短，同时iter会逐渐往后移动，直到iter == cont.end()，由于容器中end()返回的迭代器是最后一个元素的下一个（这个地方没有任何值），现在考虑这个状态前一个状态，此时要删除的点是iter, tempIt = iter, ++iter会指向此时的end()，但是执行erase(tempIt)之后，end()向前移动了！！！问题来了，此时iter空了！！！不崩溃才怪。</p></li><li><p>list，erase(pos)，干的事情很简单，删除自己，前后的节点连接起来就完了，所以iter自增的过程不会指空，不会崩溃喽。</p></li><li><p>map，erase(pos)，干的事情太复杂，但是我们需要知道的信息其实很少。该容器底层实现是RBTree，删除操作分了很多种情形来讨论的，目的是为了维持红黑树性质。但是我们需要知道的就是每个节点类似于list节点，都是单独分配的空间，所以删除一个节点并不会对其他迭代器产生影响，对应到题目中，不会崩溃喽。</p></li><li><p>deque，erase(pos)，与vector的erase(pos)有些类似，基于结构的不同导致中间有些步骤不太一致。先说说deque的结构（这个结构本身比较复杂，拣重要说吧，具体看STL源码），它是一个双向开口的连续线性空间，实质是分段连续的，由中控器map维持其整体连续的假象。其实题中只要知道它是双向开口的就够了（可以在头部或尾部增加、删除）。在题中有erase(pos)，deque是这样处理的：如果pos之前的元素个数比较少，那么把start到pos-1的数据移到起始地址为start+1的区间内；否则把pos后面的数据移到起始地址为pos的区间内。在题中iter一直往后移动，总会出现后面数据比前面少的时候，这时候问题就和1一样了，必须崩溃！</p></li><li><p>关联容器(如map, set, multimap,multiset)，【不会失效】删除当前的iterator，只会使当前的iterator失效，只要在erase时，递增当前iterator即可。</p></li><li><p>对于序列式容器(如vector,deque)，【会失效】删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。不过erase方法可以返回下一个有效的iterator，cont.erase(iter++)可以修改为cont.erase(iter)</p></li><li><p>list使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator。</p></li></ol><h3 id="五、为不同的容器选择不同删除方式"><a href="#五、为不同的容器选择不同删除方式" class="headerlink" title="五、为不同的容器选择不同删除方式"></a>五、为不同的容器选择不同删除方式</h3><p>删除连续容器(vector,deque,string)的元素</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 当c是vector、string，删除value</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除</span><span class="token keyword">bool</span> <span class="token function">assertFun</span><span class="token punctuation">(</span>valuetype<span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove_if</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> assertFun<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 有时候我们不得不遍历去完成，并删除</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除list中某个元素</p><pre class="line-numbers language-cpp"><code class="language-cpp">c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断value是否满足某个条件，删除    </span>c<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>assertFun<span class="token punctuation">)</span><span class="token punctuation">;</span>删除关联容器<span class="token punctuation">(</span>set<span class="token punctuation">,</span>map<span class="token punctuation">)</span>中某个元素c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">assertFun</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ···        c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="各大容器性能对比："><a href="#各大容器性能对比：" class="headerlink" title="各大容器性能对比："></a>各大容器性能对比：</h2><ol><li><p>vector<br>变长一维数组，连续存放的内存块，有保留内存，堆中分配内存；<br>支持[]操作，高效率的随机访问；<br>在最后增加元素时，一般不需要分配内存空间，速度快；在中间或开始操作元素时要进行内存拷贝效率低；<br>vector高效的原因在于配置了比其所容纳的元素更多的内存，内存重新配置会花很多时间；<br>vector的内存分配：<br>一般是按你当时存储数据的两倍开辟空间，当插入数据空间不够时，又会重新增加空间至当时数据空间的2倍，此动作降低了vector的工作效率！！！<br>注：需要高效的随即存取，而不在乎插入和删除使用vector。   </p></li><li><p>list<br>双向链表，内存空间上可能是不连续的，无保留内存，堆中分配内存；<br>不支持随机存取，开始和结尾元素的访问时间快,其它元素都O（n）；<br>在任何位置安插和删除元素速度都比较快，安插和删除操作不会使其他元素的各个pointer，reference，iterator失效；   </p></li></ol><p>注：大量的插入和删除，而不关系随即存取使用list。   </p><ol start="3"><li><p>deque<br>双端队列，在堆上分配内存，一个堆保存几个元素，而堆之间使用指针连接；<br>支持[]操作，在首端和末端插入和删除元素比较快，在中部插入和删除则比较慢，像是list和vector的结合；<br>注：关心插入和删除并关心随即存取折中使用deque。   </p></li><li><p>set&amp;multiset<br>有序集合，使用平衡二叉树存储，按照给定的排序规则（默认按less排序）对set中的数据进行排序；<br>set中不允许有重复元素，multiset中运行有重复元素；<br>两者不支持直接存取元素的操作；<br>因为是自动排序，查找元素速度比较快；<br>不能直接改变元素值，否则会打乱原本正确的顺序，必须先下删除旧元素，再插入新的元素。 </p></li><li><p>map&amp;multimap<br>字典库，一个值映射成另一个值，使用平衡二叉树存储，按照给定的排序规则对map中的key值进行排序；<br>map中的key值不允许重复，multimap中的key允许重复；<br>根据已知的key值查找元素比较快；<br>插入和删除操作比较慢。   </p></li><li><p>hash_map<br>hash_map使用hash表来排列配对，hash表是使用关键字来计算表位置。当这个表的大小合适，并且计算算法合适的情况下，hash表的算法复杂度为O(1)的，但是这是理想的情况下的，如果hash表的关键字计算与表位置存在冲突，那么最坏的复杂度为O(n)。<br>选用map还是hash_map， 关键是看关键字查询操作次数，以及你所需要保证的是查询总体时间还是单个查询的时间。如果是要很多次操作，要求其整体效率，那么使用hash_map，平均处理时间短。如果是少数次的操作，使用 hash_map可能造成不确定的O(N)，那么使用平均处理时间相对较慢、单次处理时间恒定的map，便更好些。</p></li></ol><h2 id="STL容器对比："><a href="#STL容器对比：" class="headerlink" title="STL容器对比："></a>STL容器对比：</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>名称</td><td>向量容器</td><td>双向队列容器</td><td>列表容器</td><td>集合</td><td>多重集合</td><td>映射</td><td>多重映射</td></tr><tr><td>内部数 据结构</td><td>连续存储的数组形式（一端开口的组）</td><td>连续或分段连续存储数组（两端 开口的数组）</td><td>双向环状链表</td><td>红黑树（平衡检索二叉树）</td><td>红黑树</td><td>红黑树</td><td>红黑树</td></tr><tr><td>特  点</td><td>获取元素效率很高，插入和删除的 效率很低</td><td>获取元素效率较高，插入和删除的效率较高</td><td>获取元素效率很低，插入和删除的效率很高</td><td>1.键（关键字）和值（数据）相等（就是模版只有一个参数，键和值合起来） 2.键唯一 3.元素默认按升序排列</td><td>1.键和值相等 2.键可以不唯一 3.元素默认按升序排列</td><td>1.键和值分开（模版有两个参数，前面是键后面是值） 2.键唯一 3.元素默认按键的升序排列</td><td>1.键和值分开 2.键可以不唯一 3.元素默认按键的升序排列</td></tr><tr><td>头文件</td><td>#include <vector></td><td>#include <deque></td><td>#include <list></td><td>#include <set></td><td>#include <set></td><td>#include <map></td><td>#include <map></td></tr><tr><td>操作元素的方式</td><td>下标运算符：[0]（可以用迭代器，但插入删除操作时会失效）</td><td>下标运算符或迭代器</td><td>只能用迭代器(不断用变量值来递推新值，相当于指针)，不支持使用下标运算符</td><td>迭代器</td><td>迭代器</td><td>迭代器</td><td>迭代器</td></tr><tr><td>插入删除操作迭代器是否失效</td><td>插入和删除元素都会使迭代器失效</td><td>插入任何元素都会使迭代器失效。删除头和尾元素，指向被删除节点迭代器失效，而删除中间元素会使所有迭代器失效</td><td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td><td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td><td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td><td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td><td>插入，迭代器不会失效。删除，指向被删除节点迭代器失效</td></tr></tbody></table><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>典型内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>可随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对 key 而言：不是</td><td>否</td></tr><tr><td>元素搜寻速度</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对 key 而言：快</td><td>对 key 而言：快</td></tr><tr><td>元素安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="容器自定义比较方式："><a href="#容器自定义比较方式：" class="headerlink" title="容器自定义比较方式："></a>容器自定义比较方式：</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> fruit <span class="token punctuation">{</span>        string name<span class="token punctuation">;</span>         <span class="token keyword">int</span> price<span class="token punctuation">;</span>         <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>fruit fl<span class="token punctuation">,</span> fruit f2<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                <span class="token keyword">return</span> fl<span class="token punctuation">.</span> price<span class="token operator">></span>f2<span class="token punctuation">.</span> price<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="STL容器新颖使用"><a href="#STL容器新颖使用" class="headerlink" title="STL容器新颖使用"></a>STL容器新颖使用</h2><p>将数组中的值直接付给容器<br>int arry[size] = {0,1,2,3,4,5,6};<br>xxx<int>contain(arry, arry+size);//即将数组中的值直接初始化赋予了容器中</p><h1 id="简介SGI："><a href="#简介SGI：" class="headerlink" title="简介SGI："></a>简介SGI：</h1><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">:</span><span class="token keyword">class</span> <span class="token class-name">alloc</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">=</span>alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span><span class="token punctuation">{</span><span class="token keyword">public</span>：     <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>Alloc<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"swap()"</span><span class="token operator">&lt;&lt;</span> endl；    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>x<span class="token punctuation">,</span>y<span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">=</span>alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>     <span class="token keyword">typedef</span> value_type<span class="token operator">*</span> iterator<span class="token punctuation">;</span>     <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">,</span>I first<span class="token punctuation">,</span>I last<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"insert()"</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>x<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator ite<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>stack:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>clase A1loc<span class="token operator">=</span>alloc<span class="token punctuation">,</span>size_t BufSiz<span class="token operator">=</span><span class="token number">0</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">deque</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"deque"</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据前一个参数值T，设定下一个参数Sequence的默认值为deque&lt;T></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，claas Sequence<span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"stack"</span><span class="token operator">&lt;&lt;</span> end1<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Sequence c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>x<span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">=</span>alloc<span class="token punctuation">,</span>size_t BufSiz<span class="token operator">=</span><span class="token number">0</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">deque</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span><span class="token string">"deque"</span><span class="token operator">&lt;&lt;</span><span class="token string">''</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T，Sequence<span class="token operator">></span><span class="token operator">&amp;</span>x，<span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T，Sequence<span class="token operator">></span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T，Sequence<span class="token operator">></span><span class="token operator">&amp;</span>x，<span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T，Sequence<span class="token operator">></span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span>，<span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">=</span>deque<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//写成这样是可以的</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span> <span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//写成这样也是可以的</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//写成这样也是可以的</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token operator">></span>（<span class="token keyword">const</span> stack<span class="token operator">&amp;</span>，<span class="token keyword">const</span> stack<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//写成这样就不可以</span>    <span class="token comment" spellcheck="true">//friend bool operator==(const stack&amp;，const stack&amp;);</span>    <span class="token comment" spellcheck="true">//friend bool operator&lt;(const stack&amp;，const stack&amp;);</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"stack"</span><span class="token operator">&lt;&lt;</span>endl；<span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Sequence c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Sequence<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Sequence<span class="token operator">></span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> cout <span class="token operator">&lt;&lt;</span><span class="token string">"operator=="</span><span class="token operator">&lt;&lt;</span><span class="token string">'\t'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Sequence<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> stack<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Sequence<span class="token operator">></span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> cout <span class="token operator">&lt;&lt;</span><span class="token string">"operator&lt;"</span><span class="token operator">&lt;&lt;</span><span class="token string">'\t'</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//deque stack</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>y<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//deque stack </span>    cout <span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//operator==1</span>    cout <span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span>y<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>end1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//operator&lt;1</span>    stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span>y1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//deque stack</span>    <span class="token comment" spellcheck="true">//cout c&lt;(x== y1)&lt;&lt; endl; //error: no match for...</span>    <span class="token comment" spellcheck="true">//cout &lt;&lt;(x&lt; y1)&lt;&lt; end1;//error: no match for...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>deque:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">inline</span> sizet <span class="token function">_deque_buf_size</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span>size_t sz<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> n<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">?</span>n<span class="token operator">:</span><span class="token punctuation">(</span>sz<span class="token operator">&lt;</span><span class="token number">512</span><span class="token operator">?</span><span class="token function">size_t</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token operator">/</span>sz<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">size_t</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token punctuation">,</span>size_t BufSiz<span class="token operator">></span><span class="token keyword">struct</span> _deque_iterator<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _deque_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token operator">&amp;</span><span class="token punctuation">,</span>T<span class="token operator">*</span><span class="token punctuation">,</span>BufSiz<span class="token operator">></span> iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> __deque_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> T<span class="token operator">*</span><span class="token punctuation">,</span>BufSiz<span class="token operator">></span>const_iterator<span class="token punctuation">;</span>     <span class="token keyword">static</span> size_t <span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> deque_ <span class="token function">buf_size</span><span class="token punctuation">(</span>Bufsiz<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">=</span>alloc<span class="token punctuation">,</span>size_t Buf8iz<span class="token operator">=</span><span class="token number">0</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> deque_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token operator">&amp;</span><span class="token punctuation">,</span>T<span class="token operator">*</span><span class="token punctuation">,</span>BufSiz<span class="token operator">></span> iterator<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator<span class="token operator">::</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>end1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//128</span>cout <span class="token operator">&lt;&lt;</span> deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>alloc<span class="token punctuation">,</span><span class="token number">64</span><span class="token operator">></span><span class="token operator">::</span>iterator<span class="token operator">::</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="第二章、空间配置："><a href="#第二章、空间配置：" class="headerlink" title="第二章、空间配置："></a>第二章、空间配置：</h1><ol><li>考虑到小型区块所可能造成的内存破碎问题，SGI设计了双层配置器，第一级配置器直接使用malloc和free，第二级配置器则视情况采用不用的策略(需求区块是否大于128bytes)。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102600276-1255786342.png" alt=" "></li></ol><p>第一级适配器以malloc()，free()，reaclloc()等C函数执行实际的内存配置、释放、重配置操作。第二级配置器多了一些机制，避免太多小额区块造成内存的碎片。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102607726-222688072.png" alt=" "></p><p>SGI第二级配置器的做法是，如果区块够大，超过128字节时，就移交第一级配置器处理。当区块小于128字节时，则以内存池(memory pool)管理，此法又称为次层配置(sub-allocation)：每次配置一大块内存，并维护对应的自由链表(free-list)。下次若再有相同大小的内存需求，就直接从free-lists中拔出。如果没有，则向系统要一大块内存，然后做切割，此时切割出来的小内存块，不带cookie。如果客户端释放小额区块，就由配置器回收。为方便管理，任何小额区块的内存需求量上调至8的倍数，并维护16个free-lists，各自管理大小分别为8,16,24…128字节。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102613857-2071157239.png" alt=" "></p><p>在G4.9中编译器使用的是不作任何优化的空间配置器，如果需要制定，则需要指明第二参数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> __gnu_cxx<span class="token operator">::</span>__pool_alloc<span class="token operator">&lt;</span>string<span class="token operator">>></span> vec<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果free-list中没有可用的区块，将区块大小上调至8的倍数边界，然后调用refill()，准备为free-list重新填充空间。refill()之后介绍。<br>空间的释放，大于128字节就调用第一级配置器，小于128字节就找出对应的free list，将区块回收。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102620400-1938054497.png" alt=" "></p><p>refill()重新填充空间，新的空间将取自内存池(经由chunk_alloc()完成)。内存池实际操练结果如下图：<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102625685-1826453299.png" alt=" "></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102633369-309620775.png" alt=" "></p><ol start="2"><li>第一级配置器直接调用C函数执行实际的内存操作，并实现类似C++ new handler的机制。</li></ol><ol start="3"><li><p>当区块超过128bytes时，视之为足够大，便调用第一级配置器。当配置器小于128bytes时，视之为过小，便采用内存池的方式。每次配置一大块内存，并维护对应之自由链表，下次若再有相同大小的内存需求，就直接从free-list中拔出。如果客端释还小额区块，就由配置器回收到free-list中。为了方便管理，SGI第二季配置器会主动将任何小额区块的内存需求量上调至8的倍数（例如客端要求30bytes，就自动调整为32bytes），并维护16个free-list，大小分别是8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128bytes。</p></li><li><p>内存池  </p></li></ol><p>如果水量充足，就直接调出20个区块返回给free-list，如果不够20则返回不足实际个数。如果一个都拿不出，则调用malloc配置40个区块的空间，其中20个给free-list，剩下的20个留在内存池。如果malloc分配失败，则调用第一级配置器。因为第一级配置器有new-handler机制，获取能够整理出多余的空间。、</p><ol start="5"><li>内存基本处理工具<br>uninitialized_copy，uninitialized_fill,uninitialized_fill_n， 能够将内存配置与对象构造行为分离开来。并且会对POD（即标量型别或传统C struct） 对象采用最有效率的初值填写手法，而对non-POD型别采取最保险安全的做法。</li></ol><p>为了细化分工，STL allocator将两阶段操作区分开来。内存配置操作由alloc::allocate()负责，内存释放操作由alloc::deallocate()负责；对象构造操作由::construct负责，对象析构操作由::destroy()负责。<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102648805-1757914145.png" alt=" "></p><h2 id="内存池："><a href="#内存池：" class="headerlink" title="内存池："></a>内存池：</h2><p>当申请空间不充足时，系统首先将剩余的空间尽量为你申请出来<br>一般新申请的空间大小为你所需求空间大小的2倍加上一个随机配置次数增加愈加增大的附加量<br><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102706624-214811463.png" alt=""></p><p><img src="https://img2018.cnblogs.com/i-beta/1463063/201912/1463063-20191222102718902-167431135.png" alt=""></p><h1 id="第三章、迭代器概念"><a href="#第三章、迭代器概念" class="headerlink" title="第三章、迭代器概念"></a>第三章、迭代器概念</h1><p>STL的中心思想在于：将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。</p><h2 id="迭代器相应型别："><a href="#迭代器相应型别：" class="headerlink" title="迭代器相应型别："></a>迭代器相应型别：</h2><h3 id="迭代器相应型别之一：value-type："><a href="#迭代器相应型别之一：value-type：" class="headerlink" title="迭代器相应型别之一：value type："></a>迭代器相应型别之一：value type：</h3><p>所谓 value type，是指迭代器所指对象的型别。任何一个打算与STL算法有完美搭配的class，都应该定义自己的vluetype内嵌型别， 做法就像上节所述。</p><h3 id="迭代器相应型别之二：difference-type："><a href="#迭代器相应型别之二：difference-type：" class="headerlink" title="迭代器相应型别之二：difference type："></a>迭代器相应型别之二：difference type：</h3><p>differencetype用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。<br>如果一个泛型算法提供计数功能，例如STL的count（），其传回值就必须使用迭代器的diference type：  </p><h3 id="迭代器相应型别之三：reference-type"><a href="#迭代器相应型别之三：reference-type" class="headerlink" title="迭代器相应型别之三：reference type"></a>迭代器相应型别之三：reference type</h3><p>从“迭代器所指之物的内容是否允许改变”的角度观之，迭代器分为两种：<br>不允许改变“所指对象之内容”者，称为constant iterators，例如 const int *pic；【视为不可改的右值】</p><p>允许改变“所指对象之内容”者，称为mutable iterators，例如int *pi。当我们对一个mutable iterators进行提领操作时，获得的不应该是一个右值（rvalue），应该是一个左值（lvalue），因为右值不允许赋值操作（assignment），左值才允许：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>pi<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span>（<span class="token number">5</span>）；<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pci<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span>（<span class="token number">9</span>）；<span class="token operator">*</span>pi<span class="token operator">=</span><span class="token number">7</span>；<span class="token comment" spellcheck="true">//对mutable iterator进行提领操作时，获得的应该是个左值，允许赋值</span><span class="token operator">*</span>pci<span class="token operator">=</span><span class="token number">1</span>；<span class="token comment" spellcheck="true">//这个操作不允许，因为pci是个constant iterator，</span>   <span class="token comment" spellcheck="true">//提领pci所得结果，是个右值，不允许被赋值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代器相应型别之四：pointer-type"><a href="#迭代器相应型别之四：pointer-type" class="headerlink" title="迭代器相应型别之四：pointer type"></a>迭代器相应型别之四：pointer type</h3><p>pointers和references在C++中有非常密切的关联。如果“传回一个左值，令它代表p所指之物”是可能的，那么“传回一个左值，令它代表p所指之物的地址”也一定可以。也就是说，我们能够传回一个pointer，指向迭代器所指之物。  </p><h3 id="迭代器相应型别之五：iterator-category"><a href="#迭代器相应型别之五：iterator-category" class="headerlink" title="迭代器相应型别之五：iterator_category"></a>迭代器相应型别之五：iterator_category</h3><p>最后一个（第五个）迭代器的相应型别会引发较大规模的写代码工程。在那之前，我必须先讨论迭代器的分类。  </p><h2 id="根据移动特性与施行操作，迭代器被分为五类："><a href="#根据移动特性与施行操作，迭代器被分为五类：" class="headerlink" title="根据移动特性与施行操作，迭代器被分为五类："></a>根据移动特性与施行操作，迭代器被分为五类：</h2><ul><li>Input lterator：这种迭代器所指的对象，不允许外界改变。只读（read only）。</li><li>Output terator：唯写（write only）。</li><li>Forward lterator：允许“写入型”算法（例如replace（））在此种迭代器所形成的区间上进行读写操作。</li><li>Bidirectiona lterator：可双向移动。某些算法需要逆向走访某个迭代器区间（例如逆向拷贝某范围内的元素），可以使用Biairectional lterators。</li><li>Random Access lterator：前四种迭代器都只供应一部分指针算术能力（前三种支持operator++，第四种再加上operator–），第五种则涵盖所有指针算术能力，包括<code>p+n，p-n，p[n]，pl-p2，p1&lt;p2</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
